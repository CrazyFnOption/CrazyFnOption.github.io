<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Magical Bean</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wsx1128.cn/"/>
  <updated>2020-03-12T14:45:30.189Z</updated>
  <id>http://wsx1128.cn/</id>
  
  <author>
    <name>五光君</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kaggle Titanic 生存预测</title>
    <link href="http://wsx1128.cn/2020/03/11/Kaggle-Titanic-%E7%94%9F%E5%AD%98%E9%A2%84%E6%B5%8B/"/>
    <id>http://wsx1128.cn/2020/03/11/Kaggle-Titanic-生存预测/</id>
    <published>2020-03-11T15:02:08.000Z</published>
    <updated>2020-03-12T14:45:30.189Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这是一篇入门的kaggle的初级案例。</p><p>本来自己第一遍去做的时候，发现预测的正确率只能够达到77%，经过了无数次调参，最后也只能到达79%，于是自己决定花点时间按照流程写一遍，并且记录下来</p><p>题目比较具有趣味性。给你两个数据集合，其中一个有标签值，另外一个没有标签值，然后给出了姓名，性别，船费，年龄，以及船仓位相关的数据</p><p>然后预测这个人是否能够存活</p><p>按照相关的步骤来：</p><h3 id="分析题目"><a href="#分析题目" class="headerlink" title="分析题目"></a>分析题目</h3><p>首先这道题就是一个让你预测test数据组里面的人能否存活，其实就是一个二分类问题，如果存活最后的结果输出1，如果没有存活，那么最后的结果输出0</p><p>确认这是一个二分类问题，接下来就可以去整理数据了</p><h3 id="数据总览"><a href="#数据总览" class="headerlink" title="数据总览"></a>数据总览</h3><p>Titanic 生存模型预测，其中包含了两组数据：train.csv 和 test.csv，分别为训练集合和测试集合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面这函数就是在jupyter notbook里面，</span></span><br><span class="line"><span class="comment"># 可以不必写show函数，可以直接显示出来</span></span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure><p>运用pandas里面的函数，去进行观测数据，并且开始着手数据的处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">train_data = pd.read_csv(<span class="string">'data/train.csv'</span>)</span><br><span class="line">test_data = pd.read_csv(<span class="string">'data/test.csv'</span>)</span><br><span class="line"></span><br><span class="line">sns.set_style(<span class="string">'whitegrid'</span>)</span><br><span class="line">train_data.head()</span><br></pre></td></tr></table></figure><p><img src="/2020/03/11/Kaggle-Titanic-生存预测/1.jpg" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">train_data.info()</span><br><span class="line">print(<span class="string">"-"</span> * <span class="number">40</span>)</span><br><span class="line">test_data.info()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>'&gt;</span></span><br><span class="line"><span class="class">    <span class="title">RangeIndex</span>:</span> <span class="number">891</span> entries, <span class="number">0</span> to <span class="number">890</span></span><br><span class="line">    Data columns (total <span class="number">12</span> columns):</span><br><span class="line">    PassengerId    <span class="number">891</span> non-null int64</span><br><span class="line">    Survived       <span class="number">891</span> non-null int64</span><br><span class="line">    Pclass         <span class="number">891</span> non-null int64</span><br><span class="line">    Name           <span class="number">891</span> non-null object</span><br><span class="line">    Sex            <span class="number">891</span> non-null object</span><br><span class="line">    Age            <span class="number">714</span> non-null float64</span><br><span class="line">    SibSp          <span class="number">891</span> non-null int64</span><br><span class="line">    Parch          <span class="number">891</span> non-null int64</span><br><span class="line">    Ticket         <span class="number">891</span> non-null object</span><br><span class="line">    Fare           <span class="number">891</span> non-null float64</span><br><span class="line">    Cabin          <span class="number">204</span> non-null object</span><br><span class="line">    Embarked       <span class="number">889</span> non-null object</span><br><span class="line">    dtypes: float64(<span class="number">2</span>), int64(<span class="number">5</span>), object(<span class="number">5</span>)</span><br><span class="line">    memory usage: <span class="number">83.6</span>+ KB</span><br><span class="line">    ----------------------------------------</span><br><span class="line">    &lt;<span class="class"><span class="keyword">class</span> '<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>'&gt;</span></span><br><span class="line"><span class="class">    <span class="title">RangeIndex</span>:</span> <span class="number">418</span> entries, <span class="number">0</span> to <span class="number">417</span></span><br><span class="line">    Data columns (total <span class="number">11</span> columns):</span><br><span class="line">    PassengerId    <span class="number">418</span> non-null int64</span><br><span class="line">    Pclass         <span class="number">418</span> non-null int64</span><br><span class="line">    Name           <span class="number">418</span> non-null object</span><br><span class="line">    Sex            <span class="number">418</span> non-null object</span><br><span class="line">    Age            <span class="number">332</span> non-null float64</span><br><span class="line">    SibSp          <span class="number">418</span> non-null int64</span><br><span class="line">    Parch          <span class="number">418</span> non-null int64</span><br><span class="line">    Ticket         <span class="number">418</span> non-null object</span><br><span class="line">    Fare           <span class="number">417</span> non-null float64</span><br><span class="line">    Cabin          <span class="number">91</span> non-null object</span><br><span class="line">    Embarked       <span class="number">418</span> non-null object</span><br><span class="line">    dtypes: float64(<span class="number">2</span>), int64(<span class="number">4</span>), object(<span class="number">5</span>)</span><br><span class="line">    memory usage: <span class="number">36.0</span>+ KB</span><br></pre></td></tr></table></figure><p>从上面我们可以看出，Age、Cabin、Embarked、Fare几个特征存在缺失值。</p><p>绘制存活的比例：</p><p>下面先来一个可视化：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_data[<span class="string">'Survived'</span>].value_counts().plot.pie(autopct = <span class="string">'%1.2f%%'</span>)</span><br></pre></td></tr></table></figure></p><p><img src="/2020/03/11/Kaggle-Titanic-生存预测/2.jpg" alt=""></p><p>由上面这张图，我们可以得知 活下来的人与没有活下来的人总体比例，就开始对数据有一个整体的认知</p><h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><p>接下来，我们就要开始准备数据的处理，一般数据存在的问题，要么就是离群点问题，要么就是缺失值问题，要么就是数据变换的问题。</p><h4 id="数值变换"><a href="#数值变换" class="headerlink" title="数值变换"></a>数值变换</h4><p><strong>变量转换的目的是将数据转换为适用于模型使用的数据，不同模型接受不同类型的数据，Scikit-learn要求数据都是数字型numeric，所以我们要将一些非数字型的原始数据转换为数字型numeric。</strong></p><p>所有的数据可以分为两类：</p><ol><li>定性(Quantitative)变量可以以某种方式排序，Age就是一个很好的列子。</li><li>定量(Qualitative)变量描述了物体的某一（不能被数学表示的）方面，Embarked就是一个例子。</li></ol><p>针对上面不可以被数学数字表示的数据，下面采取：</p><h5 id="Dummy-Variables"><a href="#Dummy-Variables" class="headerlink" title="Dummy Variables"></a>Dummy Variables</h5><p>就是类别变量或者二元变量，当qualitative variable是一些频繁出现的几个独立变量时，Dummy Variables比较适合使用。我们以Embarked为例，Embarked只包含三个值’S’,’C’,’Q’，我们可以使用下面的代码将其转换为dummies:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">embark_dummies  = pd.get_dummies(train_data[<span class="string">'Embarked'</span>])</span><br><span class="line">train_data = train_data.join(embark_dummies)</span><br><span class="line">train_data.drop([<span class="string">'Embarked'</span>], axis=<span class="number">1</span>,inplace=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">embark_dummies = train_data[[<span class="string">'S'</span>, <span class="string">'C'</span>, <span class="string">'Q'</span>]]</span><br><span class="line">embark_dummies.head()</span><br></pre></td></tr></table></figure><p><img src="/2020/03/11/Kaggle-Titanic-生存预测/3.jpg" alt=""></p><p>其实上面的这种方法有点特别像RNN中词向量。给每一个词加上相应的特征，应用one-hot编码形式</p><h5 id="Factorizing"><a href="#Factorizing" class="headerlink" title="Factorizing"></a>Factorizing</h5><p>dummy不好处理Cabin（船舱号）这种标称属性，因为他出现的变量比较多。所以Pandas有一个方法叫做factorize()，它可以创建一些数字，来表示类别变量，对每一个类别映射一个ID，这种映射最后只生成一个特征，不像dummy那样生成多个特征。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Replace missing values with "U0"</span></span><br><span class="line">train_data[<span class="string">'Cabin'</span>][train_data.Cabin.isnull()] = <span class="string">'U0'</span></span><br><span class="line"><span class="comment"># create feature for the alphabetical part of the cabin number</span></span><br><span class="line">train_data[<span class="string">'CabinLetter'</span>] = train_data[<span class="string">'Cabin'</span>].map( <span class="keyword">lambda</span> x : re.compile(<span class="string">"([a-zA-Z]+)"</span>).search(x).group())</span><br><span class="line"><span class="comment"># convert the distinct cabin letters with incremental integer values</span></span><br><span class="line">train_data[<span class="string">'CabinLetter'</span>] = pd.factorize(train_data[<span class="string">'CabinLetter'</span>])[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">train_data[<span class="string">'CabinLetter'</span>].head()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>    <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>    <span class="number">1</span></span><br><span class="line"> <span class="number">2</span>    <span class="number">0</span></span><br><span class="line"> <span class="number">3</span>    <span class="number">1</span></span><br><span class="line"> <span class="number">4</span>    <span class="number">0</span></span><br><span class="line"> Name: CabinLetter, dtype: int64</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="comment">##### Scaling</span></span><br><span class="line">Scaling可以将一个很大范围的数值映射到一个很小的范围(通常是<span class="number">-1</span> - <span class="number">1</span>，或则是<span class="number">0</span> - <span class="number">1</span>)，很多情况下我们需要将数值做Scaling使其范围大小一样，否则大范围数值特征将会由更高的权重。比如：Age的范围可能只是<span class="number">0</span><span class="number">-100</span>，而income的范围可能是<span class="number">0</span><span class="number">-10000000</span>，在某些对数组大小敏感的模型中会影响其结果。</span><br><span class="line"></span><br><span class="line">下面对Age进行Scaling：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> np.size(train_data[<span class="string">'Age'</span>]) == <span class="number">891</span></span><br><span class="line"><span class="comment"># StandardScaler will subtract the mean from each value then scale to the unit variance</span></span><br><span class="line">scaler = preprocessing.StandardScaler()</span><br><span class="line">train_data[<span class="string">'Age_scaled'</span>] = scaler.fit_transform(train_data[<span class="string">'Age'</span>].values.reshape(<span class="number">-1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_data[<span class="string">'Age_scaled'</span>].head()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>   <span class="number">-0.558449</span></span><br><span class="line"><span class="number">1</span>    <span class="number">0.606773</span></span><br><span class="line"><span class="number">2</span>   <span class="number">-0.267144</span></span><br><span class="line"><span class="number">3</span>    <span class="number">0.388293</span></span><br><span class="line"><span class="number">4</span>    <span class="number">0.388293</span></span><br><span class="line">Name: Age_scaled, dtype: float64</span><br></pre></td></tr></table></figure><h5 id="Binning"><a href="#Binning" class="headerlink" title="Binning"></a>Binning</h5><p>Binning通过观察“邻居”(即周围的值)将连续数据离散化。存储的值被分布到一些“桶”或“箱“”中，就像直方图的bin将数据划分成几块一样。下面的代码对Fare进行Binning。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Divide all fares into quartiles</span></span><br><span class="line">train_data[<span class="string">'Fare_bin'</span>] = pd.qcut(train_data[<span class="string">'Fare'</span>], <span class="number">5</span>)</span><br><span class="line">train_data[<span class="string">'Fare_bin'</span>].head()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>      (<span class="number">-0.001</span>, <span class="number">7.854</span>]</span><br><span class="line"><span class="number">1</span>    (<span class="number">39.688</span>, <span class="number">512.329</span>]</span><br><span class="line"><span class="number">2</span>        (<span class="number">7.854</span>, <span class="number">10.5</span>]</span><br><span class="line"><span class="number">3</span>    (<span class="number">39.688</span>, <span class="number">512.329</span>]</span><br><span class="line"><span class="number">4</span>        (<span class="number">7.854</span>, <span class="number">10.5</span>]</span><br><span class="line">Name: Fare_bin, dtype: category</span><br><span class="line">Categories (<span class="number">5</span>, interval[float64]): [(<span class="number">-0.001</span>, <span class="number">7.854</span>] &lt; (<span class="number">7.854</span>, <span class="number">10.5</span>] &lt; (<span class="number">10.5</span>, <span class="number">21.679</span>] &lt; (<span class="number">21.679</span>, <span class="number">39.688</span>] &lt; (<span class="number">39.688</span>, <span class="number">512.329</span>]]</span><br></pre></td></tr></table></figure><p>一般这里比较好的使用这个算法的位置是给范围值进行等级的划分，这样以来，然而就会有更好的结果</p><p>在将数据Bining化后，要么将数据factorize化，要么dummies化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># factorize</span></span><br><span class="line">train_data[<span class="string">'Fare_bin_id'</span>] = pd.factorize(train_data[<span class="string">'Fare_bin'</span>])[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># dummies</span></span><br><span class="line">fare_bin_dummies_df = pd.get_dummies(train_data[<span class="string">'Fare_bin'</span>]).rename(columns=<span class="keyword">lambda</span> x: <span class="string">'Fare_'</span> + str(x))</span><br><span class="line">train_data = pd.concat([train_data, fare_bin_dummies_df], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h4><p>一些机器学习算法能够处理缺失值，比如神经网络，一些则不能。对于缺失值，一般有以下几种处理方法：</p><ul><li>如果数据集很多，但有很少的缺失值，可以删掉带缺失值的行；</li><li>如果该属性相对学习来说不是很重要，可以对缺失值赋均值或者众数。比如在哪儿上船Embarked这一属性（共有三个上船地点），缺失俩值，可以用众数赋值</li></ul><p>因为“Embarked”项的缺失值不多，所以这里我们以众数来填充：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">combined_train_test[<span class="string">'Embarked'</span>].fillna(combined_train_test[<span class="string">'Embarked'</span>].mode().iloc[<span class="number">0</span>], inplace=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>对于三种不同的港口，由上面介绍的数值转换，我们知道可以有两种特征处理方式：dummy和facrorizing。因为只有三个港口，所以我们可以直接用dummy来处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了后面的特征分析，这里我们将 Embarked 特征进行facrorizing</span></span><br><span class="line">combined_train_test[<span class="string">'Embarked'</span>] = pd.factorize(combined_train_test[<span class="string">'Embarked'</span>])[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 pd.get_dummies 获取one-hot 编码</span></span><br><span class="line">emb_dummies_df = pd.get_dummies(combined_train_test[<span class="string">'Embarked'</span>], prefix=combined_train_test[[<span class="string">'Embarked'</span>]].columns[<span class="number">0</span>])</span><br><span class="line">combined_train_test = pd.concat([combined_train_test, emb_dummies_df], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>因为Age项的缺失值较多，所以不能直接填充age的众数或者平均数。</p><p>常见的有两种对年龄的填充方式：一种是根据Title中的称呼，如Mr，Master、Miss等称呼不同类别的人的平均年龄来填充；一种是综合几项如Sex、Title、Pclass等其他没有缺失值的项，使用机器学习算法来预测Age。</p><p>这里我们使用后者来处理。以Age为目标值，将Age完整的项作为训练集，将Age缺失的项作为测试集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">missing_age_df = pd.DataFrame(combined_train_test[</span><br><span class="line"> [<span class="string">'Age'</span>, <span class="string">'Embarked'</span>, <span class="string">'Sex'</span>, <span class="string">'Title'</span>, <span class="string">'Name_length'</span>, <span class="string">'Family_Size'</span>, <span class="string">'Family_Size_Category'</span>,<span class="string">'Fare'</span>, <span class="string">'Fare_bin_id'</span>, <span class="string">'Pclass'</span>]])</span><br><span class="line"></span><br><span class="line">missing_age_train = missing_age_df[missing_age_df[<span class="string">'Age'</span>].notnull()]</span><br><span class="line">missing_age_test = missing_age_df[missing_age_df[<span class="string">'Age'</span>].isnull()]</span><br><span class="line"></span><br><span class="line">missing_age_test.head()</span><br></pre></td></tr></table></figure><p><img src="/2020/03/11/Kaggle-Titanic-生存预测/4.jpg" alt=""></p><p>建立Age的预测模型，我们可以多模型预测，然后再做模型的融合，提高预测的精度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> ensemble</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> model_selection</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill_missing_age</span><span class="params">(missing_age_train, missing_age_test)</span>:</span></span><br><span class="line">    missing_age_X_train = missing_age_train.drop([<span class="string">'Age'</span>], axis=<span class="number">1</span>)</span><br><span class="line">    missing_age_Y_train = missing_age_train[<span class="string">'Age'</span>]</span><br><span class="line">    missing_age_X_test = missing_age_test.drop([<span class="string">'Age'</span>], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># model 1  gbm</span></span><br><span class="line">    gbm_reg = GradientBoostingRegressor(random_state=<span class="number">42</span>)</span><br><span class="line">    gbm_reg_param_grid = &#123;<span class="string">'n_estimators'</span>: [<span class="number">2000</span>], <span class="string">'max_depth'</span>: [<span class="number">4</span>], <span class="string">'learning_rate'</span>: [<span class="number">0.01</span>], <span class="string">'max_features'</span>: [<span class="number">3</span>]&#125;</span><br><span class="line">    gbm_reg_grid = model_selection.GridSearchCV(gbm_reg, gbm_reg_param_grid, cv=<span class="number">10</span>, n_jobs=<span class="number">25</span>, verbose=<span class="number">1</span>, scoring=<span class="string">'neg_mean_squared_error'</span>)</span><br><span class="line">    gbm_reg_grid.fit(missing_age_X_train, missing_age_Y_train)</span><br><span class="line">    print(<span class="string">'Age feature Best GB Params:'</span> + str(gbm_reg_grid.best_params_))</span><br><span class="line">    print(<span class="string">'Age feature Best GB Score:'</span> + str(gbm_reg_grid.best_score_))</span><br><span class="line">    print(<span class="string">'GB Train Error for "Age" Feature Regressor:'</span> + str(gbm_reg_grid.score(missing_age_X_train, missing_age_Y_train)))</span><br><span class="line">    missing_age_test.loc[:, <span class="string">'Age_GB'</span>] = gbm_reg_grid.predict(missing_age_X_test)</span><br><span class="line">    print(missing_age_test[<span class="string">'Age_GB'</span>][:<span class="number">4</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># model 2 rf</span></span><br><span class="line">    rf_reg = RandomForestRegressor()</span><br><span class="line">    rf_reg_param_grid = &#123;<span class="string">'n_estimators'</span>: [<span class="number">200</span>], <span class="string">'max_depth'</span>: [<span class="number">5</span>], <span class="string">'random_state'</span>: [<span class="number">0</span>]&#125;</span><br><span class="line">    rf_reg_grid = model_selection.GridSearchCV(rf_reg, rf_reg_param_grid, cv=<span class="number">10</span>, n_jobs=<span class="number">25</span>, verbose=<span class="number">1</span>, scoring=<span class="string">'neg_mean_squared_error'</span>)</span><br><span class="line">    rf_reg_grid.fit(missing_age_X_train, missing_age_Y_train)</span><br><span class="line">    print(<span class="string">'Age feature Best RF Params:'</span> + str(rf_reg_grid.best_params_))</span><br><span class="line">    print(<span class="string">'Age feature Best RF Score:'</span> + str(rf_reg_grid.best_score_))</span><br><span class="line">    print(<span class="string">'RF Train Error for "Age" Feature Regressor'</span> + str(rf_reg_grid.score(missing_age_X_train, missing_age_Y_train)))</span><br><span class="line">    missing_age_test.loc[:, <span class="string">'Age_RF'</span>] = rf_reg_grid.predict(missing_age_X_test)</span><br><span class="line">    print(missing_age_test[<span class="string">'Age_RF'</span>][:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># two models merge</span></span><br><span class="line">    print(<span class="string">'shape1'</span>, missing_age_test[<span class="string">'Age'</span>].shape, missing_age_test[[<span class="string">'Age_GB'</span>, <span class="string">'Age_RF'</span>]].mode(axis=<span class="number">1</span>).shape)</span><br><span class="line">    <span class="comment"># missing_age_test['Age'] = missing_age_test[['Age_GB', 'Age_LR']].mode(axis=1)</span></span><br><span class="line"></span><br><span class="line">    missing_age_test.loc[:, <span class="string">'Age'</span>] = np.mean([missing_age_test[<span class="string">'Age_GB'</span>], missing_age_test[<span class="string">'Age_RF'</span>]])</span><br><span class="line">    print(missing_age_test[<span class="string">'Age'</span>][:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">    missing_age_test.drop([<span class="string">'Age_GB'</span>, <span class="string">'Age_RF'</span>], axis=<span class="number">1</span>, inplace=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> missing_age_test</span><br></pre></td></tr></table></figure><p>利用融合模型预测的结果填充Age的缺失值：</p><p>其实这个地方需要注意的，上面是将trainset与testset进行一个有效的拼接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">combined_train_test.loc[(combined_train_test.Age.isnull()), <span class="string">'Age'</span>] = fill_missing_age(missing_age_train, missing_age_test)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Fitting <span class="number">10</span> folds <span class="keyword">for</span> each of <span class="number">1</span> candidates, totalling <span class="number">10</span> fits</span><br><span class="line"></span><br><span class="line"> [Parallel(n_jobs=<span class="number">25</span>)]: Done   <span class="number">5</span> out of  <span class="number">10</span> | elapsed:    <span class="number">3.9</span>s remaining:    <span class="number">3.9</span>s</span><br><span class="line"> [Parallel(n_jobs=<span class="number">25</span>)]: Done  <span class="number">10</span> out of  <span class="number">10</span> | elapsed:    <span class="number">6.9</span>s finished</span><br><span class="line"></span><br><span class="line"> Age feature Best GB Params:&#123;<span class="string">'n_estimators'</span>: <span class="number">2000</span>, <span class="string">'learning_rate'</span>: <span class="number">0.01</span>, <span class="string">'max_features'</span>: <span class="number">3</span>, <span class="string">'max_depth'</span>: <span class="number">4</span>&#125;</span><br><span class="line"> Age feature Best GB Score:<span class="number">-130.295677599</span></span><br><span class="line"> GB Train Error <span class="keyword">for</span> <span class="string">"Age"</span> Feature Regressor:<span class="number">-64.6566961723</span></span><br><span class="line"> <span class="number">5</span>     <span class="number">35.773942</span></span><br><span class="line"> <span class="number">17</span>    <span class="number">31.489153</span></span><br><span class="line"> <span class="number">19</span>    <span class="number">34.113840</span></span><br><span class="line"> <span class="number">26</span>    <span class="number">28.621281</span></span><br><span class="line"> Name: Age_GB, dtype: float64</span><br><span class="line"> Fitting <span class="number">10</span> folds <span class="keyword">for</span> each of <span class="number">1</span> candidates, totalling <span class="number">10</span> fits</span><br><span class="line"></span><br><span class="line"> [Parallel(n_jobs=<span class="number">25</span>)]: Done   <span class="number">5</span> out of  <span class="number">10</span> | elapsed:    <span class="number">6.2</span>s remaining:    <span class="number">6.2</span>s</span><br><span class="line"> [Parallel(n_jobs=<span class="number">25</span>)]: Done  <span class="number">10</span> out of  <span class="number">10</span> | elapsed:   <span class="number">10.7</span>s finished</span><br><span class="line"></span><br><span class="line"> Age feature Best RF Params:&#123;<span class="string">'n_estimators'</span>: <span class="number">200</span>, <span class="string">'random_state'</span>: <span class="number">0</span>, <span class="string">'max_depth'</span>: <span class="number">5</span>&#125;</span><br><span class="line"> Age feature Best RF Score:<span class="number">-119.094956052</span></span><br><span class="line"> RF Train Error <span class="keyword">for</span> <span class="string">"Age"</span> Feature Regressor<span class="number">-96.0603148448</span></span><br><span class="line"> <span class="number">5</span>     <span class="number">33.459421</span></span><br><span class="line"> <span class="number">17</span>    <span class="number">33.076798</span></span><br><span class="line"> <span class="number">19</span>    <span class="number">34.855942</span></span><br><span class="line"> <span class="number">26</span>    <span class="number">28.146718</span></span><br><span class="line"> Name: Age_RF, dtype: float64</span><br><span class="line"> shape1 (<span class="number">263</span>,) (<span class="number">263</span>, <span class="number">2</span>)</span><br><span class="line"> <span class="number">5</span>     <span class="number">30.000675</span></span><br><span class="line"> <span class="number">17</span>    <span class="number">30.000675</span></span><br><span class="line"> <span class="number">19</span>    <span class="number">30.000675</span></span><br><span class="line"> <span class="number">26</span>    <span class="number">30.000675</span></span><br><span class="line"> Name: Age, dtype: float64</span><br></pre></td></tr></table></figure><p>最后一项缺失值处理</p><p>因为Cabin项的缺失值确实太多了，我们很难对其进行分析，或者预测。所以这里我们可以直接将Cabin这一项特征去除。但通过上面的分析，可以知道，该特征信息的有无也与生存率有一定的关系，所以这里我们暂时保留该特征，并将其分为有和无两类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">combined_train_test.loc[combined_train_test.Cabin.isnull(), <span class="string">'Cabin'</span>] = <span class="string">'U0'</span></span><br><span class="line">combined_train_test[<span class="string">'Cabin'</span>] = combined_train_test[<span class="string">'Cabin'</span>].apply(<span class="keyword">lambda</span> x: <span class="number">0</span> <span class="keyword">if</span> x == <span class="string">'U0'</span> <span class="keyword">else</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="特征处理"><a href="#特征处理" class="headerlink" title="特征处理"></a>特征处理</h3><p>上面已经处理了一些数据，现在我需要增强一些特征，以便与后面特征的变化</p><h4 id="Sex"><a href="#Sex" class="headerlink" title="Sex"></a>Sex</h4><p>对Sex也进行one-hot编码，也就是dummy处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了后面的特征分析，这里我们也将 Sex 特征进行facrorizing</span></span><br><span class="line">combined_train_test[<span class="string">'Sex'</span>] = pd.factorize(combined_train_test[<span class="string">'Sex'</span>])[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">sex_dummies_df = pd.get_dummies(combined_train_test[<span class="string">'Sex'</span>], prefix=combined_train_test[[<span class="string">'Sex'</span>]].columns[<span class="number">0</span>])</span><br><span class="line">combined_train_test = pd.concat([combined_train_test, sex_dummies_df], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h4><p>首先先从名字中提取各种称呼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># what is each person's title? </span></span><br><span class="line">combined_train_test[<span class="string">'Title'</span>] = combined_train_test[<span class="string">'Name'</span>].map(<span class="keyword">lambda</span> x: re.compile(<span class="string">", (.*?)\."</span>).findall(x)[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>将各式称呼进行统一化处理：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">title_Dict = &#123;&#125;</span><br><span class="line">title_Dict.update(dict.fromkeys([<span class="string">'Capt'</span>, <span class="string">'Col'</span>, <span class="string">'Major'</span>, <span class="string">'Dr'</span>, <span class="string">'Rev'</span>], <span class="string">'Officer'</span>))</span><br><span class="line">title_Dict.update(dict.fromkeys([<span class="string">'Don'</span>, <span class="string">'Sir'</span>, <span class="string">'the Countess'</span>, <span class="string">'Dona'</span>, <span class="string">'Lady'</span>], <span class="string">'Royalty'</span>))</span><br><span class="line">title_Dict.update(dict.fromkeys([<span class="string">'Mme'</span>, <span class="string">'Ms'</span>, <span class="string">'Mrs'</span>], <span class="string">'Mrs'</span>))</span><br><span class="line">title_Dict.update(dict.fromkeys([<span class="string">'Mlle'</span>, <span class="string">'Miss'</span>], <span class="string">'Miss'</span>))</span><br><span class="line">title_Dict.update(dict.fromkeys([<span class="string">'Mr'</span>], <span class="string">'Mr'</span>))</span><br><span class="line">title_Dict.update(dict.fromkeys([<span class="string">'Master'</span>,<span class="string">'Jonkheer'</span>], <span class="string">'Master'</span>))</span><br><span class="line"></span><br><span class="line">combined_train_test[<span class="string">'Title'</span>] = combined_train_test[<span class="string">'Title'</span>].map(title_Dict)</span><br></pre></td></tr></table></figure></p><p>使用dummy对不同的称呼进行分列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了后面的特征分析，这里我们也将 Title 特征进行facrorizing</span></span><br><span class="line">combined_train_test[<span class="string">'Title'</span>] = pd.factorize(combined_train_test[<span class="string">'Title'</span>])[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">title_dummies_df = pd.get_dummies(combined_train_test[<span class="string">'Title'</span>], prefix=combined_train_test[[<span class="string">'Title'</span>]].columns[<span class="number">0</span>])</span><br><span class="line">combined_train_test = pd.concat([combined_train_test, title_dummies_df], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>下面开始就不准备贴代码了，可以去GitHub上面去看</p><h4 id="Fare"><a href="#Fare" class="headerlink" title="Fare"></a>Fare</h4><p>由前面分析可以知道，Fare项在测试数据中缺少一个值，所以需要对该值进行填充。</p><p>我们按照一二三等舱各自的均价来填充：</p><p>下面transform将函数np.mean应用到各个group中</p><p>通过对Ticket数据的分析，我们可以看到部分票号数据有重复，同时结合亲属人数及名字的数据，和票价船舱等级对比，我们可以知道购买的票中有家庭票和团体票，所以我们需要将团体票的票价分配到每个人的头上。</p><p>使用binning给票价分等级，对于5个等级的票价我们也可以继续使用dummy为票价等级分列。</p><h4 id="Pclass"><a href="#Pclass" class="headerlink" title="Pclass"></a>Pclass</h4><p>这里是神来之笔，我看到别人在这个地方有出奇的特征增强方法：</p><p>Pclass这一项，其实已经可以不用继续处理了，我们只需要将其转换为dummy形式即可。</p><p>但是为了更好的分析问题，我们这里假设对于不同等级的船舱，各船舱内部的票价也说明了各等级舱的位置，那么也就很有可能与逃生的顺序有关系。所以这里分出每等舱里的高价和低价位。</p><h4 id="Parch-and-SibSp"><a href="#Parch-and-SibSp" class="headerlink" title="Parch and SibSp"></a>Parch and SibSp</h4><p>对于这两个参数，大佬们的处理就是 <strong>将这两个特征整合成一个特征，牛逼了大佬</strong></p><h3 id="特征间相关性分析"><a href="#特征间相关性分析" class="headerlink" title="特征间相关性分析"></a>特征间相关性分析</h3><p>我们挑选一些主要的特征，生成特征之间的关联图，查看特征与特征之间的相关性：<br>将上述所有特征去看看相互之间的关系或者与结果之间的关系</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Correlation = pd.DataFrame(combined_train_test[</span><br><span class="line"> [<span class="string">'Embarked'</span>, <span class="string">'Sex'</span>, <span class="string">'Title'</span>, <span class="string">'Name_length'</span>, <span class="string">'Family_Size'</span>, <span class="string">'Family_Size_Category'</span>,<span class="string">'Fare'</span>, <span class="string">'Fare_bin_id'</span>, <span class="string">'Pclass'</span>, </span><br><span class="line">  <span class="string">'Pclass_Fare_Category'</span>, <span class="string">'Age'</span>, <span class="string">'Ticket_Letter'</span>, <span class="string">'Cabin'</span>]])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">colormap = plt.cm.viridis</span><br><span class="line">plt.figure(figsize=(<span class="number">14</span>,<span class="number">12</span>))</span><br><span class="line">plt.title(<span class="string">'Pearson Correlation of Features'</span>, y=<span class="number">1.05</span>, size=<span class="number">15</span>)</span><br><span class="line">sns.heatmap(Correlation.astype(float).corr(),linewidths=<span class="number">0.1</span>,vmax=<span class="number">1.0</span>, square=<span class="keyword">True</span>, cmap=colormap, linecolor=<span class="string">'white'</span>, annot=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p><img src="/2020/03/11/Kaggle-Titanic-生存预测/5.jpg" alt=""></p><p><strong>特征之间的数据分布图</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = sns.pairplot(combined_train_test[[<span class="string">u'Survived'</span>, <span class="string">u'Pclass'</span>, <span class="string">u'Sex'</span>, <span class="string">u'Age'</span>, <span class="string">u'Fare'</span>, <span class="string">u'Embarked'</span>,</span><br><span class="line">    <span class="string">u'Family_Size'</span>, <span class="string">u'Title'</span>, <span class="string">u'Ticket_Letter'</span>]], hue=<span class="string">'Survived'</span>, palette = <span class="string">'seismic'</span>,size=<span class="number">1.2</span>,diag_kind = <span class="string">'kde'</span>,diag_kws=dict(shade=<span class="keyword">True</span>),plot_kws=dict(s=<span class="number">10</span>) )</span><br><span class="line">g.set(xticklabels=[])</span><br></pre></td></tr></table></figure><p><img src="/2020/03/11/Kaggle-Titanic-生存预测/6.jpg" alt=""></p><h4 id="输入模型前的一些处理"><a href="#输入模型前的一些处理" class="headerlink" title="输入模型前的一些处理"></a>输入模型前的一些处理</h4><p>这里我们将Age和fare进行<strong>正则化</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scale_age_fare = preprocessing.StandardScaler().fit(combined_train_test[[<span class="string">'Age'</span>,<span class="string">'Fare'</span>, <span class="string">'Name_length'</span>]])</span><br><span class="line">combined_train_test[[<span class="string">'Age'</span>,<span class="string">'Fare'</span>, <span class="string">'Name_length'</span>]] = scale_age_fare.transform(combined_train_test[[<span class="string">'Age'</span>,<span class="string">'Fare'</span>, <span class="string">'Name_length'</span>]])</span><br></pre></td></tr></table></figure><p>丢弃掉一些无用的特征</p><p>对于上面的特征工程中，我们从一些原始的特征中提取出了很多要融合到模型中的特征，但是我们需要剔除那些原本的我们用不到的或者非数值特征。</p><p><strong>首先对我们的数据先进行一下备份，以便后期的再次分析：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">combined_data_backup = combined_train_test</span><br><span class="line">combined_train_test.drop([<span class="string">'PassengerId'</span>, <span class="string">'Embarked'</span>, <span class="string">'Sex'</span>, <span class="string">'Name'</span>, <span class="string">'Title'</span>, <span class="string">'Fare_bin_id'</span>, <span class="string">'Pclass_Fare_Category'</span>, </span><br><span class="line">                       <span class="string">'Parch'</span>, <span class="string">'SibSp'</span>, <span class="string">'Family_Size_Category'</span>, <span class="string">'Ticket'</span>],axis=<span class="number">1</span>,inplace=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>将训练数据和测试数据分开：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">train_data = combined_train_test[:<span class="number">891</span>]</span><br><span class="line">test_data = combined_train_test[<span class="number">891</span>:]</span><br><span class="line"></span><br><span class="line">titanic_train_data_X = train_data.drop([<span class="string">'Survived'</span>],axis=<span class="number">1</span>)</span><br><span class="line">titanic_train_data_Y = train_data[<span class="string">'Survived'</span>]</span><br><span class="line">titanic_test_data_X = test_data.drop([<span class="string">'Survived'</span>],axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">titanic_train_data_X.shape</span><br></pre></td></tr></table></figure><h3 id="模型融合以及测试"><a href="#模型融合以及测试" class="headerlink" title="模型融合以及测试"></a>模型融合以及测试</h3><p>需要按照下面的这些步骤来进行：</p><h4 id="利用不同的模型来对特征进行筛选，选出较为重要的特征："><a href="#利用不同的模型来对特征进行筛选，选出较为重要的特征：" class="headerlink" title="利用不同的模型来对特征进行筛选，选出较为重要的特征："></a>利用不同的模型来对特征进行筛选，选出较为重要的特征：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> ExtraTreesClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_top_n_features</span><span class="params">(titanic_train_data_X, titanic_train_data_Y, top_n_features)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># random forest</span></span><br><span class="line">    rf_est = RandomForestClassifier(random_state=<span class="number">0</span>)</span><br><span class="line">    rf_param_grid = &#123;<span class="string">'n_estimators'</span>: [<span class="number">500</span>], <span class="string">'min_samples_split'</span>: [<span class="number">2</span>, <span class="number">3</span>], <span class="string">'max_depth'</span>: [<span class="number">20</span>]&#125;</span><br><span class="line">    rf_grid = model_selection.GridSearchCV(rf_est, rf_param_grid, n_jobs=<span class="number">25</span>, cv=<span class="number">10</span>, verbose=<span class="number">1</span>)</span><br><span class="line">    rf_grid.fit(titanic_train_data_X, titanic_train_data_Y)</span><br><span class="line">    print(<span class="string">'Top N Features Best RF Params:'</span> + str(rf_grid.best_params_))</span><br><span class="line">    print(<span class="string">'Top N Features Best RF Score:'</span> + str(rf_grid.best_score_))</span><br><span class="line">    print(<span class="string">'Top N Features RF Train Score:'</span> + str(rf_grid.score(titanic_train_data_X, titanic_train_data_Y)))</span><br><span class="line">    feature_imp_sorted_rf = pd.DataFrame(&#123;<span class="string">'feature'</span>: list(titanic_train_data_X),</span><br><span class="line">                                          <span class="string">'importance'</span>: rf_grid.best_estimator_.feature_importances_&#125;).sort_values(<span class="string">'importance'</span>, ascending=<span class="keyword">False</span>)</span><br><span class="line">    features_top_n_rf = feature_imp_sorted_rf.head(top_n_features)[<span class="string">'feature'</span>]</span><br><span class="line">    print(<span class="string">'Sample 10 Features from RF Classifier'</span>)</span><br><span class="line">    print(str(features_top_n_rf[:<span class="number">10</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># AdaBoost</span></span><br><span class="line">    ada_est =AdaBoostClassifier(random_state=<span class="number">0</span>)</span><br><span class="line">    ada_param_grid = &#123;<span class="string">'n_estimators'</span>: [<span class="number">500</span>], <span class="string">'learning_rate'</span>: [<span class="number">0.01</span>, <span class="number">0.1</span>]&#125;</span><br><span class="line">    ada_grid = model_selection.GridSearchCV(ada_est, ada_param_grid, n_jobs=<span class="number">25</span>, cv=<span class="number">10</span>, verbose=<span class="number">1</span>)</span><br><span class="line">    ada_grid.fit(titanic_train_data_X, titanic_train_data_Y)</span><br><span class="line">    print(<span class="string">'Top N Features Best Ada Params:'</span> + str(ada_grid.best_params_))</span><br><span class="line">    print(<span class="string">'Top N Features Best Ada Score:'</span> + str(ada_grid.best_score_))</span><br><span class="line">    print(<span class="string">'Top N Features Ada Train Score:'</span> + str(ada_grid.score(titanic_train_data_X, titanic_train_data_Y)))</span><br><span class="line">    feature_imp_sorted_ada = pd.DataFrame(&#123;<span class="string">'feature'</span>: list(titanic_train_data_X),</span><br><span class="line">                                           <span class="string">'importance'</span>: ada_grid.best_estimator_.feature_importances_&#125;).sort_values(<span class="string">'importance'</span>, ascending=<span class="keyword">False</span>)</span><br><span class="line">    features_top_n_ada = feature_imp_sorted_ada.head(top_n_features)[<span class="string">'feature'</span>]</span><br><span class="line">    print(<span class="string">'Sample 10 Feature from Ada Classifier:'</span>)</span><br><span class="line">    print(str(features_top_n_ada[:<span class="number">10</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ExtraTree</span></span><br><span class="line">    et_est = ExtraTreesClassifier(random_state=<span class="number">0</span>)</span><br><span class="line">    et_param_grid = &#123;<span class="string">'n_estimators'</span>: [<span class="number">500</span>], <span class="string">'min_samples_split'</span>: [<span class="number">3</span>, <span class="number">4</span>], <span class="string">'max_depth'</span>: [<span class="number">20</span>]&#125;</span><br><span class="line">    et_grid = model_selection.GridSearchCV(et_est, et_param_grid, n_jobs=<span class="number">25</span>, cv=<span class="number">10</span>, verbose=<span class="number">1</span>)</span><br><span class="line">    et_grid.fit(titanic_train_data_X, titanic_train_data_Y)</span><br><span class="line">    print(<span class="string">'Top N Features Best ET Params:'</span> + str(et_grid.best_params_))</span><br><span class="line">    print(<span class="string">'Top N Features Best ET Score:'</span> + str(et_grid.best_score_))</span><br><span class="line">    print(<span class="string">'Top N Features ET Train Score:'</span> + str(et_grid.score(titanic_train_data_X, titanic_train_data_Y)))</span><br><span class="line">    feature_imp_sorted_et = pd.DataFrame(&#123;<span class="string">'feature'</span>: list(titanic_train_data_X),</span><br><span class="line">                                          <span class="string">'importance'</span>: et_grid.best_estimator_.feature_importances_&#125;).sort_values(<span class="string">'importance'</span>, ascending=<span class="keyword">False</span>)</span><br><span class="line">    features_top_n_et = feature_imp_sorted_et.head(top_n_features)[<span class="string">'feature'</span>]</span><br><span class="line">    print(<span class="string">'Sample 10 Features from ET Classifier:'</span>)</span><br><span class="line">    print(str(features_top_n_et[:<span class="number">10</span>]))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># GradientBoosting</span></span><br><span class="line">    gb_est =GradientBoostingClassifier(random_state=<span class="number">0</span>)</span><br><span class="line">    gb_param_grid = &#123;<span class="string">'n_estimators'</span>: [<span class="number">500</span>], <span class="string">'learning_rate'</span>: [<span class="number">0.01</span>, <span class="number">0.1</span>], <span class="string">'max_depth'</span>: [<span class="number">20</span>]&#125;</span><br><span class="line">    gb_grid = model_selection.GridSearchCV(gb_est, gb_param_grid, n_jobs=<span class="number">25</span>, cv=<span class="number">10</span>, verbose=<span class="number">1</span>)</span><br><span class="line">    gb_grid.fit(titanic_train_data_X, titanic_train_data_Y)</span><br><span class="line">    print(<span class="string">'Top N Features Best GB Params:'</span> + str(gb_grid.best_params_))</span><br><span class="line">    print(<span class="string">'Top N Features Best GB Score:'</span> + str(gb_grid.best_score_))</span><br><span class="line">    print(<span class="string">'Top N Features GB Train Score:'</span> + str(gb_grid.score(titanic_train_data_X, titanic_train_data_Y)))</span><br><span class="line">    feature_imp_sorted_gb = pd.DataFrame(&#123;<span class="string">'feature'</span>: list(titanic_train_data_X),</span><br><span class="line">                                           <span class="string">'importance'</span>: gb_grid.best_estimator_.feature_importances_&#125;).sort_values(<span class="string">'importance'</span>, ascending=<span class="keyword">False</span>)</span><br><span class="line">    features_top_n_gb = feature_imp_sorted_gb.head(top_n_features)[<span class="string">'feature'</span>]</span><br><span class="line">    print(<span class="string">'Sample 10 Feature from GB Classifier:'</span>)</span><br><span class="line">    print(str(features_top_n_gb[:<span class="number">10</span>]))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># DecisionTree</span></span><br><span class="line">    dt_est = DecisionTreeClassifier(random_state=<span class="number">0</span>)</span><br><span class="line">    dt_param_grid = &#123;<span class="string">'min_samples_split'</span>: [<span class="number">2</span>, <span class="number">4</span>], <span class="string">'max_depth'</span>: [<span class="number">20</span>]&#125;</span><br><span class="line">    dt_grid = model_selection.GridSearchCV(dt_est, dt_param_grid, n_jobs=<span class="number">25</span>, cv=<span class="number">10</span>, verbose=<span class="number">1</span>)</span><br><span class="line">    dt_grid.fit(titanic_train_data_X, titanic_train_data_Y)</span><br><span class="line">    print(<span class="string">'Top N Features Best DT Params:'</span> + str(dt_grid.best_params_))</span><br><span class="line">    print(<span class="string">'Top N Features Best DT Score:'</span> + str(dt_grid.best_score_))</span><br><span class="line">    print(<span class="string">'Top N Features DT Train Score:'</span> + str(dt_grid.score(titanic_train_data_X, titanic_train_data_Y)))</span><br><span class="line">    feature_imp_sorted_dt = pd.DataFrame(&#123;<span class="string">'feature'</span>: list(titanic_train_data_X),</span><br><span class="line">                                          <span class="string">'importance'</span>: dt_grid.best_estimator_.feature_importances_&#125;).sort_values(<span class="string">'importance'</span>, ascending=<span class="keyword">False</span>)</span><br><span class="line">    features_top_n_dt = feature_imp_sorted_dt.head(top_n_features)[<span class="string">'feature'</span>]</span><br><span class="line">    print(<span class="string">'Sample 10 Features from DT Classifier:'</span>)</span><br><span class="line">    print(str(features_top_n_dt[:<span class="number">10</span>]))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># merge the three models</span></span><br><span class="line">    features_top_n = pd.concat([features_top_n_rf, features_top_n_ada, features_top_n_et, features_top_n_gb, features_top_n_dt], </span><br><span class="line">                               ignore_index=<span class="keyword">True</span>).drop_duplicates()</span><br><span class="line">    </span><br><span class="line">    features_importance = pd.concat([feature_imp_sorted_rf, feature_imp_sorted_ada, feature_imp_sorted_et, </span><br><span class="line">                                   feature_imp_sorted_gb, feature_imp_sorted_dt],ignore_index=<span class="keyword">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> features_top_n , features_importance</span><br></pre></td></tr></table></figure><p>上面的代码不需要看着害怕，其实无非就是调用一些神奇的函数而已，上面的代码就是在 多个模型中去寻找重要的特征，并且进行排序，为后面模型训练作出贡献。</p><h4 id="依据我们筛选出的特征构建训练集和测试集"><a href="#依据我们筛选出的特征构建训练集和测试集" class="headerlink" title="依据我们筛选出的特征构建训练集和测试集"></a>依据我们筛选出的特征构建训练集和测试集</h4><p>但如果在进行特征工程的过程中，产生了大量的特征，而特征与特征之间会存在一定的相关性。太多的特征一方面会影响模型训练的速度，另一方面也可能会使得模型过拟合。所以在特征太多的情况下，我们可以利用不同的模型对特征进行筛选，选取出我们想要的前n个特征。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">feature_to_pick = <span class="number">30</span></span><br><span class="line">feature_top_n, feature_importance = get_top_n_features(titanic_train_data_X, titanic_train_data_Y, feature_to_pick)</span><br><span class="line">titanic_train_data_X = pd.DataFrame(titanic_train_data_X[feature_top_n])</span><br><span class="line">titanic_test_data_X = pd.DataFrame(titanic_test_data_X[feature_top_n])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">Fitting <span class="number">10</span> folds <span class="keyword">for</span> each of <span class="number">2</span> candidates, totalling <span class="number">20</span> fits</span><br><span class="line"></span><br><span class="line"> [Parallel(n_jobs=<span class="number">25</span>)]: Done  <span class="number">13</span> out of  <span class="number">20</span> | elapsed:   <span class="number">13.7</span>s remaining:    <span class="number">7.3</span>s</span><br><span class="line"> [Parallel(n_jobs=<span class="number">25</span>)]: Done  <span class="number">20</span> out of  <span class="number">20</span> | elapsed:   <span class="number">19.2</span>s finished</span><br><span class="line"></span><br><span class="line"> Top N Features Best RF Params:&#123;<span class="string">'n_estimators'</span>: <span class="number">500</span>, <span class="string">'min_samples_split'</span>: <span class="number">3</span>, <span class="string">'max_depth'</span>: <span class="number">20</span>&#125;</span><br><span class="line"> Top N Features Best RF Score:<span class="number">0.822671156004</span></span><br><span class="line"> Top N Features RF Train Score:<span class="number">0.979797979798</span></span><br><span class="line"> Sample <span class="number">10</span> Features <span class="keyword">from</span> RF Classifier</span><br><span class="line"> <span class="number">15</span>      Name_length</span><br><span class="line"> <span class="number">0</span>               Age</span><br><span class="line"> <span class="number">2</span>              Fare</span><br><span class="line"> <span class="number">7</span>             Sex_0</span><br><span class="line"> <span class="number">9</span>           Title_0</span><br><span class="line"> <span class="number">8</span>             Sex_1</span><br><span class="line"> <span class="number">27</span>      Family_Size</span><br><span class="line"> <span class="number">3</span>            Pclass</span><br><span class="line"> <span class="number">31</span>    Ticket_Letter</span><br><span class="line"> <span class="number">11</span>          Title_2</span><br><span class="line"> Name: feature, dtype: object</span><br><span class="line"> Fitting <span class="number">10</span> folds <span class="keyword">for</span> each of <span class="number">2</span> candidates, totalling <span class="number">20</span> fits</span><br><span class="line"></span><br><span class="line"> [Parallel(n_jobs=<span class="number">25</span>)]: Done  <span class="number">13</span> out of  <span class="number">20</span> | elapsed:   <span class="number">10.3</span>s remaining:    <span class="number">5.5</span>s</span><br><span class="line"> [Parallel(n_jobs=<span class="number">25</span>)]: Done  <span class="number">20</span> out of  <span class="number">20</span> | elapsed:   <span class="number">14.9</span>s finished</span><br><span class="line"></span><br><span class="line"> Top N Features Best Ada Params:&#123;<span class="string">'n_estimators'</span>: <span class="number">500</span>, <span class="string">'learning_rate'</span>: <span class="number">0.01</span>&#125;</span><br><span class="line"> Top N Features Best Ada Score:<span class="number">0.81593714927</span></span><br><span class="line"> Top N Features Ada Train Score:<span class="number">0.820426487093</span></span><br><span class="line"> Sample <span class="number">10</span> Feature <span class="keyword">from</span> Ada Classifier:</span><br><span class="line"> <span class="number">9</span>                    Title_0</span><br><span class="line"> <span class="number">2</span>                       Fare</span><br><span class="line"> <span class="number">27</span>               Family_Size</span><br><span class="line"> <span class="number">7</span>                      Sex_0</span><br><span class="line"> <span class="number">3</span>                     Pclass</span><br><span class="line"> <span class="number">28</span>    Family_Size_Category_0</span><br><span class="line"> <span class="number">1</span>                      Cabin</span><br><span class="line"> <span class="number">8</span>                      Sex_1</span><br><span class="line"> <span class="number">15</span>               Name_length</span><br><span class="line"> <span class="number">0</span>                        Age</span><br><span class="line"> Name: feature, dtype: object</span><br><span class="line"> Fitting <span class="number">10</span> folds <span class="keyword">for</span> each of <span class="number">2</span> candidates, totalling <span class="number">20</span> fits</span><br><span class="line"></span><br><span class="line"> [Parallel(n_jobs=<span class="number">25</span>)]: Done  <span class="number">13</span> out of  <span class="number">20</span> | elapsed:    <span class="number">9.8</span>s remaining:    <span class="number">5.3</span>s</span><br><span class="line"> [Parallel(n_jobs=<span class="number">25</span>)]: Done  <span class="number">20</span> out of  <span class="number">20</span> | elapsed:   <span class="number">14.2</span>s finished</span><br><span class="line"></span><br><span class="line"> Top N Features Best ET Params:&#123;<span class="string">'n_estimators'</span>: <span class="number">500</span>, <span class="string">'min_samples_split'</span>: <span class="number">4</span>, <span class="string">'max_depth'</span>: <span class="number">20</span>&#125;</span><br><span class="line"> Top N Features Best ET Score:<span class="number">0.828282828283</span></span><br><span class="line"> Top N Features ET Train Score:<span class="number">0.971941638608</span></span><br><span class="line"> Sample <span class="number">10</span> Features <span class="keyword">from</span> ET Classifier:</span><br><span class="line"> <span class="number">9</span>           Title_0</span><br><span class="line"> <span class="number">8</span>             Sex_1</span><br><span class="line"> <span class="number">7</span>             Sex_0</span><br><span class="line"> <span class="number">15</span>      Name_length</span><br><span class="line"> <span class="number">0</span>               Age</span><br><span class="line"> <span class="number">2</span>              Fare</span><br><span class="line"> <span class="number">1</span>             Cabin</span><br><span class="line"> <span class="number">31</span>    Ticket_Letter</span><br><span class="line"> <span class="number">11</span>          Title_2</span><br><span class="line"> <span class="number">10</span>          Title_1</span><br><span class="line"> Name: feature, dtype: object</span><br><span class="line"> Fitting <span class="number">10</span> folds <span class="keyword">for</span> each of <span class="number">2</span> candidates, totalling <span class="number">20</span> fits</span><br><span class="line"></span><br><span class="line"> [Parallel(n_jobs=<span class="number">25</span>)]: Done  <span class="number">13</span> out of  <span class="number">20</span> | elapsed:   <span class="number">25.9</span>s remaining:   <span class="number">13.9</span>s</span><br><span class="line"> [Parallel(n_jobs=<span class="number">25</span>)]: Done  <span class="number">20</span> out of  <span class="number">20</span> | elapsed:   <span class="number">27.9</span>s finished</span><br><span class="line"></span><br><span class="line"> Top N Features Best GB Params:&#123;<span class="string">'n_estimators'</span>: <span class="number">500</span>, <span class="string">'learning_rate'</span>: <span class="number">0.1</span>, <span class="string">'max_depth'</span>: <span class="number">20</span>&#125;</span><br><span class="line"> Top N Features Best GB Score:<span class="number">0.789001122334</span></span><br><span class="line"> Top N Features GB Train Score:<span class="number">0.996632996633</span></span><br><span class="line"> Sample <span class="number">10</span> Feature <span class="keyword">from</span> GB Classifier:</span><br><span class="line"> <span class="number">0</span>               Age</span><br><span class="line"> <span class="number">2</span>              Fare</span><br><span class="line"> <span class="number">15</span>      Name_length</span><br><span class="line"> <span class="number">31</span>    Ticket_Letter</span><br><span class="line"> <span class="number">9</span>           Title_0</span><br><span class="line"> <span class="number">27</span>      Family_Size</span><br><span class="line"> <span class="number">23</span>         Pclass_2</span><br><span class="line"> <span class="number">3</span>            Pclass</span><br><span class="line"> <span class="number">18</span>           Fare_2</span><br><span class="line"> <span class="number">14</span>          Title_5</span><br><span class="line"> Name: feature, dtype: object</span><br><span class="line"> Fitting <span class="number">10</span> folds <span class="keyword">for</span> each of <span class="number">2</span> candidates, totalling <span class="number">20</span> fits</span><br><span class="line"></span><br><span class="line"> [Parallel(n_jobs=<span class="number">25</span>)]: Done  <span class="number">13</span> out of  <span class="number">20</span> | elapsed:    <span class="number">6.3</span>s remaining:    <span class="number">3.3</span>s</span><br><span class="line"> [Parallel(n_jobs=<span class="number">25</span>)]: Done  <span class="number">20</span> out of  <span class="number">20</span> | elapsed:    <span class="number">9.6</span>s finished</span><br><span class="line"></span><br><span class="line"> Top N Features Best DT Params:&#123;<span class="string">'min_samples_split'</span>: <span class="number">4</span>, <span class="string">'max_depth'</span>: <span class="number">20</span>&#125;</span><br><span class="line"> Top N Features Best DT Score:<span class="number">0.784511784512</span></span><br><span class="line"> Top N Features DT Train Score:<span class="number">0.959595959596</span></span><br><span class="line"> Sample <span class="number">10</span> Features <span class="keyword">from</span> DT Classifier:</span><br><span class="line"> <span class="number">9</span>           Title_0</span><br><span class="line"> <span class="number">0</span>               Age</span><br><span class="line"> <span class="number">2</span>              Fare</span><br><span class="line"> <span class="number">15</span>      Name_length</span><br><span class="line"> <span class="number">27</span>      Family_Size</span><br><span class="line"> <span class="number">14</span>          Title_5</span><br><span class="line"> <span class="number">26</span>         Pclass_5</span><br><span class="line"> <span class="number">3</span>            Pclass</span><br><span class="line"> <span class="number">31</span>    Ticket_Letter</span><br><span class="line"> <span class="number">23</span>         Pclass_2</span><br><span class="line"> Name: feature, dtype: object</span><br></pre></td></tr></table></figure><p>上面就是对之前的一个函数进行的一个调整</p><p>用视图可视化不同算法筛选的特征排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">rf_feature_imp = feature_importance[:<span class="number">10</span>]</span><br><span class="line">Ada_feature_imp = feature_importance[<span class="number">32</span>:<span class="number">32</span>+<span class="number">10</span>].reset_index(drop=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make importances relative to max importance</span></span><br><span class="line">rf_feature_importance = <span class="number">100.0</span> * (rf_feature_imp[<span class="string">'importance'</span>] / rf_feature_imp[<span class="string">'importance'</span>].max())</span><br><span class="line">Ada_feature_importance = <span class="number">100.0</span> * (Ada_feature_imp[<span class="string">'importance'</span>] / Ada_feature_imp[<span class="string">'importance'</span>].max())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the indexes of all features over the importance threshold</span></span><br><span class="line">rf_important_idx = np.where(rf_feature_importance)[<span class="number">0</span>]</span><br><span class="line">Ada_important_idx = np.where(Ada_feature_importance)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Adapted from Gradient Boosting regression</span></span><br><span class="line">pos = np.arange(rf_important_idx.shape[<span class="number">0</span>]) + <span class="number">.5</span></span><br><span class="line"></span><br><span class="line">plt.figure(<span class="number">1</span>, figsize = (<span class="number">18</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.barh(pos, rf_feature_importance[rf_important_idx][::<span class="number">-1</span>])</span><br><span class="line">plt.yticks(pos, rf_feature_imp[<span class="string">'feature'</span>][::<span class="number">-1</span>])</span><br><span class="line">plt.xlabel(<span class="string">'Relative Importance'</span>)</span><br><span class="line">plt.title(<span class="string">'RandomForest Feature Importance'</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.barh(pos, Ada_feature_importance[Ada_important_idx][::<span class="number">-1</span>])</span><br><span class="line">plt.yticks(pos, Ada_feature_imp[<span class="string">'feature'</span>][::<span class="number">-1</span>])</span><br><span class="line">plt.xlabel(<span class="string">'Relative Importance'</span>)</span><br><span class="line">plt.title(<span class="string">'AdaBoost Feature Importance'</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2020/03/11/Kaggle-Titanic-生存预测/7.jpg" alt=""></p><h4 id="模型融合"><a href="#模型融合" class="headerlink" title="模型融合"></a>模型融合</h4><p>前面已经训练了多个模型，这个时候就可以直接展开融合了。</p><p>常见的模型融合方法有：Bagging、Boosting、Stacking、Blending</p><p>常见的相关介绍，直接去看笔记中</p><p><strong>Stacking框架融合:</strong></p><p>这里我们使用了两层的模型融合，Level 1使用了：RandomForest、AdaBoost、ExtraTrees、GBDT、DecisionTree、KNN、SVM ，一共7个模型，Level 2使用了XGBoost使用第一层预测的结果作为特征对最终的结果进行预测。</p><ol><li><p>Stacking框架是堆叠使用基础分类器的预测作为对二级模型的训练的输入。 然而，我们不能简单地在全部训练数据上训练基本模型，产生预测，输出用于第二层的训练。如果我们在Train Data上训练，然后在Train Data上预测，就会造成标签泄露。为了避免标签泄露，我们需要对每个基学习器使用K-fold，将K个模型对Valid Set的预测结果拼起来，作为下一层学习器的输入。</p><p> 所以这里我们建立输出K-fold预测的方法：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"></span><br><span class="line"><span class="comment"># Some useful parameters which will come in handy later on</span></span><br><span class="line">ntrain = titanic_train_data_X.shape[<span class="number">0</span>]</span><br><span class="line">ntest = titanic_test_data_X.shape[<span class="number">0</span>]</span><br><span class="line">SEED = <span class="number">0</span> <span class="comment"># for reproducibility</span></span><br><span class="line">NFOLDS = <span class="number">7</span> <span class="comment"># set folds for out-of-fold prediction</span></span><br><span class="line">kf = KFold(n_splits = NFOLDS, random_state=SEED, shuffle=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_out_fold</span><span class="params">(clf, x_train, y_train, x_test)</span>:</span></span><br><span class="line">    oof_train = np.zeros((ntrain,))</span><br><span class="line">    oof_test = np.zeros((ntest,))</span><br><span class="line">    oof_test_skf = np.empty((NFOLDS, ntest))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, (train_index, test_index) <span class="keyword">in</span> enumerate(kf.split(x_train)):</span><br><span class="line">        x_tr = x_train[train_index]</span><br><span class="line">        y_tr = y_train[train_index]</span><br><span class="line">        x_te = x_train[test_index]</span><br><span class="line"></span><br><span class="line">        clf.fit(x_tr, y_tr)</span><br><span class="line"></span><br><span class="line">        oof_train[test_index] = clf.predict(x_te)</span><br><span class="line">        oof_test_skf[i, :] = clf.predict(x_test)</span><br><span class="line"></span><br><span class="line">    oof_test[:] = oof_test_skf.mean(axis=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> oof_train.reshape(<span class="number">-1</span>, <span class="number">1</span>), oof_test.reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ol><pre><code>构建不同的基学习器，这里我们使用了RandomForest、AdaBoost、ExtraTrees、GBDT、DecisionTree、KNN、SVM 七个基学习器：（这里的模型可以使用如上面的GridSearch方法对模型的超参数进行搜索选择）上面GridSearch就是对参数的搜索选择<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"></span><br><span class="line">rf = RandomForestClassifier(n_estimators=<span class="number">500</span>, warm_start=<span class="keyword">True</span>, max_features=<span class="string">'sqrt'</span>,max_depth=<span class="number">6</span>, </span><br><span class="line">                            min_samples_split=<span class="number">3</span>, min_samples_leaf=<span class="number">2</span>, n_jobs=<span class="number">-1</span>, verbose=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ada = AdaBoostClassifier(n_estimators=<span class="number">500</span>, learning_rate=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">et = ExtraTreesClassifier(n_estimators=<span class="number">500</span>, n_jobs=<span class="number">-1</span>, max_depth=<span class="number">8</span>, min_samples_leaf=<span class="number">2</span>, verbose=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">gb = GradientBoostingClassifier(n_estimators=<span class="number">500</span>, learning_rate=<span class="number">0.008</span>, min_samples_split=<span class="number">3</span>, min_samples_leaf=<span class="number">2</span>, max_depth=<span class="number">5</span>, verbose=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">dt = DecisionTreeClassifier(max_depth=<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">knn = KNeighborsClassifier(n_neighbors = <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">svm = SVC(kernel=<span class="string">'linear'</span>, C=<span class="number">0.025</span>)</span><br></pre></td></tr></table></figure>将pandas转换为arrays：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x_train = titanic_train_data_X.values <span class="comment"># Creates an array of the train data</span></span><br><span class="line">x_test = titanic_test_data_X.values <span class="comment"># Creats an array of the test data</span></span><br><span class="line">y_train = titanic_train_data_Y.values</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rf_oof_train, rf_oof_test = get_out_fold(rf, x_train, y_train, x_test) <span class="comment"># Random Forest</span></span><br><span class="line">ada_oof_train, ada_oof_test = get_out_fold(ada, x_train, y_train, x_test) <span class="comment"># AdaBoost </span></span><br><span class="line">et_oof_train, et_oof_test = get_out_fold(et, x_train, y_train, x_test) <span class="comment"># Extra Trees</span></span><br><span class="line">gb_oof_train, gb_oof_test = get_out_fold(gb, x_train, y_train, x_test) <span class="comment"># Gradient Boost</span></span><br><span class="line">dt_oof_train, dt_oof_test = get_out_fold(dt, x_train, y_train, x_test) <span class="comment"># Decision Tree</span></span><br><span class="line">knn_oof_train, knn_oof_test = get_out_fold(knn, x_train, y_train, x_test) <span class="comment"># KNeighbors</span></span><br><span class="line">svm_oof_train, svm_oof_test = get_out_fold(svm, x_train, y_train, x_test) <span class="comment"># Support Vector</span></span><br></pre></td></tr></table></figure></code></pre><ol><li><p>预测并提交文件。我们利用XGBoost，使用第一层预测的结果作为特征对最终的结果进行预测。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xgboost <span class="keyword">import</span> XGBClassifier</span><br><span class="line"></span><br><span class="line">gbm = XGBClassifier( n_estimators= <span class="number">2000</span>, max_depth= <span class="number">4</span>, min_child_weight= <span class="number">2</span>, gamma=<span class="number">0.9</span>, subsample=<span class="number">0.8</span>, </span><br><span class="line">                    colsample_bytree=<span class="number">0.8</span>, objective= <span class="string">'binary:logistic'</span>, nthread= <span class="number">-1</span>, scale_pos_weight=<span class="number">1</span>).fit(x_train, y_train)</span><br><span class="line">predictions = gbm.predict(x_test)</span><br></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StackingSubmission = pd.DataFrame(&#123;<span class="string">'PassengerId'</span>: PassengerId, <span class="string">'Survived'</span>: predictions&#125;)</span><br><span class="line">StackingSubmission.to_csv(<span class="string">'StackingSubmission.csv'</span>,index=<span class="keyword">False</span>,sep=<span class="string">','</span>)</span><br></pre></td></tr></table></figure></li></ol><p>最后的步骤就是验证了</p><h3 id="验证：学习曲线"><a href="#验证：学习曲线" class="headerlink" title="验证：学习曲线"></a>验证：学习曲线</h3><p>在我们对数据不断地进行特征工程，产生的特征越来越多，用大量的特征对模型进行训练，会使我们的训练集拟合得越来越好，但同时也可能会逐渐丧失泛化能力，从而在测试数据上表现不佳，发生过拟合现象。</p><p>当然我们建立的模型可能不仅在预测集上表型不好，也很可能是因为在训练集上的表现就不佳，处于欠拟合状态。</p><p><strong>所以我们通过学习曲线观察模型处于什么样的状态。从而决定对模型进行如何的操作。当然，我们把验证放到最后，并不是是这一步是在最后去做。对于我们的Stacking框架中第一层的各个基学习器我们都应该对其学习曲线进行观察，从而去更好地调节超参数，进而得到更好的最终结果。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.learning_curve <span class="keyword">import</span> learning_curve</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_learning_curve</span><span class="params">(estimator, title, X, y, ylim=None, cv=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                        n_jobs=<span class="number">1</span>, train_sizes=np.linspace<span class="params">(<span class="number">.1</span>, <span class="number">1.0</span>, <span class="number">5</span>)</span>, verbose=<span class="number">0</span>)</span>:</span></span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.title(title)</span><br><span class="line">    <span class="keyword">if</span> ylim <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        plt.ylim(*ylim)</span><br><span class="line">    plt.xlabel(<span class="string">"Training examples"</span>)</span><br><span class="line">    plt.ylabel(<span class="string">"Score"</span>)</span><br><span class="line">    train_sizes, train_scores, test_scores = learning_curve(</span><br><span class="line">        estimator, X, y, cv=cv, n_jobs=n_jobs, train_sizes=train_sizes)</span><br><span class="line">    train_scores_mean = np.mean(train_scores, axis=<span class="number">1</span>)</span><br><span class="line">    train_scores_std = np.std(train_scores, axis=<span class="number">1</span>)</span><br><span class="line">    test_scores_mean = np.mean(test_scores, axis=<span class="number">1</span>)</span><br><span class="line">    test_scores_std = np.std(test_scores, axis=<span class="number">1</span>)</span><br><span class="line">    plt.grid()</span><br><span class="line"></span><br><span class="line">    plt.fill_between(train_sizes, train_scores_mean - train_scores_std,</span><br><span class="line">                     train_scores_mean + train_scores_std, alpha=<span class="number">0.1</span>,</span><br><span class="line">                     color=<span class="string">"r"</span>)</span><br><span class="line">    plt.fill_between(train_sizes, test_scores_mean - test_scores_std,</span><br><span class="line">                     test_scores_mean + test_scores_std, alpha=<span class="number">0.1</span>, color=<span class="string">"g"</span>)</span><br><span class="line">    plt.plot(train_sizes, train_scores_mean, <span class="string">'o-'</span>, color=<span class="string">"r"</span>,</span><br><span class="line">             label=<span class="string">"Training score"</span>)</span><br><span class="line">    plt.plot(train_sizes, test_scores_mean, <span class="string">'o-'</span>, color=<span class="string">"g"</span>,</span><br><span class="line">             label=<span class="string">"Cross-validation score"</span>)</span><br><span class="line"></span><br><span class="line">    plt.legend(loc=<span class="string">"best"</span>)</span><br><span class="line">    <span class="keyword">return</span> plt</span><br></pre></td></tr></table></figure><p>逐一观察不同模型的学习曲线</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">X = x_train</span><br><span class="line">Y = y_train</span><br><span class="line"></span><br><span class="line"><span class="comment"># RandomForest</span></span><br><span class="line">rf_parameters = &#123;<span class="string">'n_jobs'</span>: <span class="number">-1</span>, <span class="string">'n_estimators'</span>: <span class="number">500</span>, <span class="string">'warm_start'</span>: <span class="keyword">True</span>, <span class="string">'max_depth'</span>: <span class="number">6</span>, <span class="string">'min_samples_leaf'</span>: <span class="number">2</span>, </span><br><span class="line">              <span class="string">'max_features'</span> : <span class="string">'sqrt'</span>,<span class="string">'verbose'</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># AdaBoost</span></span><br><span class="line">ada_parameters = &#123;<span class="string">'n_estimators'</span>:<span class="number">500</span>, <span class="string">'learning_rate'</span>:<span class="number">0.1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ExtraTrees</span></span><br><span class="line">et_parameters = &#123;<span class="string">'n_jobs'</span>: <span class="number">-1</span>, <span class="string">'n_estimators'</span>:<span class="number">500</span>, <span class="string">'max_depth'</span>: <span class="number">8</span>, <span class="string">'min_samples_leaf'</span>: <span class="number">2</span>, <span class="string">'verbose'</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># GradientBoosting</span></span><br><span class="line">gb_parameters = &#123;<span class="string">'n_estimators'</span>: <span class="number">500</span>, <span class="string">'max_depth'</span>: <span class="number">5</span>, <span class="string">'min_samples_leaf'</span>: <span class="number">2</span>, <span class="string">'verbose'</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># DecisionTree</span></span><br><span class="line">dt_parameters = &#123;<span class="string">'max_depth'</span>:<span class="number">8</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># KNeighbors</span></span><br><span class="line">knn_parameters = &#123;<span class="string">'n_neighbors'</span>:<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># SVM</span></span><br><span class="line">svm_parameters = &#123;<span class="string">'kernel'</span>:<span class="string">'linear'</span>, <span class="string">'C'</span>:<span class="number">0.025</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># XGB</span></span><br><span class="line">gbm_parameters = &#123;<span class="string">'n_estimators'</span>: <span class="number">2000</span>, <span class="string">'max_depth'</span>: <span class="number">4</span>, <span class="string">'min_child_weight'</span>: <span class="number">2</span>, <span class="string">'gamma'</span>:<span class="number">0.9</span>, <span class="string">'subsample'</span>:<span class="number">0.8</span>, </span><br><span class="line">               <span class="string">'colsample_bytree'</span>:<span class="number">0.8</span>, <span class="string">'objective'</span>: <span class="string">'binary:logistic'</span>, <span class="string">'nthread'</span>:<span class="number">-1</span>, <span class="string">'scale_pos_weight'</span>:<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title = <span class="string">"Learning Curves"</span></span><br><span class="line">plot_learning_curve(RandomForestClassifier(**rf_parameters), title, X, Y, cv=<span class="keyword">None</span>,  n_jobs=<span class="number">4</span>, train_sizes=[<span class="number">50</span>, <span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">350</span>, <span class="number">400</span>, <span class="number">450</span>, <span class="number">500</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2020/03/11/Kaggle-Titanic-生存预测/8.jpg" alt=""></p><p>提交结果终于到达了87左右了，后面还是可以尝试一下在模型融合这里慢慢加强。</p><p>但是 后面就是无尽无尽的调整参数的过程咯</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="机器学习" scheme="http://wsx1128.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Kaggle" scheme="http://wsx1128.cn/tags/Kaggle/"/>
    
      <category term="机器学习" scheme="http://wsx1128.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>改善深层神经网络</title>
    <link href="http://wsx1128.cn/2020/03/11/%E6%94%B9%E5%96%84%E6%B7%B1%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://wsx1128.cn/2020/03/11/改善深层神经网络/</id>
    <published>2020-03-11T11:36:10.000Z</published>
    <updated>2020-03-11T14:51:57.263Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="深度学习的相关实践"><a href="#深度学习的相关实践" class="headerlink" title="深度学习的相关实践"></a>深度学习的相关实践</h2><h3 id="数据集合"><a href="#数据集合" class="headerlink" title="数据集合"></a>数据集合</h3><p>紧接着前面 关于 欠拟合和过拟合的情况，所以这个地方直接将数据集分成了，训练，验证，测试集</p><p>然后这几个集合之间的定义就是：</p><p>训练集（train set）：用训练集对算法或模型进行训练过程；<br>验证集（development set）：利用验证集或者又称为简单交叉验证集（hold-out cross validation set）进行交叉验证，选择出最好的模型；<br>测试集（test set）：最后利用测试集对模型进行测试，获取模型运行的无偏估计。</p><p><strong>小数据时代</strong><br>在小数据量的时代，如：100、1000、10000的数据量大小，可以将data做以下划分：</p><p>无验证集的情况：70% / 30%；<br>有验证集的情况：60% / 20% / 20%；<br>通常在小数据量时代，以上比例的划分是非常合理的。</p><p><strong>大数据时代</strong><br>但是在如今的大数据时代，对于一个问题，我们拥有的data的数量可能是百万级别的，所以验证集和测试集所占的比重会趋向于变得更小。</p><p>验证集的目的是为了验证不同的算法哪种更加有效，所以验证集只要足够大能够验证大约2-10种算法哪种更好就足够了，不需要使用20%的数据作为验证集。如百万数据中抽取1万的数据作为验证集就可以了。</p><p>测试集的主要目的是评估模型的效果，如在单个分类器中，往往在百万级别的数据中，我们选择其中1000条数据足以评估单个模型的效果。</p><p>100万数据量：98% / 1% / 1%；<br>超百万数据量：99.5% / 0.25% / 0.25%（或者99.5% / 0.4% / 0.1%）</p><p><strong>注意</strong></p><p>建议验证集和测试集来自于同一个分布，这样可以使得机器学习算法变得更快；<br>如果不需要用无偏估计来评估模型的性能，则可以不需要测试集。</p><h3 id="偏差、方差"><a href="#偏差、方差" class="headerlink" title="偏差、方差"></a>偏差、方差</h3><p>对应上面过拟合，与欠拟合的情况，关于如何界定的问题，也在相应的章节中有讲述，所以这里就不再过多赘述了。</p><p>只需要记住一个小小的总结即可：</p><p>如果训练集误差与验证集误差相差过大，那么一定是出现了过拟合的问题，方差过大</p><p>如果 训练集误差与验证集误差不大，但是 二者的数值较大，那么一定是出现欠拟合的问题，偏差过大。</p><h3 id="解决上述问题的方法"><a href="#解决上述问题的方法" class="headerlink" title="解决上述问题的方法"></a>解决上述问题的方法</h3><ol><li><p>是否存在High bias ?<br>增加网络结构，如增加隐藏层数目；<br>训练更长时间；<br>寻找合适的网络架构，使用更大的NN结构；</p></li><li><p>是否存在High variance？<br>获取更多的数据；<br>正则化（ regularization）；<br>寻找合适的网络结构；</p></li></ol><p>在大数据时代，深度学习对监督式学习大有裨益，使得我们不用像以前一样太过关注如何平衡偏差和方差的权衡问题，通过以上方法可以使得再不增加另一方的情况下减少一方的值。</p><h3 id="正则化（惩罚参数）"><a href="#正则化（惩罚参数）" class="headerlink" title="正则化（惩罚参数）"></a>正则化（惩罚参数）</h3><p>利用正则化来解决High variance 的问题，正则化是在 Cost function 中加入一项正则化项，惩罚模型的复杂度。</p><p><img src="/2020/03/11/改善深层神经网络/1.png" alt=""></p><p><img src="/2020/03/11/改善深层神经网络/2.png" alt=""></p><p><img src="/2020/03/11/改善深层神经网络/3.png" alt=""></p><p><strong>那为什么正则化可以减少神经网络的过拟合情况呢</strong></p><p>对于神经网络的 Cost function：加入正则化项，直观上理解，正则化因子lambd设置的足够大的情况下，为了使代价函数最小化，权重矩阵 weight 就会被设置为接近于0的值。则相当于消除了很多神经元的影响，那么图中的大的神经网络就会变成一个较小的网络。</p><p>当然上面这种解释是一种直观上的理解，但是实际上隐藏层的神经元依然存在，但是他们的影响变小了，便不会导致过拟合。</p><p>而下面则是一种 较好的数学解释，可以拿来参考借鉴：</p><p><img src="/2020/03/11/改善深层神经网络/4.png" alt=""></p><p>这里还存在一种正则化的方式 Dropout正则化</p><p>Dropout（随机失活）就是在神经网络的Dropout层，为每个神经元结点设置一个随机消除的概率，对于保留下来的神经元，我们得到一个节点较少，规模较小的网络进行训练。</p><p>意思就是随机失活类型之类的</p><p>这里解释下为什么要有最后一步：a3 /= keep_prob</p><p>依照例子中的 keep_prob = 0.8 ，那么就有大约20%的神经元被删除了，也就是说 a3 中有20%的元素被归零了，在下一层的计算中有 z4 = w4 <em> a3 + b4 ，所以为了不影响 Z4 的期望值，所以需要W4 </em> a3 的部分除以一个keep_prob。</p><p>Inverted dropout 通过对“a3 /= keep_prob”,则保证无论 keep_prob 设置为多少，都不会对W4 * a3的期望值产生影响。</p><p>Notation：在测试阶段不要用dropout，因为那样会使得预测结果变得随机。</p><p><strong>理解Dropout</strong></p><p>另外一种对于Dropout的理解。</p><p>这里我们以单个神经元入手，单个神经元的工作就是接收输入，并产生一些有意义的输出，但是加入了Dropout以后，输入的特征都是有可能会被随机清除的，所以该神经元不会再特别依赖于任何一个输入特征，也就是说不会给任何一个输入设置太大的权重。</p><p>所以通过传播过程，dropout将产生和L2范数相同的收缩权重的效果。</p><p>对于不同的层，设置的keep_prob也不同，一般来说神经元较少的层，会设 keep_prob</p><p>=1.0，神经元多的层，则会将keep_prob设置的较小。</p><p>dropout的一大缺点就是其使得 Cost function不能再被明确的定义，以为每次迭代都会随机消除一些神经元结点，所以我们无法绘制出每次迭代cost函数下降的图</p><h4 id="其他正则化的方法"><a href="#其他正则化的方法" class="headerlink" title="其他正则化的方法"></a>其他正则化的方法</h4><p><strong>数据增强</strong>，将一些数据进行一些维度意义上面的增强</p><p><strong>归一化处理输入数据</strong><br>由图可以看出不使用归一化和使用归一化前后 Cost function 的函数形状会有很大的区别。</p><p>在不使用归一化的代价函数中，如果我们设置一个较小的学习率，那么很可能我们需要很多次迭代才能到达代价函数全局最优解；如果使用了归一化，那么无论从哪个位置开始迭代，我们都能以相对很少的迭代次数找到全局最优解。</p><p><strong>提前停止数据等</strong></p><p>如果神经网络过于深，那么就一定会发生 梯度消失的问题，<br>所以这个地方就涉及到应用初始化去缓解梯度消失的问题</p><p><img src="/2020/03/11/改善深层神经网络/5.png" alt=""></p><p><img src="/2020/03/11/改善深层神经网络/6.png" alt=""></p><h3 id="梯度检验"><a href="#梯度检验" class="headerlink" title="梯度检验"></a>梯度检验</h3><p>下面用前面一节的方法来进行梯度检验。</p><p><img src="/2020/03/11/改善深层神经网络/7.png" alt=""></p><p><img src="/2020/03/11/改善深层神经网络/8.png" alt=""></p><p>不要在训练过程中使用梯度检验，只在debug的时候使用，使用完毕关闭梯度检验的功能；<br>如果算法的梯度检验出现了错误，要检查每一项，找出错误，也就是说要找出哪个的值相差比较大；<br>不要忘记了正则化项；<br>梯度检验不能与dropout同时使用。因为每次迭代的过程中，dropout会随机消除隐层单元的不同神经元，这时是难以计算dropout在梯度下降上的代价函数J；<br>在随机初始化的时候运行梯度检验，或许在训练几次后再进行。（没听懂大师这个点的意思？）</p><h2 id="深度学习的优化算法"><a href="#深度学习的优化算法" class="headerlink" title="深度学习的优化算法"></a>深度学习的优化算法</h2><p>这个地方很多东西 在pytorch里面已经封装好了，不需要自己去实现，但是对于这一章而言，需要弄清楚的就是，如何去用，如何去调整里面超参数</p><h3 id="Mini-batch-梯度下降法"><a href="#Mini-batch-梯度下降法" class="headerlink" title="Mini-batch 梯度下降法"></a>Mini-batch 梯度下降法</h3><p>对整个训练集进行梯度下降法的时候，我们必须处理整个训练数据集，然后才能进行一步梯度下降，即每一步梯度下降法需要对整个训练集进行一次处理，如果训练数据集很大的时候，如有500万或5000万的训练数据，处理速度就会比较慢。</p><p>但是如果每次处理训练数据的一部分，即用其子集进行梯度下降，则我们的算法速度会执行的更快。而处理的这些一小部分训练子集即称为Mini-batch。</p><p>对于普通的梯度下降法，一个epoch只能进行一次梯度下降；而对于Mini-batch梯度下降法，一个epoch可以进行Mini-batch的个数次梯度下降。</p><p>不同size大小的比较</p><p>普通的batch梯度下降法和Mini-batch梯度下降法代价函数的变化趋势，如下图所示：</p><p><img src="/2020/03/11/改善深层神经网络/9.png" alt=""></p><ul><li><p>batch梯度下降：<br>  对所有m个训练样本执行一次梯度下降，每一次迭代时间较长；<br>  Cost function 总是向减小的方向下降。</p></li><li><p>随机梯度下降：<br>  对每一个训练样本执行一次梯度下降，但是丢失了向量化带来的计算加速；<br>  Cost function总体的趋势向最小值的方向下降，但是无法到达全局最小值点，呈现波动的形式。</p></li><li><p>Mini-batch梯度下降：<br>  选择一个 size 的合适的size进行Mini-batch梯度下降，可以实现快速学习，也应用了向量化带来的好处；<br>  Cost function的下降处于前两者之间。</p></li></ul><h4 id="Mini-batch-大小的选择"><a href="#Mini-batch-大小的选择" class="headerlink" title="Mini-batch 大小的选择"></a>Mini-batch 大小的选择</h4><p>如果训练样本的大小比较小时，如 m &lt;= 2000 时 ——— 选择batch梯度下降法；<br>如果训练样本的大小比较大时，典型的大小为： 2的次方 ；<br>Mini-batch的大小要符合CPU/GPU内存。</p><h3 id="指数加权平均"><a href="#指数加权平均" class="headerlink" title="指数加权平均"></a>指数加权平均</h3><p>这里主要有一个指数加权平均的关键函数：<br><img src="/2020/03/11/改善深层神经网络/12.png" alt=""></p><p><img src="/2020/03/11/改善深层神经网络/10.png" alt=""></p><p><img src="/2020/03/11/改善深层神经网络/11.png" alt=""></p><p>因为，在计算当前时刻的平均值，只需要前一天的平均值和当前时刻的值，所以在数据量非常大的情况下，指数加权平均在节约计算成本的方面是一种非常有效的方式，可以很大程度上减少计算机资源存储和内存的占用。</p><p>指数加权平均的偏差修正</p><p>在我们执行指数加权平均的公式时，当beta = 0.98时，我们得到的并不是图中的绿色曲线，而是下图中的紫色曲线，其起点比较低。</p><p><img src="/2020/03/11/改善深层神经网络/13.png" alt=""></p><p><img src="/2020/03/11/改善深层神经网络/14.png" alt=""></p><h3 id="动量（Momentum）梯度下降法"><a href="#动量（Momentum）梯度下降法" class="headerlink" title="动量（Momentum）梯度下降法"></a>动量（Momentum）梯度下降法</h3><p>前面介绍了一大啪啦听不懂的东西 实际上就是为后面的动量梯度下降法做贡献的</p><p>动量梯度下降的基本思想就是计算梯度的指数加权平均数，并利用该梯度来更新权重。</p><p>在我们优化 Cost function 的时候，以下图所示的函数图为例：</p><p><img src="/2020/03/11/改善深层神经网络/15.png" alt=""></p><p>在利用梯度下降法来最小化该函数的时候，每一次迭代所更新的代价函数值如图中蓝色线所示在上下波动，而这种幅度比较大波动，减缓了梯度下降的速度，而且我们只能使用一个<strong>较小的学习率</strong>来进行迭代。</p><p>如果用较大的学习率，结果可能会如紫色线一样偏离函数的范围，所以为了避免这种情况，只能用较小的学习率。</p><p>但是我们又希望在如图的纵轴方向梯度下降的缓慢一些，不要有如此大的上下波动，在横轴方向梯度下降的快速一些，使得能够更快的到达最小值点，而这里用动量梯度下降法既可以实现，如红色线所示。</p><p><strong>其最本质的解释</strong></p><p>在对应上面的计算公式中，将Cost function想象为一个碗状，想象从顶部往下滚球，其中：</p><p>微分项 dw, db 想象为球提供的加速度；<br>动量项 Vdw,Vdb 相当于速度；<br>小球在向下滚动的过程中，因为加速度的存在使得速度会变快，但是由于 beta 的存在，其值小于1，可以认为是摩擦力，所以球不会无限加速下去。</p><h3 id="RMSprop-算法"><a href="#RMSprop-算法" class="headerlink" title="RMSprop 算法"></a>RMSprop 算法</h3><p>除了上面所说的Momentum梯度下降法，RMSprop（root mean square prop）也是一种可以加快梯度下降的算法。</p><p><img src="/2020/03/11/改善深层神经网络/16.png" alt=""></p><p>这里假设参数b的梯度处于纵轴方向，参数w的梯度处于横轴方向（当然实际中是处于高维度的情况），利用RMSprop算法，可以减小某些维度梯度更新波动较大的情况，如图中蓝色线所示，使其梯度下降的速度变得更快，如图绿色线所示。</p><p>在如图所示的实现中，RMSprop将微分项进行平方，然后使用平方根进行梯度更新，同时为了确保算法不会除以0，平方根分母中在实际使用会加入一个很小的值如 [公式] 。</p><h3 id="Adam-优化算法"><a href="#Adam-优化算法" class="headerlink" title="Adam 优化算法"></a>Adam 优化算法</h3><p>Adam （Adaptive Moment Estimation）优化算法的基本思想就是将 Momentum 和 RMSprop 结合起来形成的一种适用于不同深度学习结构的优化算法。</p><p>这个弄懂的地方 实际上需要去看相关的数学证明才可以弄清楚</p><p>这里只介绍一些调试的办法</p><p><img src="/2020/03/11/改善深层神经网络/17.png" alt=""></p><h3 id="学习率衰减"><a href="#学习率衰减" class="headerlink" title="学习率衰减"></a>学习率衰减</h3><p>当这个地方使用学习率去衰减变化的时候，因为训练到后期的时候，如果再去使用大的学习率，容易造成不太好的影响</p><p>在我们利用 mini-batch 梯度下降法来寻找Cost function的最小值的时候，如果我们设置一个固定的学习速率 ，则算法在到达最小值点附近后，由于不同batch中存在一定的噪声，使得不会精确收敛，而一直会在一个最小值点较大的范围内波动，如下图中蓝色线所示。</p><p>但是如果我们使用学习率衰减，逐渐减小学习速率，在算法开始的时候，学习速率还是相对较快，能够相对快速的向最小值点的方向下降。但随着学习率的减小，下降的步伐也会逐渐变小，最终会在最小值附近的一块更小的区域里波动，如图中绿色线所示。</p><p><img src="/2020/03/11/改善深层神经网络/18.png" alt=""></p><h3 id="局部最优解"><a href="#局部最优解" class="headerlink" title="局部最优解"></a>局部最优解</h3><p>建议在构造模型的时候多去尝试，因为可能在构造过程中达到了局部最优解，而不是全局最优解，所以需要初始值选取的得当，才可以。</p><p>但是，如果我们建立一个高维度的神经网络。通常梯度为零的点，并不是如左图中的局部最优点，而是右图中的鞍点（叫鞍点是因为其形状像马鞍的形状）。</p><p><img src="/2020/03/11/改善深层神经网络/19.png" alt=""></p><p>在一个具有高维度空间的函数中，如果梯度为0，那么在每个方向，Cost function可能是凸函数，也有可能是凹函数。但如果参数维度为2万维，想要得到局部最优解，那么所有维度均需要是凹函数，其概率为特别特别小，可能性非常的小。也就是说，在低维度中的局部最优点的情况，并不适用于高维度，在梯度为0的点更有可能是鞍点，而不是局部最小值点。</p><p>在高纬度的情况下：</p><ul><li>几乎不可能陷入局部最小值点；</li><li>处于鞍点的停滞区会减缓学习过程，利用如Adam等算法进行改善。</li></ul><h2 id="超参数的调试和Batch-Norm"><a href="#超参数的调试和Batch-Norm" class="headerlink" title="超参数的调试和Batch Norm"></a>超参数的调试和Batch Norm</h2><h3 id="超阐述的调试处理"><a href="#超阐述的调试处理" class="headerlink" title="超阐述的调试处理"></a>超阐述的调试处理</h3><p>前面已经讲了很多超参数，这里就要集中进行一个处理过程</p><p>在机器学习领域，超参数比较少的情况下，我们之前利用设置网格点的方式来调试超参数；<br>但在深度学习领域，超参数较多的情况下，不是设置规则的网格点，而是随机选择点进行调试。这样做是因为在我们处理问题的时候，是无法知道哪个超参数是更重要的，所以随机的方式去测试超参数点的性能，更为合理，这样可以探究更超参数的潜在价值。</p><h3 id="为超参数选择合适的范围"><a href="#为超参数选择合适的范围" class="headerlink" title="为超参数选择合适的范围"></a>为超参数选择合适的范围</h3><p><strong>Scale均匀随机</strong></p><p>在超参数选择的时候，一些超参数是在一个范围内进行均匀随机取值，如隐藏层神经元结点的个数、隐藏层的层数等。但是有一些超参数的选择做均匀随机取值是不合适的，这里需要按照一定的比例在不同的小范围内进行均匀随机取值，以学习率的选择为例，在 0.001 到 1 范围内进行选择：</p><p>如上图所示，如果在0.001～1的范围内进行进行均匀随机取值，则有90%的概率 选择范围在0.1～1之间，而只有10%的概率才能选择到0.001～0.1之间，显然是不合理的。</p><p>所以在选择的时候，在不同比例范围内进行均匀随机取值，如 0.0001～0.001 、0.001～0.01、0.01～0.1， 0.1～1范围内选择。</p><p>同样，在使用指数加权平均的时候，超参数beta 也需要用上面这种方向进行选择。</p><h3 id="超参数调试实践—Pandas-vs-Caviar"><a href="#超参数调试实践—Pandas-vs-Caviar" class="headerlink" title="超参数调试实践—Pandas vs. Caviar"></a>超参数调试实践—Pandas vs. Caviar</h3><p>不要看名字起的这么高端，其实就是一句话<br>在超参数调试的实际操作中，我们需要根据我们现有的计算资源来决定以什么样的方式去调试超参数，进而对模型进行改进。下面是不同情况下的两种方式：</p><p>在计算资源有限的情况下，使用第一种，仅调试一个模型，每天不断优化；<br>在计算资源充足的情况下，使用第二种，同时并行调试多个模型，选取其中最好的模型。</p><h3 id="网络中激活值的归一化"><a href="#网络中激活值的归一化" class="headerlink" title="网络中激活值的归一化"></a>网络中激活值的归一化</h3><p>在Logistic Regression 中，将输入特征进行归一化，可以加速模型的训练。那么对于更深层次的神经网络，我们是否可以归一化隐藏层的输出al或者经过激活函数前的zl ，以便加速神经网络的训练过程？答案是肯定的。</p><p>常用的方式是将隐藏层的经过激活函数前的zl进行归一化。</p><p>比如卷积网络和RNN中如果应用这个的化，那么就会造成不需要bias的情况，因为其已经将bias的情况给剔除了。</p><p><img src="/2020/03/11/改善深层神经网络/20.png" alt=""></p><p>这里不太需要去弄清楚其的底层实现，pytorch已经将其封装好了，可以直接去使用了</p><p>可以直接加入到输入函数和激活函数之间就可以了</p><h3 id="Batch-Norm-起作用的原因"><a href="#Batch-Norm-起作用的原因" class="headerlink" title="Batch Norm 起作用的原因"></a>Batch Norm 起作用的原因</h3><h4 id="First-Reason"><a href="#First-Reason" class="headerlink" title="First Reason"></a>First Reason</h4><p>首先Batch Norm 可以加速神经网络训练的原因和输入层的输入特征进行归一化，从而改变Cost function的形状，使得每一次梯度下降都可以更快的接近函数的最小值点，从而加速模型训练过程的原理是有相同的道理。</p><p>只是Batch Norm 不是单纯的将输入的特征进行归一化，而是将各个隐藏层的激活函数的激活值进行的归一化，并调整到另外的分布。</p><h4 id="Second-Reason"><a href="#Second-Reason" class="headerlink" title="Second Reason"></a>Second Reason</h4><p>Batch Norm 可以加速神经网络训练的另外一个原因是它可以使权重比网络更滞后或者更深层。</p><p>下面是一个判别是否是猫的分类问题，假设第一训练样本的集合中的猫均是黑猫，而第二个训练样本集合中的猫是各种颜色的猫。如果我们将第二个训练样本直接输入到用第一个训练样本集合训练出的模型进行分类判别，那么我们在很大程度上是无法保证能够得到很好的判别结果。</p><p>这是因为第一个训练集合中均是黑猫，而第二个训练集合中各色猫均有，虽然都是猫，但是很大程度上样本的分布情况是不同的，所以我们无法保证模型可以仅仅通过黑色猫的样本就可以完美的找到完整的决策边界。第二个样本集合相当于第一个样本的分布的改变，称为：Covariate shift。</p><p>上面的意思 说人话就是 每一个集合的协和特征得出来，进行归纳即可，意思就是保存了数据之间的均值和方差，不会被下一个不一样的集合所影响</p><h3 id="Batch-Norm-正则化效果"><a href="#Batch-Norm-正则化效果" class="headerlink" title="Batch Norm 正则化效果"></a>Batch Norm 正则化效果</h3><p>Batch Norm还有轻微的正则化效果。</p><p>这是因为在使用Mini-batch梯度下降的时候，每次计算均值和偏差都是在一个Mini-batch上进行计算，而不是在整个数据样集上。这样就在均值和偏差上带来一些比较小的噪声。那么用均值和偏差计算得到的 Zl 也将会加入一定的噪声。</p><p>所以和Dropout相似，其在每个隐藏层的激活值上加入了一些噪声，（这里因为Dropout以一定的概率给神经元乘上0或者1）。所以和Dropout相似，Batch Norm 也有轻微的正则化效果。</p><p>这里引入一个小的细节就是，如果使用Batch Norm ，那么使用大的Mini-batch如256，相比使用小的Mini-batch如64，会引入跟少的噪声，那么就会减少正则化的效果。</p><h3 id="在测试数据上使用-Batch-Norm"><a href="#在测试数据上使用-Batch-Norm" class="headerlink" title="在测试数据上使用 Batch Norm"></a>在测试数据上使用 Batch Norm</h3><p><img src="/2020/03/11/改善深层神经网络/21.png" alt=""></p><h3 id="Softmax-回归"><a href="#Softmax-回归" class="headerlink" title="Softmax 回归"></a>Softmax 回归</h3><p>在多分类问题中，有一种 logistic regression的一般形式，叫做Softmax regression。Softmax回归可以将多分类任务的输出转换为各个类别可能的概率，从而将最大的概率值所对应的类别作为输入样本的输出类别。</p><p>计算公式</p><p>下图是Softmax的公式以及一个简单的例子：</p><p><img src="/2020/03/11/改善深层神经网络/22.png" alt=""></p><h3 id="训练-Sotfmax-分类器"><a href="#训练-Sotfmax-分类器" class="headerlink" title="训练 Sotfmax 分类器"></a>训练 Sotfmax 分类器</h3><p>为什么叫做Softmax？我们以前面的例子为例，</p><p>通常我们判定模型的输出类别，是将输出的最大值对应的类别判定为该模型的类别，也就是说最大值为的位置1，其余位置为0，这也就是所谓的“hardmax”。而Sotfmax将模型判定的类别由原来的最大数字5，变为了一个最大的概率0.842，这相对于“hardmax”而言，输出更加“soft”而没有那么“hard”。</p><p>Sotfmax回归 将 logistic回归 从二分类问题推广到了多分类问题上。<br>说白了与全链接层类似。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="机器学习" scheme="http://wsx1128.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://wsx1128.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="http://wsx1128.cn/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="http://wsx1128.cn/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>逻辑回归--深度学习网络雏型</title>
    <link href="http://wsx1128.cn/2020/03/10/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E9%9B%8F%E5%9E%8B/"/>
    <id>http://wsx1128.cn/2020/03/10/逻辑回归-深度学习网络雏型/</id>
    <published>2020-03-10T08:31:27.000Z</published>
    <updated>2020-03-11T02:35:19.631Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><p>前面有讲过，相应的线性回归方程，一般用在对于数据的拟合和预测上，甚至还是可以放下多维度的数字。</p><p>而这里要总结的就是 逻辑回归模型，虽然这里命名为回归，其实是一个分类问题。</p><p>比如邮件的归类，以及在线的资源判断，或者是医学上面的肿瘤 良性以及恶性的判断。</p><p>一般很常用的 分类函数里面有 sigmoid函数，或者深度学习中的Tanh</p><p><img src="/2020/03/10/逻辑回归-深度学习网络雏型/1.png" alt=""></p><p>另外在机器学习中，逻辑回归，还负责一类问题，就是将多个数据群进行一个有效的划分，如果拟合的函数 太过于欠拟合的话，考虑采用复杂的函数来拟合</p><p><img src="/2020/03/10/逻辑回归-深度学习网络雏型/2，png" alt=""></p><p>甚至还会存在非线性的分界线情况，就像如下：<br><img src="/2020/03/10/逻辑回归-深度学习网络雏型/3.png" alt=""></p><p>目前这个地方只会去介绍一下 二元分类的问题，后面再去涉及到多元分类的问题</p><p>另外 关于其梯度下降的相关知识点，由于pytorch框架已经给封装好了，所以这里不多在赘述了，与前面的线性回归的梯度下降类似，就是换了一个方程而已<br><img src="/2020/03/10/逻辑回归-深度学习网络雏型/7.png" alt=""></p><p>另外，在机器学习的课程李，给出了一对多的分类方式，如果这样分类的话，每次只看一种数据，并且将其与所有的物质进行相反的链接</p><p>就像下面的图所示：</p><p><img src="/2020/03/10/逻辑回归-深度学习网络雏型/4.png" alt=""></p><p>这里又提到一个过拟合的概念，这个概念也是在后面机器学习甚至是深度学习中反复提到的，处理过拟合的方法，这个具体就在后面说，这里只会提到一点点。</p><p>具体就两种办法，要么正则化，要么就直接减少特征数（机器学习数据拟合中的特征是自己去设置的）</p><p>机器学习中 过渡到深度学习神经网络的构建是直接从非线性回归问题，直接去分类。</p><p><img src="/2020/03/10/逻辑回归-深度学习网络雏型/5.png" alt=""></p><p>上面的每一个节点都是相同的运算（拟合运算 + 激活函数） 在后面深度学习中 这个是分开的。</p><p>正是因为有神经网络这样的结构在，正好就可以满足多元分类，最后输出的节点就可以来判断出 多个分类对象。<br>（注意，这里 机器学习课程上面讲述的是hardmax是硬性分类，而一般采用的是softmax 求出概率而不是直接得出结果）</p><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>首先 先必须注意一点，输入到神经网络中数据的形状 一定是 batch_size * n(特征)</p><p>基于上面 逻辑回归，梯度下降，前向传播，反向传播，构建神经网络</p><p>下面需要弄清楚的有一点就是 python的notation</p><p>虽然在Python有广播的机制，但是在Python程序中，为了保证矩阵运算的正确性，可以使用reshape()函数来对矩阵设定所需要进行计算的维度，这是个好的习惯；</p><p>如果用下列语句来定义一个向量，则这条语句生成的a的维度为（5，），既不是行向量也不是列向量，称为秩（rank）为1的array，如果对a进行转置，则会得到a本身，这在计算中会给我们带来一些问题。</p><p>其实也可以在pytorch中使用view来进行一个更改，这里也不多赘述了，因为毕竟是基础中的基础。</p><h3 id="浅层网络"><a href="#浅层网络" class="headerlink" title="浅层网络"></a>浅层网络</h3><p>除输入层之外每层的计算输出可由下图总结出：</p><p><img src="/2020/03/10/逻辑回归-深度学习网络雏型/8.png" alt=""></p><p>其中，每个结点都对应这两个部分的运算，z运算和a运算。 在编程中，我们使用向量化去计算神经网络的输出：</p><p>假定在m个训练样本的神经网络中，计算神经网络的输出，用向量化的方法去实现可以避免在程序中使用for循环，提高计算的速度。</p><p>向量化，说白了就是线性代数的另外一种说法而已</p><p>另外需要纠结的是 激活函数的选择：</p><p>sigmoid函数和tanh函数比较：</p><p>隐藏层：tanh函数的表现要好于sigmoid函数，因为tanh取值范围为 -1～+1 ，输出分布在0值的附近，均值为0，从隐藏层到输出层数据起到了归一化（均值为0）的效果。<br>输出层：对于二分类任务的输出取值为 0～1 ，故一般会选择sigmoid函数。<br>然而sigmoid和tanh函数在当 z 很大的时候，梯度会很小，在依据梯度的算法中，更新在后期会变得很慢。在实际应用中，要使 [公式] 尽可能的落在0值附近。</p><p>ReLU弥补了前两者的缺陷，当 z 时，梯度始终为1，从而提高神经网络基于梯度算法的运算速度。然而当 [公式] 时，梯度一直为0，但是实际的运用中，该缺陷的影响不是很大。</p><p>Leaky ReLU保证在 z &lt; 0 的时候，梯度仍然不为0。</p><p>在选择激活函数的时候，如果在不知道该选什么的时候就选择ReLU，当然也没有固定答案，要依据实际问题在交叉验证集合中进行验证分析。</p><p>对于神经网络中的梯度下降法 就是直接用框架就可以去解决。</p><p>最后，初始化问题会在后面优化神经网络的办法中详细的去讲述，这里只是随机初始化，是最简单的一种初始化办法</p><p>如果在初始时，两个隐藏神经元的参数设置为相同的大小，那么两个隐藏神经元对输出单元的影响也是相同的，通过反向梯度下降去进行计算的时候，会得到同样的梯度大小，所以在经过多次迭代后，两个隐藏层单位仍然是对称的。无论设置多少个隐藏单元，其最终的影响都是相同的，那么多个隐藏神经元就没有了意义。</p><p>在初始化的时候， W 参数要进行随机初始化， b 则不存在对称性的问题它可以设置为0。 以2个输入，2个隐藏神经元为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">W = np.random.rand((<span class="number">2</span>,<span class="number">2</span>))* <span class="number">0.01</span></span><br><span class="line">b = np.zero((<span class="number">2</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>这里我们将W的值乘以0.01是为了尽可能使得权重W初始化为较小的值，这是因为如果使用sigmoid函数或者tanh函数作为激活函数时，W比较小，则 Z = WX + b所得的值也比较小，处在0的附近，0点区域的附近梯度较大，能够大大提高算法的更新速度。而如果W设置的太大的话，得到的梯度较小，训练过程因此会变得很慢。</p><p>ReLU和Leaky ReLU作为激活函数时，不存在这种问题，因为在大于0的时候，梯度均为1。</p><h3 id="深度网络"><a href="#深度网络" class="headerlink" title="深度网络"></a>深度网络</h3><p>在深度网络中，因为现在有框架可以去帮助coding，以及集成好的相关操作<br>但是自己需要注意的是四点</p><ol><li>矩阵的维度，一定要在神经网络里面对应好</li></ol><p><img src="/2020/03/10/逻辑回归-深度学习网络雏型/9.png" alt=""></p><ol><li><p>深度学习的一些建构好的模型，比如后面将要学习到的CNN 以及 RNN 这都是后面将会学习到的</p></li><li><p>前向传播，以及反向传播的时候不要写错，虽然现在有框架帮忙，可以减少很多体力活，但是需要注意的是在构建自己模型的时候需要去好好深思一下</p></li><li><p>参数，超参数。 这估计就是深度学习中最核心的话题了，因为基本上一大部分时间都回去调整一下参数，</p></li></ol><p><img src="/2020/03/10/逻辑回归-深度学习网络雏型/10.png" alt=""></p><p>以上就是从逻辑回归到达 深度学习基础的内容，下一篇博客就会主要讲在构建深度学习的过程中，需要去改善，优化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="机器学习" scheme="http://wsx1128.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://wsx1128.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="http://wsx1128.cn/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="http://wsx1128.cn/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Deep learning of Structuring Machine Learning Projects</title>
    <link href="http://wsx1128.cn/2020/03/06/Deep-learning-of-Structuring-Machine-Learning-Projects/"/>
    <id>http://wsx1128.cn/2020/03/06/Deep-learning-of-Structuring-Machine-Learning-Projects/</id>
    <published>2020-03-05T17:33:18.000Z</published>
    <updated>2020-03-05T17:35:13.763Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先声明 本篇所涉及到的知识点 全部来自于 Courase deeplearning.ai Structuring Machine Learning Projects week one —- week two</p><p>这一门课没有太多的实践内容，帮助构建自己的机器学习项目，错误分析已经相关优化，已经调整参数，介绍一些常用的策略，也算是深度学习中非常重要的课程了。</p><h2 id="Orthogonalization（正交化）"><a href="#Orthogonalization（正交化）" class="headerlink" title="Orthogonalization（正交化）"></a>Orthogonalization（正交化）</h2><p>我们在机器学习模型建立的整个流程中，我们需要根据不同部分反映的问题，去做相应的调整，从而更加容易地判断出是在哪一个部分出现了问题，并做相应的解决措施。</p><p>正交化或正交性是一种系统设计属性，其确保修改算法的指令或部分不会对系统的其他部分产生或传播副作用。 相互独立地验证使得算法变得更简单，减少了测试和开发的时间。</p><p>而正交化表现在四个方面：</p><ol><li><p>系统在训练集上表现的好<br> 否则使用更大的神经网络、更好的优化算法</p></li><li><p>系统在开发集上表现的好<br> 否则使用正则化、更大的训练集</p></li><li><p>系统在测试集上表现的好<br> 否则使用更大的开发集</p></li><li><p>在真实的系统环境中表现的好<br> 否则修改开发测试集、修改代价函数</p></li></ol><h2 id="setting-your-goal-单一数字评估指标"><a href="#setting-your-goal-单一数字评估指标" class="headerlink" title="setting your goal(单一数字评估指标)"></a>setting your goal(单一数字评估指标)</h2><p>在训练机器学习的模型的时候，无论是调整超参数，还是尝试更好的办法，为你的目标设置一个评估指标，这样有利于你在这个方向上面前进</p><p>在二分类问题之中，通过预测可以得到真实值以及下面的预测值的表:</p><p><img src="/2020/03/06/Deep-learning-of-Structuring-Machine-Learning-Projects/1.jpg" alt=""></p><p>下面就是指标的计算方法，一般都是用这个来对付二元分类问题</p><p><img src="/2020/03/06/Deep-learning-of-Structuring-Machine-Learning-Projects/2.png" alt=""></p><p>那么 如果在多元问题的分类上面呢？如果仅仅是上面的查准率以及查全率的化反而不太准确。</p><p>如果是多元问题的化，那么就采用地区的平均值来对模型效果进行评估。</p><p><img src="/2020/03/06/Deep-learning-of-Structuring-Machine-Learning-Projects/3.jpg" alt=""></p><p>该模型在各个地区有着不同的表现，这里用地区平均值对模型效果进行评估的化，反而会显示的性能好一点。</p><h2 id="满足和优化指标"><a href="#满足和优化指标" class="headerlink" title="满足和优化指标"></a>满足和优化指标</h2><p><img src="/2020/03/06/Deep-learning-of-Structuring-Machine-Learning-Projects/4.png" alt=""></p><h2 id="训练、开发、测试集"><a href="#训练、开发、测试集" class="headerlink" title="训练、开发、测试集"></a>训练、开发、测试集</h2><ul><li>训练、开发、测试集的设置会对产品带来非常大的影响</li><li>在选择开发集和测试集时要使二者来自同一分布，且从所有数据中随机选取</li><li>所选择的开发集和测试集中的数据，要与未来想要或者能够得到的数据类似，即模型数据和未来数据要具有相似性</li><li>设置的测试集只要足够大，使其能够在过拟合的系统中给出高方差的结果就可以，也许10000左右的数目足够</li><li>设置开发集只要足够使其能够检测不同算法、不同模型之间的优劣差异就可以，百万大数据中1%的大小就足够</li></ul><p>总之 只需要记住三者之间的比例，一般较小的数据中，训练60% 然后开发、测试占%20<br>如果是深度学习，大数据的项目，那么训练980000:10000:10000 这样的比例就行了</p><p>训练集 训练模型<br>开发集 选取模型，以及模型调优<br>测试集 选择解决问题最适合的模型<br><strong>有的时候没有测试集，直接用在了测试集中</strong></p><h2 id="根据需要改变指标"><a href="#根据需要改变指标" class="headerlink" title="根据需要改变指标"></a>根据需要改变指标</h2><p>在针对某一问题我们设置开发集和评估指标后，这就像把目标定在某个位置，后面的过程就聚焦在该位置上。但有时候在这个项目的过程中，可能会发现目标的位置设置错了，所以要移动改变我们的目标。</p><p>比如课程中举出的相应的例子</p><p>评估指标：分类错误率<br>算法A： 3% 错误率<br>算法B： 5% 错误率</p><p>这样来看，算法A的表现更好。但是在实际的测试中，算法A可能因为某些原因，将很多色情图片分类成了猫。所以当我们在线上部署的时候，算法A会给爱猫人士推送更多更准确的猫的图片（因为其误差率只有 3% ），但同时也会给用户推送一些色情图片，这是不能忍受的。所以，虽然算法A的错误率很低，但是它却不是一个好的算法。</p><p>这个时候我们就需要改变开发集、测试集或者评估指标。</p><p>假设开始我们的评估指标如下：</p><p><img src="/2020/03/06/Deep-learning-of-Structuring-Machine-Learning-Projects/5.png" alt=""></p><p>该评估指标对色情图片和非色情图片一视同仁，但是我们希望，分类器不会错误将色情图片标记为猫。</p><p>修改的方法，在其中加入权重w ：</p><p><img src="/2020/03/06/Deep-learning-of-Structuring-Machine-Learning-Projects/6.png" alt=""></p><p>总结来说就是：如果评估指标无法正确评估算法的排名，则需要重新定义一个新的评估指标。</p><h2 id="与人类表现进行比较"><a href="#与人类表现进行比较" class="headerlink" title="与人类表现进行比较"></a>与人类表现进行比较</h2><p>假设针对两个问题分别具有相同的训练误差和交叉验证误差，如下所示：</p><p>对于左边的问题，人类的误差为 1% ，对于右边的问题，人类的误差为 7.5%。</p><p>对于某些任务如计算机视觉上，人类能够做到的水平和贝叶斯误差相差不远。（这里贝叶斯误差指最好的分类器的分类误差，也就是说没有分类器可以做到100%正确）。这里将人类水平误差近似为贝叶斯误差。</p><p>左边的例子： 8% 与 1% 差距较大<br>主要着手减少偏差，即减少训练集误差和人类水平误差之间的差距，来提高模型性能。</p><p>右边的例子： 8% 与 7.5% 接近<br>主要着手减少方差，即减少开发集误差和测试集误差之间的差距，来提高模型性能。</p><p>对人类水平误差有一个大概的估计，可以让我们去估计贝叶斯误差，这样可以让我们更快的做出决定：减少偏差还是减少方差。</p><p>而这个决策技巧通常都很有效果，直到系统的性能开始超越人类，那么我们对贝叶斯误差的估计就不再准确了，再从减少偏差和减少方差方面提升系统性能就会比较困难了。</p><p>如果二者与人类表现相差过大，那么应该改善偏差，如果训练集与开发集相差过大，那么应该改善方差</p><h2 id="改善模型的表现"><a href="#改善模型的表现" class="headerlink" title="改善模型的表现"></a>改善模型的表现</h2><p>根据课程上面提到的例子，以及进行的总结来看</p><p>减少偏差的办法：</p><ul><li>训练更大的模型</li><li>训练更长时间、训练更好的优化算法（Momentum、RMSprop、Adam）</li><li>寻找更好的网络架构（RNN、CNN）、寻找更好的超参数</li></ul><p>减少方差的办法：</p><ul><li>收集更多的数据</li><li>正则化（L2、dropout、数据增强）</li><li>寻找更好的网络架构（RNN、CNN）、寻找更好的超参数</li></ul><p><img src="/2020/03/06/Deep-learning-of-Structuring-Machine-Learning-Projects/7.jpg" alt=""></p><h3 id="误差分析"><a href="#误差分析" class="headerlink" title="误差分析"></a>误差分析</h3><p>当我们在训练一个模型的时候，如一个猫和狗分类模型，最终得到了90%的精确度，即有10%的错误率。所以我们需要对模型的一些部分做相应调整，才能更好地提升分类的精度。</p><p>如果不加分析去做，可能几个月的努力对于提升精度并没有作用。所以一个好的误差分析的流程就相当重要。</p><p><strong>下面就是错误分析的样例</strong></p><h4 id="收集错误样例"><a href="#收集错误样例" class="headerlink" title="收集错误样例"></a>收集错误样例</h4><p>在开发集（测试集）中，获取大约100个错误标记的例子，并统计其中有多少个是狗。</p><ul><li><p>假设一种情况是100个数据中，有5个样例是狗，那么如果我们对数据集的错误标记做努力去改进模型的精度，那么可以提升的上限就是 5%，即仅仅可以达到 95% 的准确率，这有时称为性能上限。那么这种情况下，可能这样耗时的努力方向就不是很值得的一件事情。</p></li><li><p>另外一种假设是100个数据中，有50多个样例是狗，那么这种情况下，我们去改进数据集的错误标记，就是一个比较值得的改进方向，可以将模型的精确度提升至 95% 。</p></li></ul><h4 id="并行分析"><a href="#并行分析" class="headerlink" title="并行分析"></a>并行分析</h4><ul><li>修改那些被分类成猫的狗狗图片标签</li><li>修改那些被错误分类的大型猫科动物，如：狮子，豹子等</li><li>提升模糊图片的质量。</li></ul><p>为了并行的分析，建立表格来进行。以单个错误分类样本为对象，分析每个样本错误分类的原因。</p><p>最后，统计错误类型的百分比，这个分析步骤可以给我们一个粗略的估计，让我们大致确定是否值得去处理每个不同的错误类型。</p><h4 id="清楚错误标记的样本"><a href="#清楚错误标记的样本" class="headerlink" title="清楚错误标记的样本"></a>清楚错误标记的样本</h4><p>下面还是以猫和狗分类问题为例子，来进行分析。如下面的分类中的几个样本：（来源于视频中的样例）</p><p>情况一：</p><p>深度学习算法对训练集中的随机误差具有相当的包容性。</p><p>只要我们标记出错的例子符合随机误差，如：做标记的人不小心错误，或按错分类键。那么像这种随机误差导致的标记错误，一般来说不管这些误差可能也没有问题。</p><p>情况二：</p><p>虽然深度学习算法对随机误差具有很好的包容性，但是对于系统误差就不是这样了。</p><p>如果做标记的人一直把如例子中的白色的狗标记成猫，那么最终导致我们的分类器就会出现错误。</p><p>dev、test集中错误标记的情况：</p><p>如果在开发集和测试集中出现了错误标记的问题，我们可以在误差分析的过程中，增加错误标记这一原因，再对错误的数据进行分析，得出修正这些标记错误的价值。</p><p><strong>修正开发、测试集上面的错误样例</strong></p><ul><li><p>对开发集和测试集上的数据进行检查，确保他们来自于相同的分布。使得我们以开发集为目标方向，更正确地将算法应用到测试集上。</p></li><li><p>考虑分类正确的成本</p></li><li><p>训练集和开发集 来自不同的分布</p></li></ul><h4 id="搭建系统"><a href="#搭建系统" class="headerlink" title="搭建系统"></a>搭建系统</h4><ul><li>设置开发、测试集和优化指标（确定方向）</li><li>快速地建立基本的系统</li><li>使用偏差方差分析、误差分析去确定后面步骤的优先步骤</li></ul><p>总的来说，如果我们想建立自己的深度学习系统，我们就需要做到：快速的建立自己的基本系统，并进行迭代。而不是想的太多，在一开始就建立一个非常复杂，难以入手的系统。</p><h4 id="不同分布上的训练以及测试"><a href="#不同分布上的训练以及测试" class="headerlink" title="不同分布上的训练以及测试"></a>不同分布上的训练以及测试</h4><p>在深度学习的时代，因为需求的数据量非常大，现在很多的团队，使用的训练数据都是和开发集和测试集来自不同的分布。</p><p>下面是一些处理训练集和测试集存在差异的最佳的做法。以前一周中的猫的分类问题为例：</p><p><img src="/2020/03/06/Deep-learning-of-Structuring-Machine-Learning-Projects/8.jpg" alt=""></p><p>我们可以从网上获取大量的高清晰的猫的图片去做分类，如200000张，但是只能获取少量利用手机拍摄的不清晰的图片，如10000张。但是我们系统的目的是应用到手机上做分类。</p><p>也就是说，我们的训练集和开发集、测试集来自于不同的分布。</p><p><strong>方法一：</strong></p><p>将两组数据合并到一起，总共得到21万张图片样本。将这些样本随机分配到训练、开发、测试集中。</p><p>好处：三个集合中的数据均来自于同一分布；<br>坏处： 我们设立开发集的目的是瞄准目标，而现在我们的目标绝大部分是为了去优化网上获取高清晰度的照片，而不是我们真正的目标。</p><p>该方法不是一个好的方法，不推荐。</p><p><strong>方法二：</strong></p><p>训练集均是来自网上下载的20万张高清图片，当然也可以加上5000张手机非高清图片；对于开发和测试集都是手机非高清图片。</p><p>好处：开发集全部来自手机图片，瞄准目标；<br>坏处：训练集和开发、测试集来自不同的分布。</p><p>从长期来看，这样的分布能够给我们带来更好的系统性能。</p><h4 id="不同分布上的方差与偏差"><a href="#不同分布上的方差与偏差" class="headerlink" title="不同分布上的方差与偏差"></a>不同分布上的方差与偏差</h4><p>通过估计学习算法的偏差和方差，可以帮助我们确定接下来应该优先努力的方向。但是当我们的训练集和开发、测试集来自不同的分布时，分析偏差和方差的方式就有一定的不同。</p><p><strong>方差和分布原由分析</strong></p><p>以猫分类为例，假设以人的分类误差 0% 作为贝叶斯误差。若我们模型的误差为</p><p>Training error： 1%<br>Dev error： 10%</p><p>如果我们的训练集和开发、测试集来自相同的分布，那么我们可以说模型存在很大的方差问题。但如果数据来自不同的分布，那么我们就不能下这样的定论了。</p><p>那么我们如何去确定是由于分布不匹配的问题导致开发集的误差，还是由于算法中存在的方差问题所致？</p><p><strong>设立“训练开发集”</strong></p><p>训练开发集，其中的数据和训练数据来自同一分布，但是却不用于训练过程。</p><p>如果最终，我们的模型得到的误差分别为：</p><p>Training error： 1%<br>Training-dev error： 9%<br>Dev error： 10%<br>那么，由于训练开发集尽管和训练集来自同一分布，但是却有很大的误差， 模型无法泛化到同分布的数据，那么说明我们的模型存在方差问题。</p><p>但如果我们的模型得到的误差分别为：</p><p>Training error： 1%<br>Training-dev error： 1.5%<br>Dev error： 10%</p><p>现在就可以明确看出来，前者是模型存在方差问题，而后者可能就是分布不匹配导致的问题</p><p><strong>分布不同的偏差方差分析</strong></p><p>通过：Human level、Training set error、Training-dev set error、Dev error、Test error 之间误差的大小，可以分别得知我们的模型，需要依次在：可避免的偏差、方差、数据分布不匹配、开发集的或拟合程度，这些方面做改进。</p><p><img src="/2020/03/06/Deep-learning-of-Structuring-Machine-Learning-Projects/9.jpg" alt=""></p><p>通常情况下来说，通过不同的集合上的误差分析，我们得出的结果会是中间一列误差由小变大，即误差上升的情况。但是也有一定的可能会出现右边一列误差在开发测试集上又表现的好的情况。</p><p>下面通过一个后视镜语音检测的例子来说明。我们以该例子建立更加一般的表格。</p><p><img src="/2020/03/06/Deep-learning-of-Structuring-Machine-Learning-Projects/10.jpg" alt=""></p><p>其中，横向分别是：普通语音识别数据、后视镜语音识别数据；纵向分别是：Human level、训练数据误差、未训练数据误差。表格中不同的位置分别代表不同的数据集。</p><p>通常情况下，我们分析误差会是一个递增的情况，但是对于我们的模型，在后视镜语音识别的数据数据上，可能已经可以达到人类水平误差的6%了，而最终的开发测试集也会6%的误差，要比训练误差和训练开发误差都要小。所以如果遇到这种情况，就要利用上表进行分析。</p><h4 id="解决数据分布不匹配问题"><a href="#解决数据分布不匹配问题" class="headerlink" title="解决数据分布不匹配问题"></a>解决数据分布不匹配问题</h4><p>如果通过上一节的误差分析，我们可以得知，模型最终在开发和测试集上的误差最终是由于数据分布不匹配而导致。那么这样的情况下如何解决？</p><p>进行人工误差分析，尝试去了解训练集和开发测试集的具体差异在哪里。如：噪音等；<br>尝试把训练数据变得更像开发集，或者收集更多的类似开发集和测试集的数据，如增加噪音；</p><h4 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h4><p>将从一个任务中学到的知识，应用到另一个独立的任务中。</p><p><img src="/2020/03/06/Deep-learning-of-Structuring-Machine-Learning-Projects/11.jpg" alt=""></p><p>迁移学习适合以下场合：迁移来源问题有很多数据，但是迁移目标问题却没有那么多的数据。</p><p>假设图像识别任务中有1百万个样本，里面的数据相当多；但对与一些特定的图像识别问题，如放射科图像，也许只有一百个样本，所以对于放射学诊断问题的数据很少。所以从图像识别训练中学到的很多知识可以迁移，来帮助我们提升放射科识别任务的性能。</p><p>同样一个例子是语音识别，可能在普通的语音识别中，我们有庞大的数据量来训练模型，所以模型从中学到了很多人类声音的特征。但是对于触发字检测任务，可能我们拥有的数据量很少，所以对于这种情况下，学习人类声音特征等知识就显得相当重要。所以迁移学习可以帮助我们建立一个很好的唤醒字检测系统。</p><p>其的意义就在于</p><p>任务A和任务B有着相同的输入；<br>任务A所拥有的数据要远远大于任务B（对于更有价值的任务B，任务A所拥有的数据要比B大很多）；<br>任务A的低层特征学习对任务B有一定的帮助。</p><h4 id="多任务学习"><a href="#多任务学习" class="headerlink" title="多任务学习"></a>多任务学习</h4><p>与迁移学习的串行学习方式不同，在多任务学习中，多个任务是并行进行学习的，同时希望各个任务对其他的任务均有一定的帮助。</p><p>假设在自动驾驶的例子中，我们需要检测的物体很多，如行人、汽车、交通灯等等。</p><p>对于现在的任务，我们的目标值变成了一个向量的形式向量中的每一个值代表检测到是否有如行人、汽车、交通灯等，一张图片有多个标签。</p><p><img src="/2020/03/06/Deep-learning-of-Structuring-Machine-Learning-Projects/12.jpg" alt=""></p><p>模型的神经网络结构如下图所示：</p><p><img src="/2020/03/06/Deep-learning-of-Structuring-Machine-Learning-Projects/13.jpg" alt=""></p><p>这个问题的cost函数为</p><p><img src="/2020/03/06/Deep-learning-of-Structuring-Machine-Learning-Projects/14.png" alt=""></p><p>对于这样的问题，我们就是在做多任务学习，因为我们建立单个神经网络，来解决多个问题。</p><p>特定的对于一些问题，例如在我们的例子中，数据集中可能只标注了部分信息，如其中一张只标注了人，汽车和交通灯的标识没有标注。那么对于这样的数据集，我们依旧可以用多任务学习来训练模型。当然要注意这里Loss function求和的时候，只对带0、1标签的 j 进行求和。</p><p>多任务学习有意义的情况：</p><p>如果训练的一组任务可以共用低层特征；<br>通常，对于每个任务大量的数据具有很大的相似性；（如，在迁移学习中由任务A“100万数据”迁移到任务B“1000数据”；多任务学习中，任务多的，每个任务均有1000个数据，合起来就有1000n个数据，共同帮助任务的训练）<br>可以训练一个足够大的神经网络并同时做好所有的任务。</p><h4 id="端到端深度学习"><a href="#端到端深度学习" class="headerlink" title="端到端深度学习"></a>端到端深度学习</h4><p>端到端学习的定义：</p><p>相对于传统的一些数据处理系统或者学习系统，它们包含了多个阶段的处理过程，而端到端的深度学习则忽略了这些阶段，用单个神经网络来替代。</p><p>语音识别例子：</p><p>在少数据集的情况下传统的特征提取方式可能会取得好的效果；如果在有足够的大量数据集情况下，端到端的深度学习会发挥巨大的价值。</p><p><img src="/2020/03/06/Deep-learning-of-Structuring-Machine-Learning-Projects/15.jpg" alt=""></p><p><strong>优缺点</strong></p><p>优点：<br>端到端学习可以直接让数据“说话”；<br>所需手工设计的组件更少。<br>缺点：<br>需要大量的数据；<br>排除了可能有用的手工设计组件。<br>应用端到端学习的 Key question：是否有足够的数据能够直接学习到从 x 映射到 y 的足够复杂的函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="机器学习" scheme="http://wsx1128.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://wsx1128.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="http://wsx1128.cn/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Machine Learning: Programming Exercise 1: Linear Regression</title>
    <link href="http://wsx1128.cn/2020/01/20/Machine-Learning-Programming-Exercise-1-Linear-Regression/"/>
    <id>http://wsx1128.cn/2020/01/20/Machine-Learning-Programming-Exercise-1-Linear-Regression/</id>
    <published>2020-01-20T08:36:31.000Z</published>
    <updated>2020-02-26T07:31:05.486Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="知识梗概"><a href="#知识梗概" class="headerlink" title="知识梗概"></a>知识梗概</h2><pre><code>这一周首先一开始就直接介绍，机器学习以及深度学习的相关概念，介绍了两个概念 一个是监督学习，另一个就是非监督学习，简要的区分了上述两种基本学习的形式。以下重点关注了线性回归，分为了两个部分来讲解，首先是一个参数的线性回归方程，另外一个就是多个参数的线性回归方程。</code></pre><h2 id="机器学习的介绍"><a href="#机器学习的介绍" class="headerlink" title="机器学习的介绍"></a>机器学习的介绍</h2><p>总的来说，简而言之就是通过数据来预测，识别，分类。 （目前自己所能接触到的地方）</p><p><strong>监督学习</strong> </p><ol><li><p>房价的预测，通过数据来整合出特征量，然后模拟出函数（假设），最后通过给出的特征量来得出房价</p></li><li><p>癌症肿瘤检测，通过数据来根据肿瘤大小，进行一个分类，然后下次预测检测肿瘤大小判断良性或者恶性。</p></li></ol><p>总结： 监督学习就是每一个数据都会有一个结果量（标签量）来和其他数据进行区分，比如房价的特征量最终的结果是房价的多少，肿瘤的大小决定了是否为良性。 需要一个结果标签量</p><p><strong>非监督学习</strong></p><p>人群分类，天文数据分析，市场比重分析</p><p>这一类的数据不需要结果标签量来区分彼此，每一个其他量没有其他的分别。主要用于没有区分的数据，进行相互组合及分类。</p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p>线性回归属于监督学习。</p><h3 id="线性回归一个参数"><a href="#线性回归一个参数" class="headerlink" title="线性回归一个参数"></a>线性回归一个参数</h3><p>具体的步骤就是<br><img src="/2020/01/20/Machine-Learning-Programming-Exercise-1-Linear-Regression/1.png" alt=""></p><p>所以接下来的步骤就是要得出这个假设函数。</p><p>所以接下来引出了<strong>cost function （代价函数）</strong></p><p><img src="/2020/01/20/Machine-Learning-Programming-Exercise-1-Linear-Regression/2.png" alt=""></p><p>现在已经得出了代价函数，接下来就是需要通过使代价函数最小来模拟出假设函数。</p><p><strong>Gradient descent（梯度下降）</strong></p><p>就像下图一样可以直接得出<br><img src="/2020/01/20/Machine-Learning-Programming-Exercise-1-Linear-Regression/3.png" alt=""></p><p>梯度下降的算法如下图所示<br><img src="/2020/01/20/Machine-Learning-Programming-Exercise-1-Linear-Regression/4.png" alt=""></p><p>注意注意 梯度下降算法 必须要同时进行，如果没有同时进行，那么不算数。</p><p>并且在$\alpha$的选择上，一定要适合，不然的话就会造成以下的后果，不过一般这种情况题目会提前给予相应的情况。</p><p><img src="/2020/01/20/Machine-Learning-Programming-Exercise-1-Linear-Regression/5.png" alt=""></p><p>最终将上述两者结合起来</p><p>梯度下降算法如下<br><img src="/2020/01/20/Machine-Learning-Programming-Exercise-1-Linear-Regression/6.png" alt=""></p><p>以上就被称为：“Batch” Gradient Descent。（后面的章节会着重讲到）</p><h3 id="线性回归多个参数"><a href="#线性回归多个参数" class="headerlink" title="线性回归多个参数"></a>线性回归多个参数</h3><p>由于之前 只有一个参数就能够模拟出相应的假设，但是现在有更复杂的徒刑，需要更多的参数 </p><p>就想着样子：<br><img src="/2020/01/20/Machine-Learning-Programming-Exercise-1-Linear-Regression/7.png" alt=""></p><p>所以更改下来 新的梯度下降算法，便成为了这个：<br><img src="/2020/01/20/Machine-Learning-Programming-Exercise-1-Linear-Regression/8.png" alt=""></p><h3 id="参数缩放以及归一化"><a href="#参数缩放以及归一化" class="headerlink" title="参数缩放以及归一化"></a>参数缩放以及归一化</h3><p>由于多个参数之后，有的特征量与其他的特征量相比，过于大了，所以现在需要采用的是 参数缩放将参数除以其的范围，限制在0到1之间。</p><p><strong>归一化</strong><br><img src="/2020/01/20/Machine-Learning-Programming-Exercise-1-Linear-Regression/10.png" alt=""></p><p>减去平均值 然后再除上最大范围</p><p><strong>正确的选择\alpha的值</strong></p><p>选择参数的时候可以灵活一点 就想这样</p><p><img src="/2020/01/20/Machine-Learning-Programming-Exercise-1-Linear-Regression/11.png" alt=""></p><p><strong>Normal Equation</strong></p><p>第二种计算线性回归的方法</p><p><img src="/2020/01/20/Machine-Learning-Programming-Exercise-1-Linear-Regression/12.png" alt=""></p><h2 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h2><pre><code>作业就是要求使用matlab 运用线性代数的知识，来模拟线性回归，已经上传到github上面，这里就不再重复叙述了。后面有时间，使用pytorch来重新练习一遍。  </code></pre><p>·</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="机器学习" scheme="http://wsx1128.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://wsx1128.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="线性回归" scheme="http://wsx1128.cn/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>告别2019，初遇2020</title>
    <link href="http://wsx1128.cn/2020/01/01/%E5%91%8A%E5%88%AB2019%EF%BC%8C%E5%88%9D%E9%81%872020/"/>
    <id>http://wsx1128.cn/2020/01/01/告别2019，初遇2020/</id>
    <published>2019-12-31T22:04:42.000Z</published>
    <updated>2020-02-27T00:22:49.714Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>2019年有很多遗憾，有很多没有达成的目标，曾经以为特别重要的东西，随着时间流逝，反而觉得没有那么重要了，曾经消极的看待世界，沉迷于世界的阴霾，绝望，无奈，以及看不到生活的希望，开始质疑生活的初心。一次又一次的被打击自信心，又一次又一次进行了信心的重塑。</p><p>在2019年 参加过很多辩论赛，打过acm，蓝桥杯，去过北京，去过其他的各大高校，同时也遇见过形形色色的很多人，感谢这些出现在我生命里的人，是他们让我们知道人生的多种可能性，也是他们让我不再纠结于自己的人生不能够在多元化迈进。</p><p>曾经觉得自己的一生一定是精彩的一生，曾经觉得自己是世界上最独一无二的人，只不过还没有觉醒发力，曾经觉得自己能做很多其他常人做不到的事情。</p><p>到最后才发现自己可能真的是一个普通人，平凡的家庭，平凡的经历，以及平凡的生活，以前会觉得这种思想是消极的懦弱的想法，但是现在只是觉得 早点认清事实，也许可以为平凡的生活增添一些不平凡的地方，就像是疲惫的平凡生活中增添几丝无限向往的英雄梦想。</p><p>2019年又很多从2018年继承下来的期望，以前的以前觉得世界很大，大到自己无法想象的程度，恐惧，无知有的时候真的会占据一大半你对这个世界的想象。有的时候其实走向未来最大的阻力真的可能就是自己。 也许真的应了那句话，奥力给。</p><p>虽然迈向2020年之前的前几天，还陷在无数考试和实验报告中，自己也曾经抑郁过一个星期不怎么起床。不过，那都是过去了，我相信未来的一年，一定是充满朝阳的一年。</p><p>任何情绪都有存在的必要，任何感觉都有被诉说的可能，任何需求都应该有发泄的可能，我自己不再阻塞，不再自闭，不再责怪自己，拥抱希望，相信时间会给你所有想要的，才是迈向人生终极梦想的道路。</p><p>现在是6点43分，跟喜欢狼人杀的同号打了一晚上的狼人杀游戏，大家有的睡着了，有的还在打游戏，真的很庆幸有一群志趣相同的朋友陪着自己度过这些天的紧张生活。 狼人杀，希望新的一年爆爆爆吧。</p><p>也许2020年会遭受很多痛苦，会有很多时间花在怀疑自己这个过程中，也许会对生活失去原本的热心。真的很害怕自己会最终成为失去光华的人，就像游戏蔚蓝一样，如果真的爬不到山顶，真的完成不了自己的目标，那么该怎么办？就像蔚蓝的女主角一样“那就失败吧，你是我需要放下的一切，在此之前，请接受自己。”</p><p>最后以一句话结束自己的告别，与迎接新的一年</p><p>我的一生注定是与自己抗争的一生，但同时也是逐渐接受自己的一生。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="成长" scheme="http://wsx1128.cn/categories/%E6%88%90%E9%95%BF/"/>
    
    
      <category term="生活" scheme="http://wsx1128.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="年终总结" scheme="http://wsx1128.cn/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>人生第一场话剧---一个人的莎士比亚</title>
    <link href="http://wsx1128.cn/2019/12/08/%E4%BA%BA%E7%94%9F%E7%AC%AC%E4%B8%80%E5%9C%BA%E8%AF%9D%E5%89%A7-%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E8%8E%8E%E5%A3%AB%E6%AF%94%E4%BA%9A/"/>
    <id>http://wsx1128.cn/2019/12/08/人生第一场话剧-一个人的莎士比亚/</id>
    <published>2019-12-08T15:43:07.000Z</published>
    <updated>2019-12-31T22:03:30.190Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这次可以说人生的第一场话剧，本来就是有一点不想去，毕竟最近自己的状态并没有恢复过来，上次生日的花费预算，也是超了一点，然后秉持着不太想乱花钱的想，于是就有点不想去。</p><p>感谢朋友的坚持，让我感受到了又浅到深的心灵交流。</p><p>这是我接触到的第一场全英文独白的话剧了，全程就是一个年过半百的美国老爷爷上台表演，通过多种表情，姿态，语气，台词展现多个角色的独角戏。而展示的角色大致如下：</p><ul><li>主角的学生时代</li><li>主角的父亲</li><li>主角的莎士比亚老师</li><li>主角的成年时代</li><li>主角莎士比亚老师的学生</li></ul><p>说句实话，自己实在是算个粗人，对比话剧人士来说，我实在是无法接收到这种不是特别强烈的画面感以及动情的背景音乐的交流。以至于我刚开始看这个话剧的时候，觉得有点带有低俗性质的无法共情。正是由于是全英文独白，没有任何额外的配音，与道具，考验观众的共情能力，以及英语能力（虽然我每个单词都能够大致听懂，但是连成一个句子实在是有点强人所难了）。但是更考验的却是演员的临场能力，以及各种情绪语气的转变能力。只能说观众向有点精湛，如果读过莎士比亚的选集再来观看可能又是不太一样的感受吧。</p><p>个人理解，这部话剧是将作者亲身经历的故事，和莎士比亚的剧本话剧，代入到一个莎士比亚悲剧精神的校长之间发生的故事。</p><p>如果由剧情上进行一个划分，基本上可以分成四个部分</p><h4 id="主角与莎士比亚话剧集的初识"><a href="#主角与莎士比亚话剧集的初识" class="headerlink" title="主角与莎士比亚话剧集的初识"></a>主角与莎士比亚话剧集的初识</h4><p>这个地方就是作者被老师校长逼迫读<strong>皆大欢喜</strong>中间的一段，由于总是读错，于是紧张的尿裤子。剧情上显得很一般，主要角色有两个，但是演员厉害的是在两种角色中转变中游刃有余，并且将学生的紧张感表现的唯妙唯俏，要知道，这仅仅只是靠了台词以及肢体语言，并没有其他多余的表现形式。 这个地方也是刚刚开始共情的地方了，从最先开始的看不懂的惊讶，到后面对于一个词语 遗赠 产生了莫大的兴趣 这也是主角尿裤子的主要原因了，这一场戏反而结合大家的想象力，反而显得特别有趣，因为每一种场景被赋予了想象力获得了独特的生命力，剧情的推进也到了下一个阶段。</p><h4 id="主角与父亲的对话"><a href="#主角与父亲的对话" class="headerlink" title="主角与父亲的对话"></a>主角与父亲的对话</h4><p>主角由于在学校里面出了丑，不敢再去学校，被父亲开解，于是敢于去学校了。父亲开解主角的那段话，让我记忆深刻，可能是最近对于细节情感的再现，真心的觉得中国普通家庭的亲子关系充满了沉重，被经济压的只剩下现实，希望自己以后能够冲破束缚改变这一切。我希望与父母或者是子女的关系（如果有的话）能够多一些轻松愉悦，不要被焦虑的担心所束缚。<br>所谓父母子女一场，不过真切关系中最有缘分的相连，不要越爱越沉重。</p><h4 id="主角与发生悲剧老师的故事"><a href="#主角与发生悲剧老师的故事" class="headerlink" title="主角与发生悲剧老师的故事"></a>主角与发生悲剧老师的故事</h4><p>「有时间再去补上」</p><h4 id="主角与老年老师的故事"><a href="#主角与老年老师的故事" class="headerlink" title="主角与老年老师的故事"></a>主角与老年老师的故事</h4><p>换言之，整部话剧最令我感动的就是这个地方，由老年的校长说出<br>全世界是一个大舞台，所有的男男女女不过是一些演员；他们都有下场的时候，也有上场的时候。<br>一个人的一生中扮演着好几个角色，他的表演可以分为七个时期。<br>最初是婴孩，在保姆的怀中啼哭呕吐。<br>然后是背着书报、满面红光的学童，像蜗牛一样慢腾腾地拖着脚步，不情愿地呜咽着上学堂。<br>然后是情人，像炉灶一样叹着气，写了一首悲哀的诗歌咏着他恋人地眉毛。<br>然后是一个军人，满口发着古怪地誓，胡须长得像豹子一样，爱惜着名誉，动不动就要打架，在炮口上寻求着泡沫一样得荣名。<br>然后是法官，胖胖圆圆的肚子塞满了阉鸡，凛然的眼光，整洁的胡须，满嘴都是格言和老生常谈；他这样扮了他的一个角色。<br>第六个时期变成了精瘦的趿着拖鞋的龙钟老叟，鼻子上架着眼镜，腰边悬着钱袋；他那年轻时候节省下来的长袜子套在他皱瘪的小腿上显得宽大异常；他那朗朗的男子的口音又变成了孩子似的尖声，像是吹着风笛和哨子。<br>终结着这段古怪的多事的历史的最后一场，是孩提时代的再现，全然的遗忘，没有牙齿，没有眼睛，没有口味，没有一切。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="成长" scheme="http://wsx1128.cn/categories/%E6%88%90%E9%95%BF/"/>
    
    
      <category term="话剧" scheme="http://wsx1128.cn/tags/%E8%AF%9D%E5%89%A7/"/>
    
      <category term="莎士比亚" scheme="http://wsx1128.cn/tags/%E8%8E%8E%E5%A3%AB%E6%AF%94%E4%BA%9A/"/>
    
  </entry>
  
  <entry>
    <title>Data Compression --- the course of algorithm</title>
    <link href="http://wsx1128.cn/2019/10/10/Data-Compression-the-course-of-algorithm/"/>
    <id>http://wsx1128.cn/2019/10/10/Data-Compression-the-course-of-algorithm/</id>
    <published>2019-10-10T08:33:38.000Z</published>
    <updated>2019-10-11T10:31:05.472Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h2><h3 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h3><p>压缩数据可以节省存储数据需要的空间和传输数据需要的时间，虽然摩尔定律说集成芯片上的晶体管每 18-24 个月翻一倍，帕金森定律说数据会自己拓展来填满可用空间，但数据压缩还是最经济的做法。</p><p>数据压缩的基本模型如下，很简单，压缩和解压，压缩率即 C(B) 和 B 的比特数之比。</p><p><img src="/2019/10/10/Data-Compression-the-course-of-algorithm/1.png" alt=""></p><p>数据压缩对象的本质实际上就是将二进制文件，抽象层次为比特流， 下面直接给出了相应读写二进制的类</p><p><img src="/2019/10/10/Data-Compression-the-course-of-algorithm/2.png" alt=""><br>这里 java的默认处理是基于8位字节流<br><img src="/2019/10/10/Data-Compression-the-course-of-algorithm/3.png" alt=""></p><p>这里我举出一个简单的数据压缩的例子</p><p>将日期 12/31/1990 这个字符串进行压缩</p><p><img src="/2019/10/10/Data-Compression-the-course-of-algorithm/4.png" alt=""></p><p>上面就可以轻而易举的看出来 压缩的好处。<br>第一张图就是原来的写法，第二张图就是将其换成int类型进行压缩<br>第三张图<br>则按照特定的压缩进行压缩</p><p><strong>这里需要注意的是，并不存在通用的压缩算法</strong></p><p>当然，这里存在一种可以供人类阅读的比特流形式，这个被称为 转储。<br>下面图，就是一些例子：</p><p><img src="/2019/10/10/Data-Compression-the-course-of-algorithm/5.png" alt=""></p><p>BinaryDump 将比特流按 0 和 1 输出来；HexDump 将比特流组织成 8 位并用两位的 16 进制数表示；PictureDump 则将比特流变为 Picture 对象，其中白色像素表示 0，黑色像素表示 1。</p><h3 id="run-length-Coding"><a href="#run-length-Coding" class="headerlink" title="run-length Coding"></a>run-length Coding</h3><p>游程编码，就是专门用来处理冗杂的数据，他是通过计算重复的个数，来最终决定压缩的形式，就像下图：</p><p><img src="/2019/10/10/Data-Compression-the-course-of-algorithm/6.png" alt=""></p><p>上面这里就是用的4位计数，而下面的代码则是使用了8位计数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunLength</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> R = <span class="number">256</span>;    <span class="comment">// maximum run-length conut</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> lgR = <span class="number">8</span>;    <span class="comment">// number of bits per conut</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> b, old = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!BinaryStdIn.isEmpty()) &#123;</span><br><span class="line">            b = BinaryStdIn.readBoolean();</span><br><span class="line">            <span class="keyword">if</span> (b != old) &#123;</span><br><span class="line">                BinaryStdOut.write(cnt);</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                old = !old;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 由于这个地方是八位计数，所以最大的限制也就是255</span></span><br><span class="line">                <span class="keyword">if</span> (cnt == <span class="number">255</span>) &#123;</span><br><span class="line">                    BinaryStdOut.write(cnt);</span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                    BinaryStdOut.write(cnt);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        BinaryStdOut.write(cnt);</span><br><span class="line">        BinaryStdOut.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> bit = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!BinaryStdIn.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> run = BinaryStdIn.readInt(lgR); <span class="comment">// read 8-bit conut from standard input</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; run; i++)</span><br><span class="line">                BinaryStdOut.write(bit);        <span class="comment">// write 1 bit to standard output</span></span><br><span class="line">            bit = !bit;</span><br><span class="line">        &#125;</span><br><span class="line">        BinaryStdOut.close();                  <span class="comment">// pad 0s for byte alignment</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种策略专门对付经常出现的，冗杂的比特流是十分有效的，游程编码的一个应用就是压缩位图，位图被广泛的用于保存图片和扫描文档。</p><p>就像这张图，左边经过压缩之后极大程度上小了很多。</p><p><img src="/2019/10/10/Data-Compression-the-course-of-algorithm/7.png" alt=""></p><p>这里的游程编码不适用于含有大量短游程的输入，而不是所有我们希望压缩的比特都能像上面一样重复个数多，且冗杂。所以接下来我们就介绍两种适用于多种类型的文件压缩算法。</p><h3 id="Huffman-Compression"><a href="#Huffman-Compression" class="headerlink" title="Huffman Compression"></a>Huffman Compression</h3><p>哈夫曼压缩</p><p>这里直接介绍了一个摩斯密码，但是像摩斯密码这一类的编码很容易产生多义性，所以密码之间还有一定的间隙隔开。</p><p>多义性的本质原因是有些字符的编码是其它字符编码的前缀，所以才可能会有不同的解读。而有种特殊的变长编码——前缀码（prefix-free code），字符编码肯定不是其它字符编码的前缀，也就不存在多义性的问题。</p><p>这里表示这种前缀码，可以很自然的使用字典树来进行表示</p><p><img src="/2019/10/10/Data-Compression-the-course-of-algorithm/8.png" alt=""></p><h3 id="节点代码"><a href="#节点代码" class="headerlink" title="节点代码"></a>节点代码</h3><p>这里直接用代码表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> ch;    <span class="comment">// used only for leaf nodes</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> freq;   <span class="comment">// used only for compress</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node left, right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> freq, Node left, Node right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ch = ch;</span><br><span class="line">        <span class="keyword">this</span>.freq = freq;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node that)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.freq - that.freq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符频率在下面生成最优前缀码的时候会使用到。</p><p>当然，在下面使用前，得将这个表示前缀码的字典树一样给压缩进入到比特流，而这里就直接使用前序遍历了。</p><p><img src="/2019/10/10/Data-Compression-the-course-of-algorithm/9.png" alt=""></p><p>当然，需要将叶子节点与其他的节点区分开来的话，到叶子节点的时候会先输出一个true，意思就是1，而其他的节点则是0，附在开头的Trie相对就会显得很小，没有什么关系。</p><p><img src="/2019/10/10/Data-Compression-the-course-of-algorithm/10.png" alt=""></p><p>上面已经将压缩字典树，以及解压缩字典树都讲到了，接下来就是构造这个前缀码字典树了。</p><p>实际上，哈夫曼的做法很好描述：首先你要知道字符出现的频率，然后每次挑两个最小的加起来，加起来的值再和原来的那些一起重复挑两个最小的加起来，从下往上接成 Trie。</p><p><img src="/2019/10/10/Data-Compression-the-course-of-algorithm/11.png" alt=""></p><h3 id="构造代码"><a href="#构造代码" class="headerlink" title="构造代码"></a>构造代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">buildTrie</span><span class="params">(<span class="keyword">int</span>[] freq)</span> </span>&#123;</span><br><span class="line">    MinPQ&lt;Node&gt; pq = <span class="keyword">new</span> MinPQ&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> i = <span class="number">0</span>; i &lt; R; i++)</span><br><span class="line">        <span class="keyword">if</span> (freq[i] &gt; <span class="number">0</span>)</span><br><span class="line">            pq.insert(<span class="function">New <span class="title">Node</span><span class="params">(i, freq[i], <span class="keyword">null</span>, <span class="keyword">null</span>)</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// merge two smallest tries</span></span><br><span class="line">    <span class="keyword">while</span> (pq.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        Node x = pq.delMin();</span><br><span class="line">        Node y = pq.delMin();</span><br><span class="line">        Node parent = <span class="keyword">new</span> Node(<span class="string">'\0'</span>, x.freq + y.freq, x, y);</span><br><span class="line">        <span class="comment">// 这里有点类似于广搜的操作，这样的做法就是直接将每一个最小的值弄出来，然后分别给其设置父亲节点</span></span><br><span class="line">        pq.insert(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一定一定就是根节点了。</span></span><br><span class="line">    <span class="keyword">return</span> pa.delMin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最优解证明"><a href="#最优解证明" class="headerlink" title="最优解证明"></a>最优解证明</h3><p>这个地方目前对自己不作要求，贴两个网址</p><p><a href="https://www.cnblogs.com/mingyueanyao/p/9516423.html" target="_blank" rel="noopener">文字讲解</a></p><p><a href="https://www.coursera.org/lecture/algorithms/058ha-fu-man-suan-fa-de-zheng-que-xing-zheng-ming-nLQya" target="_blank" rel="noopener">视频讲解</a></p><h3 id="LZW-compression"><a href="#LZW-compression" class="headerlink" title="LZW-compression"></a>LZW-compression</h3><p>LZW 压缩算法是自适应性的（adaptive）模型，在读入文本的时候学习并更新模型，不需要将模型附在比特流中用于解压，但解压的时候只能从文本开头开始。</p><h3 id="压缩例子"><a href="#压缩例子" class="headerlink" title="压缩例子"></a>压缩例子</h3><p>展开和压缩类似，有下面几个步骤：</p><p>创建符号表，但这次编码为键，对应的字符串为值。<br>初始化符号表，加入单个字符的键值对。<br>从压缩文件读入 W 位的编码，输出编码对应的字符串。<br>预读下一个编码，得到下个字符，类似地更新符号表。<br>重复上两步直到读入结束编码。<br>例图即展开上面压缩形成的编码。</p><p><img src="/2019/10/10/Data-Compression-the-course-of-algorithm/12.png" alt=""></p><p>一开始读入 8 位编码 41，从符号表可知对应字符串 A，输出 A 后预读下一个编码 42，对应 B，于是往符号表中加入新键值对 (81, AB)；现在读到编码 42，输出 B 并预读 52 得到 R，所以加入 (82, BR) … 直到读入编码 80，表示文件结束。</p><p>似乎展开和压缩差不多，甚至更简单，因为不需要找最长前缀，符号表直接用数组简单实现。但是，展开有时会碰到一个特殊的情况：</p><p><img src="/2019/10/10/Data-Compression-the-course-of-algorithm/13.png" alt=""></p><p>压缩字符串 ABABABA 编码成 41 42 81 83 80，现在对这编码进行展开。编码 41 输出 A，预读 42 后加入 (81, AB) 更新符号表；编码 42 输出 B，预读 81 知道下个字符是 A，加入 (82, BA)；编码 81 输出 AB，预读 83 卡住，因为符号表中还没有这个键。</p><p>但是，这种时候我们还是可以知道 AB 的下一个字符是什么的。假设 AB 后面的字符分别为 𝑐1，𝑐2，𝑐3，卡住的时候（更新要加入的编码和预读到的编码一样）肯定有 AB𝑐1=𝑐1𝑐2𝑐3,所以下个字符即 A，加入 (83, ABA) 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;                                      <span class="comment">// 当前更新符号表要加入的编码</span></span><br><span class="line">    String[] st = <span class="keyword">new</span> String[L];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; R; i++)</span><br><span class="line">        st[i] = <span class="string">""</span> + (<span class="keyword">char</span>) i;</span><br><span class="line">    st[i++] = <span class="string">" "</span>;                             <span class="comment">// 例图中表示文件结束的 0x80</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> codeword = BinaryStdIn.readInt(W);</span><br><span class="line">    String val = st[codeword];</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        BinaryStdOut.write(val);</span><br><span class="line">        codeword = BinaryStdIn.readInt(W);    <span class="comment">// 预读的编码</span></span><br><span class="line">        <span class="keyword">if</span> (codeword == R) <span class="keyword">break</span>;</span><br><span class="line">        String s = st[codeword];</span><br><span class="line">        <span class="keyword">if</span> (i == codeword)                   <span class="comment">// 要加入的编码和预读的编码相同</span></span><br><span class="line">            s = val + val.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; L)</span><br><span class="line">            st[i++] = val + s.charAt(<span class="number">0</span>);</span><br><span class="line">        val = s;</span><br><span class="line">    &#125;</span><br><span class="line">    BinaryStdOut.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于第二种压缩方式 有点不是很好理解，可以配合算法视频课一起食用，这里就可以不用传输模型展开压缩，编码文件了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法" scheme="http://wsx1128.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://wsx1128.cn/tags/java/"/>
    
      <category term="普林斯顿算法课" scheme="http://wsx1128.cn/tags/%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%AE%97%E6%B3%95%E8%AF%BE/"/>
    
      <category term="数据压缩" scheme="http://wsx1128.cn/tags/%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>Regular Expressions --- the course of algorithm</title>
    <link href="http://wsx1128.cn/2019/10/09/Regular-Expressions-the-course-of-algorithm/"/>
    <id>http://wsx1128.cn/2019/10/09/Regular-Expressions-the-course-of-algorithm/</id>
    <published>2019-10-09T11:11:42.000Z</published>
    <updated>2019-10-09T12:52:28.485Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Regular-Expressions"><a href="#Regular-Expressions" class="headerlink" title="Regular Expressions"></a>Regular Expressions</h2><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>在文本中查找子字符串只是寻找一个单一的字符串，但经常的我们可能不知道这个字符串的完整信息，或是寻找的是吻合某种模式的一些字符串，即所谓 模式匹配（Pattern Matching）。</p><p>正则表达式（Regular Expressions） 就是用来描述模式的，表示符合某种模式的字符串的集合（可能是无限的），它有下面几种基本操作：</p><p><img src="/2019/10/09/Regular-Expressions-the-course-of-algorithm/1.png" alt=""></p><p>就是普通的正则表达式里面的操作。</p><p>连接、或、闭包和括号，都不难理解。其中闭包表示若干个自身连接，可以是零个。</p><p>然后他一般有以下这些缩略方式</p><p><img src="/2019/10/09/Regular-Expressions-the-course-of-algorithm/2.png" alt=""></p><p>关于完整的正则表达式 可以去看看</p><p><a href="https://www.jb51.net/tools/regexsc.htm" target="_blank" rel="noopener">正则表达式速查表</a></p><p><a href="https://blog.csdn.net/carechere/article/details/52315728" target="_blank" rel="noopener">基本上常用的正则表达式</a></p><p>因为之前接触过正则表达式，所以这个地方也就不再多余赘述了。</p><h3 id="REs-And-NFAs"><a href="#REs-And-NFAs" class="headerlink" title="REs And NFAs"></a>REs And NFAs</h3><p>其实，正则表达式和确定型有穷自动机间存在着二元性（duality），即 Kleene 定理所说：对任意 DFA 存在着描述同样字符串集合的正则表达式，对任意正则表达式存在着识别同样字符串集合的 DFA。</p><p>就像之前学习KMP的时候构造的DFA，这里其实也可以构造一个DFA，就像这样<br><img src="/2019/10/09/Regular-Expressions-the-course-of-algorithm/3.png" alt=""></p><p>当然应用在KMP上面的DFA是线性时间的性能保证，但是这个办法并不可行，因为正则表达式对应的DFA的状态数目可能是指数级的。</p><p>于是，就来了解一下 非确定型有限状态自动机，状态之间的转移并不是确定的。</p><ul><li><p>正则表达式用括号括起。</p></li><li><p>正则每个符号对应 NFA 一个状态，再加个接受状态。</p></li><li><p>接受空串𝜖，不扫描下个字符而直接改变状态（下图红线），不确定性所在。</p></li><li><p>扫描字符，匹配转移到一下个状态（下图黑线）。</p></li><li><p>在扫描完全部文本字符后，如果有 任一 转移序列到达接受状态，则匹配成功。</p></li></ul><p><img src="/2019/10/09/Regular-Expressions-the-course-of-algorithm/4.png" alt=""></p><h3 id="NFA-construction"><a href="#NFA-construction" class="headerlink" title="NFA-construction"></a>NFA-construction</h3><p>首先先讲一下它的构造过程</p><p>最先开始的状态，最后一个位置表示完成匹配<br><img src="/2019/10/09/Regular-Expressions-the-course-of-algorithm/5.png" alt=""></p><p>所有字符直接指向下一个<br><img src="/2019/10/09/Regular-Expressions-the-course-of-algorithm/6.png" alt=""></p><p>括号或者空的，就直接往下面指就行了<br><img src="/2019/10/09/Regular-Expressions-the-course-of-algorithm/7.png" alt=""></p><p>闭包，比较巧妙<br><img src="/2019/10/09/Regular-Expressions-the-course-of-algorithm/8.png" alt=""></p><p>不过分两种情况，例子里面的就是第一种情况<br><img src="/2019/10/09/Regular-Expressions-the-course-of-algorithm/9.png" alt=""></p><p>符号 ‘|’<br><img src="/2019/10/09/Regular-Expressions-the-course-of-algorithm/10.png" alt=""></p><p>最后再来两个空转移<br><img src="/2019/10/09/Regular-Expressions-the-course-of-algorithm/11.png" alt=""></p><p>当然，在完成上面的构造的过程中，需要借助数据结构栈，碰到左括号或者‘|’的时候就直接将其的编号压到栈内，碰到右括号就弹出栈顶，如果对于的是其他东西，就直接根据上面的图来顺应结果，具体看代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里就是直接用有向图来进行表示。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Digraph <span class="title">buildNFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Digraph g = <span class="keyword">new</span> Digraph(M + <span class="number">1</span>); <span class="comment">// 顶点数加1</span></span><br><span class="line">    Stack&lt;Integer&gt; ops = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> lp = i;</span><br><span class="line">        <span class="keyword">if</span> (re[i] == <span class="string">'('</span> || re[i] == <span class="string">'|'</span>) ops.push(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (re[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> or = ops.pop();</span><br><span class="line">            <span class="keyword">if</span> (re[or] == <span class="string">'|'</span>) &#123;</span><br><span class="line">                lp = ops.pop();</span><br><span class="line">                g.addEdge(lp, or + <span class="number">1</span>);</span><br><span class="line">                g.addEdge(or + <span class="number">1</span>, lp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> lp = or;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; M - <span class="number">1</span> &amp;&amp; re[i + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">            g.addEdge(lp, i + <span class="number">1</span>);</span><br><span class="line">            g.addEdge(i + <span class="number">1</span>, lp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (re[i] == <span class="string">'('</span> || re[i] == <span class="string">'*'</span> || re[i] == <span class="string">')'</span>)</span><br><span class="line">            g.addEdge(i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NFA-simulation"><a href="#NFA-simulation" class="headerlink" title="NFA-simulation"></a>NFA-simulation</h3><p>首先我们这样来表示 NFA：用整数 0 到 M（正则长度）来标号状态（像上图），用数组 re 来存储正则表达式，用有向图来存储空转移</p><p>至于怎么模拟 NFA 输入文本运行，感觉类似广搜，维护每一步所有可能走到的状态，下一步再拓展这些状态，要是文本流结束那步的状态里包含接受状态，就表示匹配成功。例图：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NFA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] re;    <span class="comment">// match transitions</span></span><br><span class="line">    <span class="keyword">private</span> Digraph G;    <span class="comment">// epsilon transition digraph</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;        <span class="comment">// number of states</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NFA</span><span class="params">(String regexp)</span> </span>&#123;</span><br><span class="line">        M = regexp.length();</span><br><span class="line">        re = regexp.toCharArray();    </span><br><span class="line">        G = buildEpsilonTransitionDigraph();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recognizes</span><span class="params">(String txt)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// states reachable from start by epsilon transitions</span></span><br><span class="line">        Bag&lt;Integer&gt; pc = <span class="keyword">new</span> Bag&lt;Integer&gt;();</span><br><span class="line">        DirectedDFS dfs = <span class="keyword">new</span> DirectedDFS(G, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)</span><br><span class="line">            <span class="keyword">if</span> (dfs.marked(v)) pc.add(v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; txt.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// states reachable after scanning past txt.charAt(i)</span></span><br><span class="line">            Bag&lt;Integer&gt; match = <span class="keyword">new</span> Bag&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v : pc) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v == M) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 匹配时直接加上下一个状态</span></span><br><span class="line">                <span class="keyword">if</span> ((re[v] == txt.charAt(i)) || re[v] == <span class="string">'.'</span>)</span><br><span class="line">                    match.add(v + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//最坏的结果就是 match 重新复制了一遍上述的全部</span></span><br><span class="line">            dfs = <span class="keyword">new</span> DirectedDFS(G, match);    <span class="comment">// 拓展上一步的所有状态</span></span><br><span class="line">            pc = <span class="keyword">new</span> Bag&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)</span><br><span class="line">                <span class="keyword">if</span> (dfs.marked(v)) pc.add(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// accept if can end in state M</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : pc)</span><br><span class="line">            <span class="keyword">if</span> (v == M) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图文 大部分借鉴 <a href="https://www.cnblogs.com/mingyueanyao/p/9495243.html" target="_blank" rel="noopener">博客</a></p><p>若侵权，必删。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法" scheme="http://wsx1128.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://wsx1128.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="java" scheme="http://wsx1128.cn/tags/java/"/>
    
      <category term="普林斯顿算法课" scheme="http://wsx1128.cn/tags/%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%AE%97%E6%B3%95%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>BoggleSolver</title>
    <link href="http://wsx1128.cn/2019/09/28/BoggleSolver/"/>
    <id>http://wsx1128.cn/2019/09/28/BoggleSolver/</id>
    <published>2019-09-28T13:44:37.000Z</published>
    <updated>2019-10-09T12:50:55.537Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a><a href="https://coursera.cs.princeton.edu/algs4/assignments/boggle/specification.php" target="_blank" rel="noopener">题目</a></h3><p><img src="/2019/09/28/BoggleSolver/1.png" alt="1"><br><img src="/2019/09/28/BoggleSolver/2.png" alt="2"><br><img src="/2019/09/28/BoggleSolver/3.png" alt="3"><br><img src="/2019/09/28/BoggleSolver/4.png" alt="4"><br><img src="/2019/09/28/BoggleSolver/5.png" alt="5"></p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>这道题的意思就是 给你一个四乘以四的方块，然后再这个方块里面遍历所有能到的位置，八个方向，每个位置只能走一次，方块上面各有一个字母，走过每一个字母之后构成一个单词，然后看这个单词最后在不在字典中，且能得到多少分？</p><p><img src="https://coursera.cs.princeton.edu/algs4/assignments/boggle/pins.png" alt=""></p><p>最先开始的想法，是用一个bfs，然后将每一个遍历每一个单词，然后再讲每一个单词放入到其中进行判断，这样的话，时间复杂度会特别高，没一个单词都要遍历全部位置，并且 一些单词没有的前缀，<strong>比如，没有Y 开头的单词的话，那么我在从Y这里开始走的话，会浪费特别多的精力。</strong></p><p>所以，看了一下解析，是直接用字典树去存储，然后遍历位置，就相当于遍历字典树一样。</p><p>找时间得重新写一下。自己做的很不对的地方就在于，自己用的bfs，注意的是这个状态并不是循序渐进的变化，而是每一个状态都不一样，如果要用bfs的话，那么每一个状态都要存进去大量的东西重置，所以，这就是不准确的地方。</p><h3 id="贴代码"><a href="#贴代码" class="headerlink" title="贴代码"></a>贴代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.Bag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoggleSolver</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//自己建立的 字典树，这样方便后面dfs查询的时候的剪枝。</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> BoggleBoard board;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> col,row;</span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;String&gt; allwords;</span><br><span class="line">    <span class="keyword">private</span> Bag&lt;Integer&gt;[] adj;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] vis;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; dice;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> Node[] next = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoggleSolver</span><span class="params">(String[] dictionary)</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dictionary.length; i++) &#123;</span><br><span class="line">            put(dictionary[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        root = put(root, word, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里就是直接构造出一个字典树，通过这个字典树来存储所有字符，并且剪枝dfs。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x, String word, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) x = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="keyword">if</span> (d == word.length()) &#123;</span><br><span class="line">            x.val = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> c = word.charAt(d) - <span class="string">'A'</span>;</span><br><span class="line">        x.next[c] = put(x.next[c], word, d + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Node x = get(root, word, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> x.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">get</span><span class="params">(Node x, String word, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (d == word.length()) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">int</span> c = word.charAt(d) - <span class="string">'A'</span>;</span><br><span class="line">        <span class="keyword">return</span> get(x.next[c], word, d + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; row &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; col;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">getAllValidWords</span><span class="params">(BoggleBoard board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.board = board;</span><br><span class="line">        allwords = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        row = board.rows();</span><br><span class="line">        col = board.cols();</span><br><span class="line">        <span class="comment">//这个地方的写法需要注意一下。</span></span><br><span class="line">        adj = (Bag&lt;Integer&gt;[]) <span class="keyword">new</span> Bag[row * col];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = i * col + j;</span><br><span class="line">                adj[v] = <span class="keyword">new</span> Bag&lt;Integer&gt;();</span><br><span class="line">                <span class="comment">//这里就相当于图论里面的建立边，直接给后面dfs提供条件</span></span><br><span class="line">                <span class="keyword">if</span> (check(i - <span class="number">1</span>, j)) adj[v].add((i - <span class="number">1</span>) * col + j);</span><br><span class="line">                <span class="keyword">if</span> (check(i + <span class="number">1</span>, j)) adj[v].add((i + <span class="number">1</span>) * col + j);</span><br><span class="line">                <span class="keyword">if</span> (check(i, j - <span class="number">1</span>)) adj[v].add(i * col + j - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (check(i, j + <span class="number">1</span>)) adj[v].add(i * col + j + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (check(i + <span class="number">1</span>, j - <span class="number">1</span>)) adj[v].add((i + <span class="number">1</span>) * col + j - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (check(i + <span class="number">1</span>, j + <span class="number">1</span>)) adj[v].add((i + <span class="number">1</span>) * col + j + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (check(i - <span class="number">1</span>, j - <span class="number">1</span>)) adj[v].add((i - <span class="number">1</span>) * col + j - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (check(i - <span class="number">1</span>, j + <span class="number">1</span>)) adj[v].add((i - <span class="number">1</span>) * col + j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接下来就到了 dfs搜图的时候</span></span><br><span class="line">        <span class="comment">//最先开始我个人的想法是在这个地方用bfs来进行，当时发现到后面存在很多的问题，比如时间复杂度是特别高的。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row * col; i++) &#123;</span><br><span class="line">            vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[row * col];</span><br><span class="line">            dice = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">            vis[i] = <span class="keyword">true</span>;</span><br><span class="line">            dice.push(i);</span><br><span class="line">            <span class="comment">//这个地方需要留意的是 root在这里并没有其他的含义</span></span><br><span class="line">            <span class="keyword">char</span> c = getLetter(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'Q'</span>) dfs(i, root.next[<span class="string">'Q'</span> - <span class="string">'A'</span>].next[<span class="string">'U'</span> - <span class="string">'A'</span>], <span class="string">"QU"</span>, dice);</span><br><span class="line">            <span class="keyword">else</span> dfs(i, root.next[c - <span class="string">'A'</span>], c + <span class="string">""</span>, dice);</span><br><span class="line">            <span class="comment">//由于这个地方前面就直接重新定义了，所以就不需要采用清空操作了。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allwords;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">char</span> <span class="title">getLetter</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> board.getLetter(v / col , v % col);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, Node x, String prefix, Stack&lt;Integer&gt;dices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prefix.length() &gt; <span class="number">2</span> &amp;&amp; x != <span class="keyword">null</span> &amp;&amp; x.val == <span class="number">1</span>) &#123;</span><br><span class="line">            allwords.add(prefix);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : adj[v]) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = getLetter(w);</span><br><span class="line">            <span class="keyword">if</span> (!vis[w] &amp;&amp; x != <span class="keyword">null</span> &amp;&amp; x.next[c - <span class="string">'A'</span>] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                dice.push(w);</span><br><span class="line">                vis[w] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'Q'</span>) &#123;</span><br><span class="line">                    dfs(w, x.next[<span class="string">'Q'</span> - <span class="string">'A'</span>].next[<span class="string">'U'</span> - <span class="string">'A'</span>], prefix + <span class="string">"QU"</span>, dice);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> dfs(w, x.next[c - <span class="string">'A'</span>], prefix + c, dice);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> d = dice.pop();</span><br><span class="line">                vis[d] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scoreOf</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (get(word) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> len = word.length();</span><br><span class="line">            <span class="keyword">if</span> (len &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">3</span> || len == <span class="number">4</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">5</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">6</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">7</span>) <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这次的作业后面还有后续，后续的地方就是 直接构成一个框架进行写，直接将这个游戏具象化，等自己熟悉了之后，再将代码贴出来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法" scheme="http://wsx1128.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://wsx1128.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="java" scheme="http://wsx1128.cn/tags/java/"/>
    
      <category term="普林斯顿算法大作业" scheme="http://wsx1128.cn/tags/%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%AE%97%E6%B3%95%E5%A4%A7%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>Substring Search --- kmp</title>
    <link href="http://wsx1128.cn/2019/09/20/Substring-Search-kmp/"/>
    <id>http://wsx1128.cn/2019/09/20/Substring-Search-kmp/</id>
    <published>2019-09-20T02:34:17.000Z</published>
    <updated>2019-09-23T03:34:32.758Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Substring-Search"><a href="#Substring-Search" class="headerlink" title="Substring Search"></a>Substring Search</h2><p>这里主要讲的是<strong>kmp算法</strong>。</p><h3 id="java-from-the-course-of-algorithm"><a href="#java-from-the-course-of-algorithm" class="headerlink" title="java from the course of algorithm"></a>java from the course of algorithm</h3><h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><p>在长度为 N 的文本里寻找长度为 M 的模式（子串），典型情况是 N &gt;&gt; M。</p><p><img src="https://images2018.cnblogs.com/blog/886021/201808/886021-20180801230900919-1725939841.png" alt=""></p><p>这里就需要扩展两种做法，暴力与kmp算法了。</p><h4 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h4><p>首先先来看一下暴力查找。</p><p><img src="https://images2018.cnblogs.com/blog/886021/201808/886021-20180801230913345-679738515.png" alt=""></p><p>就暴力地两个循环，查找文本的每个位置，最坏情况下需要近似<strong>MN</strong>次字符比较</p><p><img src="https://images2018.cnblogs.com/blog/886021/201808/886021-20180801230928182-823845050.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String pat, String txt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M = pat.length();</span><br><span class="line">    <span class="keyword">int</span> N = txt.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N - M; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j++)</span><br><span class="line">            <span class="keyword">if</span> (txt.charAt(i + j) != pat.charAt(j))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (j == M) <span class="keyword">return</span> i;    <span class="comment">// index in txt where pattern starts</span></span><br><span class="line">        <span class="keyword">return</span> N;    <span class="comment">// not found</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暴力算法大多数情况下会跑的特别慢，因为建立在纯暴力的做法，会存在很多回退的情况，于是就会跑的很慢。</p><p>所以暴力算法并不是总能满足我们的需求，我们希望有线性时间级别的性能保证，希望避免在文本流中回退。</p><h4 id="Knuth-Morris-Pratt"><a href="#Knuth-Morris-Pratt" class="headerlink" title="Knuth-Morris-Pratt"></a>Knuth-Morris-Pratt</h4><p>KMP算法就可以解决上面所说的问题，不用回退，最多也就访问一次就可以解决问题</p><p>首先先要了解一个名词</p><p><strong>Deterministic Finite State Automaton</strong></p><p>确定型有穷（状态）自动机（DFA），是一个抽象的字符串查找机器。</p><ul><li><p>状态数目是有穷的（包括初始状态和终结状态）。</p></li><li><p>每个状态对每个字符有且仅有一个转移。</p></li><li><p>转移到终结状态则接受这个字符串，即含有我们寻找的子串（模式）。</p></li></ul><p>其中 dfa[i][j] 表示状态 j 遇到字符 i 会转移到下一个状态，并不包括终结状态。</p><p>现在查找子串就很简单啦，一开始在初始状态，文本流读到哪个字符就往哪条路走，要是走到了终结状态，也就表示找到了子串。像我们这样构造的 DFA，走到状态几，就说明已经匹配了多少个字符其实，所以走到终结状态就表示全部匹配。</p><p>就像这样</p><p><img src="https://images2018.cnblogs.com/blog/886021/201808/886021-20180806171432655-228466052.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">seach</span> <span class="params">(String txt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,N = txt.length();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; N &amp;&amp; j &lt; M; i++) </span><br><span class="line">        j = dfa[txt.chaAt(i)][j];</span><br><span class="line">    <span class="keyword">if</span> (j == M) <span class="keyword">return</span> i - M;</span><br><span class="line">    <span class="comment">//这种情况就是没有找到</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的匹配过程特别轻松，重要的就是下面构造dfa这个数组的过程。</p><h4 id="Construct-DFA"><a href="#Construct-DFA" class="headerlink" title="Construct DFA"></a>Construct DFA</h4><ol><li>匹配情况</li></ol><p>匹配的时候转移就特别好办，直接进行到下一个状态就可以了。</p><p><img src="https://images2018.cnblogs.com/blog/886021/201808/886021-20180806171446315-1202770884.png" alt=""></p><ol><li>不匹配的情况</li></ol><p>关键在不匹配时该如何转移。</p><p>假设在状态 j 时读到的下一个字符 c 不等于要找的子串的第 j + 1 个字符（pat.charAt(j)，从 0 标号），那么这个时候，我们从文本流中最近读出的 j - 1 个字符即为 pat[1..j - 1] + c，就是暴力算法要重新扫描的部分。</p><p>当前首字母到状态 j 出现了不匹配，按暴力算法该丢弃它从下一个字母再开始，即 pat[1]，再一路重新扫描到 c。所以，现在状态 j 遇到 c 该怎么转移，实际上和字符串 pat[1.. j - 1] + c 在 DFA 中所到状态碰到 c 的转移目标一样才对。于是我们这么计算 dfa[c][j]：在 DFA 上模拟 pat[1.. j - 1]，然后直接取字符 c 的转移。</p><p>下面举个例子 计算状态5的时候 如何去考虑字符A 和 字符B的转移</p><p><img src="https://images2018.cnblogs.com/blog/886021/201808/886021-20180806171501965-420417384.png" alt=""></p><p>具体可以看下面的代码，因为这里存在一个 restart state 直接用 x来表示，因为这里的状态有的时候可以直接转移初始状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KMP</span> <span class="params">(String pat)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pat = pat;</span><br><span class="line">    M = pat.length();</span><br><span class="line">    dfa = <span class="keyword">new</span> <span class="keyword">int</span> [R][M];</span><br><span class="line">    <span class="comment">//设置初始状态</span></span><br><span class="line">    <span class="comment">//这里的版本就是构造有限类型的自动机，帮助记录状态迁移</span></span><br><span class="line">    dfa[pat.chaAt(<span class="number">0</span>)][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>, j = <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; R; c++)</span><br><span class="line">            dfa[c][j] = dfa[c][x];</span><br><span class="line">        dfa[pat.charAt(j)][j] = j + <span class="number">1</span>;</span><br><span class="line">        x = dfa[pat.charAt(j)][x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这个算法的复杂度 优化之后 也达到了 (o(M) + o(N)) * 字母表</p><p>于是 C++ 版本里面会再次进行优化</p><p>注：  这里还有两张算法<br><strong>Boyer-Moore</strong> 与 <strong>Rabin-Karp</strong></p><p>这个<a href="https://www.cnblogs.com/mingyueanyao/p/9404556.html" target="_blank" rel="noopener">博客</a>中有详细的讲解，就不再重复记录了。</p><h3 id="C-from-some-template-in-acm"><a href="#C-from-some-template-in-acm" class="headerlink" title="C++ from some template in acm"></a>C++ from some template in acm</h3><p>当上面的有限型自动机优化的版本，最后导致的结果就是 每一都得遍历一遍字母表 所以有没有其他办法来进行优化呢</p><p>所以就有了 改进的kmp算法<br>利用 模式串中的 最长前缀与最长后缀的关系来构造next数组</p><p>就像这个样子</p><p><img src="https://img-blog.csdn.net/2018100519473444?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTY5NDMz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>于是这里就先讲解一下 </p><h4 id="构造next数组的过程"><a href="#构造next数组的过程" class="headerlink" title="构造next数组的过程"></a>构造next数组的过程</h4><p>我们规定任何一个串，next[1]=0。(不用next[0]，与串的所有对应)，仍是一张动图搞定问题：</p><p><img src="https://img-blog.csdn.net/20181005223221225?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTY5NDMz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>通过把next值“看”出来，我们再来分析next值，这就很容易得到超级有名的公式了，这个式子对后面的算法理解很重要！所以先要看懂这个式子，如果上面的内容通下来了，这个应该很容易看懂了：</p><p><img src="https://img-blog.csdn.net/20181005224812581?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTY5NDMz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>首先是构造next数组的过程。</p><h4 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lenp = p.size();</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; lenp - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || p[j] == p[i]) &#123;</span><br><span class="line">            next[++i] = ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然 这样写next数组是完全没有问题，但是 如果有一种情况p[next[j]] == p[j] 当出现这样的情况该如何解决呢？直接看图。</p><p>比如，如果用之前的next 数组方法求模式串“abab”的next 数组，可得其next 数组为-1 0 0 1（0 0 1 2整体右移一位，初值赋为-1），当它跟下图中的文本串去匹配的时候，发现b跟c失配，于是模式串右移j - next[j] = 3 - 1 =2位。</p><p><img src="http://hi.csdn.net/attachment/201106/14/8394323_1308075859Zfue.jpg" alt=""></p><p>右移2位后，b又跟c失配。事实上，因为在上一步的匹配中，已经得知p[3] = b，与s[3] = c失配，而右移两位之后，让p[ next[3] ] = p[1] = b 再跟s[3]匹配时，必然失配。问题出在哪呢？</p><p><img src="http://hi.csdn.net/attachment/201106/14/8394323_13080758591kyV.jpg" alt=""></p><p>问题出在不该出现p[j] = p[ next[j] ]。为什么呢？理由是：当p[j] != s[i] 时，下次匹配必然是p[ next [j]] 跟s[i]匹配，如果p[j] = p[ next[j] ]，必然导致后一步匹配失败（因为p[j]已经跟s[i]失配，然后你还用跟p[j]等同的值p[next[j]]去跟s[i]匹配，很显然，必然失配），所以不能允许p[j] = p[ next[j ]]。如果出现了p[j] = p[ next[j] ]咋办呢？如果出现了，则需要再次递归，即令next[j] = next[ next[j] ]。</p><p>所以就需要更改一下 下面的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lenp = p.size();</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; lenp - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || p[j] == p[i]) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//重点就在下面这个地方</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span> (p[i] != p[j]) next[i] = j;</span><br><span class="line">            <span class="comment">//这个地方就放入其继续进入递归。</span></span><br><span class="line">            <span class="keyword">else</span> next[i] = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面就只剩下一开始匹配过程了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span> <span class="params">(<span class="built_in">string</span> s,<span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> slen = s.size();</span><br><span class="line">    <span class="keyword">int</span> plen = p.size();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; slen &amp;&amp; j &lt; plen) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] = p[j]) &#123;</span><br><span class="line">            i ++ ;</span><br><span class="line">            j ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == plen) <span class="keyword">return</span> i - j;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面还有两种拓展类型的算法<br>BM算法 与 sunday算法<br>这两种算法 有时间的情况下再来总结</p><p>这里直接贴出网址<br><a href="https://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="noopener">博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法" scheme="http://wsx1128.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://wsx1128.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="java" scheme="http://wsx1128.cn/tags/java/"/>
    
      <category term="字符串" scheme="http://wsx1128.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="kmp" scheme="http://wsx1128.cn/tags/kmp/"/>
    
  </entry>
  
  <entry>
    <title>Tries --- the course of algorithm</title>
    <link href="http://wsx1128.cn/2019/09/17/Tries-the-course-of-algorithm/"/>
    <id>http://wsx1128.cn/2019/09/17/Tries-the-course-of-algorithm/</id>
    <published>2019-09-17T10:56:00.000Z</published>
    <updated>2019-09-17T11:59:05.235Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="单词查找树-字典树"><a href="#单词查找树-字典树" class="headerlink" title="单词查找树(字典树)"></a>单词查找树(字典树)</h2><p>首先先贴出 要实现的api:</p><p><img src="https://images2018.cnblogs.com/blog/886021/201807/886021-20180729171733111-1117062077.png" alt=""></p><h3 id="R-way-Tries"><a href="#R-way-Tries" class="headerlink" title="R-way Tries"></a>R-way Tries</h3><p>这里实现的要点就是在每一个node类里面加入一个数组去记录每一个字符可能存在的node 意思就是 256个 算上所有ASCII里面的</p><p>这里就不贴出具体函数表示功能的示意图了。</p><h4 id="Tries-Java-implementaion"><a href="#Tries-Java-implementaion" class="headerlink" title="Tries: Java implementaion"></a>Tries: Java implementaion</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TriesST</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> R = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">private</span> Node root = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object value;</span><br><span class="line">        <span class="keyword">private</span> Node[] next = <span class="keyword">new</span> Node[R]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span> <span class="params">(String key, Value val)</span> </span>&#123;</span><br><span class="line">        root = put(root, key, val, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x, String key, Value val, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) x = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="keyword">if</span> (d == key.length()) &#123;</span><br><span class="line">            x.val = val;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> c = key.charAt(d);</span><br><span class="line">        x.next[c] = put(x.next[c], key, val, d + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span> <span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(key) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Node x = get(root, key, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> (Value)x.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">get</span><span class="params">(Node x, String key, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (d == key.length()) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">char</span> c = key.charAt(d);</span><br><span class="line">        <span class="keyword">return</span> get(x.next[c], key, d + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，上面这个算法可以很快匹配到字符串，但是特别郎芬空间，因为其有很多误用的空节点，并且空链接也太多了。</p><h4 id="Tries-deletion"><a href="#Tries-deletion" class="headerlink" title="Tries: deletion"></a>Tries: deletion</h4><p>删除单词查找树中的某个字符串时，首先要找到它，然后把最后一个节点的值置空，再递归删除没有非空链接的空值节点。例子：</p><p><img src="https://images2018.cnblogs.com/blog/886021/201807/886021-20180729171843615-47757674.png" alt=""></p><p>这里没有例子，就直接给出相应的图了。</p><h3 id="Ternary-Search-Tries"><a href="#Ternary-Search-Tries" class="headerlink" title="Ternary Search Tries"></a>Ternary Search Tries</h3><p>这里有点借鉴快排的思想，将每一个节点分成三个链接，大于，小于，等于<br>三向单词查找树，如图：</p><p><img src="https://images2018.cnblogs.com/blog/886021/201807/886021-20180730211441659-95166443.png" alt=""></p><p>这里也不再详细讲解其插入，构造，删除的过程了，类似于前面。</p><h4 id="TST-Java-implementation"><a href="#TST-Java-implementation" class="headerlink" title="TST: Java implementation"></a>TST: Java implementation</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TST</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Value val;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">private</span> Node left, mid, right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Value val)</span> </span>&#123;</span><br><span class="line">        root = put(root, key, val, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x, String key, Value val, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c = key.charAt(d);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x = <span class="keyword">new</span> Node();</span><br><span class="line">            x.c = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c &lt; x.c) x.left = put(x.left, key, val, d);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; x.c) x.right = put(x.right, key, val, d);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (d &lt; key.length() - <span class="number">1</span>) x.mid = put(x.mid, key, val, d + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> x.val = val;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(key) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Node x = get(root, key, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> x.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">get</span><span class="params">(Node x, String key, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">char</span> c = key.charAt(d);</span><br><span class="line">        <span class="keyword">if</span> (c &lt; x.c) <span class="keyword">return</span> get(x.left, key, d);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; x.c) <span class="keyword">return</span> get(x.right, key, d);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (d &lt; key.length() - <span class="number">1</span>) <span class="keyword">return</span> get(x.mid, key, d + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TST的复杂度其实有点时候是和红黑是相当，查找的效率有的时候是跟哈希的符号表也差不多，所以可能通过相应的平衡操作来保持其的性能。</p><p><strong>不过有的时候还可以将其与R-way tries 结合起来</strong></p><p><img src="https://images2018.cnblogs.com/blog/886021/201807/886021-20180731115403647-1725352123.png" alt=""></p><p>上面虽然空间上面会多花一点，但是查找性能会大大提升。</p><h3 id="Character-based-Operations"><a href="#Character-based-Operations" class="headerlink" title="Character-based Operations"></a>Character-based Operations</h3><h4 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h4><p><img src="https://images2018.cnblogs.com/blog/886021/201808/886021-20180801101623633-226094687.png" alt=""></p><p>返回其的所有的存储的字符串 就像中序遍历这棵树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> Queue&lt;String&gt;();</span><br><span class="line">    collect(root, <span class="string">""</span>, queue);</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prefix: sequence of characters on path from root to x</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">(Node x, String prefix, Queue&lt;String&gt; q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//只有在满足了这个条件才会入队。</span></span><br><span class="line">    <span class="keyword">if</span> (x. val != <span class="keyword">null</span>) q.enqueue(prefix);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="number">0</span>; c &lt; R; c++)</span><br><span class="line">        collect(x.next[c], prefix + c, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Prefix"><a href="#Prefix" class="headerlink" title="Prefix"></a>Prefix</h4><p><img src="https://images2018.cnblogs.com/blog/886021/201808/886021-20180801101645088-790496881.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">keyWithPrefix</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> Queue&lt;String&gt;();</span><br><span class="line">    <span class="comment">// x: root of subtrie for all strings</span></span><br><span class="line">    <span class="comment">// beginning with given prefix</span></span><br><span class="line">    Node x = get(root, prefix, <span class="number">0</span>);</span><br><span class="line">    collect(x, prefix, queue);</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Longest-Prefix"><a href="#Longest-Prefix" class="headerlink" title="Longest Prefix"></a>Longest Prefix</h4><p><img src="https://images2018.cnblogs.com/blog/886021/201808/886021-20180801101657607-1814743932.png" alt=""></p><p><img src="https://images2018.cnblogs.com/blog/886021/201808/886021-20180801101711263-980961056.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPrefixOf</span><span class="params">(String query)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = search(root, query, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> query.substring(<span class="number">0</span>, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Node x, String query, <span class="keyword">int</span> d, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> length;</span><br><span class="line">    <span class="keyword">if</span> (x.val != <span class="keyword">null</span>) length = d;</span><br><span class="line">    <span class="keyword">if</span> ( d == query.length()) <span class="keyword">return</span> length;</span><br><span class="line">    <span class="keyword">char</span> c = query.charAt(d);</span><br><span class="line">    <span class="keyword">return</span> search(x.next[c], query, d + <span class="number">1</span>, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面继续提到了 前缀树与后缀树。</p><p>参考该<a href="https://www.cnblogs.com/mingyueanyao/p/9386004.html" target="_blank" rel="noopener">博客</a></p><p><strong>侵删</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法" scheme="http://wsx1128.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://wsx1128.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="java" scheme="http://wsx1128.cn/tags/java/"/>
    
      <category term="字符串" scheme="http://wsx1128.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Radix Sort --- the course of algorithm</title>
    <link href="http://wsx1128.cn/2019/09/17/Radix-Sort-the-course-of-algorithm/"/>
    <id>http://wsx1128.cn/2019/09/17/Radix-Sort-the-course-of-algorithm/</id>
    <published>2019-09-17T07:09:25.000Z</published>
    <updated>2019-09-17T08:09:50.581Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p><a href="https://www.coursera.org/learn/algorithms-part2/supplement/v5gBy/lecture-slides" target="_blank" rel="noopener">课程地址</a></p><h3 id="String-in-java"><a href="#String-in-java" class="headerlink" title="String in java"></a>String in java</h3><h4 id="Char-Data-Type"><a href="#Char-Data-Type" class="headerlink" title="Char Data Type"></a>Char Data Type</h4><p>C 语言中的字符数据类型占一个字节（8 比特），最多只能表示 256 个字符。支持 7 位的标准 ASCII(American Standard Code for Information Interchange，美国标准信息交换编码)，最高位用于奇偶校验。或是拓展的 ASCII，最高位用来确定附加的 128 个特殊的字符。</p><p>而java中的字符数据类型占两个字节，支持16位的Unicode编码。</p><h4 id="String-Data-Type"><a href="#String-Data-Type" class="headerlink" title="String Data Type"></a>String Data Type</h4><p>java String api</p><p><img src="https://images2018.cnblogs.com/blog/886021/201807/886021-20180721162521004-905655523.png" alt="api"></p><p>接下来就是java中两种字符串类型的比较，一种是String，另外一种就是StringBuilder 这两种之间的区别就在于 一个是内部可变，另外一种就是内部不可变。</p><p>然而 还有一种StringBuffer 这种与前面后者的相比就是线程安全与否的区别了。</p><h3 id="Key-indexed-counting"><a href="#Key-indexed-counting" class="headerlink" title="Key-indexed counting"></a>Key-indexed counting</h3><p>因为一般字符串中基于排序的比较 基本上至少都是需要NlgN的比较，然后有一种基数比较的办法诞生，称作<strong>键索引计数比较法</strong></p><p>设想有个数组 a = {d, a, c, f, f, b, d, b, f, b, e, a} 要排序，知道总共有 6 个不同的字母，要先统计它们出现的频数。</p><p>字母 a 的键为 0 （a[i] - ‘a’），出现的次数在 count 数组中的索引为键值加一。</p><p><img src="https://images2018.cnblogs.com/blog/886021/201807/886021-20180721174333877-1881107237.png" alt=""></p><p><strong>java implements</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> R = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> N = a.length;</span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[R + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    count[a[i] - <span class="string">'a'</span> + <span class="number">1</span>]++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历一遍count数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++)</span><br><span class="line">    count[i + <span class="number">1</span>] += count[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在 count 数组中保存的即对应字母在排好序的数组中开始的索引值，像两个 d 应该放在 a[6] 和 a[7]。</span></span><br><span class="line"><span class="keyword">char</span>[] aux = <span class="keyword">new</span> <span class="keyword">char</span>[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    aux[count[a[i] - <span class="string">'a'</span>]++] = a[i];</span><br></pre></td></tr></table></figure><p>辅助数组 aux 借助 count 数组找到了每个 a[i] 的位置。注意 count 数组在这一步中还会改变，每次要加一，下次相同的 a[i] 就会放在下一个位置。所以这个算法也是稳定的（stable），相同元素间的相对顺序不会改变。</p><p><img src="https://images2018.cnblogs.com/blog/886021/201807/886021-20180721174344508-415087789.png" alt=""></p><p>最后把 aux 数组一个个赋值回原数组，即完成了排序。</p><p>键索引计数法排序只需要几个一重循环，不需要比较，只要 R 在 N 的一个常数因子范围内，它就是一个线性时间级别的排序方法。</p><h3 id="LSD-Radix-Sort"><a href="#LSD-Radix-Sort" class="headerlink" title="LSD Radix Sort"></a>LSD Radix Sort</h3><p>低位优先排序，就是将等长的字符串进行排序，必须是等长的字符串进行排序，需要做的是从右向左进行排序</p><p><img src="https://images2018.cnblogs.com/blog/886021/201807/886021-20180723155344760-2032525065.png" alt=""></p><p>这个排序是稳定的，相同键之间的相对顺序是不会改变的，意思就是在i前面的，在i + 1排完字后，依然还是在i前面，如果是相同键的情况下。</p><h4 id="LSD-Java-Implementation"><a href="#LSD-Java-Implementation" class="headerlink" title="LSD: Java Implementation"></a>LSD: Java Implementation</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LSD</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String []a,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        String[] aux = <span class="keyword">new</span> String[N];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从后往前面依次进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = w - <span class="number">1</span>; d &gt;= <span class="number">0</span>; d--) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span> [R + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">                count[a[i].charAt(d) + <span class="number">1</span>] ++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) </span><br><span class="line">                count[r + <span class="number">1</span>] += count[r];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">                aux[count[a[i].charAt(d)]++] = a[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">                a[i] = aux[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于典型的应用,R(基数)远小于N(总数),对定长(W)的字符串排序的时间是MN级别。</strong></p><h3 id="MSD-Radix-Sort"><a href="#MSD-Radix-Sort" class="headerlink" title="MSD Radix Sort"></a>MSD Radix Sort</h3><p>高位排序，有别于低位排序的是，其可以对不等长的字符串进行排序，从左向右进行一位一位的扫描，然后再递归的对子字符串进行基数排序。</p><p>就像这样：<br><img src="https://images2018.cnblogs.com/blog/886021/201807/886021-20180723172529187-913394612.png" alt=""></p><p>因为涉及到递归，所以必须得设置一下递归出口，用一下函数直接设置递归出口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">charAt</span><span class="params">(String s, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d &lt; s.length) <span class="keyword">return</span> s.charAt(d);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MSD-Java-Implementation"><a href="#MSD-Java-Implementation" class="headerlink" title="MSD: Java Implementation"></a>MSD: Java Implementation</h4><p>由于上面多了一个键，所以现在count的数组大小必须是R + 2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a)</span> </span>&#123;</span><br><span class="line">    aux = <span class="keyword">new</span> String[a.length];</span><br><span class="line">    sort(a, aux, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a, String[] aux, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[R + <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++)</span><br><span class="line">        count[charAt(a[i], d) + <span class="number">2</span>]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R + <span class="number">1</span>; r++)</span><br><span class="line">        count[r + <span class="number">1</span>] += count[r];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= h; i++)</span><br><span class="line">        aux[count[charAt(a[i], d) + <span class="number">1</span>]++] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++)</span><br><span class="line">        a[i] = aux[i -lo];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort R subarrays recursively</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++)</span><br><span class="line">        sort(a, aux, lo + count[r], lo + count[r + <span class="number">1</span>] - <span class="number">1</span>, d + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//另外用于辅助的数组aux可以重复使用，但是每一次都需要新的count数组，不仅耗费空间，还需要时间去初始化，所以对于小型的子数组，可以直接使用插入排序直接进行改善</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; lo &amp;&amp; less(a[j], a[j - <span class="number">1</span>], d); j--)</span><br><span class="line">            exch(a, j, j -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(String v, String w, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.substring(d).compareTo(w.substring(d)) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MSD算法的性能取决于要输入的数据，最坏的情况下需要检查的所有的字符，和LSD一样都是线性的时间级别。<br><img src="https://images2018.cnblogs.com/blog/886021/201807/886021-20180723204033182-1142104535.png" alt=""></p><h3 id="3-way-Radix-Quicksort"><a href="#3-way-Radix-Quicksort" class="headerlink" title="3-way Radix Quicksort"></a>3-way Radix Quicksort</h3><p>三相切分的思想其实很简单，基于MSD的思想，加入了快排，将第一个字符串的首字母，进行切分，分成大于，小于，等于该字母的组合，然后再分别进入到子字符串中进行递归使用。</p><p><img src="https://images2018.cnblogs.com/blog/886021/201807/886021-20180724163107802-1133643500.png" alt=""></p><h4 id="3-way-String-Quicksort-Java-Implementation"><a href="#3-way-String-Quicksort-Java-Implementation" class="headerlink" title="3-way String Quicksort: Java Implementation"></a>3-way String Quicksort: Java Implementation</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a)</span> </span>&#123;</span><br><span class="line">    sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String []a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> lt = lo, gt = hi;</span><br><span class="line">    <span class="keyword">int</span> v = charAt(a[lo], d);</span><br><span class="line">    <span class="keyword">int</span> i = lo + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = charAt(a[i], d);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; v) exch(a, lt++, i++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; v) exch(a,i,gt--);</span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是再次比较前面的数组进行三相切分。</span></span><br><span class="line">    sort(a, lo, lt - <span class="number">1</span>, d);</span><br><span class="line">    <span class="comment">//这里的意思第一个字母是相同的，所以可以开始递归第二个字母了</span></span><br><span class="line">    <span class="keyword">if</span> (v &gt;= <span class="number">0</span>) sort(a, lt, gt, d + <span class="number">1</span>); </span><br><span class="line">    sort(a, gt + <span class="number">1</span>, hi, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Suffix-Arrays"><a href="#Suffix-Arrays" class="headerlink" title="Suffix Arrays"></a>Suffix Arrays</h3><p>字符串后缀数组 有很多应用，比如关键词查找，最长重复子字符等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[] suffixes(String s) &#123;</span><br><span class="line">    <span class="keyword">int</span> N = s.length();</span><br><span class="line">    String[] suffixes = <span class="keyword">new</span> String[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        suffixes[i] = s.substring(i, N);</span><br><span class="line">    <span class="keyword">return</span> suffixes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于后缀数组进行排序，就可以把相同的字符串给安排到一起了，这样的话查找关键词也就快了很多。</p><p><img src="https://images2018.cnblogs.com/blog/886021/201807/886021-20180727212115060-421776584.png" alt=""></p><p>就像这样，最长重复子字符串也差不多<br><img src="https://images2018.cnblogs.com/blog/886021/201807/886021-20180727212127781-214870736.png" alt=""></p><h4 id="LRS-Java-Implementation"><a href="#LRS-Java-Implementation" class="headerlink" title="LRS: Java Implementation"></a>LRS: Java Implementation</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">lrs</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = s.length();</span><br><span class="line"></span><br><span class="line">    String[] suffixes = <span class="keyword">new</span> String[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        suffixes[i] =s.substring(i, N);</span><br><span class="line"></span><br><span class="line">    Arrays.sort(suffixes);</span><br><span class="line"></span><br><span class="line">    String lrs = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// compute longest common prefix</span></span><br><span class="line">        <span class="comment">// between adjacent suffixes insorted order</span></span><br><span class="line">        <span class="keyword">int</span> len = lcp(suffixes[i], suffixes[i + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (len &gt; lrs.length())</span><br><span class="line">           lrs = suffixes[i].substring(<span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lrs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过最坏的情况,应该会达到 n$^{2}$。<br>因为输入字符串重复时，需要很多次比较才能完成排序，所以这里介绍了另外一种算法 Manber-Myer MSD 算法</p><p>有兴趣的话 可以自己去查一查 这里就不在多说了。</p><p>本篇文章借鉴该<a href="https://www.cnblogs.com/mingyueanyao/p/9347094.html" target="_blank" rel="noopener">博客</a></p><p>若侵删。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法" scheme="http://wsx1128.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://wsx1128.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="java" scheme="http://wsx1128.cn/tags/java/"/>
    
      <category term="字符串" scheme="http://wsx1128.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>BaseballElimination</title>
    <link href="http://wsx1128.cn/2019/09/14/BaseballElimination/"/>
    <id>http://wsx1128.cn/2019/09/14/BaseballElimination/</id>
    <published>2019-09-14T10:44:03.000Z</published>
    <updated>2019-09-14T18:06:04.197Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://coursera.cs.princeton.edu/algs4/assignments/baseball/specification.php" target="_blank" rel="noopener">题目链接</a></h3><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="/2019/09/14/BaseballElimination/1.png" alt="1"><br><img src="/2019/09/14/BaseballElimination/2.png" alt="2"><br><img src="/2019/09/14/BaseballElimination/3.png" alt="3"><br><img src="/2019/09/14/BaseballElimination/4.png" alt="4"><br><img src="/2019/09/14/BaseballElimination/5.png" alt="5"></p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><h4 id="题目意思"><a href="#题目意思" class="headerlink" title="题目意思"></a>题目意思</h4><p>给你n支队伍，然后每一个队伍有三个参数，赢得比赛，输的比赛，以及还有多少场比赛没打，然后再给一个所有剩余比赛的示意图，来表示剩余比赛谁与谁去打。获胜条件是 只有一支队伍胜利，其余的全部直接被淘汰。</p><p>现在需要做的是评估其中的一支队伍是否被淘汰。</p><p><strong>淘汰方式有两种</strong></p><ul><li><p>第一种，评估队伍的最大获胜数，（算上其还没有打的比赛全部赢），还是没有某些队伍已经获取的胜利比赛数多，那么则可以说这个队伍已经被淘汰了。</p></li><li><p>第二种，需要建立一个最大流的图，然后通过最大流的图，来判断是否已经在数学上被淘汰了。</p></li></ul><h4 id="最大流的建立方法"><a href="#最大流的建立方法" class="headerlink" title="最大流的建立方法"></a>最大流的建立方法</h4><p>这里一共需要建立 2 + n - 1 + $C_{2}^{n - 1}\textrm{}$ 个节，分别是源点与汇点，加上队伍节点与比赛节点，就像下面这一张图</p><p><img src="https://coursera.cs.princeton.edu/algs4/assignments/baseball/baseball.png" alt=""></p><pre><code>如上图所示，评判方式，如果从S点出发的边里流量都等于容量的话，那么 此时的flow 一定等同于 最大流，说明其他队伍用了九牛二虎之力所做到的最好的结果也就是与评估队伍打成平手。而如果flow大于最大流，则说明，有一些从s出发的边并没有达到容量，再还有比赛没有打完的时候，就已经有队伍分数跟评估队伍的分数一样了，则说明评估队伍已经被淘汰了。</code></pre><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Programming_Assignment_8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.FlowEdge;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.FlowNetwork;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.FordFulkerson;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.In;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseballElimination</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flows;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] win;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] lose;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] left;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] remain;</span><br><span class="line">    <span class="keyword">private</span> String[] teams;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> teamnum;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer,Integer&gt;pos;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, Integer&gt; map;</span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;String&gt; set;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> allv;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gameTeams;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseballElimination</span><span class="params">(String filename)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (filename == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Wrong file name..."</span>);</span><br><span class="line">        In in = <span class="keyword">new</span> In(filename);</span><br><span class="line">        teamnum = Integer.parseInt(in.readLine());</span><br><span class="line">        teams = <span class="keyword">new</span> String[teamnum];</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">        win = <span class="keyword">new</span> <span class="keyword">int</span>[teamnum];</span><br><span class="line">        lose = <span class="keyword">new</span> <span class="keyword">int</span> [teamnum];</span><br><span class="line">        left = <span class="keyword">new</span> <span class="keyword">int</span>[teamnum];</span><br><span class="line">        remain = <span class="keyword">new</span> <span class="keyword">int</span>[teamnum][teamnum];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (in.hasNextLine()) &#123;</span><br><span class="line">            String readline = in.readLine().trim();</span><br><span class="line">            String []token = readline.split(<span class="string">" +"</span>);</span><br><span class="line">            map.put(token[<span class="number">0</span>], tot);</span><br><span class="line"></span><br><span class="line">            teams[tot] = token[<span class="number">0</span>];</span><br><span class="line">            win[tot] = Integer.parseInt(token[<span class="number">1</span>]);</span><br><span class="line">            lose[tot] = Integer.parseInt(token[<span class="number">2</span>]);</span><br><span class="line">            left[tot] = Integer.parseInt(token[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; teamnum; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == tot) remain[tot][i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> remain[tot][i] = Integer.parseInt(token[<span class="number">4</span> + i]);</span><br><span class="line">            &#125;</span><br><span class="line">            tot++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfTeams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> teamnum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">teams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.keySet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wins</span><span class="params">(String team)</span> </span>&#123;</span><br><span class="line">        valid(team);</span><br><span class="line">        Integer id = map.get(team);</span><br><span class="line">        <span class="keyword">return</span> win[id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">losses</span><span class="params">(String team)</span> </span>&#123;</span><br><span class="line">        valid(team);</span><br><span class="line">        Integer id = map.get(team);</span><br><span class="line">        <span class="keyword">return</span> lose[id];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remaining</span><span class="params">(String team)</span> </span>&#123;</span><br><span class="line">        valid(team);</span><br><span class="line">        Integer id = map.get(team);</span><br><span class="line">        <span class="keyword">return</span> left[id];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">against</span><span class="params">(String team1, String team2)</span> </span>&#123;</span><br><span class="line">        valid(team1);</span><br><span class="line">        valid(team2);</span><br><span class="line">        Integer id1 = map.get(team1);</span><br><span class="line">        Integer id2 = map.get(team2);</span><br><span class="line">        <span class="keyword">return</span> remain[id1][id2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> FlowNetwork <span class="title">buildFlowNetwrok</span><span class="params">(String team)</span> </span>&#123;</span><br><span class="line">        valid(team);</span><br><span class="line">        Integer id = map.get(team);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> most = win[id] + left[id];</span><br><span class="line"></span><br><span class="line">        gameTeams = (teamnum - <span class="number">1</span>) * (teamnum - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        allv = gameTeams + teamnum - <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">        flows = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        pos = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, t = allv - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> gameIndex = <span class="number">1</span>; <span class="comment">//比赛结点</span></span><br><span class="line">        <span class="keyword">int</span> indexi = gameTeams;<span class="comment">// 球队节点</span></span><br><span class="line">        <span class="keyword">int</span> indexj = indexi;</span><br><span class="line">        <span class="keyword">double</span> max = Double.POSITIVE_INFINITY;</span><br><span class="line"></span><br><span class="line">        FlowNetwork flowNetwork = <span class="keyword">new</span> FlowNetwork(allv);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; teamnum; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id == i) <span class="keyword">continue</span>;</span><br><span class="line">            indexi++;</span><br><span class="line">            indexj = indexi;</span><br><span class="line">            <span class="keyword">if</span>(win[i] &gt; most) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; teamnum; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == id) <span class="keyword">continue</span>;</span><br><span class="line">                indexj++;</span><br><span class="line">                flows += remain[i][j];</span><br><span class="line">                flowNetwork.addEdge(<span class="keyword">new</span> FlowEdge(s,gameIndex,remain[i][j]));</span><br><span class="line">                flowNetwork.addEdge(<span class="keyword">new</span> FlowEdge(gameIndex,indexi,max));</span><br><span class="line">                flowNetwork.addEdge(<span class="keyword">new</span> FlowEdge(gameIndex,indexj,max));</span><br><span class="line">                gameIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            pos.put(indexi,i);</span><br><span class="line"></span><br><span class="line">            flowNetwork.addEdge(<span class="keyword">new</span> FlowEdge(indexi,t,most - win[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flowNetwork;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">valid</span><span class="params">(String team)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (team == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Wrong teams"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(team)) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Not in the team"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEliminated</span><span class="params">(String team)</span> </span>&#123;</span><br><span class="line">       valid(team);</span><br><span class="line">       FlowNetwork flowNetwork = buildFlowNetwrok(team);</span><br><span class="line">       <span class="keyword">int</span> id = map.get(team);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (flowNetwork == <span class="keyword">null</span>) &#123;</span><br><span class="line">           set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; teamnum; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (id == i) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (win[id] + left[id] &lt; win[i]) &#123;</span><br><span class="line">                    set.add(teams[i]);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       FordFulkerson fordFulkerson = <span class="keyword">new</span> FordFulkerson(flowNetwork,<span class="number">0</span>,allv - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (flows &gt; fordFulkerson.value()) &#123;</span><br><span class="line">           set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = gameTeams + <span class="number">1</span>; i &lt; allv - <span class="number">1</span> ;i++) &#123;</span><br><span class="line">               <span class="comment">//其实这个地方是一直弄不清楚这个函数，主要是弄不清 为什么这个点在最小割上面 就可以证明出 来自s点的边 流量不等于容量</span></span><br><span class="line">               <span class="comment">//查阅了相关资料，最后发现，其实 这里incut 就相当于割边直接将整张图一分为2，这里是靠近源点s的</span></span><br><span class="line">               <span class="comment">//换言之，就是在跑完最后一遍寻找增广路的时候，是否会有在其剩余的路径上，意思就是 当我查看队伍的点的时候，只要没有剩余的流量，就一定不会遍历到这个点上</span></span><br><span class="line">               <span class="keyword">if</span> (fordFulkerson.inCut(i)) &#123;</span><br><span class="line">                   <span class="keyword">int</span> Id = pos.get(i);</span><br><span class="line">                   set.add(teams[Id]);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">certificateOfElimination</span><span class="params">(String team)</span>  </span>&#123;</span><br><span class="line">        valid(team);</span><br><span class="line">        <span class="keyword">if</span> (isEliminated(team)) <span class="keyword">return</span> set;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意上面所说的位置，incut 这里就是标记是否有位置还有剩余，当最后一次在找增广路的时候，那么这些位置就是没有满的位置</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>觉得这次大作业做的特别诡异，主要是题目好了好久时间才理解其真正的意思，还有可能是对于最大流的概念理解的还是不够透彻，这就是我个人的问题，接下来所需要做的就是 下一次的大作业，以及好好理解一下 最大流 最小割定理之间的变化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法" scheme="http://wsx1128.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://wsx1128.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="java" scheme="http://wsx1128.cn/tags/java/"/>
    
      <category term="普林斯顿算法课" scheme="http://wsx1128.cn/tags/%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%AE%97%E6%B3%95%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>SeamCarver</title>
    <link href="http://wsx1128.cn/2019/09/10/SeamCarver/"/>
    <id>http://wsx1128.cn/2019/09/10/SeamCarver/</id>
    <published>2019-09-10T13:20:06.000Z</published>
    <updated>2019-09-10T13:41:41.157Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://coursera.cs.princeton.edu/algs4/assignments/seam/specification.php" target="_blank" rel="noopener">题目链接</a></p><p><strong>题目详图</strong><br><img src="/2019/09/10/SeamCarver/1.png" alt="1"><br><img src="/2019/09/10/SeamCarver/2.png" alt="2"><br><img src="/2019/09/10/SeamCarver/3.png" alt="3"><br><img src="/2019/09/10/SeamCarver/4.png" alt="4"><br><img src="/2019/09/10/SeamCarver/5.png" alt="5"><br><img src="/2019/09/10/SeamCarver/6.png" alt="6"></p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>这道题是我这几次做这个java大作业里面，还特别有意思的一次作业，主要是这次介绍的这个算法特别流弊，感觉特别常见，就是发现于2007年的算法，并且应用于 Photoshop内核的算法，用于图片的拉伸与缩放。</p><p>先开始是作为最短路里面的算法出现，感觉特别的懵逼，因为完全不知道该怎么下手，不过后面就好很多了，意思就是使用一个特定的公式，将每一个像素点与周围8个方向的点的差异相联系，作为整个像素点的权值，然后从不同于拉伸的方向，从顶部到底部找一条像素点权值最小的路线，然后将这条路线进行删除，最后便得到结果。</p><p>然后找最短路的办法，这里使用的就是 对每一个点，至上而下的松弛，最终得到结果，这次作业只是看着有点吓人，但是其实还是特别简单的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.Picture;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeamCarver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里图像会发生改变，所以这里不能直接写定义成不变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][] picture;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> [][] energy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a seam carver object based on the given picture</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeamCarver</span><span class="params">(Picture picture)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (picture == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.height = picture.height();</span><br><span class="line">        <span class="keyword">this</span>.width = picture.width();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.picture = <span class="keyword">new</span> <span class="keyword">int</span> [width][height];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.width; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.height; j++) &#123;</span><br><span class="line">                <span class="keyword">this</span>.picture[i][j] = picture.getRGB(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        renewenergy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateindex</span><span class="params">(<span class="keyword">int</span> col, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= height || col &lt; <span class="number">0</span> || col &gt;= width) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Wrong index"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">renewenergy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        energy = <span class="keyword">new</span> <span class="keyword">double</span>[width][height];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; width; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; height; j++) &#123;</span><br><span class="line">                calculatenergy(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calculatenergy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        validateindex(x, y);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span> || y == <span class="number">0</span> || x == width - <span class="number">1</span> || y == height - <span class="number">1</span>) &#123;</span><br><span class="line">            energy[x][y] = <span class="number">1000.0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rgbUp = picture[x][y - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> rgbDown = picture[x][y + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> rgbLeft = picture[x - <span class="number">1</span>][y];</span><br><span class="line">        <span class="keyword">int</span> rgbRight = picture[x + <span class="number">1</span>][y];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> rx = Math.pow(((rgbLeft &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>) - ((rgbRight &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>), <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">double</span> gx = Math.pow(((rgbLeft &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>) - ((rgbRight &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>), <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">double</span> bx = Math.pow(((rgbLeft &gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xFF</span>) - ((rgbRight &gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xFF</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> ry = Math.pow(((rgbUp &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>) - ((rgbDown &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>), <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">double</span> gy = Math.pow(((rgbUp &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>) - ((rgbDown &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>), <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">double</span> by = Math.pow(((rgbUp &gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xFF</span>) - ((rgbDown &gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xFF</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        energy[x][y] =  Math.sqrt(rx + gx + bx + ry + gy + by);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Picture <span class="title">picture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Picture tmp = <span class="keyword">new</span> Picture(width, height);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; width; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; height; j++) &#123;</span><br><span class="line">                tmp.setRGB(i, j, picture[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">width</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">energy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        validateindex(x, y);</span><br><span class="line">        <span class="keyword">return</span> energy[x][y];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = height;</span><br><span class="line">        height = width;</span><br><span class="line">        width = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> [][] en = <span class="keyword">new</span> <span class="keyword">double</span>[width][height];</span><br><span class="line">        <span class="keyword">int</span> [][] p = <span class="keyword">new</span> <span class="keyword">int</span>[width][height];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; width; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; height; j++) &#123;</span><br><span class="line">                en[i][j] = energy[j][i];</span><br><span class="line">                p[i][j] = picture[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        energy = en;</span><br><span class="line">        picture = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findHorizontalSeam() &#123;</span><br><span class="line">        transform();</span><br><span class="line">        <span class="keyword">int</span> [] res = findVerticalSeam();</span><br><span class="line">        transform();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relaxVertical</span><span class="params">(<span class="keyword">double</span>[][] disTo, <span class="keyword">int</span>[][]edgeTo, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        validateindex(x, y);</span><br><span class="line">        <span class="keyword">if</span> (disTo[x][y + <span class="number">1</span>] &gt; disTo[x][y] + energy[x][y + <span class="number">1</span>]) &#123;</span><br><span class="line">            disTo[x][y + <span class="number">1</span>] = disTo[x][y] + energy[x][y + <span class="number">1</span>];</span><br><span class="line">            edgeTo[x][y + <span class="number">1</span>] = x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; disTo[x - <span class="number">1</span>][y + <span class="number">1</span>] &gt; disTo[x][y] + energy[x - <span class="number">1</span>][y + <span class="number">1</span>]) &#123;</span><br><span class="line">            disTo[x - <span class="number">1</span>][y + <span class="number">1</span>] = disTo[x][y] + energy[x - <span class="number">1</span>][y + <span class="number">1</span>];</span><br><span class="line">            edgeTo[x - <span class="number">1</span>][y + <span class="number">1</span>] = x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &lt; width - <span class="number">1</span> &amp;&amp; disTo[x + <span class="number">1</span>][y + <span class="number">1</span>] &gt; disTo[x][y] + energy[x + <span class="number">1</span>][y + <span class="number">1</span>]) &#123;</span><br><span class="line">            disTo[x + <span class="number">1</span>][y + <span class="number">1</span>] = disTo[x][y] + energy[x + <span class="number">1</span>][y + <span class="number">1</span>];</span><br><span class="line">            edgeTo[x + <span class="number">1</span>][y + <span class="number">1</span>] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findVerticalSeam() &#123;</span><br><span class="line">        <span class="keyword">int</span> [] seam = <span class="keyword">new</span> <span class="keyword">int</span>[height];</span><br><span class="line">        <span class="keyword">double</span> [][] disTo = <span class="keyword">new</span> <span class="keyword">double</span> [width][height];</span><br><span class="line">        <span class="keyword">int</span> [][] edgeTo = <span class="keyword">new</span> <span class="keyword">int</span> [width][height];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; width; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; height; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) disTo[i][j] = energy[i][j];</span><br><span class="line">                <span class="keyword">else</span> disTo[i][j] = Double.POSITIVE_INFINITY;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里的顺序错了，因为 这里比较特殊的是矩阵的存法，所以必须将循环翻过来进行存取</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; height - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; width; i++) &#123;</span><br><span class="line">                relaxVertical(disTo, edgeTo, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> min = Double.POSITIVE_INFINITY;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; width; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; disTo[i][height - <span class="number">1</span>]) &#123;</span><br><span class="line">                min = disTo[i][height - <span class="number">1</span>];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        seam[height - <span class="number">1</span>] = index;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = height - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            index = edgeTo[index][i + <span class="number">1</span>];</span><br><span class="line">            seam[i] = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> seam;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove horizontal seam from current picture</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeHorizontalSeam</span><span class="params">(<span class="keyword">int</span>[] seam)</span> </span>&#123;</span><br><span class="line">        transform();</span><br><span class="line">        removeVerticalSeam(seam);</span><br><span class="line">        transform();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] seam)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (width &lt;= <span class="number">1</span> || seam == <span class="keyword">null</span> || seam.length != height) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seam[i] &lt; <span class="number">0</span> || seam[i] &gt; width - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; Math.abs(seam[i - <span class="number">1</span>] - seam[i]) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove vertical seam from current picture</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeVerticalSeam</span><span class="params">(<span class="keyword">int</span>[] seam)</span> </span>&#123;</span><br><span class="line">        check(seam);</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seam[i] &gt; max) max = seam[i];</span><br><span class="line">            <span class="keyword">if</span> (seam[i] &lt; min) min = seam[i];</span><br><span class="line">            <span class="comment">//这个地方可以直接该位置上将每一个位置的元素进行变化</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = seam[i]; j &lt; width - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                picture[j][i] = picture[j + <span class="number">1</span>][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        width = width - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (min &gt; <span class="number">0</span>) min--;</span><br><span class="line">        <span class="keyword">if</span> (max &gt; width - <span class="number">1</span>) max = width - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; height; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class="line">                calculatenergy(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = max + <span class="number">1</span>; i &lt; width - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                energy[i][j] = energy[i + <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这里需要自己重温一下 上一周的作业 就是图的api这些部分，有的只是会用c++跑，用Java总是感觉有点力不从心，希望后面尽快熟悉起来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法" scheme="http://wsx1128.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://wsx1128.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="java" scheme="http://wsx1128.cn/tags/java/"/>
    
      <category term="普林斯顿算法大作业" scheme="http://wsx1128.cn/tags/%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%AE%97%E6%B3%95%E5%A4%A7%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>WordNet</title>
    <link href="http://wsx1128.cn/2019/09/10/WordNet/"/>
    <id>http://wsx1128.cn/2019/09/10/WordNet/</id>
    <published>2019-09-10T13:19:31.000Z</published>
    <updated>2019-09-14T17:56:55.055Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://coursera.cs.princeton.edu/algs4/assignments/wordnet/specification.php" target="_blank" rel="noopener">题目链接</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="/2019/09/10/WordNet/1.png" alt="题目图"><br><img src="/2019/09/10/WordNet/2.png" alt="题目图"><br><img src="/2019/09/10/WordNet/3.png" alt="题目图"><br><img src="/2019/09/10/WordNet/4.png" alt="题目图"><br><img src="/2019/09/10/WordNet/5.png" alt="题目图"><br><img src="/2019/09/10/WordNet/6.png" alt="题目图"><br><img src="/2019/09/10/WordNet/7.png" alt="题目图"><br><img src="/2019/09/10/WordNet/8.png" alt="题目图"></p><p>我个人觉得这一次大作业得重新做一遍，因为对于这次的大作业有一些地方，总还是弄不清楚，最关键的就是这次的图里面有一些api需要花时间去弄清楚</p><p>所以这里就不贴讲解了，时间过去太久了，反而自己也搞忘了，所以这里直接贴出代码</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>SAP.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Programming_Assignment_6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.Digraph;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SAP</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ancestor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Digraph copyG;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] distTo1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] distTo2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Stack&lt;Integer&gt; stack1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Stack&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor takes a digraph (not necessarily a DAG)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SAP</span><span class="params">(Digraph G)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (G == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument to G"</span>);</span><br><span class="line">        copyG = <span class="keyword">new</span> Digraph(G);</span><br><span class="line">        distTo1 = <span class="keyword">new</span> <span class="keyword">int</span> [G.V()];</span><br><span class="line">        distTo2 = <span class="keyword">new</span> <span class="keyword">int</span> [G.V()];</span><br><span class="line">        marked1 = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        marked2 = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkVertex</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = marked1.length;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= v) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkVertices</span><span class="params">(Iterable&lt;Integer&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">int</span> v = marked1.length;</span><br><span class="line">        <span class="keyword">for</span> (Integer vv :x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vv == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">            <span class="keyword">if</span> (vv &lt; <span class="number">0</span> || vv &gt;= v) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = stack1.pop();</span><br><span class="line">            marked1[v] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = stack2.pop();</span><br><span class="line">            marked2[v] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// length of shortest ancestral path between v and w; -1 if no such path</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        checkVertex(v);</span><br><span class="line">        checkVertex(w);</span><br><span class="line">        compute(v, w);</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        length = -<span class="number">1</span>;</span><br><span class="line">        ancestor = -<span class="number">1</span>;</span><br><span class="line">        distTo1[v] = <span class="number">0</span>;</span><br><span class="line">        distTo2[w] = <span class="number">0</span>;</span><br><span class="line">        marked1[v] = <span class="keyword">true</span>;</span><br><span class="line">        marked2[w] = <span class="keyword">true</span>;</span><br><span class="line">        stack1.push(v);</span><br><span class="line">        stack2.push(w);</span><br><span class="line">        Queue&lt;Integer&gt; q1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; q2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q1.add(v);</span><br><span class="line">        q2.add(w);</span><br><span class="line">        bfs(q1, q2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">(Iterable&lt;Integer&gt; v, Iterable&lt;Integer&gt; w)</span> </span>&#123;</span><br><span class="line">        length = -<span class="number">1</span>;</span><br><span class="line">        ancestor = -<span class="number">1</span>;</span><br><span class="line">        Queue&lt;Integer&gt; q1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; q2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x :v) &#123;</span><br><span class="line">            marked1[x] = <span class="keyword">true</span>;</span><br><span class="line">            stack1.push(x);</span><br><span class="line">            distTo1[x] = <span class="number">0</span>;</span><br><span class="line">            q1.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: w) &#123;</span><br><span class="line">            marked2[x] = <span class="keyword">true</span>;</span><br><span class="line">            stack2.push(x);</span><br><span class="line">            distTo2[x] = <span class="number">0</span>;</span><br><span class="line">            q2.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        bfs(q1, q2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Queue&lt;Integer&gt; q1, Queue&lt;Integer&gt; q2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!q1.isEmpty() || !q2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!q1.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = q1.remove();</span><br><span class="line">                <span class="keyword">if</span> (marked2[v]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (distTo1[v] + distTo2[v] &lt; length || length == -<span class="number">1</span>) &#123;</span><br><span class="line">                        ancestor = v;</span><br><span class="line">                        length = distTo1[v] + distTo2[v];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (distTo1[v] &lt; length || length == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> w: copyG.adj(v)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!marked1[w]) &#123;</span><br><span class="line">                            distTo1[w] = distTo1[v] + <span class="number">1</span>;</span><br><span class="line">                            marked1[w] = <span class="keyword">true</span>;</span><br><span class="line">                            stack1.push(w);</span><br><span class="line">                            q1.add(w);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!q2.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = q2.remove();</span><br><span class="line">                <span class="keyword">if</span> (marked1[v]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (distTo1[v] + distTo2[v] &lt; length || length == -<span class="number">1</span>) &#123;</span><br><span class="line">                        ancestor = v;</span><br><span class="line">                        length = distTo1[v] + distTo2[v];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (distTo2[v] &lt; length || length == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> w:copyG.adj(v)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!marked2[w]) &#123;</span><br><span class="line">                            distTo2[w] = distTo2[v] + <span class="number">1</span>;</span><br><span class="line">                            marked2[w] = <span class="keyword">true</span>;</span><br><span class="line">                            stack2.push(w);</span><br><span class="line">                            q2.add(w);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a common ancestor of v and w that participates in a shortest ancestral path; -1 if no such path</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ancestor</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        checkVertex(v);</span><br><span class="line">        checkVertex(w);</span><br><span class="line">        compute(v, w);</span><br><span class="line">        <span class="keyword">return</span> ancestor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// length of shortest ancestral path between any vertex in v and any vertex in w; -1 if no such path</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">(Iterable&lt;Integer&gt; v, Iterable&lt;Integer&gt; w)</span> </span>&#123;</span><br><span class="line">        checkVertices(v);</span><br><span class="line">        checkVertices(w);</span><br><span class="line">        compute(v, w);</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a common ancestor that participates in shortest ancestral path; -1 if no such path</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ancestor</span><span class="params">(Iterable&lt;Integer&gt; v, Iterable&lt;Integer&gt; w)</span> </span>&#123;</span><br><span class="line">        checkVertices(v);</span><br><span class="line">        checkVertices(w);</span><br><span class="line">        compute(v, w);</span><br><span class="line">        <span class="keyword">return</span> ancestor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Wordnet.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> Programming_Assignment_6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.Digraph;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.In;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.Topological;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordNet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, TreeSet&lt;Integer&gt; &gt; synSets;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, String&gt; ssynsets;</span><br><span class="line">    <span class="keyword">private</span> Digraph hyperNyms;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> idSum;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> outSum;</span><br><span class="line">    <span class="keyword">private</span> SAP sap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor takes the name of the two input files</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordNet</span><span class="params">(String synsets, String hypernyms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (synsets == <span class="keyword">null</span> || hypernyms == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"arguments to WordNet() is null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        readsynset(synsets);</span><br><span class="line">        readhypernyms(hypernyms);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readsynset</span><span class="params">(String synsets)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        synSets = <span class="keyword">new</span> TreeMap&lt;String, TreeSet&lt;Integer&gt; &gt;();</span><br><span class="line">        <span class="keyword">this</span>.ssynsets = <span class="keyword">new</span> TreeMap&lt;Integer, String&gt;();</span><br><span class="line">        In synset = <span class="keyword">new</span> In(synsets);</span><br><span class="line">        idSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (synset.hasNextLine()) &#123;</span><br><span class="line"></span><br><span class="line">            idSum++;</span><br><span class="line">            String str = synset.readLine();</span><br><span class="line">            String[] field = str.split(<span class="string">","</span>);</span><br><span class="line">            <span class="keyword">int</span> id = Integer.parseInt(field[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">this</span>.ssynsets.put(id, field[<span class="number">1</span>]);</span><br><span class="line">            String[] nons = field[<span class="number">1</span>].split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">for</span> (String tmp : nons) &#123;</span><br><span class="line">                <span class="keyword">if</span> (synSets.containsKey(tmp)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (synSets.containsKey(tmp)) &#123;</span><br><span class="line">                        synSets.get(tmp).add(id);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    TreeSet&lt;Integer&gt; ids = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">                    ids.add(id);</span><br><span class="line">                    synSets.put(tmp, ids);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readhypernyms</span><span class="params">(String hypernyms)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        hyperNyms = <span class="keyword">new</span> Digraph(idSum);</span><br><span class="line">        In hypernym = <span class="keyword">new</span> In(hypernyms);</span><br><span class="line">        <span class="keyword">boolean</span>[] outToal = <span class="keyword">new</span> <span class="keyword">boolean</span>[idSum];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (hypernym.hasNextLine()) &#123;</span><br><span class="line">            String str = hypernym.readLine();</span><br><span class="line">            String[] field = str.split(<span class="string">","</span>);</span><br><span class="line">            <span class="keyword">int</span> v = Integer.parseInt(field[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; field.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = Integer.parseInt(field[i]);</span><br><span class="line">                hyperNyms.addEdge(v, w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!outToal[v] &amp;&amp; field.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                outSum++;</span><br><span class="line">            &#125;</span><br><span class="line">            outToal[v] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        isRootRAG();</span><br><span class="line">        sap = <span class="keyword">new</span> SAP(hyperNyms);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">isRootRAG</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idSum - outSum != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"more than one root"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Topological TO = <span class="keyword">new</span> Topological(hyperNyms);</span><br><span class="line">        <span class="keyword">if</span> (!TO.hasOrder()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"is not a Root RAG"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// returns all WordNet nouns</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">nouns</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> synSets.keySet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is the word a WordNet noun?</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNoun</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"word is null"</span>);</span><br><span class="line">        <span class="keyword">return</span> synSets.containsKey(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distance</span><span class="params">(String nounA, String nounB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nounA == <span class="keyword">null</span> || nounB == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"nounA or nounB is null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isNoun(nounA) || !isNoun(nounB)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"the two noun is not exist"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeSet&lt;Integer&gt; setA = synSets.get(nounA);</span><br><span class="line">        TreeSet&lt;Integer&gt; setB = synSets.get(nounB);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (setA.size() == <span class="number">1</span> &amp;&amp; setB.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sap.length(setA.last(), setB.last());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> sap.length(setA, setB);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a synset (second field of synsets.txt) that is the common ancestor of nounA and nounB</span></span><br><span class="line">    <span class="comment">// in a shortest ancestral path (defined below)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sap</span><span class="params">(String nounA, String nounB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nounA == <span class="keyword">null</span> || nounB == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isNoun(nounA) || !isNoun(nounB)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        TreeSet&lt;Integer&gt; setA = synSets.get(nounA);</span><br><span class="line">        TreeSet&lt;Integer&gt; setB = synSets.get(nounB);</span><br><span class="line">        <span class="keyword">int</span> ID;</span><br><span class="line">        <span class="keyword">if</span> (setA.size() == <span class="number">1</span> &amp;&amp; setB.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            ID = sap.ancestor(setA.last(), setB.last());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ID = sap.ancestor(setA, setB);</span><br><span class="line">        <span class="keyword">return</span> ssynsets.get(ID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Outcast.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> Programming_Assignment_6;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.In;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdOut;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outcast</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WordNet wordnet;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outcast</span><span class="params">(WordNet wordnet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (wordnet == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"wrong wordnet"</span>);</span><br><span class="line">        <span class="keyword">this</span>.wordnet = wordnet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">outcast</span><span class="params">(String[] nouns)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nouns == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"this nouns is null"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> Maxn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nouns.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nouns.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> tmp = wordnet.distance(nouns[i], nouns[j]);</span><br><span class="line">                <span class="keyword">if</span> (tmp == -<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                sum += tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; Maxn) &#123;</span><br><span class="line">                Maxn = sum;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"error"</span>);</span><br><span class="line">        <span class="keyword">return</span> nouns[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WordNet wordnet = <span class="keyword">new</span> WordNet(args[<span class="number">0</span>], args[<span class="number">1</span>]);</span><br><span class="line">        Outcast outcast = <span class="keyword">new</span> Outcast(wordnet);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">2</span>; t &lt; args.length; t++) &#123;</span><br><span class="line">            In in = <span class="keyword">new</span> In(args[t]);</span><br><span class="line">            String[] nouns = in.readAllStrings();</span><br><span class="line">            StdOut.println(args[t] + <span class="string">": "</span> + outcast.outcast(nouns));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法" scheme="http://wsx1128.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://wsx1128.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="java" scheme="http://wsx1128.cn/tags/java/"/>
    
      <category term="普林斯顿算法课" scheme="http://wsx1128.cn/tags/%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%AE%97%E6%B3%95%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级题目解析及考试总结</title>
    <link href="http://wsx1128.cn/2019/08/30/PAT%E7%94%B2%E7%BA%A7%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%E5%8F%8A%E8%A7%A3%E6%9E%90/"/>
    <id>http://wsx1128.cn/2019/08/30/PAT甲级题目总结及解析/</id>
    <published>2019-08-30T08:39:31.000Z</published>
    <updated>2019-09-10T13:19:11.848Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="首先这里贴出-所有题目的解析。"><a href="#首先这里贴出-所有题目的解析。" class="headerlink" title="首先这里贴出 所有题目的解析。"></a>首先这里贴出 所有题目的解析。</h2><p><a href="https://github.com/CrazyFnOption/PAT_A" target="_blank" rel="noopener">甲级题目解析</a></p><p>本来最先开始想的是 一道题一道题的总结，但是到后面发现好像真的没有这个时间（主要还是自己懒，宁愿把这个时间用来刷剧）</p><p><strong>这里不能直接插入pdf，所以只能转化为图片一点一点的看咯</strong></p><p><img src="/2019/08/30/PAT甲级题目总结及解析/1.png" alt="1"></p><p><img src="/2019/08/30/PAT甲级题目总结及解析/2.png" alt="2"></p><p><img src="/2019/08/30/PAT甲级题目总结及解析/3.png" alt="3"></p><p><img src="/2019/08/30/PAT甲级题目总结及解析/4.png" alt="4"></p><p><img src="/2019/08/30/PAT甲级题目总结及解析/5.png" alt="5"></p><p><img src="/2019/08/30/PAT甲级题目总结及解析/6.png" alt="6"></p><p><img src="/2019/08/30/PAT甲级题目总结及解析/7.png" alt="7"></p><h2 id="考时状况"><a href="#考时状况" class="headerlink" title="考时状况"></a>考时状况</h2><pre><code>双非新大三，acm铁牌选手，第一次考甲级 92/100 但是觉得排名有点弱 将近300名了 前面满分大佬 这么流弊的吗？第一道题的时候卡了半个小时，用了各种剪枝，把所有没有进位的情况全部剔除掉了，也注意到了排序，到最后都开始怀疑自己gcd是不是写错了，于是果断放弃，开始写第二道题。写第二道题的时候，由于读英文读的很快，然后开始写，最先开始 我是分三种情况 mod 3 ，3种情况去写，然后考虑到各种情况去终止，然后写完去测试样例，直接内存崩了，估计超限了，然后这个时候 我旁边的那位小姐姐，交卷了？！！ 似乎不到一个半小时，直接喊了老师交卷了，然后我心态就有点崩了,这里想找找那位小姐姐(西安交大 402考场的 41号 还是 39 号的小姐姐)，小姐姐 你真的厉害...这个时候由于心态有点炸，觉得强行开这道题不太可能于是转到第三题去了。第三题跟之前甲级有道题很像，自己轻松写完代码之后，以为是后序遍历，但是，当没有左子树的时候，就变成前缀表达式了，先开始没有注意到，各种地方去调试加hello world，去找运行位置，然后，答案跟样例一模一样的时候去提交结果全错，这个时候我发现，万恶的hello world 还在我的输出答案中！！！整个时间花了30多分钟吧 感谢hello world 教会我人生哲理....第四道题 一看就觉得是道板子题，直接去写 dijkstra 的板子，写完之后再看题目，不知道是英文的问题，觉得表述上有点奇怪，先开始觉得只需要判断是不是在最短路序列上，后来才发现只需要去判断距离就行了，感觉又变成暴力杯中的找规律，所以就直接过了。这个时候还有一个小时左右的时间，于是这个时候返回第二题，删掉全部代码，重新写，认认真真静下来读完题目，才发现贼简单，自己想复杂了，因为不可能出现，大序列结束，小序列不结束的情况，想通这个就直接开始写，果然直接就一发ac了，还是心理暗示最重要，只能说小姐姐太厉害了。还有40分钟左右，只剩下第一题的8分没拿到手了，于是回去各种找规律，重新仔细扣题目，然后当我再次交的时候，还是有问题 ，当时就很懵逼，脑海里面各种算法开始交杂，二分，线段树，树状数组？？？然后再次冷静下来去写的时候，我记得是还有二十多分钟的时候 服务器炸了，我这个人还是挺迷信的，觉得天意如此（好像提交的时间也占排名）就直接交了走人了。不过今年刚大三，得明年考的pat成绩才算，所以这次就当打怪升级练手咯，不过 听说还会考很多顶级类似的题目，下次得把顶级的题目刷一遍再来考。看到知乎里面都是满分的大佬，不开心。 sad face...</code></pre><h2 id="考后总结"><a href="#考后总结" class="headerlink" title="考后总结"></a>考后总结</h2><p>第一次考甲级 考了92，分数上还不错，但是排名也太弱鸡了，枉费了我提前了20多分钟交卷，早知道这个排名不是看提交速度的话，我应该坚持到最后一刻的，当时的想法就是觉得 92分够了，因为知道自己明年还会再去考一次式，当时似乎有点轻松，所有有点松懈，希望下次能一步登天，有看这里的朋友，可以一起约着备考明年的pat，</p><p>不过最近也不能松懈，再补前面的坑的同时，还要好好准备后面的其他考试了。  加油。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法" scheme="http://wsx1128.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://wsx1128.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="浙大pat" scheme="http://wsx1128.cn/tags/%E6%B5%99%E5%A4%A7pat/"/>
    
  </entry>
  
  <entry>
    <title>7.27线性dp与区间dp题目解析</title>
    <link href="http://wsx1128.cn/2019/07/27/7-27%E7%BA%BF%E6%80%A7dp%E4%B8%8E%E5%8C%BA%E9%97%B4dp/"/>
    <id>http://wsx1128.cn/2019/07/27/7-27线性dp与区间dp/</id>
    <published>2019-07-27T09:12:52.000Z</published>
    <updated>2019-08-07T17:49:56.826Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="A-导弹袭击"><a href="#A-导弹袭击" class="headerlink" title="A.导弹袭击"></a><a href="http://sustoj.com/JudgeOnline/problem.php?cid=1055&amp;pid=0" target="_blank" rel="noopener">A.导弹袭击</a></h2><p><strong>代码如下：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("test1.in", "r", stdin);   </span></span><br><span class="line">    <span class="comment">//freopen("test1.out", "w", stdout); </span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T))</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> dp[T + <span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> data[T + <span class="number">5</span>];</span><br><span class="line">        data[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; data[i];</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= T; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (data[i] &gt; data[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                num = max(num, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="B-Common-Subsequence"><a href="#B-Common-Subsequence" class="headerlink" title="B.Common Subsequence"></a><a href="http://sustoj.com/JudgeOnline/problem.php?cid=1055&amp;pid=1" target="_blank" rel="noopener">B.Common Subsequence</a></h2><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s1, s2, tmp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("test1.in", "r", stdin); </span></span><br><span class="line">    <span class="comment">//freopen("test1.out", "w", stdout); </span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.size() &lt; s2.size())</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = s1;</span><br><span class="line">            s1 = s2;</span><br><span class="line">            s2 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[s1.size() + <span class="number">10</span>][s1.size() + <span class="number">10</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">int</span> Max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s2.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s1.size(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> l = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (s1[j] == s2[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[k][l] = dp[k - <span class="number">1</span>][l - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[k][l] = max(dp[k - <span class="number">1</span>][l], dp[k][l - <span class="number">1</span>]);</span><br><span class="line">                Max = max(Max, dp[k][l]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[s2.size()][s1.size()] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-滑雪"><a href="#C-滑雪" class="headerlink" title="C.滑雪"></a><a href="http://sustoj.com/JudgeOnline/problem.php?cid=1055&amp;pid=2" target="_blank" rel="noopener">C.滑雪</a></h2><p><strong>代码如下：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> len[N][N], a[N][N];</span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tx, ty, k, s, ms;</span><br><span class="line">    ms = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (len[x][y] != <span class="number">0</span>) <span class="comment">//递归出口；</span></span><br><span class="line">        <span class="keyword">return</span> len[x][y];</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= <span class="number">3</span>; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        tx = dis[k][<span class="number">0</span>] + x;</span><br><span class="line">        ty = dis[k][<span class="number">1</span>] + y;</span><br><span class="line">        <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || ty &lt; <span class="number">0</span> || tx &gt; m - <span class="number">1</span> || ty &gt; n - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[tx][ty] &lt; a[x][y])</span><br><span class="line">        &#123;</span><br><span class="line">            s = dp(tx, ty);</span><br><span class="line">            ms = max(ms, s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    len[x][y] = ms + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> len[x][y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("test1.in", "r", stdin); </span></span><br><span class="line">    <span class="comment">//freopen("test1.out", "w", stdout); </span></span><br><span class="line">    <span class="keyword">int</span> i, j, Max;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="built_in">memset</span>(len, <span class="number">0</span>, <span class="keyword">sizeof</span>(len));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">        Max = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                Max = max(Max, dp(i, j));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="D-小红红益智游戏"><a href="#D-小红红益智游戏" class="headerlink" title="D.小红红益智游戏"></a><a href="http://sustoj.com/JudgeOnline/problem.php?cid=1055&amp;pid=3" target="_blank" rel="noopener">D.小红红益智游戏</a></h2><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">-0x3f3f3f3f</span>; <span class="comment">//定义一个无穷大的值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">205</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> sum[maxn][maxn], n, x;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            sum[i][i] = x;</span><br><span class="line">            fill(dp[i], dp[i] + maxn, INF); <span class="comment">//初始化</span></span><br><span class="line">            dp[i][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//区间dp</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++) <span class="comment">//枚举区间长度</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (i + len - <span class="number">1</span>) &lt;= n; i++) <span class="comment">//枚举区间起点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k++) <span class="comment">//枚举中断点</span></span><br><span class="line">                &#123;</span><br><span class="line">                    sum[i][j] = sum[i][k] + sum[k + <span class="number">1</span>][j];</span><br><span class="line">                    dp[i][j] = max(dp[i][j], dp[i][k] + </span><br><span class="line">                        dp[k + <span class="number">1</span>][j] + sum[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[<span class="number">1</span>][n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-最大括号匹配数"><a href="#E-最大括号匹配数" class="headerlink" title="E.最大括号匹配数"></a><a href="http://sustoj.com/JudgeOnline/problem.php?cid=1055&amp;pid=4" target="_blank" rel="noopener">E.最大括号匹配数</a></h2><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="built_in">string</span> V;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; V, V[<span class="number">0</span>] != <span class="string">'0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = V.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(dp[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(dp[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + len - <span class="number">1</span> &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (V[i] == <span class="string">'('</span> &amp;&amp; V[j] == <span class="string">')'</span> || </span><br><span class="line">                V[i] == <span class="string">'['</span> &amp;&amp; V[j] == <span class="string">']'</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i + <span class="number">1</span> &gt; j - <span class="number">1</span>)</span><br><span class="line">                        dp[i][j] = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k++) &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i][j], </span><br><span class="line">                    dp[i][k] + dp[k + <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[<span class="number">0</span>][n - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        V.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-红红跳格子"><a href="#F-红红跳格子" class="headerlink" title="F.红红跳格子"></a><a href="http://sustoj.com/JudgeOnline/problem.php?cid=1055&amp;pid=5" target="_blank" rel="noopener">F.红红跳格子</a></h2><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="keyword">int</span> num[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//总结一下这类的线性DP。</span></span><br><span class="line"><span class="comment">//这里dp数组保存的是每一个点为止这个位置上的递增子序列之和</span></span><br><span class="line"><span class="comment">//然后这个地方的每一个确定的值再与之前的去比较，最后加上相应的值即可。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("test1.in", "r", stdin); </span></span><br><span class="line">    <span class="comment">//freopen("test1.out", "w", stdout); </span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; T &amp;&amp; T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[<span class="number">1</span>] = num[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= T; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = num[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (num[i] &gt; num[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + num[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> Max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Max = max(Max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Max &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-请客的红红"><a href="#G-请客的红红" class="headerlink" title="G.请客的红红"></a><a href="http://sustoj.com/JudgeOnline/problem.php?cid=1055&amp;pid=6" target="_blank" rel="noopener">G.请客的红红</a></h2><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这道题就是被前面的思想所影响，其实这道题不像前面前面几个状态一定会影响到后面的状态，</span></span><br><span class="line"><span class="comment">    仅仅只是一个一维的线性dp，考虑到前面的这些情况，他是另外的两个dp方程组进行放与不放的操作</span></span><br><span class="line"><span class="comment">    所以不会涉及到多个循环反复到前面之前的状态去寻找，</span></span><br><span class="line"><span class="comment">    只需要在一次遍历的过程中去实现究竟是一次还是两次的操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    跟着每一个状态往下面找出每一个位置的局部最优解 最后得到结果。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2005</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="keyword">int</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("test1.in", "r", stdin); </span></span><br><span class="line">    <span class="comment">//freopen("test1.out", "w", stdout); </span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">            dp[i] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; d[i];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = s[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = min(dp[i - <span class="number">1</span>] + s[i], dp[i - <span class="number">2</span>] + d[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> h = dp[n] / <span class="number">3600</span> + <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">int</span> m = dp[n] / <span class="number">60</span> % <span class="number">60</span>;</span><br><span class="line">        <span class="keyword">int</span> s = dp[n] % <span class="number">60</span>;</span><br><span class="line">        <span class="keyword">if</span> (h &lt;= <span class="number">12</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%02d:%02d:%02d am\n"</span>, h, m, s);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%02d:%02d:%02d pm\n"</span>, h, m, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H-红红与糖果"><a href="#H-红红与糖果" class="headerlink" title="H.红红与糖果"></a><a href="http://sustoj.com/JudgeOnline/problem.php?cid=1055&amp;pid=7" target="_blank" rel="noopener">H.红红与糖果</a></h2><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][<span class="number">11</span>];</span><br><span class="line"><span class="keyword">int</span> date[maxn][<span class="number">11</span>];</span><br><span class="line"><span class="keyword">int</span> _time, pie;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("test1.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("test1.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(date, <span class="number">0</span>, <span class="keyword">sizeof</span> date);</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">int</span> maxTime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;pie, &amp;_time);</span><br><span class="line">            date[_time][pie]++;</span><br><span class="line">            maxTime = max(maxTime, _time);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一秒的运行时间，里面所有的运行情况</span></span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">4</span>] = date[<span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">5</span>] = date[<span class="number">1</span>][<span class="number">5</span>];</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">6</span>] = date[<span class="number">1</span>][<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里其实是由第二次运转的时间来看，因为第一秒的时间我已经全部标记下来了。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxTime; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="comment">//不过需要注意的是 这些全部都是前几秒的动作，上一秒更新的状态，到下一秒后执行的状态</span></span><br><span class="line">                <span class="comment">//下面这个地方就是很奇幻的地方了，一共三个状态，取出来还是不取出来，就是这三种状态</span></span><br><span class="line">                <span class="comment">//左边一个位置取，还是右边一个位置取，还是原本的位置去出来。</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (j &lt; <span class="number">10</span>)</span><br><span class="line">                    dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">                dp[i][j] += date[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> Max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Max = max(Max, dp[maxTime][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Max &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="I-老左的矩阵"><a href="#I-老左的矩阵" class="headerlink" title="I.老左的矩阵"></a><a href="http://sustoj.com/JudgeOnline/problem.php?cid=1055&amp;pid=8" target="_blank" rel="noopener">I.老左的矩阵</a></h2><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个地方就直接就是答案的思路了，由一种倒叙的方法往前面推，将对角线存储的数，</span></span><br><span class="line"><span class="comment">    就是当前能存储到的最大的矩阵。</span></span><br><span class="line"><span class="comment">    状态转移方程就是 dp[i][j] 由 dp[i - k][j]与 dp[i][j - k] 是否相等然后再来存储</span></span><br><span class="line"><span class="comment">    不过这里有一个技巧就是 每一个仅仅只是存储这个数组能够承受的最大值、</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    自己想的办法没有考虑到状态的迁移，也就是没有考虑到状态与状态之间的联系，这里就展现出来了。</span></span><br><span class="line"><span class="comment">    将每一个值存储到dp[i - 1][j + 1] 上，然后再一次对其进行验证。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">char</span> ch[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("test2.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("test2.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; ch[i][j];</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> Max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">1</span> || j == n)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> tmp = dp[i - <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= tmp; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ch[i - k][j] == ch[i][j + k])</span><br><span class="line">                        dp[i][j]++;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Max = max(Max, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="J-阿春取数字"><a href="#J-阿春取数字" class="headerlink" title="J.阿春取数字"></a><a href="http://sustoj.com/JudgeOnline/problem.php?cid=1055&amp;pid=9" target="_blank" rel="noopener">J.阿春取数字</a></h2><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这道题目就是典型的区间DP的题目了，对一个区间里面的值进行动态规划的求解，就像下面的状态转移方程</span></span><br><span class="line"><span class="comment">    dp[i][j] = max(dp[i + 1][j] + num[i] *(n + i - j),</span></span><br><span class="line"><span class="comment">    dp[i][j - 1] + num[j] * (n + i - j));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    这道题唯一特别难想到的是，这道题目是一道逆序求解的问题，</span></span><br><span class="line"><span class="comment">    意思就是从后面的状态往前面推，这当时的我就完全没有想到了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2005</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> num[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("test3.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("test3.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">            dp[i][i] = num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//这里乘以 n + i - j 其实一开始的变形就是 n - (j - i + 1) + 1</span></span><br><span class="line">                dp[i][j] = max(dp[i + <span class="number">1</span>][j] + num[i] * (n + i - j), dp[i][j - <span class="number">1</span>] + num[j] * (n + i - j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[<span class="number">1</span>][n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法" scheme="http://wsx1128.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://wsx1128.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="习题解析" scheme="http://wsx1128.cn/tags/%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>7.26_记忆化搜索和背包习题解析</title>
    <link href="http://wsx1128.cn/2019/07/26/7-26-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E5%92%8C%E8%83%8C%E5%8C%85%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/"/>
    <id>http://wsx1128.cn/2019/07/26/7-26-记忆化搜索和背包习题解析/</id>
    <published>2019-07-26T09:19:12.000Z</published>
    <updated>2019-07-26T13:52:09.004Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="A-小辉辉玩积木"><a href="#A-小辉辉玩积木" class="headerlink" title="A.小辉辉玩积木"></a><a href="http://sustoj.com/JudgeOnline/problem.php?cid=1054&amp;pid=0" target="_blank" rel="noopener">A.小辉辉玩积木</a></h2><p><strong>代码如下：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">60</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[n])</span><br><span class="line">        <span class="keyword">return</span> a[n];</span><br><span class="line">    <span class="keyword">return</span> a[n] = f(n - <span class="number">2</span>) + f(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; f(N - <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这道题就仅仅只是用到了一个递归和记忆化搜索，属于基础简单的题目。</p><h2 id="B-入侵和反击"><a href="#B-入侵和反击" class="headerlink" title="B.入侵和反击"></a><a href="http://sustoj.com/JudgeOnline/problem.php?cid=1054&amp;pid=1" target="_blank" rel="noopener">B.入侵和反击</a></h2><p><strong>代码如下：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">int</span> dp[n + <span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> num[n + <span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i ++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//memset(dp,1,sizeof dp);</span></span><br><span class="line">        <span class="comment">//fill (num,num+n,1);</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//这个地方的状态转移方程，需要去细想比较一下。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num[i] &lt;= num[j]) &#123;</span><br><span class="line">                    dp[i] = max(dp[i],dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> Max = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Max = max(Max,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n - Max &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 9 17 8 19 3</span></span><br><span class="line">        <span class="comment">// 1  1 2 1  3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="C-红红数钞票"><a href="#C-红红数钞票" class="headerlink" title="C.红红数钞票"></a><a href="http://sustoj.com/JudgeOnline/problem.php?cid=1054&amp;pid=2" target="_blank" rel="noopener">C.红红数钞票</a></h2><p><strong>代码如下：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其实这道题也算是一道特别简单的题目，还是动态规划里面最基础的问题，但是总是容易去弄混。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    记得自己当时的问题就在于 这里每一次相加的和，如何保证后面加了负数之后，再次加上一个正数不被影响呢，</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    下面的注释里面有写，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    因为题目中限制了，如果这道题有多个答案，比如说 前面与后面相加为零，但是后面的那个正数正好作为最后的正确答案的话</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    比如 1 2 -3 8 10 -1 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    1 2 -3 正好相加为0  但是题目中要求的 序列 1 2 -3 8 作为最后的结果序列。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    自己当时也在这一块上面纠结。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> num[m + <span class="number">5</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tmpleft = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> Max = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">        tmp += num[i];</span><br><span class="line">        <span class="keyword">if</span> (tmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            tmp = <span class="number">0</span>;</span><br><span class="line">            tmpleft = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tmp &gt; Max) &#123;</span><br><span class="line">            Max = tmp;</span><br><span class="line">            right = i;</span><br><span class="line">            left = tmpleft;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (Max &gt;= <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; Max &lt;&lt; <span class="string">" "</span> &lt;&lt; num[left] &lt;&lt; <span class="string">" "</span> &lt;&lt; num[right] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; num[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; num[m - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="D-Charm-Bracelet"><a href="#D-Charm-Bracelet" class="headerlink" title="D.Charm Bracelet"></a><a href="http://sustoj.com/JudgeOnline/problem.php?cid=1054&amp;pid=3" target="_blank" rel="noopener">D.Charm Bracelet</a></h2><p><strong>代码如下：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一道题属于一个简单的01背包模板题目，这里不多说 可以直接套模板。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">13000</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">3500</span>],v[<span class="number">3500</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= w[i]; j--) &#123;</span><br><span class="line">                dp[j] = max(dp[j],dp[j - w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="E-红红绝地求生"><a href="#E-红红绝地求生" class="headerlink" title="E.红红绝地求生"></a><a href="http://sustoj.com/JudgeOnline/problem.php?cid=1054&amp;pid=4" target="_blank" rel="noopener">E.红红绝地求生</a></h2><p><strong>代码如下：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一段简单的模板题目，不过需要弄清楚的 一维数组与二维数组在这里相应的区别，往往这里会产生很大的区别，</span></span><br><span class="line"><span class="comment">    比如第二个循环的开始条件，因为这里是由子问题的堆积，然后一点一点向上升最终得到的问题，所以这李最好控制背包的放与不放的问题、</span></span><br><span class="line"><span class="comment">    就比如我在这道题目的第二个问题中出现的错误，就是将j=0这个条件直接掠过去了，其实这里是不对的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> weight[maxn],value[maxn],dp[maxn][maxn];</span><br><span class="line"><span class="keyword">long</span> v,w;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w &gt;&gt; v;</span><br><span class="line">        value[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        weight[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= w; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; value[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= w; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; weight[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= w; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= v; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= weight[i]) &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j],dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[w][v] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="F-一卡通"><a href="#F-一卡通" class="headerlink" title="F.一卡通"></a><a href="http://sustoj.com/JudgeOnline/problem.php?cid=1054&amp;pid=5" target="_blank" rel="noopener">F.一卡通</a></h2><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一维滚动数组的做法，由于是01背包，所以直接套模板</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">1010</span>];</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1010</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; d[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p;</span><br><span class="line">        sort(d + <span class="number">1</span>, d + n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = p - <span class="number">5</span>; j &gt;= d[i]; j--)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j] = max(dp[j], dp[j - d[i]] + d[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; p - dp[p - <span class="number">5</span>] - d[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二种方法：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">二维数组直接套模板</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这道题神奇的地方就在于 其的重量限制于价值重合在了一起，所以对于这道题而言就是只能重合的去写状态转移方程了</span></span><br><span class="line"><span class="comment">    另外需要注意的是最后输出结果的办法，是将最后一个物品交给剩下的最大的钱去购买，这样能彻底用光最后的钱财</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> num[maxn],dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">        sort(num + <span class="number">1</span>, num + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="comment">//这里与上面一维滚动数组不太一样的是，一维滚动数组是不能有对物品限制的操作。</span></span><br><span class="line">        <span class="comment">//意思就是 我二维数组可以算出n-1个数，然后算出最后一个数给出的钱数dp[i - 1][j]</span></span><br><span class="line">        <span class="comment">//而一维数组由于只有一个参数就是体积容量的参数dp[i]</span></span><br><span class="line">        <span class="comment">//所以下面多算了一个，最后再通过计算出n-1个物品的体积，再减去相应的钱数，得到最终答案。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m - <span class="number">5</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= num[i]) &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j],dp[i - <span class="number">1</span>][j - num[i]] + num[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; m - dp[n - <span class="number">1</span>][m - <span class="number">5</span>] - num[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="G-红红减肥记"><a href="#G-红红减肥记" class="headerlink" title="G.红红减肥记"></a><a href="http://sustoj.com/JudgeOnline/problem.php?cid=1054&amp;pid=6" target="_blank" rel="noopener">G.红红减肥记</a></h2><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这道题使用二维数组就一直就会超时 具体的我也不太清楚，但是 没有办法 只能使用一维滚动数组，进行了相应的空间优化 不过这里需要补充几个知识点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    第一 关于二维数组的完全背包状态转移方程 dp[i][j] = max (dp[i - 1][j],dp[i - 1][j - k * c[i]] + k * v[i]);</span></span><br><span class="line"><span class="comment">    由上面这个式子就可以得出，状态转移方程  于是 一种空间优化的写法 是直接写成 max(dp[i - 1][j]，dp[i][j - w[i]] + v[i])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    第二 如果换成滚动数组的话 记住 第二个循环的两个顺序，如果是倒叙的话 则就是要保证每一个物品只会取一次，但是如果是正序的话，那么就不需要保证上面所说的顺序了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    而这里官方的解释 就在这里 ：</span></span><br><span class="line"><span class="comment">    让 v 递减是为了保证第i次循环中的状态F[i;v]是由状态F[i-1;v-Ci]递推而来。</span></span><br><span class="line"><span class="comment">    换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第 i 件物品”这件策</span></span><br><span class="line"><span class="comment">    略时，依据的是一个绝无已经选入第 i 件物品的子结果F[i-1;v-Ci]。而现在完全背</span></span><br><span class="line"><span class="comment">    包的特点恰是每种物品可选无限件，所以在考虑“加选一件第 i 种物品”这种策略时，</span></span><br><span class="line"><span class="comment">    却正需要一个可能已选入第 i 种物品的子结果F[i;v-Ci]，所以就可以并且必须采用v</span></span><br><span class="line"><span class="comment">    递增的顺序循环。这就是这个简单的程序为何成立的道理。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a, b, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> happiness[maxn], kaluli[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">110000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;happiness[i],&amp;kaluli[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = kaluli[i]; j &lt;= m; j++) &#123;</span><br><span class="line">                dp[j] = max(dp[j],dp[j - kaluli[i]] + happiness[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[m]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H-Piggy-Bank"><a href="#H-Piggy-Bank" class="headerlink" title="H.Piggy-Bank"></a><a href="http://sustoj.com/JudgeOnline/problem.php?cid=1054&amp;pid=7" target="_blank" rel="noopener">H.Piggy-Bank</a></h2><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这道题是一个完全背包的裸题，对于这道题而言更加神奇的地方就在于其实求最小值而不是求最大值</span></span><br><span class="line"><span class="comment">    所以在最先开始初始化的时候不应该去初始化为0，而应该初始化为无穷大</span></span><br><span class="line"><span class="comment">    而千万不要忘记了再初始化的时候一定要对第一个状态进行一个单独赋值是等于0，还是等于无穷大，这个等到时候再看。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _beg,_end;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">505</span>;</span><br><span class="line"><span class="keyword">int</span> v[maxn],w[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;_beg,&amp;_end);</span><br><span class="line">        <span class="keyword">int</span> bottle = _end - _beg;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;v[i],&amp;w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0x3f3f3f3f</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = w[i]; j &lt;= bottle; j++) &#123;</span><br><span class="line">                dp[j] = min(dp[j],dp[j - w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[bottle] != <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"The minimum amount of money in the piggy-bank is "</span> &lt;&lt; dp[bottle] &lt;&lt; <span class="string">"."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"This is impossible."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="I-美元的困惑"><a href="#I-美元的困惑" class="headerlink" title="I.美元的困惑"></a><a href="http://sustoj.com/JudgeOnline/problem.php?cid=1054&amp;pid=8" target="_blank" rel="noopener">I.美元的困惑</a></h2><p><strong>代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n,k;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            BigInteger[] dp = <span class="keyword">new</span> BigInteger[<span class="number">1005</span>];</span><br><span class="line">            n = in.nextInt();</span><br><span class="line">            k = in.nextInt();</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="keyword">new</span> BigInteger(<span class="string">"1"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                dp[i] = <span class="keyword">new</span> BigInteger(<span class="string">"0"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j++) &#123;</span><br><span class="line">                    dp[j] = dp[j].add(dp[j - i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           System.out.println(dp[n]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="J-Coins"><a href="#J-Coins" class="headerlink" title="J.Coins"></a><a href="http://sustoj.com/JudgeOnline/problem.php?cid=1054&amp;pid=9" target="_blank" rel="noopener">J.Coins</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这道题神奇的地方就是将多重背包的裸题进行了改变，</span></span><br><span class="line"><span class="comment">    主要就是每一次增加的价值会发生改变，这才是最关键的地方。</span></span><br><span class="line"><span class="comment">    这里的价值就不再是个数，而是进行一个打表，通过这个打表来判断这个重量是否能够达到。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> bag;</span><br><span class="line"><span class="keyword">bool</span> dp[<span class="number">100040</span>];</span><br><span class="line"><span class="keyword">int</span> value[<span class="number">105</span>],number[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zeroonepack</span><span class="params">(<span class="keyword">int</span> weight, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = bag; j &gt;= weight; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dp[j] &amp;&amp; dp[j - weight])&#123;</span><br><span class="line">            dp[j] = <span class="literal">true</span>;</span><br><span class="line">            cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完全背包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">completepack</span><span class="params">(<span class="keyword">int</span> weight, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = weight; j &lt;= bag; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dp[j] &amp;&amp; dp[j - weight]) &#123;</span><br><span class="line">            dp[j] = <span class="literal">true</span>;</span><br><span class="line">            cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//多重背包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multilpack</span><span class="params">(<span class="keyword">int</span> weight, <span class="keyword">int</span> number, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//第一种情况就是 如果这件物品所有的重量是小于背包的重量的话</span></span><br><span class="line">    <span class="comment">//那么对于背包而言 这个物品是可以取无限大。</span></span><br><span class="line">    <span class="keyword">if</span> (bag &lt;= number * weight)</span><br><span class="line">    &#123;</span><br><span class="line">        completepack(weight, value);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//而超过的这个范围的就只能使用01背包 然后使用二进制的方法</span></span><br><span class="line">    <span class="comment">//将每一类型的背包进行一个分组</span></span><br><span class="line">    <span class="comment">//后面再依次分别使用多重背包。</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; number)</span><br><span class="line">    &#123;</span><br><span class="line">        zeroonepack(k * weight, k * value);</span><br><span class="line">        number = number - k;</span><br><span class="line">        k = k * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zeroonepack(number * weight, number * value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; bag &amp;&amp; n &amp;&amp; bag) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; value[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i ++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; number[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ;i ++) &#123;</span><br><span class="line">            multilpack(value[i],number[i],value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法" scheme="http://wsx1128.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://wsx1128.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="习题解析" scheme="http://wsx1128.cn/tags/%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>PTA 1013 两种方法解决点与路径的关系</title>
    <link href="http://wsx1128.cn/2019/07/24/PTA-1013-%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%E7%82%B9%E4%B8%8E%E8%B7%AF%E5%BE%84%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://wsx1128.cn/2019/07/24/PTA-1013-两种方法解决点与路径的关系/</id>
    <published>2019-07-24T13:09:05.000Z</published>
    <updated>2019-07-24T13:47:22.791Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这道题很有趣，这里直接贴出题目。</p><p><img src="/2019/07/24/PTA-1013-两种方法解决点与路径的关系/12.png" alt="PTA-1013-两种方法解决点与路径的关系/12.png"></p><p>这道题纯粹就是给出一系列边与点的关系，然后再去掉一个点，看看剩余需要多少个点才能连接成一个完整的图。</p><h4 id="第一种方法并查集"><a href="#第一种方法并查集" class="headerlink" title="第一种方法并查集"></a>第一种方法并查集</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这道题最先开始真的是不知道何从入手，因为本身对于图论的相关知识并不是特别在行</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    这道题的两种方法，第一就是并查集，第二就是利用dfs遍历完所有需要遍历的点。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,M,K;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="comment">//再次错在了这种地方，范围小了，这里题目虽然并没有给出相应的范围</span></span><br><span class="line"><span class="comment">//但是按照每一条边之间的链接来看，这里需要加大其的范围。</span></span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pp[maxn * maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] != x) fa[x] = find(fa[x]);</span><br><span class="line">    <span class="keyword">return</span>  fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = find(x);</span><br><span class="line">    <span class="keyword">int</span> fy = find(y);</span><br><span class="line">    <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">        fa[fx] = fy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; K;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        pp[i].first = a;</span><br><span class="line">        pp[i].second = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pp[j].first != tmp &amp;&amp; pp[j].second != tmp) &#123;</span><br><span class="line">                merge(pp[j].first,pp[j].second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fa[i] == i) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (N == <span class="number">2</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cnt - <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二种方法-通过dfs深搜后进行标记"><a href="#第二种方法-通过dfs深搜后进行标记" class="headerlink" title="第二种方法 通过dfs深搜后进行标记"></a>第二种方法 通过dfs深搜后进行标记</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1008</span>;</span><br><span class="line"><span class="keyword">int</span> N,M,K;</span><br><span class="line"><span class="keyword">bool</span> dis[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i] == <span class="literal">false</span> &amp;&amp; dis[x][i] == <span class="literal">true</span>) &#123;</span><br><span class="line">            dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; K;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="literal">false</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        dis[a][b] = dis[b][a] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">        vis[tmp] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cnt - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法" scheme="http://wsx1128.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://wsx1128.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="http://wsx1128.cn/tags/PAT/"/>
    
  </entry>
  
</feed>

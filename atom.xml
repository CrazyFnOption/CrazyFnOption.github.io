<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Magical Beans</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://crazyfnoption.github.io/"/>
  <updated>2018-12-01T17:19:56.161Z</updated>
  <id>http://crazyfnoption.github.io/</id>
  
  <author>
    <name>五光君</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>海边的卡夫卡的短书评</title>
    <link href="http://crazyfnoption.github.io/2018/12/02/%E6%B5%B7%E8%BE%B9%E7%9A%84%E5%8D%A1%E5%A4%AB%E5%8D%A1%E7%9A%84%E7%9F%AD%E4%B9%A6%E8%AF%84/"/>
    <id>http://crazyfnoption.github.io/2018/12/02/海边的卡夫卡的短书评/</id>
    <published>2018-12-01T17:18:33.000Z</published>
    <updated>2018-12-01T17:19:56.161Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>《海边的卡夫卡》这本书以一个悲剧戏剧为蓝本，进行双线构造，相互交织，相互迎合，从而使一个十五岁的少年的成长历程逐渐完善。虽然取自于俄狄浦斯王中杀父奸母的桥段，但是结局导向以及传达出来的意义绝不一样，前者是悲剧式的自我毁灭以及无常命运的慨叹，而后者则是彻彻底底的自我救赎式的成长。<br>不知有多少人曾在那里流血，你本身也会流血，温暖而又鲜红的血。你的双手将会接住它们，那既是你的血，又是别人的血，而沙尘暴偃旗息鼓的时候，你恐怕还不能完全明白自己是如同从中穿过而得以逃生的。甚至它是否过去都无从判断，不过有一点是你一定是非常清楚的，从沙尘暴中逃生的不再是跨入沙尘暴的你。<br>每一个人的成长都是自由的，但同时却也是不可预测的。村上君用一个十五岁少年的成长史告诉我们在命运的妥协与抗争之间还存在救赎和成长。但是如果仅仅写出少年的成长史的话只能算一般小说。但是村上君肯定不会这样落入俗套，于是他巧妙利用第二条故事线，一个十五岁之后丧失一切的老爷爷的奇遇，这位老爷爷拥有着诸多神奇的能力，但是就是无法思考，记不清楚发生在自己身上的一切，甚至是与整个世界脱轨。看似与第一条故事线没有任何关联，实则丝丝入扣，一个十五岁之后拥有无限可能的人生经历和一个十五岁之后一切都是空白的人生经历相对比，更加深了本文成长与救赎的主题。<br>这本书另一个引人注目的地方也就是作者村上春树对成长中最大的敌人的定义：<br>缺乏想象力的狭隘，苛刻，自以为是的命题，空洞的术语，被篡夺的理想，僵化的思想体系，这些才是最可怕的，但是何为正确，何为不正确，这些都是值得深思的话题，但是某种个体的判断失误，在很多情况下事后不是不可能挽回，只要有勇气主动承认错误，都是可以补救。<br>村上春树这本书以一个全新的视角诠释我们在成长之行上必定会遇到的善与恶，以及一步步走向顽强的心路历程，不要畏惧前方有未知的风暴，因为你是世界上最顽强的是19岁的少年。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="书评" scheme="http://crazyfnoption.github.io/tags/%E4%B9%A6%E8%AF%84/"/>
    
      <category term="村上春树" scheme="http://crazyfnoption.github.io/tags/%E6%9D%91%E4%B8%8A%E6%98%A5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>条款11：在 operator 中处理自我赋值的情况</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E6%9D%A1%E6%AC%BE11%EF%BC%9A%E5%9C%A8operator%E4%B8%AD%E5%A4%84%E7%90%86%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E7%9A%84%E6%83%85%E5%86%B5/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/条款11：在operator中处理自我赋值的情况/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T14:37:23.368Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="本来是可以不用担心拷贝过程中发生自我赋值的情况，但是就是为了防止用户，或者对象自身的这种情况，所以需要完成避免自赋值的情况"><a href="#本来是可以不用担心拷贝过程中发生自我赋值的情况，但是就是为了防止用户，或者对象自身的这种情况，所以需要完成避免自赋值的情况" class="headerlink" title="本来是可以不用担心拷贝过程中发生自我赋值的情况，但是就是为了防止用户，或者对象自身的这种情况，所以需要完成避免自赋值的情况"></a>本来是可以不用担心拷贝过程中发生自我赋值的情况，但是就是为了防止用户，或者对象自身的这种情况，所以需要完成避免自赋值的情况</h4><ol><li><p>比如两个指针对象进行自赋值的时候，为了防止多次删除，需要检查一下自赋值的情况。</p></li><li><p>同时不仅要考虑的是自我赋值的安全性，仍然需要考虑的是异常的安全，也就是前者是需要判断如果前者的地址等于后者的地址话 就直接返回不作为，并且先删除原本的，再赋值新的，而后者则是先构造一个对象赋值给另外一个，然后先赋值，再删除。</p></li></ol><p><img src="//crazyfnoption.github.io/2018/12/01/条款11：在operator中处理自我赋值的情况/1.png" alt=""></p><p>就类似于这样，这样既能保证自赋值的情况，但是又能保证异常安全，不会在new对象的时候发生错误。</p><ol start="3"><li><p>还要记住的是一般在移动赋值运算符的时候也应该注意一下自赋值的情况，不过上面的异常安全很少涉及到，因为上面的相比于前者更费点时间。</p></li><li><p>或者是直接使用自定义的 swap 功能，这样的话对于自赋值的情况以及异常安全的情况来比，更加省事和高效。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/categories/effective-C/"/>
    
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/贪心算法/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-02T01:48:21.459Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>贪心算法的本质目的也就在于对于一个问题来看，我可以用最简单的办法算出局部的解集，并且按照这个最简单的办法同样可以算出该问题的最终解决办法，即贪心算法。</p><h3 id="三个经典的贪心算法问题"><a href="#三个经典的贪心算法问题" class="headerlink" title="三个经典的贪心算法问题"></a>三个经典的贪心算法问题</h3><ol><li>事件的序列问题：<br> <img src="//crazyfnoption.github.io/2018/12/01/贪心算法/15333634457989.jpg" alt=""><br><img src="//crazyfnoption.github.io/2018/12/01/贪心算法/15333634528118.jpg" alt=""></li></ol><p>遇到这样的题目，首先就是要想着能不能找到最长的子序列的前提，到底是按节目的开始时间进行排序，还是按照节目的结束时间进行排序。<br><strong>下面就是核心代码</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Show</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> beg;</span><br><span class="line">    <span class="keyword">int</span> en;</span><br><span class="line">&#125;show[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;show[i].beg&gt;&gt;show[i].en;</span><br><span class="line">        &#125;</span><br><span class="line">        stable_sort(show,show+n,</span><br><span class="line">        [](<span class="keyword">const</span> Show &amp;a, <span class="keyword">const</span> Show &amp;b)&#123;<span class="keyword">return</span> a.en&lt;b.en;&#125;);</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (show[i].beg&gt;=show[j].en)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                j=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此处的关键就是从第一个开始把结束时间最早的进行一个相对位置的排序，然后把第一个结束的与后面开始的时间进行挨个挨个的比较，最终得出的结果就是在这里。</p><ol start="2"><li>区间覆盖问题<br><img src="//crazyfnoption.github.io/2018/12/01/贪心算法/15333675702356.jpg" alt=""><br><strong>下面就是这道题目的核心代码：</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">greedy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="keyword">int</span> i,sum = <span class="number">1</span>,n=x.size();</span><br><span class="line">　　sort(x.begin(),x.end());</span><br><span class="line">　　<span class="keyword">int</span> temp = x[<span class="number">0</span>];<span class="comment">//区间的起始位置</span></span><br><span class="line">　　<span class="keyword">for</span>(i=<span class="number">1</span>;i &lt; n; ++i)</span><br><span class="line">　　　　<span class="keyword">if</span>(x[i] - temp &gt; k)　　&#123;sum++,temp=x[i]&#125;;</span><br><span class="line">　　<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>题目这里就是<br>分别计数，用一个最简单的思维做出一整道题目的思路。</p><ol start="3"><li>区间相交问题：<br><img src="//crazyfnoption.github.io/2018/12/01/贪心算法/15333716368154.jpg" alt=""><br>其实就是跟第一道题目类似</li></ol><p>算连续的序列 并且把总长度减去这些连续的序列之后得到的是剩余的区间，即得到题目答案。</p><p>==以后若还有关于贪心类型的题目可以继续往上面加==</p><p><strong>一下就是贪心的习题</strong></p><p><img src="//crazyfnoption.github.io/2018/12/01/贪心算法/15333719681518.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="题解" scheme="http://crazyfnoption.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="acm" scheme="http://crazyfnoption.github.io/tags/acm/"/>
    
      <category term="贪心" scheme="http://crazyfnoption.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>关于模拟与搜索的相应简单题目</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E5%85%B3%E4%BA%8E%E6%A8%A1%E6%8B%9F%E4%B8%8E%E6%90%9C%E7%B4%A2%E7%9A%84%E7%9B%B8%E5%BA%94%E7%AE%80%E5%8D%95%E9%A2%98%E7%9B%AE/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/关于模拟与搜索的相应简单题目/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-03T10:32:46.417Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>题目</strong><br><img src="//crazyfnoption.github.io/2018/12/01/关于模拟与搜索的相应简单题目/15338826192241.jpg" alt=""></p><p><strong>代码如下：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> w,v;</span><br><span class="line">    <span class="keyword">int</span> x,y,m;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;w&gt;&gt;v)&#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        reverse(w.begin(),w.end());</span><br><span class="line">        reverse(v.begin(),v.end());</span><br><span class="line">        <span class="keyword">if</span> (w.size()&gt;v.size())&#123;</span><br><span class="line">            m=w.size()-v.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=v.size();i++)&#123;</span><br><span class="line">                x=w[i]-<span class="string">'0'</span>;</span><br><span class="line">                y=v[i]-<span class="string">'0'</span>;</span><br><span class="line">                x+=y;</span><br><span class="line">                <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                    flag=<span class="number">0</span>;</span><br><span class="line">                    x++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (x&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    x=x<span class="number">-10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ch=x+<span class="string">'0'</span>;</span><br><span class="line">                s.push_back(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i=v.size();</span><br><span class="line">            <span class="keyword">while</span> (flag==<span class="number">1</span>&amp;&amp;i&lt;=m)&#123;</span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">                x=w[i]-<span class="string">'0'</span>;</span><br><span class="line">                x++;</span><br><span class="line">                <span class="keyword">if</span> (x&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    x=x<span class="number">-10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ch=x+<span class="string">'0'</span>;</span><br><span class="line">                s.push_back(ch);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag&amp;&amp;i==w.size())&#123;</span><br><span class="line">                s.push_back(<span class="string">'1'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            m=v.size()-w.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=w.size();i++)&#123;</span><br><span class="line">                x=w[i]-<span class="string">'0'</span>;</span><br><span class="line">                y=v[i]-<span class="string">'0'</span>;</span><br><span class="line">                x+=y;</span><br><span class="line">                <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                    flag=<span class="number">0</span>;</span><br><span class="line">                    x++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (x&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    x=x<span class="number">-10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ch=x+<span class="string">'0'</span>;</span><br><span class="line">                s.push_back(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i=w.size();</span><br><span class="line">            <span class="keyword">while</span> (flag&amp;&amp;i&lt;=m)&#123;</span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">                x=w[i]-<span class="string">'0'</span>;</span><br><span class="line">                x++;</span><br><span class="line">                <span class="keyword">if</span> (x&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    x=x<span class="number">-10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ch=x+<span class="string">'0'</span>;</span><br><span class="line">                s.push_back(ch);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag&amp;&amp;i==v.size())&#123;</span><br><span class="line">                s.push_back(<span class="string">'1'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(s.begin(),s.end());</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>题解：</strong><br>其实这道题目属于一道相应简单的题目，就是要注意相应string与char之间的区别就行了。<br>另外 <code>int</code>转换<code>char</code>是加上‘0’<br><code>char</code>转换<code>int</code>是减去‘0’。</p><h2 id="一道简单的dfs的题目"><a href="#一道简单的dfs的题目" class="headerlink" title="一道简单的dfs的题目"></a>一道简单的dfs的题目</h2><p><img src="//crazyfnoption.github.io/2018/12/01/关于模拟与搜索的相应简单题目/15338976566985.jpg" alt=""></p><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">char</span> h[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;=n||h[i][j]!=<span class="string">'W'</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (j&lt;<span class="number">0</span>||j&gt;=m||h[i][j]!=<span class="string">'W'</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (h[i][j]==<span class="string">'W'</span>)&#123;</span><br><span class="line">        h[i][j]=<span class="string">'.'</span>;</span><br><span class="line">        dfs(i<span class="number">-1</span>,j);</span><br><span class="line">        dfs(i<span class="number">-1</span>,j<span class="number">-1</span>);</span><br><span class="line">        dfs(i+<span class="number">1</span>,j);</span><br><span class="line">        dfs(i+<span class="number">1</span>,j+<span class="number">1</span>);</span><br><span class="line">        dfs(i,j<span class="number">-1</span>);</span><br><span class="line">        dfs(i<span class="number">-1</span>,j+<span class="number">1</span>);</span><br><span class="line">        dfs(i,j+<span class="number">1</span>);</span><br><span class="line">        dfs(i+<span class="number">1</span>,j<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&amp;&amp;(n!=<span class="number">0</span>&amp;&amp;m!=<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=n;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j!=m;j++)&#123;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;h[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j!=m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (h[i][j]==<span class="string">'W'</span>)&#123;</span><br><span class="line">                    dfs(i,j);</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题解简单的dfs搜索出每一种情况，然后让其返回就行了。</p><h2 id="一道经典的BFS的题目"><a href="#一道经典的BFS的题目" class="headerlink" title="一道经典的BFS的题目"></a>一道经典的BFS的题目</h2><p><strong>题目</strong><br><img src="//crazyfnoption.github.io/2018/12/01/关于模拟与搜索的相应简单题目/15346617217857.jpg" alt="-w780"></p><p><strong>代码如下:</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fxy[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//朝着四个方向</span></span><br><span class="line"><span class="keyword">char</span> dis[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> kp[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下的node就作为每一次前进的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,cnt;</span><br><span class="line">    node(<span class="keyword">int</span> a=<span class="number">0</span>,<span class="keyword">int</span> b=<span class="number">0</span>,<span class="keyword">int</span> c=<span class="number">0</span>)&#123;</span><br><span class="line">        x=a; y=b; cnt=c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n,k,g,k1,g1;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;m,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,dis[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//      用队列整合的思想来完成</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;struct node&gt;q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                kp[i][j]=<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//      两种初始化过程，并且找到起点与终点的所在位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[i][j]==<span class="string">'S'</span>)&#123;</span><br><span class="line">                    k=i;</span><br><span class="line">                    g=j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dis[i][j]==<span class="string">'E'</span>)&#123;</span><br><span class="line">                    k1=i;</span><br><span class="line">                    g1=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//        将起点存进去</span></span><br><span class="line">        <span class="function">node <span class="title">a</span><span class="params">(k,g,<span class="number">0</span>)</span></span>;</span><br><span class="line">        q.push(a);</span><br><span class="line">        <span class="comment">//        下面就是为bfs的相应搜索</span></span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">now</span>=<span class="title">q</span>.<span class="title">front</span>();</span></span><br><span class="line">            q.pop();</span><br><span class="line">            kp[now.x][now.y]=now.cnt;</span><br><span class="line">            <span class="comment">//            将起点走了多少步数以及起点的坐标点存入到题目中去</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                node next;</span><br><span class="line">                next.x=now.x+fxy[i][<span class="number">0</span>];</span><br><span class="line">                next.y=now.y+fxy[i][<span class="number">1</span>];</span><br><span class="line">                <span class="comment">//                判断走的下一步有没有出界，或者使下一步走的不会碰到路障</span></span><br><span class="line">                    <span class="keyword">if</span>(next.x&gt;=<span class="number">0</span>&amp;&amp;next.x&lt;m&amp;&amp;next.y&gt;=<span class="number">0</span>&amp;&amp;next.y&lt;n&amp;&amp;dis[next.x][next.y]!=<span class="string">'#'</span>&amp;&amp;kp[next.x][next.y]==<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="function">node <span class="title">empt</span><span class="params">(next.x,next.y,now.cnt+<span class="number">1</span>)</span></span>;</span><br><span class="line">                    q.push(empt);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(kp[k1][g1]==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"Trapped!\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Escaped in %d minute(s).\n"</span>,kp[k1][g1]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>记住上面相应的队列思想。</p><h2 id="一道DFS与BFS的综合题"><a href="#一道DFS与BFS的综合题" class="headerlink" title="一道DFS与BFS的综合题"></a>一道DFS与BFS的综合题</h2><p>==需要多花时间来温习一遍==</p><p><strong>题目</strong><br><img src="//crazyfnoption.github.io/2018/12/01/关于模拟与搜索的相应简单题目/15346690956114.jpg" alt=""></p><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k,cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x_begin,x_end,y_begin,y_end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[maxn][maxn];</span><br><span class="line"><span class="keyword">char</span> ch[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Position</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> distance;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Position() = <span class="keyword">default</span>;</span><br><span class="line">    Position(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c):x(a),y(b),distance(c)&#123;&#125;;</span><br><span class="line">    <span class="function">Position <span class="title">move</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Position Position::move(<span class="keyword">int</span> i)&#123;</span><br><span class="line">    Position post = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)         post.x = <span class="keyword">this</span> -&gt; x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>)    post.x = <span class="keyword">this</span> -&gt; x - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>)    post.y = <span class="keyword">this</span> -&gt; y + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">3</span>)    post.y = <span class="keyword">this</span> -&gt; y - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> post;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Position&gt;q_dis;</span><br><span class="line">    <span class="function">Position <span class="title">p_begin</span> <span class="params">(x_begin,y_begin,<span class="number">0</span>)</span></span>;</span><br><span class="line">    q_dis.push(p_begin);</span><br><span class="line">    <span class="keyword">while</span>(!q_dis.empty())&#123;</span><br><span class="line">        Position now = q_dis.front();</span><br><span class="line">        q_dis.pop();</span><br><span class="line">        dis[now.x][now.y]=now.distance;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">4</span>; i++)&#123;</span><br><span class="line">            Position next;</span><br><span class="line">            next = now.move(i);</span><br><span class="line">            <span class="keyword">if</span> (next.x &gt;= <span class="number">0</span> &amp;&amp; next.x &lt; n &amp;&amp; next.y &gt;= <span class="number">0</span> &amp;&amp; next.y &lt; m &amp;&amp;</span><br><span class="line">                dis[next.x][next.y] == <span class="number">-1</span> &amp;&amp; ch[next.x][next.y] != <span class="string">'#'</span>)&#123;</span><br><span class="line">                <span class="function">Position <span class="title">empt</span> <span class="params">(next.x,next.y,now.distance + <span class="number">1</span>)</span></span>;</span><br><span class="line">                q_dis.push(empt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ch[x][y]==<span class="string">'L'</span>)  &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dis[x][y] == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//  前面已经有dis可以表示每一步走的距离，所以只需要一步一步来看，这样的做法便可以完全规避障碍物，单单从路径上面考虑。</span></span><br><span class="line">    <span class="keyword">if</span> (dis[x][y]==dis[x+<span class="number">1</span>][y]+<span class="number">1</span>)   dfs(x+<span class="number">1</span>,y);</span><br><span class="line">    <span class="keyword">if</span> (dis[x][y]==dis[x<span class="number">-1</span>][y]+<span class="number">1</span>)   dfs(x<span class="number">-1</span>,y);</span><br><span class="line">    <span class="keyword">if</span> (dis[x][y]==dis[x][y+<span class="number">1</span>]+<span class="number">1</span>)   dfs(x,y+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (dis[x][y]==dis[x][y<span class="number">-1</span>]+<span class="number">1</span>)   dfs(x,y<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,Case = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        Case++;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">        <span class="keyword">bool</span> f_begin = <span class="literal">false</span>,f_end = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != m; j++)&#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; ch[i][j];</span><br><span class="line">                dis[i][j] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != m; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (f_end &amp;&amp; f_begin)   <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (ch[i][j] == <span class="string">'L'</span>)&#123;</span><br><span class="line">                    x_begin = i;</span><br><span class="line">                    y_begin = j;</span><br><span class="line">                    f_begin = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ch[i][j] == <span class="string">'C'</span>)&#123;</span><br><span class="line">                    x_end = i;</span><br><span class="line">                    y_end = j;</span><br><span class="line">                    f_end = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bfs();</span><br><span class="line">        <span class="keyword">if</span> (dis[x_end][y_end] == <span class="number">-1</span> ||dis[x_end][y_end] &gt; k )</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span>&lt;&lt;Case&lt;&lt;<span class="string">": "</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            dfs(x_end,y_end);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;Case&lt;&lt;<span class="string">": "</span>&lt;&lt;dis[x_end][y_end]&lt;&lt;<span class="string">" "</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注明一下关于==默认实参==的知识点，因为在这个地方可以直接对类的构造函数赋值一个默认实参，可以避免输入默认构造函数了。</p><p>下面则是一道DFS的题目，这道题目看上去可以用bfs来做</p><p><img src="//crazyfnoption.github.io/2018/12/01/关于模拟与搜索的相应简单题目/15351254685296.jpg" alt="-w1003"></p><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> road[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[i][j] != <span class="number">-1</span>)   <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    <span class="keyword">int</span> Max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (i<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; road[i][j]&gt;road[i<span class="number">-1</span>][j]&amp;&amp;Max&lt;dfs(i<span class="number">-1</span>,j))</span><br><span class="line">        Max = dfs(i<span class="number">-1</span>,j);</span><br><span class="line">    <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n &amp;&amp; road[i][j]&gt;road[i+<span class="number">1</span>][j]&amp;&amp;Max&lt;dfs(i+<span class="number">1</span>,j))</span><br><span class="line">        Max=dfs(i+<span class="number">1</span>,j);</span><br><span class="line">    <span class="keyword">if</span>(j<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; road[i][j]&gt;road[i][j<span class="number">-1</span>]&amp;&amp;Max&lt;dfs(i,j<span class="number">-1</span>))</span><br><span class="line">        Max=dfs(i,j<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(j+<span class="number">1</span>&lt;m &amp;&amp; road[i][j]&gt;road[i][j+<span class="number">1</span>]&amp;&amp;Max&lt;dfs(i,j+<span class="number">1</span>))</span><br><span class="line">        Max=dfs(i,j+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dp[i][j]=Max+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; road[i][j];</span><br><span class="line">                dp[i][j] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> MAX = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                MAX = max (dfs(i,j),MAX);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; MAX &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>此题其实最重要的就在于这个题目不同于其他题目，这个题目找的是最长路径，还不是最短路径，一般来说，BFS找的是最短路径，DFS找的是最短路径的条数。<br>而这里就是利用dfs的返回值（每走一步的最大值，意思就是从各个角度上）记录在dp中，将每一个位置都走到不能走为止，然后存储在dp中，最后找最大值的DP即可。<br>不过自己可以试试遍历的其他方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="题解" scheme="http://crazyfnoption.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="acm" scheme="http://crazyfnoption.github.io/tags/acm/"/>
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="模拟与搜索" scheme="http://crazyfnoption.github.io/tags/%E6%A8%A1%E6%8B%9F%E4%B8%8E%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>STL的简单总结</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/STL%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/STL的简单总结/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-04T00:13:06.615Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>补一个加快C++输入输出速度的方法：<br><img src="//crazyfnoption.github.io/2018/12/01/STL的简单总结/15335220029444.jpg" alt=""></p><p>花上一天的时间来总结 C++ primer 里面的算法以及容器这一章，多余的用法可以上网去查找当做是相应的扩展。</p><h2 id="字符串-string与字符数组"><a href="#字符串-string与字符数组" class="headerlink" title="字符串 string与字符数组"></a>字符串 string与字符数组</h2><ul><li><p><strong>构造<code>string</code>的方法</strong><br><img src="//crazyfnoption.github.io/2018/12/01/STL的简单总结/15335169766308.jpg" alt=""></p></li><li><p><strong>操作<code>string</code>的方法</strong></p></li></ul><p><img src="//crazyfnoption.github.io/2018/12/01/STL的简单总结/15335172798374.jpg" alt=""><br><img src="//crazyfnoption.github.io/2018/12/01/STL的简单总结/15335172954262.jpg" alt=""><br>上面的成员函数有的说要返回，同时，有的也存在不返回值。</p><ul><li><strong>搜索<code>string</code>的方法</strong></li></ul><p><img src="//crazyfnoption.github.io/2018/12/01/STL的简单总结/15335179836529.jpg" alt=""></p><p><img src="//crazyfnoption.github.io/2018/12/01/STL的简单总结/15335179990314.jpg" alt=""></p><p>以上就是find函数的一些用法，在泛型算法一章，还会继续涉及到。<br><strong>题目返回的是下标</strong></p><p>补充一下关于<code>string</code>中的比较函数<br><img src="//crazyfnoption.github.io/2018/12/01/STL的简单总结/15335183199373.jpg" alt=""><br>一般在string中可以直接用运算符进行比较</p><ul><li><strong><code>int</code>与<code>string</code>之间的转化</strong></li></ul><p><img src="//crazyfnoption.github.io/2018/12/01/STL的简单总结/15335184125849.jpg" alt=""></p><ul><li><strong><code>getline()</code>的两种写法</strong><br><img src="//crazyfnoption.github.io/2018/12/01/STL的简单总结/15334343361243.jpg" alt=""><br>注意在<code>cin&gt;&gt;t</code>;必须要一个<code>getchar()</code>来吞掉其前面的回车符号。<br>之后才能用<code>getline()</code>。</li></ul><h2 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h2><ul><li><strong>容器种类</strong><br><img src="//crazyfnoption.github.io/2018/12/01/STL的简单总结/15334679972152.jpg" alt=""></li></ul><p><code>vector&lt;vector&lt;int&gt; &gt;</code>来表示二维数组。</p><ul><li><strong>容器基础操作</strong><br><img src="//crazyfnoption.github.io/2018/12/01/STL的简单总结/15334684459041.jpg" alt=""><br>补充一个assign的用法：<br>允许从一个不同但相容的类型里面去赋值，或者从容器的一个子序列赋值。</li></ul><p><img src="//crazyfnoption.github.io/2018/12/01/STL的简单总结/15334692047908.jpg" alt=""><br>还有第二个版本：<br>接受一个整型值和一个元素值，用指定数目且具有相同给定元素替换容器中原有的元素：<br><img src="//crazyfnoption.github.io/2018/12/01/STL的简单总结/15334693472336.jpg" alt=""></p><p>再补充一个resize的用法：<br><img src="//crazyfnoption.github.io/2018/12/01/STL的简单总结/15335166722769.jpg" alt=""></p><p>需要记住有一些类型声明可以直接用<code>auto</code>。</p><p>初始化有两种一种<strong>直接初始化</strong>和<strong>拷贝初始化</strong>。</p><ul><li><strong>顺序容器添加元素</strong><br><img src="//crazyfnoption.github.io/2018/12/01/STL的简单总结/15334697068572.jpg" alt=""><br>上面已经列出了各种形式的插入。<br>插入是在迭代器指向的元素之前插入。插入想要插入的元素前面，比如说<code>push_back</code>是插入到了尾后迭代器的前面。<br>而返回的是新添加的第一个元素的迭代器，同样也可也==不返回==。</li></ul><p>这里要注意的是<code>push_front</code>会改变整个容器的迭代器指向，而<code>push_back</code>不会。</p><ul><li><strong>访问元素</strong></li></ul><p><img src="//crazyfnoption.github.io/2018/12/01/STL的简单总结/15334703127503.jpg" alt=""></p><p>链表，单向链表，栈，队列都不支持随机访问，也就不支持下标访问了。</p><ul><li><strong>删除元素</strong><br><img src="//crazyfnoption.github.io/2018/12/01/STL的简单总结/15334705958004.jpg" alt=""></li></ul><p>删除的是迭代器指向的元素，返回的是删除元素的后迭代器也就是被删除的元素下一个元素的前面的迭代器，同样也可以不返回。</p><p><em>这里需要注意的就是删除一个元素之后，必定会改变原容器中迭代器的指向，所以务必小心（除了<code>pop_back</code>）</em></p><ul><li><strong>改变容器大小的操作</strong></li></ul><p><img src="//crazyfnoption.github.io/2018/12/01/STL的简单总结/15335167464723.jpg" alt=""></p><ul><li><strong>特殊的forward_list（单向链表）</strong></li></ul><p><img src="//crazyfnoption.github.io/2018/12/01/STL的简单总结/15334712839686.jpg" alt=""></p><p>由于迭代器的添加删除操作都涉及到了首前和尾后，所以对于单向链表来说这里添加了一个首前迭代器<code>before_begin</code><br>而对于单向链表的插入而言 是在元素的后面进行插入，删除也是一样，指向都是迭代器指向元素之后的元素。</p><h2 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h2><p><img src="//crazyfnoption.github.io/2018/12/01/STL的简单总结/15335188187528.jpg" alt=""></p><ul><li>**关联容器里面的<code>pair</code></li></ul><p><img src="//crazyfnoption.github.io/2018/12/01/STL的简单总结/15335191398555.jpg" alt=""></p><ul><li><strong>关联容器的操作</strong></li></ul><p><img src="//crazyfnoption.github.io/2018/12/01/STL的简单总结/15335192848295.jpg" alt=""></p><ul><li><strong>关联容器的添加操作</strong></li></ul><p><img src="//crazyfnoption.github.io/2018/12/01/STL的简单总结/15335195440945.jpg" alt=""></p><p>一般都是直接用下标操作添加<code>map</code>里面的操作。<br><code>at</code>操作只能判断存不存在</p><ul><li><strong>关联容器的删除操作</strong></li></ul><p><img src="//crazyfnoption.github.io/2018/12/01/STL的简单总结/15335202245929.jpg" alt=""></p><ul><li><strong>关联容器的访问操作</strong></li></ul><p><img src="//crazyfnoption.github.io/2018/12/01/STL的简单总结/15335205177307.jpg" alt=""><br>上面关于排序的操作不适用于无序的关联容器。</p><p><strong>当允许关键词重复的multimap中查找元素时，一般使用find函数与count函数同时进行。</strong></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>大部分函数算法都放在<code>&lt;algorithm&gt;</code>的头文件里面了。<br>还有一些数值算法是放在了<code>&lt;numeric&gt;</code>的头文件里面。</p><ul><li><strong>只读算法</strong></li></ul><p>accumulate 求和算法，接受三个参数，前面两个参数是累加范围，第三个是和的初值。<br>equal 判断两个序列里面是否所有的值都相同。<br>后面网上查找 有的再补充。<br>find算法<br>binary_search()二分查找函数<br>find_end()最后一次出现算法<br>find_first_of()第一次出现的算法<br>find_if ()第三个参数就为自定义函数搜索<br>lower_bound()第一个不小于的元素<br>upper_bound()第一个大于的元素<br>count（）算法 计算出现次数<br>count_if（）函数自定义计数</p><ul><li><strong>写容器的算法</strong></li></ul><p>fill 填充算法 类似于memset函数前者在于可以赋值赋任何值，而后者理论上只能赋值0或者1或者0x3f3f3f3f。<br>fill_n也是三个参数，第一个是开始点，第二个是赋值数目，第三个为赋值初始化。<br>copy 拷贝算法，接收三个迭代器，前面两个表示输入范围，第三个为拷贝目标序列的起点。<br>replace 替换算法，将目标序列里面的某些值更改成某些值，接受四个参数，前面两个是目标序列的范围，第三个是要搜索的值，第四个是要将搜索到的第三个的值更改后的值。<br>remove 去除掉函数里面包括的参数的元素。<br>remove_if 自定义。<br>remove_copy 拷贝结果。<br>swap（）交换两个对象的值。<br>swap_range()交换两个序列的值。</p><ul><li><strong>重排容器的算法</strong></li></ul><p>其排序的算法中，定义的排序方式就在于自定义函数传入算法中。<br>有三种自定义函数：</p><ol><li>普通bool型自定义函数，比较排列顺序。</li><li>lambda 匿名小函数。</li><li>bind 函数 绑定谓词。灵活的应用自定义函数。</li></ol><p>unique 将容器中所有重复的值全部排列到后面去，接受目标序列的迭代器范围，返回指向第一个重复元素的迭代器。<br>sort 排序 本质上运用的是快速排序。<br>stable_sort 本质上运动的是归并排序。<br>stable_partition 前面进行排序后，把自定义排列的分割开来。<br>reverse 倒排函数。<br>reverse_copy 倒排函数。<br>rotate 接受三个参数，前面两个是要往后面排的范围。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul><li><p><strong>插入迭代器</strong><br>back_inserter 类似于push_back的迭代器，创建并且使用<br>front_inserter 创建并且使用一个push_front的迭代器<br>inserter 创建一个普通插入的迭代器</p></li><li><p><strong>流迭代器</strong><br>istream_iterator 输入迭代器<br><img src="//crazyfnoption.github.io/2018/12/01/STL的简单总结/15335260532129.jpg" alt=""></p></li></ul><p>ostream_iterator 输出迭代器<br><img src="//crazyfnoption.github.io/2018/12/01/STL的简单总结/15335260817218.jpg" alt=""></p><ul><li><strong>反向迭代器</strong><br>reverse_iterator</li><li><strong>移动迭代器</strong><br>后面复习到在总结 移动、拷贝、右值引用。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="acm" scheme="http://crazyfnoption.github.io/categories/acm/"/>
    
    
      <category term="acm" scheme="http://crazyfnoption.github.io/tags/acm/"/>
    
      <category term="数据结构" scheme="http://crazyfnoption.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="STL" scheme="http://crazyfnoption.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>一道STL的题解题目，需要以后花时间理解题目意思</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E4%B8%80%E9%81%93STL%E7%9A%84%E9%A2%98%E8%A7%A3%E9%A2%98%E7%9B%AE%EF%BC%8C%E9%9C%80%E8%A6%81%E4%BB%A5%E5%90%8E%E8%8A%B1%E6%97%B6%E9%97%B4%E7%90%86%E8%A7%A3%E9%A2%98%E7%9B%AE%E6%84%8F%E6%80%9D/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/一道STL的题解题目，需要以后花时间理解题目意思/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-02T01:48:21.458Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="//crazyfnoption.github.io/2018/12/01/一道STL的题解题目，需要以后花时间理解题目意思/15334616821861.jpg" alt=""></p><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">//#include&lt;function&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> fort = <span class="number">1314</span>;</span><br><span class="line"></span><br><span class="line">ll a[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//这道题目就换一种思考方式，让基数分贝加上加数，这样一来，就会简化很多步骤</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[<span class="number">0</span>]&gt;&gt;a[<span class="number">1</span>]&gt;&gt;a[<span class="number">2</span>];</span><br><span class="line">        a[<span class="number">3</span>] = <span class="number">5</span>;</span><br><span class="line">        a[<span class="number">4</span>] = <span class="number">2</span>;</span><br><span class="line">        a[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">        sort(a,  a + <span class="number">6</span>,</span><br><span class="line">        [](<span class="keyword">const</span> ll &amp;a,<span class="keyword">const</span> ll &amp;b)&#123;<span class="keyword">return</span> a&gt;b;&#125;);</span><br><span class="line">        priority_queue&lt;ll, <span class="built_in">vector</span>&lt;ll&gt;, greater&lt;ll&gt; &gt; pq;</span><br><span class="line">        <span class="built_in">set</span>&lt;ll&gt;s;</span><br><span class="line">        <span class="built_in">set</span>&lt;ll&gt;ans;</span><br><span class="line">        pq.push(<span class="number">1</span>);</span><br><span class="line">        s.insert(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;;i++)&#123;</span><br><span class="line">            ll x = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            <span class="keyword">if</span>(i)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">3</span>;k &lt; <span class="number">6</span>;k++)&#123;</span><br><span class="line">                    ans.insert(x - a[k]);</span><br><span class="line">                    <span class="keyword">if</span>(ans.size()==fort)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ans.size()==fort)&#123;</span><br><span class="line">                    <span class="comment">/*int ttt = 1;</span></span><br><span class="line"><span class="comment">                    for(set&lt;ll&gt;::iterator it = ans.begin();it!=ans.end();it++)</span></span><br><span class="line"><span class="comment">                        cout&lt;&lt;ttt++&lt;&lt;' '&lt;&lt;*it&lt;&lt;endl;*/</span></span><br><span class="line">                    <span class="keyword">auto</span> it = ans.rbegin();</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">                ll x2=x*a[j];</span><br><span class="line">                <span class="keyword">if</span>(!s.count(x2))&#123;</span><br><span class="line">                    s.insert(x2);</span><br><span class="line">                    pq.push(x2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="题解" scheme="http://crazyfnoption.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="acm" scheme="http://crazyfnoption.github.io/tags/acm/"/>
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="STL" scheme="http://crazyfnoption.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>一道有趣的题目——逆波兰计算器</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E4%B8%80%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A2%98%E7%9B%AE%E2%80%94%E2%80%94%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/一道有趣的题目——逆波兰计算器/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-02T01:48:21.458Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="//crazyfnoption.github.io/2018/12/01/一道有趣的题目——逆波兰计算器/15334382488561.jpg" alt=""></p><p><strong>题解</strong><br>首先这道题毫无疑问是要用到stringstream流的。分别依次读取字符串，并且将其导入到char型的代码中去。比如说a+b可以变成ab+，这里最好运用到栈的知识，来控制出栈与进栈。<br>==注意以下几个地方==</p><ol><li>注意输入<code>cin&gt;&gt;t</code>以后，需要用<code>getchar()</code>来清空上一个步骤留下来的回车符号</li><li>注意此处需要严格进行判断栈内是否为空。</li><li>这里是将乘除求模的运算放在最右边，这样就可以有优先级存在了</li><li>括号会提前进行一步运算，然后消除掉左括号，或者左边的所有运算式，进行一个结算。</li><li>map这里存在的意义就在于 为判断进行提供条件。</li><li>此道题目涉及字符串，栈，模拟的相应算法，需要有空的时候可以多看看。</li></ol><p><strong>代码如下：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt;ope;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;num;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m[<span class="string">'+'</span>]=m[<span class="string">'-'</span>]=<span class="number">1</span>;</span><br><span class="line">    m[<span class="string">'*'</span>]=m[<span class="string">'/'</span>]=m[<span class="string">'%'</span>]=m[<span class="string">'('</span>]=m[<span class="string">')'</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(!num.empty())</span><br><span class="line">        num.pop();</span><br><span class="line">    <span class="keyword">while</span>(!ope.empty())</span><br><span class="line">        ope.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此处为基本的运算规模。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">op1</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b,<span class="keyword">const</span> <span class="keyword">char</span> &amp;c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c ==<span class="string">'+'</span>)    a += b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'-'</span>) a=b-a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'*'</span>) a*=b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'/'</span>) a=b/a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'%'</span>) a=b%a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此处就是控制出栈的运算，一般就是括号内部的计算了。算出每一个括号内部的运算式。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">op2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = ope.top();</span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">'('</span>&amp;&amp;!ope.empty())&#123;</span><br><span class="line">        ope.pop();</span><br><span class="line">        <span class="keyword">int</span> a = num.top();</span><br><span class="line">        num.pop();</span><br><span class="line">        <span class="keyword">int</span> b = num.top();</span><br><span class="line">        num.pop();</span><br><span class="line">        op1(a,b,ch);</span><br><span class="line">        num.push(a);</span><br><span class="line">        <span class="keyword">if</span> (!ope.empty())</span><br><span class="line">            ch = ope.top();</span><br><span class="line">    &#125;<span class="comment">//这个下面要注意的判断条件中一定要加上判断是否为空。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ope.empty()&amp;&amp;ope.top() ==<span class="string">'('</span>)</span><br><span class="line">        ope.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">        getline(<span class="built_in">cin</span>,str);</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">s</span><span class="params">(str)</span></span>;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">char</span> tmp;</span><br><span class="line">        <span class="keyword">while</span> (s&gt;&gt;tmp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;=<span class="string">'0'</span>&amp;&amp;tmp&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">do</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (m[tmp]) <span class="keyword">break</span>;</span><br><span class="line">                    x *= <span class="number">10</span>;</span><br><span class="line">                    x += tmp - <span class="string">'0'</span>;<span class="comment">//此处是将char转换成int</span></span><br><span class="line">                &#125;<span class="keyword">while</span>(s&gt;&gt;tmp);</span><br><span class="line">                num.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//注意这个地方的高明之处就在于碰见‘）’的返回，以及判断有没有‘（’，</span></span><br><span class="line">            比如连加的情况就把加减乘除的优先运算级给表示出来了。</span><br><span class="line">            <span class="comment">//最后相当于将运算优先级高的全部放到了右边，然后有括号的就先解决括号，</span></span><br><span class="line">            及时左括号被提前弄没了也不要紧，存在有右括号就行，然后乘除永远放在加减的左边。</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (tmp==<span class="string">')'</span>) op2();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m[tmp]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!ope.empty()&amp;&amp;ope.top()!=<span class="string">'('</span>)</span><br><span class="line">                    op2();</span><br><span class="line">                ope.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m[tmp]) ope.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = num.top();</span><br><span class="line">        num.pop();</span><br><span class="line">        <span class="keyword">while</span> (!num.empty()&amp;&amp;!ope.empty())&#123;</span><br><span class="line">            op1(ans,num.top(),ope.top());</span><br><span class="line">            ope.pop();</span><br><span class="line">            num.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="题解" scheme="http://crazyfnoption.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="acm" scheme="http://crazyfnoption.github.io/tags/acm/"/>
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="STL" scheme="http://crazyfnoption.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>一道计算机几何算法相关题目</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E4%B8%80%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%87%A0%E4%BD%95%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/一道计算机几何算法相关题目/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-02T01:48:21.458Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>题目：</strong></p><p><img src="//crazyfnoption.github.io/2018/12/01/一道计算机几何算法相关题目/15349459741854.jpg" alt=""></p><p><strong>代码如下：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> v,s,b;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;v&gt;&gt;s&gt;&gt;b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s&lt;b)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> x = (v * v) / <span class="number">9.8</span>;</span><br><span class="line">        <span class="keyword">if</span> ( x &lt; s ) &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"move "</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">2</span>)&lt;&lt;s-x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> b = (s * <span class="number">9.8</span>) / (v * v);</span><br><span class="line">            <span class="comment">//注意反函数的转换。</span></span><br><span class="line">            <span class="keyword">double</span> a = <span class="built_in">asin</span>(b) * <span class="number">90</span> / pi;</span><br><span class="line">            <span class="comment">//这里有一个进一的操作，因为此题不太会去四舍五入。</span></span><br><span class="line">            <span class="keyword">int</span> a_ = a;</span><br><span class="line">            <span class="keyword">if</span> (a-a_ &gt;= <span class="number">0.5</span>) a_++;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"a "</span>&lt;&lt;a_&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>关于这道题目的相关要点</strong></p><ol><li><p>反函数相关要点。<br>注意 反函数最后输出的是 一个弧度值，根据相应数学的算法而言<br>记住 ==弧度值=角度*pi/180==</p></li><li><p>关于输出中进1的相关操作。<br>按照第几位，先换算成相应的整形数，最后再强转成int型 最后在判断是否大于0.5来考虑时候来加一。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="题解" scheme="http://crazyfnoption.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="acm" scheme="http://crazyfnoption.github.io/tags/acm/"/>
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="STL" scheme="http://crazyfnoption.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>二分法思想</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E4%BA%8C%E5%88%86%E6%B3%95%E6%80%9D%E6%83%B3/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/二分法思想/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-04T00:13:06.615Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>实现在单调有序的集合中查找元素，每次江集合分为左右两个部分，并且通过判断集合在哪个部分从而调整集合的上下界，重复知道找到目标元素为止。</p><p>举一个简单的例子，我要在1到100里面查找62，先拿62根这个其最中间的一个数进行比较。然后在一步一步的缩小集合的上下界，最后再来一步一步往里面缩</p><p><strong>下面是C++STL里面二分查找的函数：</strong></p><blockquote><p>binary_search  返回bool值,是否存在<br>lower_bound    返回可插入的最小位置的迭代器                                                                  即返回第一个符合条件的元素位置<br>upper_bound    返回可插入的最大位置的迭代器<br>               即返回最后一个符合条件的元素位置</p></blockquote><p>在二分查找里面最典型的题目就是二分逼近求方程式的根了。</p><p><img src="//crazyfnoption.github.io/2018/12/01/二分法思想/15333828636681.jpg" alt=""></p><p><strong>代码如下</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pre =<span class="number">1e-4</span>;</span><br><span class="line"><span class="keyword">double</span> x,y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">8</span>*<span class="built_in">pow</span>(x,<span class="number">4</span>)+<span class="number">7</span>*<span class="built_in">pow</span>(x,<span class="number">3</span>)+<span class="number">2</span>*<span class="built_in">pow</span>(x,<span class="number">2</span>)+<span class="number">3</span>*x+<span class="number">6</span>-y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;y;</span><br><span class="line">        <span class="keyword">double</span> x1=<span class="number">0</span>,x2=<span class="number">100</span>;<span class="comment">//先把上下界在这里确定好</span></span><br><span class="line">        <span class="keyword">double</span> mid=(x1+x2)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (f(x1)*f(x2)&gt;<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"No solution!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (x2-x1&gt;=pre)&#123;<span class="comment">//这里必须写的是上下界线是多少，</span></span><br><span class="line">            不能写的是用于判断mid的条件。</span><br><span class="line">                <span class="keyword">if</span> (f(x1)*f(mid)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    x2=mid;</span><br><span class="line">                    mid=(x1+x2)/<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    x1=mid;</span><br><span class="line">                    mid=(x1+x2)/<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">4</span>)&lt;&lt;mid&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面就是我第二次出错的地方，判断二分循环逼近的的条件不应该看mid的取值，而是应该看得是区间上界减去区间下界的范围从而来限定。</p><p>此处关于三分法的求解：<br>当需要求某凸性或凹形函数的极值，通过函数本身表达式并不容易求解时，就可以用三分法不断逼近求解。</p><p>三分法——求解凸性函数的极值问题<br><a href="http://hi.baidu.com/vfxupdpaipbcpuq/item/81b21d1910ea729c99ce33db" target="_blank" rel="noopener">http://hi.baidu.com/vfxupdpaipbcpuq/item/81b21d1910ea729c99ce33db</a></p><p>经典例题：<br>侵略的奶牛：<br><img src="//crazyfnoption.github.io/2018/12/01/二分法思想/15334016401434.jpg" alt=""></p><p><strong>代码如下：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn],n,c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此过程就是在判断奶牛之间的间隔为这个值合不合适</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cc</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=a[<span class="number">0</span>],cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i!=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i]-t&gt;=d)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            t=a[i];</span><br><span class="line">            <span class="keyword">if</span> (cnt&gt;=c)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此过程就是在收录每一个值，然后再分别进行判断</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,y=a[n<span class="number">-1</span>]-a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span> (x&lt;=y)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(x+y)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (cc(mid))    x=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>    y=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不过这种最大值最小值的题目需要多花时间想想。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;c)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=n;i++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        sort(a,a+n);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;solve()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>==下面则是其他地方关于二分的题目==<br><strong>基础版</strong></p><blockquote><p>POJ 3122 Pie<br>  二分枚举区间是实数<br>POJ 1064 Cable master<br>    二分枚举区间是实数,注意精度<br>POJ 3258 River Hopscotch<br>     最大化最小值<br>POJ 3273 Monthly Expense<br>    最小化最大值<br>LIGHTOJ 1076 Get the Containers<br>    最小化最大值，。和上一个差不多<br>LIGHTOJ 1307 Counting Triangles </p></blockquote><p><strong>进阶版</strong></p><blockquote><p>POJ 3579      二分搜索+二分查找<br>POJ 3685      二分搜索+二分查找<br>ZOJ 3278      也是两个二分嵌套<br>LIGHTOJ 1048<br>和LightOJ 1076一样，不过要输出一组解<br>LIGHTOJ 1383    二分加贪心（区间）<br>ZOJ 3665 某年区域赛题。，二分枚举<br>ZOJ 3726 去年区域赛题，二分查找<br>codeforces 382B 有意思的题<br>codeforces 391D2 难，。。，，、</p></blockquote><p>==下面就是关于三分的题目==</p><blockquote><p>poj3301<br>hdu4454<br>hdu3714<br>hdu2438</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="acm" scheme="http://crazyfnoption.github.io/categories/acm/"/>
    
    
      <category term="acm" scheme="http://crazyfnoption.github.io/tags/acm/"/>
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="STL" scheme="http://crazyfnoption.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>关于STL里面函数简单的应用</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E5%85%B3%E4%BA%8ESTL%E9%87%8C%E9%9D%A2%E5%87%BD%E6%95%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/关于STL里面函数简单的应用/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-02T01:48:21.459Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="//crazyfnoption.github.io/2018/12/01/关于STL里面函数简单的应用/15334646368898.jpg" alt=""></p><p><strong>代码如下：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line">    s.insert(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i!=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这道题目的主要做法是记住几个upper_bound 的STL函数</span></span><br><span class="line">        <span class="keyword">if</span>(t &lt; *s.rbegin()) &#123;</span><br><span class="line">            s.erase(*(s.upper_bound(t)));</span><br><span class="line">        &#125;</span><br><span class="line">        s.insert(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="题解" scheme="http://crazyfnoption.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="acm" scheme="http://crazyfnoption.github.io/tags/acm/"/>
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="STL" scheme="http://crazyfnoption.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>关于组合数学，两道思维题目，这里贴两道题目</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E5%85%B3%E4%BA%8E%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%8C%E4%B8%A4%E9%81%93%E6%80%9D%E7%BB%B4%E9%A2%98%E7%9B%AE%EF%BC%8C%E8%BF%99%E9%87%8C%E8%B4%B4%E4%B8%A4%E9%81%93%E9%A2%98%E7%9B%AE/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/关于组合数学，两道思维题目，这里贴两道题目/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-02T01:48:21.459Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第一道-简单的排列组合："><a href="#第一道-简单的排列组合：" class="headerlink" title="第一道 简单的排列组合："></a>第一道 简单的排列组合：</h2><p><img src="//crazyfnoption.github.io/2018/12/01/关于组合数学，两道思维题目，这里贴两道题目/15334551294656.jpg" alt=""></p><p><strong>题解如下：</strong></p><blockquote><p>题目大致可以理解为4堆牌a,b,c,d，每次从一堆牌里拿出牌顶的一张牌，问共有多少种拿法。其实我们可以一堆一堆的分析，假设只有一堆a时只有1种拿法，那两堆a,b时我们可以认为是从a个牌中插入b张牌，用数学表达式就是<strong>==C(b,a+b)==</strong>;那么三堆的话我们可以把前两堆看成一堆，那么表达式就是<strong>==C(c,a+b+c)==</strong>，这是我们需要与前两堆的组成方法相乘，就是<strong>==C(b,a+b)C(c,a+b+c)==</strong>。<br>4堆的话就是<strong>==C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)==</strong>。<br>所以答案就是<strong>==C(a,a)C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)==</strong>。<br>此外，有一公式==<strong>C(a,b)=C(a,b-1)+C(a-1,b-1)</strong>==，所以我们用数组来代替C(m,n)操作</p></blockquote><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">501</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">4</span>],sum[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//此处用到记忆化搜索，动态规划。</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[maxn*<span class="number">4</span>][maxn*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i!=<span class="number">4</span>*maxn;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//根据表格来看的确是每一行的第一个是1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="comment">//这个地方就是状态转移方程</span></span><br><span class="line">            <span class="comment">//C(a,b)=C(a,b-1)+C(a-1,b-1)根据公式来做的</span></span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="comment">//dp[i][j]=dp[i][j]%mod;</span></span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">        init();<span class="comment">//这个地方就开始初始化表格了。</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!i) sum[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> sum[i]=sum[i<span class="number">-1</span>];</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">            sum[i] += a[i];</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; sum[i]-a[i]) a[i]=sum[i]-a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i != <span class="number">4</span>; i++)&#123;</span><br><span class="line">            ans *= dp[sum[i]][a[i]];</span><br><span class="line">            <span class="comment">//ans %=mod;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二题-第一题的变式："><a href="#第二题-第一题的变式：" class="headerlink" title="第二题 第一题的变式："></a>第二题 第一题的变式：</h2><p><img src="//crazyfnoption.github.io/2018/12/01/关于组合数学，两道思维题目，这里贴两道题目/15334588459331.jpg" alt=""></p><p>题解如上，与上面一题有区别的地方就在于要有一个取模的操作</p><p><strong>代码如下</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">501</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">4</span>],sum[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//此处用到记忆化搜索，动态规划。</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[maxn*<span class="number">4</span>][maxn*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i!=<span class="number">4</span>*maxn;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//根据表格来看的确是每一行的第一个是1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="comment">//这个地方就是状态转移方程</span></span><br><span class="line">            <span class="comment">//C(a,b)=C(a,b-1)+C(a-1,b-1)根据公式来做的</span></span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            dp[i][j]=dp[i][j]%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">        init();<span class="comment">//这个地方就开始初始化表格了。</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!i) sum[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> sum[i]=sum[i<span class="number">-1</span>];</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">            sum[i] += a[i];</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; sum[i]-a[i]) a[i]=sum[i]-a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i != <span class="number">4</span>; i++)&#123;</span><br><span class="line">            ans *= dp[sum[i]][a[i]];</span><br><span class="line">            ans %=mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==以后学到后面再花时间来深究==</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="题解" scheme="http://crazyfnoption.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="acm" scheme="http://crazyfnoption.github.io/tags/acm/"/>
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="组合数学" scheme="http://crazyfnoption.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>数论基础第一节</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E8%8A%82/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/数论基础第一节/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T14:32:15.084Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>初等数论是用初等方法研究的数论，它的研究方法本质上说，就是利用整数环的整除性质，主要包括整除理论、同余理论、连分数理论。</p><h2 id="整除问题引申到同余问题"><a href="#整除问题引申到同余问题" class="headerlink" title="整除问题引申到同余问题"></a>整除问题引申到同余问题</h2><ul><li><strong>同余的性质</strong></li></ul><p><img src="//crazyfnoption.github.io/2018/12/01/数论基础第一节/15343075827029.jpg" alt=""><br>可以换算成以下式子：<br><strong>a=c(<code>mod</code>b) 这里c为余数，而b为除数</strong></p><ul><li><strong>同余的性质</strong></li></ul><ol><li>自反性 a=a <code>mod</code> m</li><li>对称性 a=b <code>mod</code> m 等价于 b=a <code>mod</code> m</li><li>传递性 a=b <code>mod</code> m 与 b=c <code>mod</code> m 等价于 a=c <code>mod</code> m</li><li>线性合成 a=b <code>mod</code> m 与 c= <code>mod</code> m 等价于 a±c=b±d <code>mod</code> m 与 ac= bd <code>mod</code> m</li><li>消去公因子 ac=bc <code>mod</code> m &amp;&amp; gcd(c,m)=1 等价于 a=b <code>mod</code> m </li></ol><h2 id="素数筛"><a href="#素数筛" class="headerlink" title="素数筛"></a>素数筛</h2><ul><li>朴素筛 一般就是循环2~√n次</li><li>埃拉托斯特尼筛</li></ul><p><strong>循环次数</strong><br><img src="//crazyfnoption.github.io/2018/12/01/数论基础第一节/15343091959776.jpg" alt=""></p><ul><li>欧拉筛</li><li><img src="//crazyfnoption.github.io/2018/12/01/数论基础第一节/15343092628399.jpg" alt=""></li></ul><p><strong>相应代码如下：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="最大公约数以及最小公倍数"><a href="#最大公约数以及最小公倍数" class="headerlink" title="最大公约数以及最小公倍数"></a>最大公约数以及最小公倍数</h2><ul><li><p>最大公约数 函数_gcd(a,b)<br>而多个数的最大公约数 就是 _gcd(a,b,c)=_gcd(gcd(a,b),c)</p></li><li><p>最小公倍数<br>_lcm(a,b)=ab/_gcd(a,b)</p></li></ul><h2 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h2><p><img src="//crazyfnoption.github.io/2018/12/01/数论基础第一节/15343099257598.jpg" alt=""></p><ul><li>关于求解线性同余方程<br><img src="//crazyfnoption.github.io/2018/12/01/数论基础第一节/15343099683275.jpg" alt=""></li><li><p>关于求逆元<br><img src="//crazyfnoption.github.io/2018/12/01/数论基础第一节/15343099966167.jpg" alt=""></p></li><li><p>关于快速幂<br><img src="//crazyfnoption.github.io/2018/12/01/数论基础第一节/15343101054154.jpg" alt=""></p></li></ul><h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p><img src="//crazyfnoption.github.io/2018/12/01/数论基础第一节/15343101566104.jpg" alt=""></p><p><strong>另外</strong><br><img src="//crazyfnoption.github.io/2018/12/01/数论基础第一节/15343103411689.jpg" alt=""></p><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><ul><li><strong>欧拉函数定义</strong><br><img src="//crazyfnoption.github.io/2018/12/01/数论基础第一节/15343107143861.jpg" alt=""></li></ul><ul><li><p><strong>欧拉函数性质</strong><br><img src="//crazyfnoption.github.io/2018/12/01/数论基础第一节/15343107974985.jpg" alt=""></p></li><li><p><strong>求值公式</strong> </p></li></ul><ol><li><img src="//crazyfnoption.github.io/2018/12/01/数论基础第一节/15343109562640.jpg" alt=""></li><li><img src="//crazyfnoption.github.io/2018/12/01/数论基础第一节/15343109655205.jpg" alt=""></li><li><img src="//crazyfnoption.github.io/2018/12/01/数论基础第一节/15343109780637.jpg" alt=""><br>上述公式 可以用来：</li></ol><ul><li><p><strong>求逆元</strong><br><img src="//crazyfnoption.github.io/2018/12/01/数论基础第一节/15343110433806.jpg" alt=""></p></li><li><p><strong>欧拉降幂公式</strong><br><img src="//crazyfnoption.github.io/2018/12/01/数论基础第一节/15343111460573.jpg" alt=""></p></li></ul><h2 id="数论函数"><a href="#数论函数" class="headerlink" title="数论函数"></a>数论函数</h2><p><img src="//crazyfnoption.github.io/2018/12/01/数论基础第一节/15343114512818.jpg" alt=""></p><ul><li><strong>中国剩余定理</strong></li></ul><p><img src="//crazyfnoption.github.io/2018/12/01/数论基础第一节/15343114886344.jpg" alt=""></p><p><strong>解法</strong><br><img src="//crazyfnoption.github.io/2018/12/01/数论基础第一节/15343115089655.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="acm" scheme="http://crazyfnoption.github.io/categories/acm/"/>
    
    
      <category term="acm" scheme="http://crazyfnoption.github.io/tags/acm/"/>
    
      <category term="算法" scheme="http://crazyfnoption.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数论" scheme="http://crazyfnoption.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>条款01：视 C++ 为一个语言联邦</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E6%9D%A1%E6%AC%BE01%EF%BC%9A%E8%A7%86%20C++%20%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/条款01：视 C++ 为一个语言联邦/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T13:08:22.838Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>现在发展的C++已经是一个多重泛型编程语言。</p><hr><p>一个同时<strong>支持过程形式</strong>、<strong>支持面向对象形式</strong>、<strong>函数形式</strong>、<strong>泛型形式</strong>、<strong>元编程形式的语言</strong>，这些能力和弹性使 C++成为了一个无可匹敌的工具。<br>对待其的方式最简单的方法是将其看做是一个由相关语言组成的一个联邦而不是某个次语言。</p><ol><li><p><strong><em>C</em></strong> 说到底 C++ 仍然是 C 的一个延伸，面对过程的编程思想仍然在某些时候很受用，而某些时刻 C++ 的解法只不过就是比 C 高级了一点点，但是当你以 C++的内 C 成分的工作的时候，高效编程则映照出了 C 语言的局限，没有模板，没有异常，没有重载。</p></li><li><p><strong><em>Object-Oriented C++</em></strong> 这部分也就是 C++ 中面对对象编程思想的直接体现，简单来说就是 C with class 比如 类，封装，继承，多态，虚函数的动态绑定。</p></li><li><p><strong><em>Template C++</em></strong> 这是 C++中的泛型编程部分，template 的相关考虑与设计已经弥漫了整个 C++ 而这种编程思想的强大，直接带来了全新的名字 模板元编程，后面得花上大部分时间去专研这个。</p></li><li><p><strong><em>STL</em></strong> 基本上包括 容器，迭代器，算法以及相应的函数对象，一般竞赛可能会直接用到里面的相关容器以及相关算法，熟练使用 STL 也是一名 C++ 程序员应该必备的素质。</p></li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/categories/effective-C/"/>
    
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>条款02：尽量以const,enum,inline 替换掉#define</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E6%9D%A1%E6%AC%BE02%EF%BC%9A%E5%B0%BD%E9%87%8F%E4%BB%A5const,enum,inline%20%E6%9B%BF%E6%8D%A2%E6%8E%89#define/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/条款02：尽量以const,enum,inline 替换掉#define/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T13:08:22.838Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="这个条款其实也就相当于宁可编译器替换预处理器比较好"><a href="#这个条款其实也就相当于宁可编译器替换预处理器比较好" class="headerlink" title="这个条款其实也就相当于宁可编译器替换预处理器比较好"></a><strong>这个条款其实也就相当于宁可编译器替换预处理器比较好</strong></h3><hr><h4 id="1-对于单纯常量而言，使用-const-对象或者是-enums-比-define-更加省时间"><a href="#1-对于单纯常量而言，使用-const-对象或者是-enums-比-define-更加省时间" class="headerlink" title="1. 对于单纯常量而言，使用 const 对象或者是 enums 比 #define 更加省时间"></a>1. 对于单纯常量而言，使用 const 对象或者是 enums 比 #define 更加省时间</h4><ul><li>时间上更为节省 作为一个语言常量而不是名称记号，由于在函数体中分配了内存，追寻起来消耗的时间比在函数中使用名称记号所花的时间更少，因为有实处更容易寻找，不像名称记号，可能有的时候并没有进入到记号表中。</li><li>还有一些其他的只能使用 const 情况 定义常量指针和类的专属常量</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/categories/effective-C/"/>
    
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>条款03：尽可能使用 const</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E6%9D%A1%E6%AC%BE03%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8%20const/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/条款03：尽可能使用 const/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T13:08:22.838Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先使用 const 可以防止后期莫名其妙的进行改变原有的意思，相当于一个约束语义，另外编译器不论什么时候都会强制施行这项约束。</p><ol><li><p>const 在 C++ 11 中有底层和顶层之分，前者是作用于指针本身，指针不再改变指向对象，而顶层 const 则<br>是指针所指向的对象则不能发生改变。</p></li><li><p>const 最具威力的用法实在面对函数声明时的用法，在一个函数的声明式里，const 可以和函数的返回值，各自的参数以及函数自身产生关联。</p></li><li><p>将引用参数设置成 const 好处是在后面写代码的过程中如果把==写成=，可以立马甄别出来。</p></li><li><p>const 成员函数存在的两个理由，一个使 class 的接口一目了然，因为知道了哪些可以被改动对象而哪些不可以被改动对象，第二则是基于代码编写的高效性而言，操作 const 对象成为可能，因为可以通过 const 成员函数返回 const 对象。</p></li><li><p>存在一种特殊情况，重载[ ]运算符的时候，如果成员函数是 const 那么其的返回值也必须是 const&amp;类型的。</p></li><li><p>如果对于const 成员函数，想要改变该对象的内部成员的话，但是又不想全部改变的话，可以在类中的数据成员定义中加上 mutable，来保证可以改变该函数，其存在的意义就在于保证了其他数据成员不能被 const 成员函数改变，但是该数据成员却可以。</p></li></ol><p>7.当 const 和 non-const 成员函数有实质等价的实现时，令 non-const 版本调用 const 版本可避免代码重复。     </p><p><strong><em>这一点还不是特别了解，需要看到后面之后花点时间来看看这一点的内容。</em></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/categories/effective-C/"/>
    
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>条款04：确定对象被使用前已先被初始化</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E6%9D%A1%E6%AC%BE04%EF%BC%9A%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/条款04：确定对象被使用前已先被初始化/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T13:08:22.838Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="在-C-语言中对象的初始化可能会变得异常容易，但是在-C-中某些语境下进行对象可能不会存在自动的初始化过程，也许会在使用-C-part-of-C-会自动有一个初始化过程，但是在其他部分下面的-C-就不能保证初始化过程了。"><a href="#在-C-语言中对象的初始化可能会变得异常容易，但是在-C-中某些语境下进行对象可能不会存在自动的初始化过程，也许会在使用-C-part-of-C-会自动有一个初始化过程，但是在其他部分下面的-C-就不能保证初始化过程了。" class="headerlink" title="在 C 语言中对象的初始化可能会变得异常容易，但是在 C++中某些语境下进行对象可能不会存在自动的初始化过程，也许会在使用 C part of C++ 会自动有一个初始化过程，但是在其他部分下面的 C++就不能保证初始化过程了。"></a>在 C 语言中对象的初始化可能会变得异常容易，但是在 C++中某些语境下进行对象可能不会存在自动的初始化过程，也许会在使用 C part of C++ 会自动有一个初始化过程，但是在其他部分下面的 C++就不能保证初始化过程了。</h4><ol><li><p>特别是在类的过程中，初始化的过程一般直接交给构造函数，初始化的过程并不等同于赋值，所以在写类的构造函数的时候，尽量不要在函数体里面写赋值给私有成员的语句，可以直接在列表上面直接写初始化的。</p></li><li><p>对于拥有多个构造函数，且每个构造函数具有自己的成员初值列，如果这些类存在许多成员变量或者基类的话，多种成员初始列表就会导致不受欢迎的重复，那么这个时候可以遗漏一些“赋值跟初始化过程差不读的成员变量”，改用他们的赋值操作，并且把这些操作放置在 private 中。</p></li><li><p>C++有着十分固定的成员初始化过程，基类的初始化会早于派生类，而类的成员变量总是以其声明的次序被初始化。</p></li><li><p>关于类的静态成员的初始化 一般在类内部进行声明，然后再类的外部进行定义，赋值，其的声明周期一般是从程序开始到程序结束。</p></li><li><p>构造函数初始化的次序非常重要，举个例子就是初始化的时候必须要为数组指定大小，所以指定大小的变量必须具有先值</p></li><li><p>对于不同人在不同时间下不同的源码文件建立起来，其的初始化相对次序并没有明确定义，所以解决办法就是将一个对象搬到自己的专属函数里面去，然后声明成静态成员，并且返回一个引用即可，后面用户直接调用这些函数，就可以无视初始化的次序问题了。具体可以看书里面P32面的相关代码。</p></li><li><p>最后总结一句为了免除“跨编译单元之初始化次序”问题，一般用 local static 对象替换 non-local static 对象。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/categories/effective-C/"/>
    
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>条款05：了解 C++默默编写并调用了哪些函数</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E6%9D%A1%E6%AC%BE05%EF%BC%9A%E4%BA%86%E8%A7%A3%20C++%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/条款05：了解 C++默默编写并调用了哪些函数/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T13:08:22.838Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>几乎每一个 class 都会用一个或多个构造函数，一个析构函数，一个拷贝重载运算符，有些是系统自动生成的合成版本，有些是需要自定义的版本，所以这一条款的目的是为了探寻哪些是需要自己去写，哪一些是需要系统自身合成的。</p><ol><li><p>千万不要写完构造函数或者拷贝构造函数或者是析构函数之后不去定义，那么会造成问题，而且此类问题会造成很多方面上的无法适应问题。</p></li><li><p>另外这里额外需要注意的是 C++11上增加的移动语义，只有在拥有了拷贝构造函数和拷贝赋值运算符之后，编译器才会自动生成移动构造函数，和移动赋值运算符。</p></li><li><p>最后这个条款需要注意的就是编译器自动生成的函数具有普遍性，所以就不具有特异性，一些特殊的操作在合成版本上面可能会出现大问题。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/categories/effective-C/"/>
    
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>条款06：若不想使用编译器自动生成的函数，就应该明确拒绝</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E6%9D%A1%E6%AC%BE06%EF%BC%9A%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E5%BA%94%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/条款06：若不想使用编译器自动生成的函数，就应该明确拒绝/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T13:08:22.838Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="有的时候鉴于某些情况，比如智能指针中-unique-str-和-io-库对象无法发生拷贝和赋值，是因为明确在类的内部进行了拒绝操作，所以无法拷贝与赋值，这一个条款就来讲解有哪些方法可以用来拒绝。"><a href="#有的时候鉴于某些情况，比如智能指针中-unique-str-和-io-库对象无法发生拷贝和赋值，是因为明确在类的内部进行了拒绝操作，所以无法拷贝与赋值，这一个条款就来讲解有哪些方法可以用来拒绝。" class="headerlink" title="有的时候鉴于某些情况，比如智能指针中 unique_str 和 io 库对象无法发生拷贝和赋值，是因为明确在类的内部进行了拒绝操作，所以无法拷贝与赋值，这一个条款就来讲解有哪些方法可以用来拒绝。"></a>有的时候鉴于某些情况，比如智能指针中 unique_str 和 io 库对象无法发生拷贝和赋值，是因为明确在类的内部进行了拒绝操作，所以无法拷贝与赋值，这一个条款就来讲解有哪些方法可以用来拒绝。</h4><ol><li><p>把自己不想要的函数，但是系统默认又会生成的函数放到私有成员中，这种方法很简便，但是有一个缺点就是在类的内部定义中仍然是可以使用拷贝与赋值功能的。</p></li><li><p>继承一个基类，使用 private 继承方法，然后将这个基类的函数放入私有成员中，这样就可以保证万无一失的方法，但是缺点就是太复杂，还需要定一个基类。</p></li><li><p>C++11 提出的新办法将函数声明出来，不仅不去定义，而且直接声明成 delete。这样更便捷。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/categories/effective-C/"/>
    
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>条款07：为多态基类声明 virtual 析构函数</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E6%9D%A1%E6%AC%BE07%EF%BC%9A%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8E%20virtual%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/条款07：为多态基类声明 virtual 析构函数/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T13:08:22.839Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="在进行基类与派生类之间动态绑定的时候，如果发生对象销毁调用的析构函数不是虚函数的话，那么就会造成析构销毁部分的现象。"><a href="#在进行基类与派生类之间动态绑定的时候，如果发生对象销毁调用的析构函数不是虚函数的话，那么就会造成析构销毁部分的现象。" class="headerlink" title="在进行基类与派生类之间动态绑定的时候，如果发生对象销毁调用的析构函数不是虚函数的话，那么就会造成析构销毁部分的现象。"></a>在进行基类与派生类之间动态绑定的时候，如果发生对象销毁调用的析构函数不是虚函数的话，那么就会造成析构销毁部分的现象。</h4><ol><li><p>C++明确指出，当 derived class 对象经由一个 base class指针被删除，而该 base class 带着一个不是虚函数的析构函数的话，其结果往往都是自定义的，就像上述的说法而言，往往是对象的 derived 成分没有被销毁，而且消除这个问题最简单的办法是在基类的析构函数上面加上虚函数的声明。</p></li><li><p>不要随便继承标准库里面的东西，因为里面大部分东西都不存在虚函数的析构函数，这样一来，如果使用动态绑定的话，那么在销毁对象的过程中就没有办法全部销毁了。</p></li><li><p>而且不一定是基类的析构函数设置成虚函数，只要类里面有一个函数是虚函数的话，那么就需要将析构函数定义成虚函数。</p></li><li><p>类的用途不是作为多态的用途的话，那么请不要将析构函数声明成虚函数，因为那样没有作用。</p></li><li><p>对于一个纯虚函数而言，这个类就是一个抽象类，但是由于存在一个析构函数，所以一般要为这个纯虚函数提供定义，其的运作方式是最深层派生的那个类的析构函数最先被调用，然后就是每一个基类的析构函数被调用，所以编译器会在派生类的析构函数中定一个对基类纯虚析构函数的调用动作，因此，一般都得进行调用。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/categories/effective-C/"/>
    
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>条款08：别让异常逃离析构函数</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E6%9D%A1%E6%AC%BE08%EF%BC%9A%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/条款08：别让异常逃离析构函数/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T13:08:22.839Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实这一项条款没有领悟的很深刻，可以理解成不要再析构函数里面写捕获异常之类的代码。因为某些时候，如果在析构函数里面抓获异常导致程序终止的话，那么就可能造成对象不能完全被销毁</p><ol><li><p>析构函数绝对不要吐出异常，如果一个被析构函数调用的函数可能抛出异常的话，析构函数应该做的应该是捕捉任何异常，然后吞下他们（不传播）或者结束程序。</p></li><li><p>如果对象需要对摸个操作函数运行期间抛出的异常做出反应，那么 class 应该提供一个普通函数（不应该在析构函数里面）执行该任务。但是该析构函数里面仍然要进行双保险的析构过程，可以在类的内部定义里面加上一个 bool 变量来判断到底有没有运行析构行为，相当于一般写程序的一个 flag。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/categories/effective-C/"/>
    
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/tags/effective-C/"/>
    
  </entry>
  
</feed>

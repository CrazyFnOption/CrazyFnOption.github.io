<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Magical Beans</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://crazyfnoption.github.io/"/>
  <updated>2018-12-16T17:25:51.680Z</updated>
  <id>http://crazyfnoption.github.io/</id>
  
  <author>
    <name>五光君</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二叉树总结</title>
    <link href="http://crazyfnoption.github.io/2018/12/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93/"/>
    <id>http://crazyfnoption.github.io/2018/12/04/二叉树总结/</id>
    <published>2018-12-04T02:49:43.000Z</published>
    <updated>2018-12-16T17:25:51.680Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="今天花时间整理一下二叉树的一切内容"><a href="#今天花时间整理一下二叉树的一切内容" class="headerlink" title="今天花时间整理一下二叉树的一切内容"></a>今天花时间整理一下二叉树的一切内容</h1><h2 id="下面的部分包括："><a href="#下面的部分包括：" class="headerlink" title="下面的部分包括："></a>下面的部分包括：</h2><ul><li><h3 id="二叉树的创建"><a href="#二叉树的创建" class="headerlink" title="二叉树的创建"></a>二叉树的创建</h3></li><li><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ul><li>二叉树的层序遍历</li><li>二叉树的深度遍历<ul><li>二叉树递归先序遍历</li><li>二叉树递归中序遍历</li><li>二叉树递归后序遍历</li><li>二叉树非递归先序遍历</li><li>二叉树非递归中序遍历</li><li>二叉树非递归后序遍历</li></ul></li></ul></li><li><h3 id="线索树"><a href="#线索树" class="headerlink" title="线索树"></a>线索树</h3></li></ul><h2 id="下面直接贴代码（在代码内部进行注释）："><a href="#下面直接贴代码（在代码内部进行注释）：" class="headerlink" title="下面直接贴代码（在代码内部进行注释）："></a>下面直接贴代码（在代码内部进行注释）：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: tree.cpp</span></span><br><span class="line"><span class="comment">&gt; Author: wangshuxiao</span></span><br><span class="line"><span class="comment">&gt; Mail: wsx1128@outlook.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 二 11/20 18:51:16 2018</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node():left(<span class="number">0</span>),right(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">    Node(<span class="keyword">char</span> e):</span><br><span class="line">    value(e)&#123;left = <span class="number">0</span>;right = <span class="number">0</span>;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> value;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bi_tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bi_tree()=<span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    ~Bi_tree()</span><br><span class="line">    &#123;</span><br><span class="line">        clear();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//由于建树与析构都要使用到递归，所以对于类而言，必须使用另外一个函数来进行递归，才不会影响私有成员</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bulid</span> <span class="params">()</span></span>;</span><br><span class="line">    Node* _bulid (Node *); </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> root == <span class="number">0</span>; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">breath_order</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(Node *t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node *t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(Node *t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">iter_preorder</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">iter_inorder</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">iter_postorder</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Node * <span class="title">get_root</span><span class="params">()</span>    </span>&#123;<span class="keyword">return</span> root;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node *p)</span></span>;</span><br><span class="line">    Node *root;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Bi_tree::clear()</span><br><span class="line">&#123;</span><br><span class="line">    clear(root);</span><br><span class="line">    root = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Bi_tree::clear(Node *n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n-&gt;left)    clear(n-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (n-&gt;right)    clear(n-&gt;right);</span><br><span class="line">        <span class="keyword">delete</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Bi_tree::print(Node *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p-&gt;value &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Bi_tree::bulid()</span><br><span class="line">&#123;</span><br><span class="line">    root = _bulid(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另外这里还是需要注意到的是，由于类的逻辑与C语言的不太相同，所以再循环的时候不能直接返回为空，所以必须要返回一个`Node*`，这样才可以把之前的给联系在一起。</span></span><br><span class="line"><span class="comment">//或者还有一种办法是，使用指针的引用，这样也就是所谓的二级指针，才能造成效果。</span></span><br><span class="line">Node * Bi_tree::_bulid(Node *t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//creat the tree by preorder</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ch ==<span class="string">'#'</span>)</span><br><span class="line">        t = <span class="literal">nullptr</span> ;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        t = <span class="keyword">new</span> Node;</span><br><span class="line">        t-&gt;value = ch;</span><br><span class="line">        t-&gt;left = _bulid(t-&gt;left);</span><br><span class="line">        t-&gt;right = _bulid(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 层序遍历</span></span><br><span class="line"><span class="keyword">void</span> Bi_tree::breath_order()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;Node*&gt; q_tree;</span><br><span class="line">Node *t = root;</span><br><span class="line"><span class="keyword">if</span> ( t != <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">q_tree.push(t);</span><br><span class="line"><span class="keyword">while</span> (!q_tree.empty())</span><br><span class="line">&#123;</span><br><span class="line">t = q_tree.front();</span><br><span class="line">q_tree.pop();</span><br><span class="line">print(t);</span><br><span class="line"><span class="keyword">if</span> (t-&gt;left != <span class="number">0</span>)</span><br><span class="line">q_tree.push(t-&gt;left);</span><br><span class="line"><span class="keyword">if</span> (t-&gt;right != <span class="number">0</span>)</span><br><span class="line">q_tree.push(t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归 先序遍历</span></span><br><span class="line"><span class="keyword">void</span> Bi_tree::preorder(Node *t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t)</span><br><span class="line">    &#123;</span><br><span class="line">        print(t);</span><br><span class="line">        preorder(t-&gt;left);</span><br><span class="line">        preorder(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归 中序遍历</span></span><br><span class="line"><span class="keyword">void</span> Bi_tree::inorder(Node *t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t)</span><br><span class="line">    &#123;</span><br><span class="line">        inorder(t-&gt;left);</span><br><span class="line">        print(t);</span><br><span class="line">        inorder(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归 后序遍历</span></span><br><span class="line"><span class="keyword">void</span> Bi_tree::postorder(Node *t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t)</span><br><span class="line">    &#123;</span><br><span class="line">        postorder(t-&gt;left);</span><br><span class="line">        postorder(t-&gt;right);</span><br><span class="line">        print(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归 先序遍历 使用栈</span></span><br><span class="line"><span class="keyword">void</span> Bi_tree::iter_preorder()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Node*&gt; s_tree;</span><br><span class="line">    Node *t = root;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s_tree.push(t);</span><br><span class="line">        <span class="keyword">while</span> (!s_tree.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            t = s_tree.top();</span><br><span class="line">            s_tree.pop();</span><br><span class="line">            print(t);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (t-&gt;right != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s_tree.push(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s_tree.push(t-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归 中序遍历 使用栈</span></span><br><span class="line"><span class="keyword">void</span> Bi_tree::iter_postorder()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Node*&gt; s_tree;</span><br><span class="line">    Node *p = root , *q = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> ( ;p-&gt;left != <span class="number">0</span>;p = p-&gt;left)</span><br><span class="line">            s_tree.push(p);</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;right == <span class="number">0</span> || p-&gt;right == q)</span><br><span class="line">        &#123;</span><br><span class="line">            print(p);</span><br><span class="line">            q = p;</span><br><span class="line">            <span class="keyword">if</span> (s_tree.empty()) <span class="keyword">return</span> ;</span><br><span class="line">            p = s_tree.top();</span><br><span class="line">            s_tree.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        s_tree.push(p);</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归 后序遍历 使用栈</span></span><br><span class="line"><span class="keyword">void</span> Bi_tree::iter_inorder()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">stack</span> &lt;Node*&gt; s_tree;</span><br><span class="line">    Node *p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right)</span><br><span class="line">                s_tree.push(p-&gt;right);</span><br><span class="line">            s_tree.push(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = s_tree.top();</span><br><span class="line">        s_tree.pop();</span><br><span class="line">        <span class="keyword">while</span> (!s_tree.empty() &amp;&amp; p-&gt;right == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            print (p);</span><br><span class="line">            p = s_tree.top();</span><br><span class="line">            s_tree.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        print(p);</span><br><span class="line">        <span class="keyword">if</span> (!s_tree.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            p = s_tree.top();</span><br><span class="line">            s_tree.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> p = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Bi_tree b;</span><br><span class="line">    b.bulid();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (b.isEmpty()) <span class="built_in">cout</span> &lt;&lt; <span class="string">"空的"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"下面是递归形式的遍历方式"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"递归形式先序遍历"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    b.preorder(b.get_root());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"递归形式后续遍历"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    b.postorder(b.get_root());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" 非递归形式的中序遍历"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    b.iter_inorder();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" 非递归形式的后序遍历"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    b.iter_postorder();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线索树-1"><a href="#线索树-1" class="headerlink" title="线索树"></a>线索树</h3><h4 id="线索二叉树原理"><a href="#线索二叉树原理" class="headerlink" title="线索二叉树原理"></a>线索二叉树原理</h4><p>通过考察各种二叉链表，不管儿叉树的形态如何，空链域的个数总是多过非空链域的个数。准确的说，n各结点的二叉链表共有2n个链域，非空链域为n-1个，但其中的空链域却有n+1个。因此，提出了一种方法，利用原来的空链域存放指针，指向树中其他结点。这种指针称为线索。</p><blockquote><p>记ptr指向二叉链表中的一个结点，以下是建立线索的规则：</p><ol><li>如果ptr-&gt;lchild为空，则存放指向中序遍历序列中该结点的<code>前驱结点</code>。这个结点称为ptr的中序前驱；</li><li>如果ptr-&gt;rchild为空，则存放指向中序遍历序列中该结点的<code>后继结点</code>。这个结点称为ptr的中序后继；</li></ol></blockquote><p>显然，在决定lchild是指向左孩子还是前驱，rchild是指向右孩子还是后继，需要一个区分标志的。因此，我们在每个结点再增设两个标志域ltag和rtag，注意ltag和rtag只是区分0或1数字的布尔型变量，其占用内存空间要小于像lchild和rchild的指针变量。</p><p>其中：</p><ol><li>ltag为0时指向该结点的左孩子，为1时指向该结点的前驱；</li><li>rtag为0时指向该结点的右孩子，为1时指向该结点的后继；</li><li>因此对于上图的二叉链表图可以修改为下图的养子。</li></ol><p><img src="http://blog.chinaunix.net/attachment/201301/17/26548237_1358403668csC7.jpg" alt=""></p><h3 id="线索二叉树的代码实现"><a href="#线索二叉树的代码实现" class="headerlink" title="线索二叉树的代码实现"></a>线索二叉树的代码实现</h3><p>对接下来的例子中，线索二叉树的中序遍历。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="数据结构" scheme="http://crazyfnoption.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="0 - 二叉树 - 算法 - 遍历" scheme="http://crazyfnoption.github.io/tags/0-%E4%BA%8C%E5%8F%89%E6%A0%91-%E7%AE%97%E6%B3%95-%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>海边的卡夫卡的短书评</title>
    <link href="http://crazyfnoption.github.io/2018/12/02/%E6%B5%B7%E8%BE%B9%E7%9A%84%E5%8D%A1%E5%A4%AB%E5%8D%A1%E7%9A%84%E7%9F%AD%E4%B9%A6%E8%AF%84/"/>
    <id>http://crazyfnoption.github.io/2018/12/02/海边的卡夫卡的短书评/</id>
    <published>2018-12-01T17:18:33.000Z</published>
    <updated>2018-12-04T10:24:04.413Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>《海边的卡夫卡》这本书以一个悲剧戏剧为蓝本，进行双线构造，相互交织，相互迎合，从而使一个十五岁的少年的成长历程逐渐完善。虽然取自于俄狄浦斯王中杀父奸母的桥段，但是结局导向以及传达出来的意义绝不一样，前者是悲剧式的自我毁灭以及无常命运的慨叹，而后者则是彻彻底底的自我救赎式的成长。<br>不知有多少人曾在那里流血，你本身也会流血，温暖而又鲜红的血。你的双手将会接住它们，那既是你的血，又是别人的血，而沙尘暴偃旗息鼓的时候，你恐怕还不能完全明白自己是如同从中穿过而得以逃生的。甚至它是否过去都无从判断，不过有一点是你一定是非常清楚的，从沙尘暴中逃生的不再是跨入沙尘暴的你。<br>每一个人的成长都是自由的，但同时却也是不可预测的。村上君用一个十五岁少年的成长史告诉我们在命运的妥协与抗争之间还存在救赎和成长。但是如果仅仅写出少年的成长史的话只能算一般小说。但是村上君肯定不会这样落入俗套，于是他巧妙利用第二条故事线，一个十五岁之后丧失一切的老爷爷的奇遇，这位老爷爷拥有着诸多神奇的能力，但是就是无法思考，记不清楚发生在自己身上的一切，甚至是与整个世界脱轨。看似与第一条故事线没有任何关联，实则丝丝入扣，一个十五岁之后拥有无限可能的人生经历和一个十五岁之后一切都是空白的人生经历相对比，更加深了本文成长与救赎的主题。<br>这本书另一个引人注目的地方也就是作者村上春树对成长中最大的敌人的定义：<br>缺乏想象力的狭隘，苛刻，自以为是的命题，空洞的术语，被篡夺的理想，僵化的思想体系，这些才是最可怕的，但是何为正确，何为不正确，这些都是值得深思的话题，但是某种个体的判断失误，在很多情况下事后不是不可能挽回，只要有勇气主动承认错误，都是可以补救。<br>村上春树这本书以一个全新的视角诠释我们在成长之行上必定会遇到的善与恶，以及一步步走向顽强的心路历程，不要畏惧前方有未知的风暴，因为你是世界上最顽强的是19岁的少年。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="书评" scheme="http://crazyfnoption.github.io/tags/%E4%B9%A6%E8%AF%84/"/>
    
      <category term="村上春树" scheme="http://crazyfnoption.github.io/tags/%E6%9D%91%E4%B8%8A%E6%98%A5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>条款10：令 operator= 返回一个 自身的返回</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E6%9D%A1%E6%AC%BE10%EF%BC%9A%E4%BB%A4%20operator=%20%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%20%E8%87%AA%E8%BA%AB%E7%9A%84%E8%BF%94%E5%9B%9E/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/条款10：令 operator= 返回一个 自身的返回/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-04T10:24:04.411Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一般重载赋值运算符号的时候一般都会返回一个自身的引用，这样可以更方面操作自身，如果仅仅只是返回一个拷贝的对象的话，那么将会在连续使用运算符的时候发生错误，而且在一些较大的类型的话，可能速度会慢些，所以一般返回自身的引用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/categories/effective-C/"/>
    
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>关于模拟与搜索的相应简单题目</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E5%85%B3%E4%BA%8E%E6%A8%A1%E6%8B%9F%E4%B8%8E%E6%90%9C%E7%B4%A2%E7%9A%84%E7%9B%B8%E5%BA%94%E7%AE%80%E5%8D%95%E9%A2%98%E7%9B%AE/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/关于模拟与搜索的相应简单题目/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-04T10:24:04.412Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>题目</strong><br><img src="/2018/12/01/关于模拟与搜索的相应简单题目/15338826192241.jpg" alt=""></p><p><strong>代码如下：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> w,v;</span><br><span class="line">    <span class="keyword">int</span> x,y,m;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;w&gt;&gt;v)&#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        reverse(w.begin(),w.end());</span><br><span class="line">        reverse(v.begin(),v.end());</span><br><span class="line">        <span class="keyword">if</span> (w.size()&gt;v.size())&#123;</span><br><span class="line">            m=w.size()-v.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=v.size();i++)&#123;</span><br><span class="line">                x=w[i]-<span class="string">'0'</span>;</span><br><span class="line">                y=v[i]-<span class="string">'0'</span>;</span><br><span class="line">                x+=y;</span><br><span class="line">                <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                    flag=<span class="number">0</span>;</span><br><span class="line">                    x++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (x&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    x=x<span class="number">-10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ch=x+<span class="string">'0'</span>;</span><br><span class="line">                s.push_back(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i=v.size();</span><br><span class="line">            <span class="keyword">while</span> (flag==<span class="number">1</span>&amp;&amp;i&lt;=m)&#123;</span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">                x=w[i]-<span class="string">'0'</span>;</span><br><span class="line">                x++;</span><br><span class="line">                <span class="keyword">if</span> (x&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    x=x<span class="number">-10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ch=x+<span class="string">'0'</span>;</span><br><span class="line">                s.push_back(ch);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag&amp;&amp;i==w.size())&#123;</span><br><span class="line">                s.push_back(<span class="string">'1'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            m=v.size()-w.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=w.size();i++)&#123;</span><br><span class="line">                x=w[i]-<span class="string">'0'</span>;</span><br><span class="line">                y=v[i]-<span class="string">'0'</span>;</span><br><span class="line">                x+=y;</span><br><span class="line">                <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                    flag=<span class="number">0</span>;</span><br><span class="line">                    x++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (x&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    x=x<span class="number">-10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ch=x+<span class="string">'0'</span>;</span><br><span class="line">                s.push_back(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i=w.size();</span><br><span class="line">            <span class="keyword">while</span> (flag&amp;&amp;i&lt;=m)&#123;</span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">                x=w[i]-<span class="string">'0'</span>;</span><br><span class="line">                x++;</span><br><span class="line">                <span class="keyword">if</span> (x&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    x=x<span class="number">-10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ch=x+<span class="string">'0'</span>;</span><br><span class="line">                s.push_back(ch);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag&amp;&amp;i==v.size())&#123;</span><br><span class="line">                s.push_back(<span class="string">'1'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(s.begin(),s.end());</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>题解：</strong><br>其实这道题目属于一道相应简单的题目，就是要注意相应string与char之间的区别就行了。<br>另外 <code>int</code>转换<code>char</code>是加上‘0’<br><code>char</code>转换<code>int</code>是减去‘0’。</p><h2 id="一道简单的dfs的题目"><a href="#一道简单的dfs的题目" class="headerlink" title="一道简单的dfs的题目"></a>一道简单的dfs的题目</h2><p><img src="/2018/12/01/关于模拟与搜索的相应简单题目/15338976566985.jpg" alt=""></p><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">char</span> h[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;=n||h[i][j]!=<span class="string">'W'</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (j&lt;<span class="number">0</span>||j&gt;=m||h[i][j]!=<span class="string">'W'</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (h[i][j]==<span class="string">'W'</span>)&#123;</span><br><span class="line">        h[i][j]=<span class="string">'.'</span>;</span><br><span class="line">        dfs(i<span class="number">-1</span>,j);</span><br><span class="line">        dfs(i<span class="number">-1</span>,j<span class="number">-1</span>);</span><br><span class="line">        dfs(i+<span class="number">1</span>,j);</span><br><span class="line">        dfs(i+<span class="number">1</span>,j+<span class="number">1</span>);</span><br><span class="line">        dfs(i,j<span class="number">-1</span>);</span><br><span class="line">        dfs(i<span class="number">-1</span>,j+<span class="number">1</span>);</span><br><span class="line">        dfs(i,j+<span class="number">1</span>);</span><br><span class="line">        dfs(i+<span class="number">1</span>,j<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&amp;&amp;(n!=<span class="number">0</span>&amp;&amp;m!=<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=n;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j!=m;j++)&#123;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;h[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j!=m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (h[i][j]==<span class="string">'W'</span>)&#123;</span><br><span class="line">                    dfs(i,j);</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题解简单的dfs搜索出每一种情况，然后让其返回就行了。</p><h2 id="一道经典的BFS的题目"><a href="#一道经典的BFS的题目" class="headerlink" title="一道经典的BFS的题目"></a>一道经典的BFS的题目</h2><p><strong>题目</strong><br><img src="/2018/12/01/关于模拟与搜索的相应简单题目/15346617217857.jpg" alt="-w780"></p><p><strong>代码如下:</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fxy[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//朝着四个方向</span></span><br><span class="line"><span class="keyword">char</span> dis[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> kp[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下的node就作为每一次前进的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,cnt;</span><br><span class="line">    node(<span class="keyword">int</span> a=<span class="number">0</span>,<span class="keyword">int</span> b=<span class="number">0</span>,<span class="keyword">int</span> c=<span class="number">0</span>)&#123;</span><br><span class="line">        x=a; y=b; cnt=c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n,k,g,k1,g1;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;m,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,dis[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//      用队列整合的思想来完成</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;struct node&gt;q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                kp[i][j]=<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//      两种初始化过程，并且找到起点与终点的所在位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[i][j]==<span class="string">'S'</span>)&#123;</span><br><span class="line">                    k=i;</span><br><span class="line">                    g=j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dis[i][j]==<span class="string">'E'</span>)&#123;</span><br><span class="line">                    k1=i;</span><br><span class="line">                    g1=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//        将起点存进去</span></span><br><span class="line">        <span class="function">node <span class="title">a</span><span class="params">(k,g,<span class="number">0</span>)</span></span>;</span><br><span class="line">        q.push(a);</span><br><span class="line">        <span class="comment">//        下面就是为bfs的相应搜索</span></span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">now</span>=<span class="title">q</span>.<span class="title">front</span>();</span></span><br><span class="line">            q.pop();</span><br><span class="line">            kp[now.x][now.y]=now.cnt;</span><br><span class="line">            <span class="comment">//            将起点走了多少步数以及起点的坐标点存入到题目中去</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                node next;</span><br><span class="line">                next.x=now.x+fxy[i][<span class="number">0</span>];</span><br><span class="line">                next.y=now.y+fxy[i][<span class="number">1</span>];</span><br><span class="line">                <span class="comment">//                判断走的下一步有没有出界，或者使下一步走的不会碰到路障</span></span><br><span class="line">                    <span class="keyword">if</span>(next.x&gt;=<span class="number">0</span>&amp;&amp;next.x&lt;m&amp;&amp;next.y&gt;=<span class="number">0</span>&amp;&amp;next.y&lt;n&amp;&amp;dis[next.x][next.y]!=<span class="string">'#'</span>&amp;&amp;kp[next.x][next.y]==<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="function">node <span class="title">empt</span><span class="params">(next.x,next.y,now.cnt+<span class="number">1</span>)</span></span>;</span><br><span class="line">                    q.push(empt);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(kp[k1][g1]==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"Trapped!\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Escaped in %d minute(s).\n"</span>,kp[k1][g1]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>记住上面相应的队列思想。</p><h2 id="一道DFS与BFS的综合题"><a href="#一道DFS与BFS的综合题" class="headerlink" title="一道DFS与BFS的综合题"></a>一道DFS与BFS的综合题</h2><p>==需要多花时间来温习一遍==</p><p><strong>题目</strong><br><img src="/2018/12/01/关于模拟与搜索的相应简单题目/15346690956114.jpg" alt=""></p><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k,cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x_begin,x_end,y_begin,y_end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[maxn][maxn];</span><br><span class="line"><span class="keyword">char</span> ch[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Position</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> distance;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Position() = <span class="keyword">default</span>;</span><br><span class="line">    Position(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c):x(a),y(b),distance(c)&#123;&#125;;</span><br><span class="line">    <span class="function">Position <span class="title">move</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Position Position::move(<span class="keyword">int</span> i)&#123;</span><br><span class="line">    Position post = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)         post.x = <span class="keyword">this</span> -&gt; x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>)    post.x = <span class="keyword">this</span> -&gt; x - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>)    post.y = <span class="keyword">this</span> -&gt; y + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">3</span>)    post.y = <span class="keyword">this</span> -&gt; y - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> post;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Position&gt;q_dis;</span><br><span class="line">    <span class="function">Position <span class="title">p_begin</span> <span class="params">(x_begin,y_begin,<span class="number">0</span>)</span></span>;</span><br><span class="line">    q_dis.push(p_begin);</span><br><span class="line">    <span class="keyword">while</span>(!q_dis.empty())&#123;</span><br><span class="line">        Position now = q_dis.front();</span><br><span class="line">        q_dis.pop();</span><br><span class="line">        dis[now.x][now.y]=now.distance;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">4</span>; i++)&#123;</span><br><span class="line">            Position next;</span><br><span class="line">            next = now.move(i);</span><br><span class="line">            <span class="keyword">if</span> (next.x &gt;= <span class="number">0</span> &amp;&amp; next.x &lt; n &amp;&amp; next.y &gt;= <span class="number">0</span> &amp;&amp; next.y &lt; m &amp;&amp;</span><br><span class="line">                dis[next.x][next.y] == <span class="number">-1</span> &amp;&amp; ch[next.x][next.y] != <span class="string">'#'</span>)&#123;</span><br><span class="line">                <span class="function">Position <span class="title">empt</span> <span class="params">(next.x,next.y,now.distance + <span class="number">1</span>)</span></span>;</span><br><span class="line">                q_dis.push(empt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ch[x][y]==<span class="string">'L'</span>)  &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dis[x][y] == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//  前面已经有dis可以表示每一步走的距离，所以只需要一步一步来看，这样的做法便可以完全规避障碍物，单单从路径上面考虑。</span></span><br><span class="line">    <span class="keyword">if</span> (dis[x][y]==dis[x+<span class="number">1</span>][y]+<span class="number">1</span>)   dfs(x+<span class="number">1</span>,y);</span><br><span class="line">    <span class="keyword">if</span> (dis[x][y]==dis[x<span class="number">-1</span>][y]+<span class="number">1</span>)   dfs(x<span class="number">-1</span>,y);</span><br><span class="line">    <span class="keyword">if</span> (dis[x][y]==dis[x][y+<span class="number">1</span>]+<span class="number">1</span>)   dfs(x,y+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (dis[x][y]==dis[x][y<span class="number">-1</span>]+<span class="number">1</span>)   dfs(x,y<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,Case = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        Case++;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">        <span class="keyword">bool</span> f_begin = <span class="literal">false</span>,f_end = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != m; j++)&#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; ch[i][j];</span><br><span class="line">                dis[i][j] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != m; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (f_end &amp;&amp; f_begin)   <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (ch[i][j] == <span class="string">'L'</span>)&#123;</span><br><span class="line">                    x_begin = i;</span><br><span class="line">                    y_begin = j;</span><br><span class="line">                    f_begin = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ch[i][j] == <span class="string">'C'</span>)&#123;</span><br><span class="line">                    x_end = i;</span><br><span class="line">                    y_end = j;</span><br><span class="line">                    f_end = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bfs();</span><br><span class="line">        <span class="keyword">if</span> (dis[x_end][y_end] == <span class="number">-1</span> ||dis[x_end][y_end] &gt; k )</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span>&lt;&lt;Case&lt;&lt;<span class="string">": "</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            dfs(x_end,y_end);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;Case&lt;&lt;<span class="string">": "</span>&lt;&lt;dis[x_end][y_end]&lt;&lt;<span class="string">" "</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注明一下关于==默认实参==的知识点，因为在这个地方可以直接对类的构造函数赋值一个默认实参，可以避免输入默认构造函数了。</p><p>下面则是一道DFS的题目，这道题目看上去可以用bfs来做</p><p><img src="/2018/12/01/关于模拟与搜索的相应简单题目/15351254685296.jpg" alt="-w1003"></p><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> road[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[i][j] != <span class="number">-1</span>)   <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    <span class="keyword">int</span> Max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (i<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; road[i][j]&gt;road[i<span class="number">-1</span>][j]&amp;&amp;Max&lt;dfs(i<span class="number">-1</span>,j))</span><br><span class="line">        Max = dfs(i<span class="number">-1</span>,j);</span><br><span class="line">    <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n &amp;&amp; road[i][j]&gt;road[i+<span class="number">1</span>][j]&amp;&amp;Max&lt;dfs(i+<span class="number">1</span>,j))</span><br><span class="line">        Max=dfs(i+<span class="number">1</span>,j);</span><br><span class="line">    <span class="keyword">if</span>(j<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; road[i][j]&gt;road[i][j<span class="number">-1</span>]&amp;&amp;Max&lt;dfs(i,j<span class="number">-1</span>))</span><br><span class="line">        Max=dfs(i,j<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(j+<span class="number">1</span>&lt;m &amp;&amp; road[i][j]&gt;road[i][j+<span class="number">1</span>]&amp;&amp;Max&lt;dfs(i,j+<span class="number">1</span>))</span><br><span class="line">        Max=dfs(i,j+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dp[i][j]=Max+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; road[i][j];</span><br><span class="line">                dp[i][j] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> MAX = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                MAX = max (dfs(i,j),MAX);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; MAX &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>此题其实最重要的就在于这个题目不同于其他题目，这个题目找的是最长路径，还不是最短路径，一般来说，BFS找的是最短路径，DFS找的是最短路径的条数。<br>而这里就是利用dfs的返回值（每走一步的最大值，意思就是从各个角度上）记录在dp中，将每一个位置都走到不能走为止，然后存储在dp中，最后找最大值的DP即可。<br>不过自己可以试试遍历的其他方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="题解" scheme="http://crazyfnoption.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="acm" scheme="http://crazyfnoption.github.io/tags/acm/"/>
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="模拟与搜索" scheme="http://crazyfnoption.github.io/tags/%E6%A8%A1%E6%8B%9F%E4%B8%8E%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>树相关题目</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/树相关题目/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-04T10:24:04.413Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="复原二叉树"><a href="#复原二叉树" class="headerlink" title="复原二叉树"></a>复原二叉树</h2><p><img src="/2018/12/01/树相关题目/15337273413710.jpg" alt=""></p><p><strong>题解</strong><br>此道题目就是要注意先序排序与中序排序，一个是根左右，一个是左根右，先序排序的第一个为根，利用递推关系输出每一个根（由于其的递推出口并没有等于号，意思就是说这里同样输出叶子节点）</p><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> pre;</span><br><span class="line"><span class="built_in">string</span> in;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//递归打印这棵树的后序，递归出口为 start &gt; end</span></span><br><span class="line">    <span class="comment">//注意这里不带等于号的原因就是要把叶子节点一样给输出来</span></span><br><span class="line"> <span class="keyword">if</span>(start&gt;end) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> i=start;<span class="comment">//i为 root所代表的值在中序中的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;end&amp;&amp;in[i]!=pre[root])</span><br><span class="line">     i++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt=i-start;<span class="comment">//左子树结点个数</span></span><br><span class="line">    <span class="comment">//由于是先序排序，顺序永远都是根左右，</span></span><br><span class="line">    post(root+<span class="number">1</span>,start,i<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//左节点 因为是后序排序，先把左节点先弄出顺序，在左节点内部在来后序排序，直到两边左边节点大于右边节点</span></span><br><span class="line"></span><br><span class="line">    post(root+<span class="number">1</span>+cnt,i+<span class="number">1</span>,end);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pre[root];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;pre&gt;&gt;in)&#123;</span><br><span class="line">        <span class="keyword">int</span> len=pre.length();</span><br><span class="line">        post(<span class="number">0</span>,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于树的一个简单DFS运用"><a href="#关于树的一个简单DFS运用" class="headerlink" title="关于树的一个简单DFS运用"></a>关于树的一个简单DFS运用</h2><p><img src="/2018/12/01/树相关题目/15338198112868.jpg" alt=""></p><p>题解 简单的dfs运用 可以模拟树的组成，但是特别耗时间，只用用相应的搜索方法来做才容易一点，这道题有必要再做一遍。</p><p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此处实际上是充分利用了vector的特性</span></span><br><span class="line"><span class="comment">//如果此处是二维数组的话，那么一定会浪费许多没必要的空间开支</span></span><br><span class="line"><span class="comment">//所以用一个vector的数组，每个vector存储其对应的祖先</span></span><br><span class="line"><span class="comment">//而一共有题目给出数量的vector</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;people[maxn];</span><br><span class="line"><span class="keyword">char</span> sex[maxn*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line"><span class="keyword">int</span> que[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里e的值只是用来判断到底是该植入值还是该判断值</span></span><br><span class="line"><span class="comment">//换算到这个题目中的意思就是前面一个人不需要看起祖先只需要输入其祖先就行了</span></span><br><span class="line"><span class="comment">//后面一个人则需要做的是根据已有的对方祖先进行判断</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> s,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s&gt;=<span class="number">5</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (e==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=top;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (x==que[i])&#123;</span><br><span class="line">                ans=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> que[top++]=x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=people[x].size();i++)</span><br><span class="line">        dfs(people[x][i],s+<span class="number">1</span>,e);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的递归搜索可以用来因为是从底层向上面进行搜索</span></span><br><span class="line"><span class="comment">//由于孩子祖先有两个所以上面搜索方式每一个孩子的祖先作为单独的节点再次进行搜索，直到递推出口为止</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> x,fa,ma;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;sex[x];</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;fa&gt;&gt;ma;</span><br><span class="line">        <span class="keyword">if</span> (fa!=<span class="number">-1</span>) people[x].push_back(fa);</span><br><span class="line">        <span class="keyword">if</span> (ma!=<span class="number">-1</span>) people[x].push_back(ma);</span><br><span class="line">        sex[fa]=<span class="string">'M'</span>;</span><br><span class="line">        sex[ma]=<span class="string">'F'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=k;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;fa&gt;&gt;ma;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (sex[fa]==sex[ma]) <span class="built_in">cout</span>&lt;&lt;<span class="string">"Never Mind"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            top=<span class="number">0</span>;</span><br><span class="line">            dfs(fa,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">            dfs(ma,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (ans) <span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="题解" scheme="http://crazyfnoption.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="acm" scheme="http://crazyfnoption.github.io/tags/acm/"/>
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="树" scheme="http://crazyfnoption.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>STL的简单总结</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/STL%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/STL的简单总结/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-16T17:25:27.461Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>补一个加快C++输入输出速度的方法：<br><img src="/2018/12/01/STL的简单总结/15335220029444.jpg" alt=""></p><p>花上一天的时间来总结 C++ primer 里面的算法以及容器这一章，多余的用法可以上网去查找当做是相应的扩展。</p><h2 id="字符串-string与字符数组"><a href="#字符串-string与字符数组" class="headerlink" title="字符串 string与字符数组"></a>字符串 string与字符数组</h2><ul><li><p><strong>构造<code>string</code>的方法</strong><br><img src="/2018/12/01/STL的简单总结/15335169766308.jpg" alt=""></p></li><li><p><strong>操作<code>string</code>的方法</strong></p></li></ul><p><img src="/2018/12/01/STL的简单总结/15335172798374.jpg" alt=""><br><img src="/2018/12/01/STL的简单总结/15335172954262.jpg" alt=""><br>上面的成员函数有的说要返回，同时，有的也存在不返回值。</p><ul><li><strong>搜索<code>string</code>的方法</strong></li></ul><p><img src="/2018/12/01/STL的简单总结/15335179836529.jpg" alt=""></p><p><img src="/2018/12/01/STL的简单总结/15335179990314.jpg" alt=""></p><p>以上就是find函数的一些用法，在泛型算法一章，还会继续涉及到。<br><strong>题目返回的是下标</strong></p><p>补充一下关于<code>string</code>中的比较函数<br><img src="/2018/12/01/STL的简单总结/15335183199373.jpg" alt=""><br>一般在string中可以直接用运算符进行比较</p><ul><li><strong><code>int</code>与<code>string</code>之间的转化</strong></li></ul><p><img src="/2018/12/01/STL的简单总结/15335184125849.jpg" alt=""></p><ul><li><strong><code>getline()</code>的两种写法</strong><br><img src="/2018/12/01/STL的简单总结/15334343361243.jpg" alt=""><br>注意在<code>cin&gt;&gt;t</code>;必须要一个<code>getchar()</code>来吞掉其前面的回车符号。<br>之后才能用<code>getline()</code>。</li></ul><h2 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h2><ul><li><strong>容器种类</strong><br><img src="/2018/12/01/STL的简单总结/15334679972152.jpg" alt=""></li></ul><p><code>vector&lt;vector&lt;int&gt; &gt;</code>来表示二维数组。</p><ul><li><strong>容器基础操作</strong><br><img src="/2018/12/01/STL的简单总结/15334684459041.jpg" alt=""><br>补充一个assign的用法：<br>允许从一个不同但相容的类型里面去赋值，或者从容器的一个子序列赋值。</li></ul><p><img src="/2018/12/01/STL的简单总结/15334692047908.jpg" alt=""><br>还有第二个版本：<br>接受一个整型值和一个元素值，用指定数目且具有相同给定元素替换容器中原有的元素：<br><img src="/2018/12/01/STL的简单总结/15334693472336.jpg" alt=""></p><p>再补充一个resize的用法：<br><img src="/2018/12/01/STL的简单总结/15335166722769.jpg" alt=""></p><p>需要记住有一些类型声明可以直接用<code>auto</code>。</p><p>初始化有两种一种<strong>直接初始化</strong>和<strong>拷贝初始化</strong>。</p><ul><li><strong>顺序容器添加元素</strong><br><img src="/2018/12/01/STL的简单总结/15334697068572.jpg" alt=""><br>上面已经列出了各种形式的插入。<br>插入是在迭代器指向的元素之前插入。插入想要插入的元素前面，比如说<code>push_back</code>是插入到了尾后迭代器的前面。<br>而返回的是新添加的第一个元素的迭代器，同样也可也==不返回==。</li></ul><p>这里要注意的是<code>push_front</code>会改变整个容器的迭代器指向，而<code>push_back</code>不会。</p><ul><li><strong>访问元素</strong></li></ul><p><img src="/2018/12/01/STL的简单总结/15334703127503.jpg" alt=""></p><p>链表，单向链表，栈，队列都不支持随机访问，也就不支持下标访问了。</p><ul><li><strong>删除元素</strong><br><img src="/2018/12/01/STL的简单总结/15334705958004.jpg" alt=""></li></ul><p>删除的是迭代器指向的元素，返回的是删除元素的后迭代器也就是被删除的元素下一个元素的前面的迭代器，同样也可以不返回。</p><p><em>这里需要注意的就是删除一个元素之后，必定会改变原容器中迭代器的指向，所以务必小心（除了<code>pop_back</code>）</em></p><ul><li><strong>改变容器大小的操作</strong></li></ul><p><img src="/2018/12/01/STL的简单总结/15335167464723.jpg" alt=""></p><ul><li><strong>特殊的forward_list（单向链表）</strong></li></ul><p><img src="/2018/12/01/STL的简单总结/15334712839686.jpg" alt=""></p><p>由于迭代器的添加删除操作都涉及到了首前和尾后，所以对于单向链表来说这里添加了一个首前迭代器<code>before_begin</code><br>而对于单向链表的插入而言 是在元素的后面进行插入，删除也是一样，指向都是迭代器指向元素之后的元素。</p><h2 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h2><p><img src="/2018/12/01/STL的简单总结/15335188187528.jpg" alt=""></p><ul><li>**关联容器里面的<code>pair</code></li></ul><p><img src="/2018/12/01/STL的简单总结/15335191398555.jpg" alt=""></p><ul><li><strong>关联容器的操作</strong></li></ul><p><img src="/2018/12/01/STL的简单总结/15335192848295.jpg" alt=""></p><ul><li><strong>关联容器的添加操作</strong></li></ul><p><img src="/2018/12/01/STL的简单总结/15335195440945.jpg" alt=""></p><p>一般都是直接用下标操作添加<code>map</code>里面的操作。<br><code>at</code>操作只能判断存不存在</p><ul><li><strong>关联容器的删除操作</strong></li></ul><p><img src="/2018/12/01/STL的简单总结/15335202245929.jpg" alt=""></p><ul><li><strong>关联容器的访问操作</strong></li></ul><p><img src="/2018/12/01/STL的简单总结/15335205177307.jpg" alt=""><br>上面关于排序的操作不适用于无序的关联容器。</p><p><strong>当允许关键词重复的multimap中查找元素时，一般使用find函数与count函数同时进行。</strong></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>大部分函数算法都放在<code>&lt;algorithm&gt;</code>的头文件里面了。<br>还有一些数值算法是放在了<code>&lt;numeric&gt;</code>的头文件里面。</p><ul><li><strong>只读算法</strong></li></ul><p>accumulate 求和算法，接受三个参数，前面两个参数是累加范围，第三个是和的初值。<br>equal 判断两个序列里面是否所有的值都相同。<br>后面网上查找 有的再补充。<br>find算法<br>binary_search()二分查找函数<br>find_end()最后一次出现算法<br>find_first_of()第一次出现的算法<br>find_if ()第三个参数就为自定义函数搜索<br>lower_bound()第一个不小于的元素<br>upper_bound()第一个大于的元素<br>count（）算法 计算出现次数<br>count_if（）函数自定义计数</p><ul><li><strong>写容器的算法</strong></li></ul><p>fill 填充算法 类似于memset函数前者在于可以赋值赋任何值，而后者理论上只能赋值0或者1或者0x3f3f3f3f。<br>fill_n也是三个参数，第一个是开始点，第二个是赋值数目，第三个为赋值初始化。<br>copy 拷贝算法，接收三个迭代器，前面两个表示输入范围，第三个为拷贝目标序列的起点。<br>replace 替换算法，将目标序列里面的某些值更改成某些值，接受四个参数，前面两个是目标序列的范围，第三个是要搜索的值，第四个是要将搜索到的第三个的值更改后的值。<br>remove 去除掉函数里面包括的参数的元素。<br>remove_if 自定义。<br>remove_copy 拷贝结果。<br>swap（）交换两个对象的值。<br>swap_range()交换两个序列的值。</p><ul><li><strong>重排容器的算法</strong></li></ul><p>其排序的算法中，定义的排序方式就在于自定义函数传入算法中。<br>有三种自定义函数：</p><ol><li>普通bool型自定义函数，比较排列顺序。</li><li>lambda 匿名小函数。</li><li>bind 函数 绑定谓词。灵活的应用自定义函数。</li></ol><p>unique 将容器中所有重复的值全部排列到后面去，接受目标序列的迭代器范围，返回指向第一个重复元素的迭代器。<br>sort 排序 本质上运用的是快速排序。<br>stable_sort 本质上运动的是归并排序。<br>stable_partition 前面进行排序后，把自定义排列的分割开来。<br>reverse 倒排函数。<br>reverse_copy 倒排函数。<br>rotate 接受三个参数，前面两个是要往后面排的范围。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul><li><p><strong>插入迭代器</strong><br>back_inserter 类似于push_back的迭代器，创建并且使用<br>front_inserter 创建并且使用一个push_front的迭代器<br>inserter 创建一个普通插入的迭代器</p></li><li><p><strong>流迭代器</strong><br>istream_iterator 输入迭代器<br><img src="/2018/12/01/STL的简单总结/15335260532129.jpg" alt=""></p></li></ul><p>ostream_iterator 输出迭代器<br><img src="/2018/12/01/STL的简单总结/15335260817218.jpg" alt=""></p><ul><li><strong>反向迭代器</strong><br>reverse_iterator</li><li><strong>移动迭代器</strong><br>后面复习到在总结 移动、拷贝、右值引用。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="acm" scheme="http://crazyfnoption.github.io/categories/acm/"/>
    
    
      <category term="acm" scheme="http://crazyfnoption.github.io/tags/acm/"/>
    
      <category term="数据结构" scheme="http://crazyfnoption.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="STL" scheme="http://crazyfnoption.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>一道STL的题解题目，需要以后花时间理解题目意思</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E4%B8%80%E9%81%93STL%E7%9A%84%E9%A2%98%E8%A7%A3%E9%A2%98%E7%9B%AE%EF%BC%8C%E9%9C%80%E8%A6%81%E4%BB%A5%E5%90%8E%E8%8A%B1%E6%97%B6%E9%97%B4%E7%90%86%E8%A7%A3%E9%A2%98%E7%9B%AE%E6%84%8F%E6%80%9D/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/一道STL的题解题目，需要以后花时间理解题目意思/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-04T10:24:04.410Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2018/12/01/一道STL的题解题目，需要以后花时间理解题目意思/15334616821861.jpg" alt=""></p><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">//#include&lt;function&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> fort = <span class="number">1314</span>;</span><br><span class="line"></span><br><span class="line">ll a[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//这道题目就换一种思考方式，让基数分贝加上加数，这样一来，就会简化很多步骤</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[<span class="number">0</span>]&gt;&gt;a[<span class="number">1</span>]&gt;&gt;a[<span class="number">2</span>];</span><br><span class="line">        a[<span class="number">3</span>] = <span class="number">5</span>;</span><br><span class="line">        a[<span class="number">4</span>] = <span class="number">2</span>;</span><br><span class="line">        a[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">        sort(a,  a + <span class="number">6</span>,</span><br><span class="line">        [](<span class="keyword">const</span> ll &amp;a,<span class="keyword">const</span> ll &amp;b)&#123;<span class="keyword">return</span> a&gt;b;&#125;);</span><br><span class="line">        priority_queue&lt;ll, <span class="built_in">vector</span>&lt;ll&gt;, greater&lt;ll&gt; &gt; pq;</span><br><span class="line">        <span class="built_in">set</span>&lt;ll&gt;s;</span><br><span class="line">        <span class="built_in">set</span>&lt;ll&gt;ans;</span><br><span class="line">        pq.push(<span class="number">1</span>);</span><br><span class="line">        s.insert(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;;i++)&#123;</span><br><span class="line">            ll x = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            <span class="keyword">if</span>(i)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">3</span>;k &lt; <span class="number">6</span>;k++)&#123;</span><br><span class="line">                    ans.insert(x - a[k]);</span><br><span class="line">                    <span class="keyword">if</span>(ans.size()==fort)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ans.size()==fort)&#123;</span><br><span class="line">                    <span class="comment">/*int ttt = 1;</span></span><br><span class="line"><span class="comment">                    for(set&lt;ll&gt;::iterator it = ans.begin();it!=ans.end();it++)</span></span><br><span class="line"><span class="comment">                        cout&lt;&lt;ttt++&lt;&lt;' '&lt;&lt;*it&lt;&lt;endl;*/</span></span><br><span class="line">                    <span class="keyword">auto</span> it = ans.rbegin();</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">                ll x2=x*a[j];</span><br><span class="line">                <span class="keyword">if</span>(!s.count(x2))&#123;</span><br><span class="line">                    s.insert(x2);</span><br><span class="line">                    pq.push(x2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="题解" scheme="http://crazyfnoption.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="acm" scheme="http://crazyfnoption.github.io/tags/acm/"/>
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="STL" scheme="http://crazyfnoption.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>一道有趣的题目——逆波兰计算器</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E4%B8%80%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A2%98%E7%9B%AE%E2%80%94%E2%80%94%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/一道有趣的题目——逆波兰计算器/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-04T10:24:04.410Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2018/12/01/一道有趣的题目——逆波兰计算器/15334382488561.jpg" alt=""></p><p><strong>题解</strong><br>首先这道题毫无疑问是要用到stringstream流的。分别依次读取字符串，并且将其导入到char型的代码中去。比如说a+b可以变成ab+，这里最好运用到栈的知识，来控制出栈与进栈。<br>==注意以下几个地方==</p><ol><li>注意输入<code>cin&gt;&gt;t</code>以后，需要用<code>getchar()</code>来清空上一个步骤留下来的回车符号</li><li>注意此处需要严格进行判断栈内是否为空。</li><li>这里是将乘除求模的运算放在最右边，这样就可以有优先级存在了</li><li>括号会提前进行一步运算，然后消除掉左括号，或者左边的所有运算式，进行一个结算。</li><li>map这里存在的意义就在于 为判断进行提供条件。</li><li>此道题目涉及字符串，栈，模拟的相应算法，需要有空的时候可以多看看。</li></ol><p><strong>代码如下：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt;ope;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;num;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m[<span class="string">'+'</span>]=m[<span class="string">'-'</span>]=<span class="number">1</span>;</span><br><span class="line">    m[<span class="string">'*'</span>]=m[<span class="string">'/'</span>]=m[<span class="string">'%'</span>]=m[<span class="string">'('</span>]=m[<span class="string">')'</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(!num.empty())</span><br><span class="line">        num.pop();</span><br><span class="line">    <span class="keyword">while</span>(!ope.empty())</span><br><span class="line">        ope.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此处为基本的运算规模。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">op1</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b,<span class="keyword">const</span> <span class="keyword">char</span> &amp;c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c ==<span class="string">'+'</span>)    a += b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'-'</span>) a=b-a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'*'</span>) a*=b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'/'</span>) a=b/a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'%'</span>) a=b%a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此处就是控制出栈的运算，一般就是括号内部的计算了。算出每一个括号内部的运算式。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">op2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = ope.top();</span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">'('</span>&amp;&amp;!ope.empty())&#123;</span><br><span class="line">        ope.pop();</span><br><span class="line">        <span class="keyword">int</span> a = num.top();</span><br><span class="line">        num.pop();</span><br><span class="line">        <span class="keyword">int</span> b = num.top();</span><br><span class="line">        num.pop();</span><br><span class="line">        op1(a,b,ch);</span><br><span class="line">        num.push(a);</span><br><span class="line">        <span class="keyword">if</span> (!ope.empty())</span><br><span class="line">            ch = ope.top();</span><br><span class="line">    &#125;<span class="comment">//这个下面要注意的判断条件中一定要加上判断是否为空。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ope.empty()&amp;&amp;ope.top() ==<span class="string">'('</span>)</span><br><span class="line">        ope.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">        getline(<span class="built_in">cin</span>,str);</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">s</span><span class="params">(str)</span></span>;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">char</span> tmp;</span><br><span class="line">        <span class="keyword">while</span> (s&gt;&gt;tmp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;=<span class="string">'0'</span>&amp;&amp;tmp&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">do</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (m[tmp]) <span class="keyword">break</span>;</span><br><span class="line">                    x *= <span class="number">10</span>;</span><br><span class="line">                    x += tmp - <span class="string">'0'</span>;<span class="comment">//此处是将char转换成int</span></span><br><span class="line">                &#125;<span class="keyword">while</span>(s&gt;&gt;tmp);</span><br><span class="line">                num.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//注意这个地方的高明之处就在于碰见‘）’的返回，以及判断有没有‘（’，</span></span><br><span class="line">            比如连加的情况就把加减乘除的优先运算级给表示出来了。</span><br><span class="line">            <span class="comment">//最后相当于将运算优先级高的全部放到了右边，然后有括号的就先解决括号，</span></span><br><span class="line">            及时左括号被提前弄没了也不要紧，存在有右括号就行，然后乘除永远放在加减的左边。</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (tmp==<span class="string">')'</span>) op2();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m[tmp]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!ope.empty()&amp;&amp;ope.top()!=<span class="string">'('</span>)</span><br><span class="line">                    op2();</span><br><span class="line">                ope.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m[tmp]) ope.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = num.top();</span><br><span class="line">        num.pop();</span><br><span class="line">        <span class="keyword">while</span> (!num.empty()&amp;&amp;!ope.empty())&#123;</span><br><span class="line">            op1(ans,num.top(),ope.top());</span><br><span class="line">            ope.pop();</span><br><span class="line">            num.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="题解" scheme="http://crazyfnoption.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="acm" scheme="http://crazyfnoption.github.io/tags/acm/"/>
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="STL" scheme="http://crazyfnoption.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>一道计算机几何算法相关题目</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E4%B8%80%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%87%A0%E4%BD%95%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/一道计算机几何算法相关题目/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-04T10:24:04.410Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>题目：</strong></p><p><img src="/2018/12/01/一道计算机几何算法相关题目/15349459741854.jpg" alt=""></p><p><strong>代码如下：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> v,s,b;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;v&gt;&gt;s&gt;&gt;b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s&lt;b)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> x = (v * v) / <span class="number">9.8</span>;</span><br><span class="line">        <span class="keyword">if</span> ( x &lt; s ) &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"move "</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">2</span>)&lt;&lt;s-x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> b = (s * <span class="number">9.8</span>) / (v * v);</span><br><span class="line">            <span class="comment">//注意反函数的转换。</span></span><br><span class="line">            <span class="keyword">double</span> a = <span class="built_in">asin</span>(b) * <span class="number">90</span> / pi;</span><br><span class="line">            <span class="comment">//这里有一个进一的操作，因为此题不太会去四舍五入。</span></span><br><span class="line">            <span class="keyword">int</span> a_ = a;</span><br><span class="line">            <span class="keyword">if</span> (a-a_ &gt;= <span class="number">0.5</span>) a_++;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"a "</span>&lt;&lt;a_&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>关于这道题目的相关要点</strong></p><ol><li><p>反函数相关要点。<br>注意 反函数最后输出的是 一个弧度值，根据相应数学的算法而言<br>记住 ==弧度值=角度*pi/180==</p></li><li><p>关于输出中进1的相关操作。<br>按照第几位，先换算成相应的整形数，最后再强转成int型 最后在判断是否大于0.5来考虑时候来加一。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="题解" scheme="http://crazyfnoption.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="acm" scheme="http://crazyfnoption.github.io/tags/acm/"/>
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="STL" scheme="http://crazyfnoption.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>关于STL里面函数简单的应用</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E5%85%B3%E4%BA%8ESTL%E9%87%8C%E9%9D%A2%E5%87%BD%E6%95%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/关于STL里面函数简单的应用/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-04T10:24:04.411Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2018/12/01/关于STL里面函数简单的应用/15334646368898.jpg" alt=""></p><p><strong>代码如下：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line">    s.insert(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i!=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这道题目的主要做法是记住几个upper_bound 的STL函数</span></span><br><span class="line">        <span class="keyword">if</span>(t &lt; *s.rbegin()) &#123;</span><br><span class="line">            s.erase(*(s.upper_bound(t)));</span><br><span class="line">        &#125;</span><br><span class="line">        s.insert(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="题解" scheme="http://crazyfnoption.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="acm" scheme="http://crazyfnoption.github.io/tags/acm/"/>
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="STL" scheme="http://crazyfnoption.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>二分法思想</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E4%BA%8C%E5%88%86%E6%B3%95%E6%80%9D%E6%83%B3/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/二分法思想/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-16T17:24:41.997Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>实现在单调有序的集合中查找元素，每次江集合分为左右两个部分，并且通过判断集合在哪个部分从而调整集合的上下界，重复知道找到目标元素为止。</p><p>举一个简单的例子，我要在1到100里面查找62，先拿62根这个其最中间的一个数进行比较。然后在一步一步的缩小集合的上下界，最后再来一步一步往里面缩</p><p><strong>下面是C++STL里面二分查找的函数：</strong></p><blockquote><p>binary_search  返回bool值,是否存在<br>lower_bound    返回可插入的最小位置的迭代器                                                                  即返回第一个符合条件的元素位置<br>upper_bound    返回可插入的最大位置的迭代器<br>               即返回最后一个符合条件的元素位置</p></blockquote><p>在二分查找里面最典型的题目就是二分逼近求方程式的根了。</p><p><img src="/2018/12/01/二分法思想/15333828636681.jpg" alt=""></p><p><strong>代码如下</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pre =<span class="number">1e-4</span>;</span><br><span class="line"><span class="keyword">double</span> x,y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">8</span>*<span class="built_in">pow</span>(x,<span class="number">4</span>)+<span class="number">7</span>*<span class="built_in">pow</span>(x,<span class="number">3</span>)+<span class="number">2</span>*<span class="built_in">pow</span>(x,<span class="number">2</span>)+<span class="number">3</span>*x+<span class="number">6</span>-y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;y;</span><br><span class="line">        <span class="keyword">double</span> x1=<span class="number">0</span>,x2=<span class="number">100</span>;<span class="comment">//先把上下界在这里确定好</span></span><br><span class="line">        <span class="keyword">double</span> mid=(x1+x2)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (f(x1)*f(x2)&gt;<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"No solution!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (x2-x1&gt;=pre)&#123;<span class="comment">//这里必须写的是上下界线是多少，</span></span><br><span class="line">            不能写的是用于判断mid的条件。</span><br><span class="line">                <span class="keyword">if</span> (f(x1)*f(mid)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    x2=mid;</span><br><span class="line">                    mid=(x1+x2)/<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    x1=mid;</span><br><span class="line">                    mid=(x1+x2)/<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">4</span>)&lt;&lt;mid&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面就是我第二次出错的地方，判断二分循环逼近的的条件不应该看mid的取值，而是应该看得是区间上界减去区间下界的范围从而来限定。</p><p>此处关于三分法的求解：<br>当需要求某凸性或凹形函数的极值，通过函数本身表达式并不容易求解时，就可以用三分法不断逼近求解。</p><p>三分法——求解凸性函数的极值问题<br><a href="http://hi.baidu.com/vfxupdpaipbcpuq/item/81b21d1910ea729c99ce33db" target="_blank" rel="noopener">http://hi.baidu.com/vfxupdpaipbcpuq/item/81b21d1910ea729c99ce33db</a></p><p>经典例题：<br>侵略的奶牛：<br><img src="/2018/12/01/二分法思想/15334016401434.jpg" alt=""></p><p><strong>代码如下：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn],n,c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此过程就是在判断奶牛之间的间隔为这个值合不合适</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cc</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=a[<span class="number">0</span>],cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i!=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i]-t&gt;=d)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            t=a[i];</span><br><span class="line">            <span class="keyword">if</span> (cnt&gt;=c)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此过程就是在收录每一个值，然后再分别进行判断</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,y=a[n<span class="number">-1</span>]-a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span> (x&lt;=y)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(x+y)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (cc(mid))    x=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>    y=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不过这种最大值最小值的题目需要多花时间想想。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;c)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=n;i++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        sort(a,a+n);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;solve()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>==下面则是其他地方关于二分的题目==<br><strong>基础版</strong></p><blockquote><p>POJ 3122 Pie<br>  二分枚举区间是实数<br>POJ 1064 Cable master<br>    二分枚举区间是实数,注意精度<br>POJ 3258 River Hopscotch<br>     最大化最小值<br>POJ 3273 Monthly Expense<br>    最小化最大值<br>LIGHTOJ 1076 Get the Containers<br>    最小化最大值，。和上一个差不多<br>LIGHTOJ 1307 Counting Triangles </p></blockquote><p><strong>进阶版</strong></p><blockquote><p>POJ 3579      二分搜索+二分查找<br>POJ 3685      二分搜索+二分查找<br>ZOJ 3278      也是两个二分嵌套<br>LIGHTOJ 1048<br>和LightOJ 1076一样，不过要输出一组解<br>LIGHTOJ 1383    二分加贪心（区间）<br>ZOJ 3665 某年区域赛题。，二分枚举<br>ZOJ 3726 去年区域赛题，二分查找<br>codeforces 382B 有意思的题<br>codeforces 391D2 难，。。，，、</p></blockquote><p>==下面就是关于三分的题目==</p><blockquote><p>poj3301<br>hdu4454<br>hdu3714<br>hdu2438</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="acm" scheme="http://crazyfnoption.github.io/categories/acm/"/>
    
    
      <category term="acm" scheme="http://crazyfnoption.github.io/tags/acm/"/>
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="STL" scheme="http://crazyfnoption.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/贪心算法/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-04T10:24:04.413Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>贪心算法的本质目的也就在于对于一个问题来看，我可以用最简单的办法算出局部的解集，并且按照这个最简单的办法同样可以算出该问题的最终解决办法，即贪心算法。</p><h3 id="三个经典的贪心算法问题"><a href="#三个经典的贪心算法问题" class="headerlink" title="三个经典的贪心算法问题"></a>三个经典的贪心算法问题</h3><ol><li>事件的序列问题：<br> <img src="/2018/12/01/贪心算法/15333634457989.jpg" alt=""><br><img src="/2018/12/01/贪心算法/15333634528118.jpg" alt=""></li></ol><p>遇到这样的题目，首先就是要想着能不能找到最长的子序列的前提，到底是按节目的开始时间进行排序，还是按照节目的结束时间进行排序。<br><strong>下面就是核心代码</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Show</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> beg;</span><br><span class="line">    <span class="keyword">int</span> en;</span><br><span class="line">&#125;show[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;show[i].beg&gt;&gt;show[i].en;</span><br><span class="line">        &#125;</span><br><span class="line">        stable_sort(show,show+n,</span><br><span class="line">        [](<span class="keyword">const</span> Show &amp;a, <span class="keyword">const</span> Show &amp;b)&#123;<span class="keyword">return</span> a.en&lt;b.en;&#125;);</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (show[i].beg&gt;=show[j].en)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                j=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此处的关键就是从第一个开始把结束时间最早的进行一个相对位置的排序，然后把第一个结束的与后面开始的时间进行挨个挨个的比较，最终得出的结果就是在这里。</p><ol start="2"><li>区间覆盖问题<br><img src="/2018/12/01/贪心算法/15333675702356.jpg" alt=""><br><strong>下面就是这道题目的核心代码：</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">greedy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="keyword">int</span> i,sum = <span class="number">1</span>,n=x.size();</span><br><span class="line">　　sort(x.begin(),x.end());</span><br><span class="line">　　<span class="keyword">int</span> temp = x[<span class="number">0</span>];<span class="comment">//区间的起始位置</span></span><br><span class="line">　　<span class="keyword">for</span>(i=<span class="number">1</span>;i &lt; n; ++i)</span><br><span class="line">　　　　<span class="keyword">if</span>(x[i] - temp &gt; k)　　&#123;sum++,temp=x[i]&#125;;</span><br><span class="line">　　<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>题目这里就是<br>分别计数，用一个最简单的思维做出一整道题目的思路。</p><ol start="3"><li>区间相交问题：<br><img src="/2018/12/01/贪心算法/15333716368154.jpg" alt=""><br>其实就是跟第一道题目类似</li></ol><p>算连续的序列 并且把总长度减去这些连续的序列之后得到的是剩余的区间，即得到题目答案。</p><p>==以后若还有关于贪心类型的题目可以继续往上面加==</p><p><strong>一下就是贪心的习题</strong></p><p><img src="/2018/12/01/贪心算法/15333719681518.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="题解" scheme="http://crazyfnoption.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="acm" scheme="http://crazyfnoption.github.io/tags/acm/"/>
    
      <category term="贪心" scheme="http://crazyfnoption.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>条款27：尽量少做转型动作</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E6%9D%A1%E6%AC%BE27%EF%BC%9A%E5%B0%BD%E9%87%8F%E5%B0%91%E5%81%9A%E8%BD%AC%E5%9E%8B%E5%8A%A8%E4%BD%9C/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/条款27：尽量少做转型动作/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-04T10:24:04.413Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C++ 规则的设计目标之一就是，保证“类型错误” 绝不可能发生，但是在 C++的某些特殊的情形下面不得不去使用转型这一特性，而 C 语言的转型语句则类似于以下：<br><img src="/2018/12/01/条款27：尽量少做转型动作/20.png" alt=""></p><p>然而 C++提供四种新式的类型转换</p><p><img src="/2018/12/01/条款27：尽量少做转型动作/21.png" alt=""></p><p><strong>注意</strong> 在真正进行类型转换的时候，我们不能仅仅认为编译器到最后仅仅只是更改一个文件名字，编译器改变的底层的编码，比如 int 转型到 double 之间底层描述是不一样的。</p><p>另外 C++中的一个特性使得多重继承的时候，一个对象含有多个地址。</p><ul><li><p>所以需要注意的是以下几点，如果可以的话，尽量避免转型，特别是在注重代码中避免dynamic_cast. 如果有设计需要转型动作的话，去试试无需转型的替代设计。</p></li><li><p>如果转型是必要的，那么试着将其隐藏在某个函数背后。客户随后可以调用该函数，而不需要讲转型放进他们自己的代码中。</p></li><li><p>宁可使用 C++新式的转型，也不要使用旧式的转型，前者很容易识别出来，而且也有着不叫分们别类的职掌。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/categories/effective-C/"/>
    
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>关于组合数学，两道思维题目，这里贴两道题目</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E5%85%B3%E4%BA%8E%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%8C%E4%B8%A4%E9%81%93%E6%80%9D%E7%BB%B4%E9%A2%98%E7%9B%AE%EF%BC%8C%E8%BF%99%E9%87%8C%E8%B4%B4%E4%B8%A4%E9%81%93%E9%A2%98%E7%9B%AE/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/关于组合数学，两道思维题目，这里贴两道题目/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-04T10:24:04.411Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第一道-简单的排列组合："><a href="#第一道-简单的排列组合：" class="headerlink" title="第一道 简单的排列组合："></a>第一道 简单的排列组合：</h2><p><img src="/2018/12/01/关于组合数学，两道思维题目，这里贴两道题目/15334551294656.jpg" alt=""></p><p><strong>题解如下：</strong></p><blockquote><p>题目大致可以理解为4堆牌a,b,c,d，每次从一堆牌里拿出牌顶的一张牌，问共有多少种拿法。其实我们可以一堆一堆的分析，假设只有一堆a时只有1种拿法，那两堆a,b时我们可以认为是从a个牌中插入b张牌，用数学表达式就是<strong>==C(b,a+b)==</strong>;那么三堆的话我们可以把前两堆看成一堆，那么表达式就是<strong>==C(c,a+b+c)==</strong>，这是我们需要与前两堆的组成方法相乘，就是<strong>==C(b,a+b)C(c,a+b+c)==</strong>。<br>4堆的话就是<strong>==C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)==</strong>。<br>所以答案就是<strong>==C(a,a)C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)==</strong>。<br>此外，有一公式==<strong>C(a,b)=C(a,b-1)+C(a-1,b-1)</strong>==，所以我们用数组来代替C(m,n)操作</p></blockquote><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">501</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">4</span>],sum[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//此处用到记忆化搜索，动态规划。</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[maxn*<span class="number">4</span>][maxn*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i!=<span class="number">4</span>*maxn;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//根据表格来看的确是每一行的第一个是1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="comment">//这个地方就是状态转移方程</span></span><br><span class="line">            <span class="comment">//C(a,b)=C(a,b-1)+C(a-1,b-1)根据公式来做的</span></span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="comment">//dp[i][j]=dp[i][j]%mod;</span></span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">        init();<span class="comment">//这个地方就开始初始化表格了。</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!i) sum[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> sum[i]=sum[i<span class="number">-1</span>];</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">            sum[i] += a[i];</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; sum[i]-a[i]) a[i]=sum[i]-a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i != <span class="number">4</span>; i++)&#123;</span><br><span class="line">            ans *= dp[sum[i]][a[i]];</span><br><span class="line">            <span class="comment">//ans %=mod;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二题-第一题的变式："><a href="#第二题-第一题的变式：" class="headerlink" title="第二题 第一题的变式："></a>第二题 第一题的变式：</h2><p><img src="/2018/12/01/关于组合数学，两道思维题目，这里贴两道题目/15334588459331.jpg" alt=""></p><p>题解如上，与上面一题有区别的地方就在于要有一个取模的操作</p><p><strong>代码如下</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">501</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">4</span>],sum[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//此处用到记忆化搜索，动态规划。</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[maxn*<span class="number">4</span>][maxn*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i!=<span class="number">4</span>*maxn;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//根据表格来看的确是每一行的第一个是1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="comment">//这个地方就是状态转移方程</span></span><br><span class="line">            <span class="comment">//C(a,b)=C(a,b-1)+C(a-1,b-1)根据公式来做的</span></span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            dp[i][j]=dp[i][j]%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">        init();<span class="comment">//这个地方就开始初始化表格了。</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!i) sum[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> sum[i]=sum[i<span class="number">-1</span>];</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">            sum[i] += a[i];</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; sum[i]-a[i]) a[i]=sum[i]-a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i != <span class="number">4</span>; i++)&#123;</span><br><span class="line">            ans *= dp[sum[i]][a[i]];</span><br><span class="line">            ans %=mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==以后学到后面再花时间来深究==</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="题解" scheme="http://crazyfnoption.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="acm" scheme="http://crazyfnoption.github.io/tags/acm/"/>
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="组合数学" scheme="http://crazyfnoption.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>数据结构相应总结</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%BA%94%E6%80%BB%E7%BB%93/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/数据结构相应总结/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-04T00:13:06.615Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ol><li><p>栈的概念<br>此处只需要记住栈的思想最重要的就是<strong>先进后出</strong>思想，也就是最先进去的最后出来。<br><img src="/2018/12/01/数据结构相应总结/15332206965126.jpg" alt=""></p></li><li><p>两种方法表示这种栈的实现</p></li></ol><ul><li>第一种则是 直接用c语言实现，采用一个一维数组来存储栈，用两个指针一个指向栈顶，另一个指向栈底。用top=bottom作为栈空的标记或者说是栈遍历完毕的标记。</li><li>第二种就是直接用C++里面STL模板<br>首先先定义一个<code>stack&lt;int&gt; s</code> 然后以下就是其的操作。   </li></ul><p><strong>注意其不能使用push_back只能使用push</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.pop()         删除栈顶元素，也就是出栈的作，把刚刚进来的元素出栈,不返回元素值。</span><br><span class="line">s.push()        创建一个新元素压入栈顶，可以通过拷贝，移动，甚至是构造而来。</span><br><span class="line">s.top()         返回栈顶的元素，也就是刚刚进来的元素。</span><br><span class="line">s.bottom()      返回栈底的元素，也就是最后一个元素</span><br></pre></td></tr></table></figure><h2 id="队列适配器"><a href="#队列适配器" class="headerlink" title="队列适配器"></a>队列适配器</h2><p>队列这里分为两种一种是普通队列，还有一种是特殊排列好的优先队列，但是这二者的区别就在于，虽然都符合先进先出的思想，但是前者是不加任何排序的先进先出，而后者就是让代码编辑者<strong>自己定义一种排序方式</strong>，然后通过这种排序方式，再来出队操作。</p><p>与上面一样，先定义一个<code>queue&lt;int&gt; q</code>与<code>priority_queue&lt;int&gt; q</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">q.pop()         按照先进先出的思想，删除首元素或者优先级最高的元素</span><br><span class="line">q.front()       返回首元素。</span><br><span class="line">q.back()        返回尾元素。</span><br><span class="line">以上两个是只适用于队列。</span><br><span class="line">q.top()         返回优先队列中优先级最高的元素。</span><br><span class="line">q.push()</span><br><span class="line">q.emplace()     加入元素到队尾，或者优先队列中一个恰当的位置，要么构造，要么拷贝。</span><br></pre></td></tr></table></figure><p>这里需要提一下==优先队列的构造方法==以及==优先队列的特殊排序==应该怎么构造</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">下面两种优先队列的定义是等价的</span><br><span class="line">priority_queue&lt;int&gt; q;</span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;;//后面有一个空格</span><br><span class="line">默认都是从小到大排序</span><br><span class="line">接受三个参数，</span><br><span class="line">第一个参数为数据类型，</span><br><span class="line">第二个参数为承载容器的类型，</span><br><span class="line">第三个就是自定义的比较函数了。</span><br><span class="line">可以使lamda匿名函数，也可以是function头文件里面的函数模板。</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>特点：自定义，不连续的。<br>同时链表也是后面相应树形结构的基础<br>实际上就是把每一个不连续的内存空间连在一起，可以认为的控制进程<br>这个需要自己改天把链表的遍历，删除，增加自己再写一遍，因为不是什么新东西，所以这里就不多说了</p><h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>这里就是vector 存在的意义了 vector里面重要的概念 容量，长度。</p><h2 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h2><h3 id="一般的树"><a href="#一般的树" class="headerlink" title="一般的树"></a>一般的树</h3><p><img src="/2018/12/01/数据结构相应总结/15332616324155.jpg" alt=""></p><p><img src="/2018/12/01/数据结构相应总结/15332617338919.jpg" alt=""></p><p>以上就是一般树的形态。<br>下面则是关于树的基本用语。<br><img src="/2018/12/01/数据结构相应总结/15332619052693.jpg" alt=""><br>关于上面重要的概念就是结点和结点的度了。</p><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><h5 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义:"></a>二叉树的定义:</h5><p><img src="/2018/12/01/数据结构相应总结/15332622735630.jpg" alt=""></p><h5 id="二叉树有五种基本形态："><a href="#二叉树有五种基本形态：" class="headerlink" title="二叉树有五种基本形态："></a>二叉树有五种基本形态：</h5><p><img src="/2018/12/01/数据结构相应总结/15332623676250.jpg" alt=""> </p><h6 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质:"></a>二叉树的性质:</h6><p><img src="/2018/12/01/数据结构相应总结/15332624449232.jpg" alt=""><br>上面所写到的==至多==都是由于将其当成了满二叉树来进行计算的。</p><h5 id="满二叉树与完全二叉树"><a href="#满二叉树与完全二叉树" class="headerlink" title="满二叉树与完全二叉树"></a>满二叉树与完全二叉树</h5><p><img src="/2018/12/01/数据结构相应总结/15332628389372.jpg" alt=""><br>前者全部都有子节点，后者基于深度为k的基础上，编号从1到n的结点一一对应。<br><strong>完全二叉树是满二叉树的一部分，而满二叉树是完全二叉树的特例。</strong></p><p>#####二叉树的存储结构：</p><ol><li><p>数组存储：<br><img src="/2018/12/01/数据结构相应总结/15332634147466.jpg" alt=""></p></li><li><p>二叉链式存储（原理类似链表）：<br><img src="/2018/12/01/数据结构相应总结/15332635553287.jpg" alt=""><br>将链表内部的*next，变成了指向两边的子节点的指针。</p></li><li><p>三叉链式存储：<br><img src="/2018/12/01/数据结构相应总结/15332636549533.jpg" alt=""><br><strong>比二叉链式结构多了一个回指向父节点的指针。</strong></p></li></ol><p><img src="/2018/12/01/数据结构相应总结/15332637977616.jpg" alt=""></p><h5 id="遍历二叉树的方法"><a href="#遍历二叉树的方法" class="headerlink" title="遍历二叉树的方法"></a>遍历二叉树的方法</h5><ol><li><p>先序遍历（根-&gt;左-&gt;右）：<br><img src="/2018/12/01/数据结构相应总结/15332639610611.jpg" alt=""></p><p> 代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</span><br><span class="line">        PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">        PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 图示：<br> <img src="/2018/12/01/数据结构相应总结/15332640892406.jpg" alt="">        </p><p> 最终结果就是==ABDGHCEIF==。</p></li><li><p>中序遍历（左-&gt;根-&gt;右)：<br> 若二叉树为空，则空操作返回，否则从根节点开始（注意不是先访问根节点），中序遍历根节点的左子树，然后是访问根节点，最后中序遍历右子树。</p><p> 代码：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</span><br><span class="line">        PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 最终结果为==GDHBAEICF==。</p></li><li><p>后序遍历（左-&gt;右-&gt;根）<br> 若二叉树为空，则空操作返回，否则从根节点开始（注意不是先访问根节点），中序遍历根节点的左子树，然后是访问根节点，最后中序遍历右子树。</p><p> 代码：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">      PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">      PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 最终结果为==GHDBIEFCA==。</p></li></ol><h5 id="关于二叉树的建立代码："><a href="#关于二叉树的建立代码：" class="headerlink" title="关于二叉树的建立代码："></a>关于二叉树的建立代码：</h5><p>代码我等下自己写出来。</p><hr><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><p>   图结构：是研究数据元素之间的多对多的关系。在这种结构中，任意两个元素之间可能存在关系。即结点之间的关系可以是任意的，图中任意元素之间都可能相关。</p><h3 id="图的专业术语："><a href="#图的专业术语：" class="headerlink" title="图的专业术语："></a>图的专业术语：</h3><p><img src="/2018/12/01/数据结构相应总结/15332695761126.jpg" alt="">    </p><p><img src="/2018/12/01/数据结构相应总结/15332695489735.jpg" alt=""></p><p><img src="/2018/12/01/数据结构相应总结/15332696082443.jpg" alt=""></p><p><img src="/2018/12/01/数据结构相应总结/15332696413788.jpg" alt=""></p><p><img src="/2018/12/01/数据结构相应总结/15332696550432.jpg" alt=""></p><h3 id="图-生成树"><a href="#图-生成树" class="headerlink" title="图-生成树"></a>图-生成树</h3><p><img src="/2018/12/01/数据结构相应总结/15332696984237.jpg" alt=""></p><p><img src="/2018/12/01/数据结构相应总结/15332697115073.jpg" alt=""><img src="/2018/12/01/数据结构相应总结/15332697228263.jpg" alt=""></p><h3 id="邻接矩阵的表示方法（数组）"><a href="#邻接矩阵的表示方法（数组）" class="headerlink" title="邻接矩阵的表示方法（数组）"></a>邻接矩阵的表示方法（数组）</h3><h4 id="不带权值的表示方法"><a href="#不带权值的表示方法" class="headerlink" title="不带权值的表示方法"></a>不带权值的表示方法</h4><p><img src="/2018/12/01/数据结构相应总结/15332704000437.jpg" alt=""></p><p><img src="/2018/12/01/数据结构相应总结/15332704263688.jpg" alt=""></p><p><strong>一般就是用二维数组来表示每一个结点之间的关系</strong></p><p><img src="/2018/12/01/数据结构相应总结/15332705567207.jpg" alt=""> <img src="/2018/12/01/数据结构相应总结/15332705659456.jpg" alt=""></p><p>关于图的遍历就最好用一个bool 类型的同二维数组 然后通过这个来标记哪些是否已经被遍历过得。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="acm" scheme="http://crazyfnoption.github.io/categories/acm/"/>
    
    
      <category term="acm" scheme="http://crazyfnoption.github.io/tags/acm/"/>
    
      <category term="数据结构" scheme="http://crazyfnoption.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数论基础第一节</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E8%8A%82/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/数论基础第一节/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-04T10:24:04.411Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>初等数论是用初等方法研究的数论，它的研究方法本质上说，就是利用整数环的整除性质，主要包括整除理论、同余理论、连分数理论。</p><h2 id="整除问题引申到同余问题"><a href="#整除问题引申到同余问题" class="headerlink" title="整除问题引申到同余问题"></a>整除问题引申到同余问题</h2><ul><li><strong>同余的性质</strong></li></ul><p><img src="/2018/12/01/数论基础第一节/15343075827029.jpg" alt=""><br>可以换算成以下式子：<br><strong>a=c(<code>mod</code>b) 这里c为余数，而b为除数</strong></p><ul><li><strong>同余的性质</strong></li></ul><ol><li>自反性 a=a <code>mod</code> m</li><li>对称性 a=b <code>mod</code> m 等价于 b=a <code>mod</code> m</li><li>传递性 a=b <code>mod</code> m 与 b=c <code>mod</code> m 等价于 a=c <code>mod</code> m</li><li>线性合成 a=b <code>mod</code> m 与 c= <code>mod</code> m 等价于 a±c=b±d <code>mod</code> m 与 ac= bd <code>mod</code> m</li><li>消去公因子 ac=bc <code>mod</code> m &amp;&amp; gcd(c,m)=1 等价于 a=b <code>mod</code> m </li></ol><h2 id="素数筛"><a href="#素数筛" class="headerlink" title="素数筛"></a>素数筛</h2><ul><li>朴素筛 一般就是循环2~√n次</li><li>埃拉托斯特尼筛</li></ul><p><strong>循环次数</strong><br><img src="/2018/12/01/数论基础第一节/15343091959776.jpg" alt=""></p><ul><li>欧拉筛</li><li><img src="/2018/12/01/数论基础第一节/15343092628399.jpg" alt=""></li></ul><p><strong>相应代码如下：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="最大公约数以及最小公倍数"><a href="#最大公约数以及最小公倍数" class="headerlink" title="最大公约数以及最小公倍数"></a>最大公约数以及最小公倍数</h2><ul><li><p>最大公约数 函数_gcd(a,b)<br>而多个数的最大公约数 就是 _gcd(a,b,c)=_gcd(gcd(a,b),c)</p></li><li><p>最小公倍数<br>_lcm(a,b)=ab/_gcd(a,b)</p></li></ul><h2 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h2><p><img src="/2018/12/01/数论基础第一节/15343099257598.jpg" alt=""></p><ul><li>关于求解线性同余方程<br><img src="/2018/12/01/数论基础第一节/15343099683275.jpg" alt=""></li><li><p>关于求逆元<br><img src="/2018/12/01/数论基础第一节/15343099966167.jpg" alt=""></p></li><li><p>关于快速幂<br><img src="/2018/12/01/数论基础第一节/15343101054154.jpg" alt=""></p></li></ul><h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p><img src="/2018/12/01/数论基础第一节/15343101566104.jpg" alt=""></p><p><strong>另外</strong><br><img src="/2018/12/01/数论基础第一节/15343103411689.jpg" alt=""></p><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><ul><li><strong>欧拉函数定义</strong><br><img src="/2018/12/01/数论基础第一节/15343107143861.jpg" alt=""></li></ul><ul><li><p><strong>欧拉函数性质</strong><br><img src="/2018/12/01/数论基础第一节/15343107974985.jpg" alt=""></p></li><li><p><strong>求值公式</strong> </p></li></ul><ol><li><img src="/2018/12/01/数论基础第一节/15343109562640.jpg" alt=""></li><li><img src="/2018/12/01/数论基础第一节/15343109655205.jpg" alt=""></li><li><img src="/2018/12/01/数论基础第一节/15343109780637.jpg" alt=""><br>上述公式 可以用来：</li></ol><ul><li><p><strong>求逆元</strong><br><img src="/2018/12/01/数论基础第一节/15343110433806.jpg" alt=""></p></li><li><p><strong>欧拉降幂公式</strong><br><img src="/2018/12/01/数论基础第一节/15343111460573.jpg" alt=""></p></li></ul><h2 id="数论函数"><a href="#数论函数" class="headerlink" title="数论函数"></a>数论函数</h2><p><img src="/2018/12/01/数论基础第一节/15343114512818.jpg" alt=""></p><ul><li><strong>中国剩余定理</strong></li></ul><p><img src="/2018/12/01/数论基础第一节/15343114886344.jpg" alt=""></p><p><strong>解法</strong><br><img src="/2018/12/01/数论基础第一节/15343115089655.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="acm" scheme="http://crazyfnoption.github.io/categories/acm/"/>
    
    
      <category term="acm" scheme="http://crazyfnoption.github.io/tags/acm/"/>
    
      <category term="算法" scheme="http://crazyfnoption.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数论" scheme="http://crazyfnoption.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>条款02：尽量以const,enum,inline 替换掉#define</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E6%9D%A1%E6%AC%BE02%EF%BC%9A%E5%B0%BD%E9%87%8F%E4%BB%A5const,enum,inline%20%E6%9B%BF%E6%8D%A2%E6%8E%89#define/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/条款02：尽量以const,enum,inline 替换掉#define/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-04T10:24:04.411Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="这个条款其实也就相当于宁可编译器替换预处理器比较好"><a href="#这个条款其实也就相当于宁可编译器替换预处理器比较好" class="headerlink" title="这个条款其实也就相当于宁可编译器替换预处理器比较好"></a><strong>这个条款其实也就相当于宁可编译器替换预处理器比较好</strong></h3><hr><h4 id="1-对于单纯常量而言，使用-const-对象或者是-enums-比-define-更加省时间"><a href="#1-对于单纯常量而言，使用-const-对象或者是-enums-比-define-更加省时间" class="headerlink" title="1. 对于单纯常量而言，使用 const 对象或者是 enums 比 #define 更加省时间"></a>1. 对于单纯常量而言，使用 const 对象或者是 enums 比 #define 更加省时间</h4><ul><li>时间上更为节省 作为一个语言常量而不是名称记号，由于在函数体中分配了内存，追寻起来消耗的时间比在函数中使用名称记号所花的时间更少，因为有实处更容易寻找，不像名称记号，可能有的时候并没有进入到记号表中。</li><li>还有一些其他的只能使用 const 情况 定义常量指针和类的专属常量</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/categories/effective-C/"/>
    
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>条款03：尽可能使用 const</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E6%9D%A1%E6%AC%BE03%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8%20const/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/条款03：尽可能使用 const/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-04T10:24:04.411Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先使用 const 可以防止后期莫名其妙的进行改变原有的意思，相当于一个约束语义，另外编译器不论什么时候都会强制施行这项约束。</p><ol><li><p>const 在 C++ 11 中有底层和顶层之分，前者是作用于指针本身，指针不再改变指向对象，而顶层 const 则<br>是指针所指向的对象则不能发生改变。</p></li><li><p>const 最具威力的用法实在面对函数声明时的用法，在一个函数的声明式里，const 可以和函数的返回值，各自的参数以及函数自身产生关联。</p></li><li><p>将引用参数设置成 const 好处是在后面写代码的过程中如果把==写成=，可以立马甄别出来。</p></li><li><p>const 成员函数存在的两个理由，一个使 class 的接口一目了然，因为知道了哪些可以被改动对象而哪些不可以被改动对象，第二则是基于代码编写的高效性而言，操作 const 对象成为可能，因为可以通过 const 成员函数返回 const 对象。</p></li><li><p>存在一种特殊情况，重载[ ]运算符的时候，如果成员函数是 const 那么其的返回值也必须是 const&amp;类型的。</p></li><li><p>如果对于const 成员函数，想要改变该对象的内部成员的话，但是又不想全部改变的话，可以在类中的数据成员定义中加上 mutable，来保证可以改变该函数，其存在的意义就在于保证了其他数据成员不能被 const 成员函数改变，但是该数据成员却可以。</p></li></ol><p>7.当 const 和 non-const 成员函数有实质等价的实现时，令 non-const 版本调用 const 版本可避免代码重复。     </p><p><strong><em>这一点还不是特别了解，需要看到后面之后花点时间来看看这一点的内容。</em></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/categories/effective-C/"/>
    
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>条款01：视 C++ 为一个语言联邦</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E6%9D%A1%E6%AC%BE01%EF%BC%9A%E8%A7%86%20C++%20%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/条款01：视 C++ 为一个语言联邦/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-04T10:24:04.411Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>现在发展的C++已经是一个多重泛型编程语言。</p><hr><p>一个同时<strong>支持过程形式</strong>、<strong>支持面向对象形式</strong>、<strong>函数形式</strong>、<strong>泛型形式</strong>、<strong>元编程形式的语言</strong>，这些能力和弹性使 C++成为了一个无可匹敌的工具。<br>对待其的方式最简单的方法是将其看做是一个由相关语言组成的一个联邦而不是某个次语言。</p><ol><li><p><strong><em>C</em></strong> 说到底 C++ 仍然是 C 的一个延伸，面对过程的编程思想仍然在某些时候很受用，而某些时刻 C++ 的解法只不过就是比 C 高级了一点点，但是当你以 C++的内 C 成分的工作的时候，高效编程则映照出了 C 语言的局限，没有模板，没有异常，没有重载。</p></li><li><p><strong><em>Object-Oriented C++</em></strong> 这部分也就是 C++ 中面对对象编程思想的直接体现，简单来说就是 C with class 比如 类，封装，继承，多态，虚函数的动态绑定。</p></li><li><p><strong><em>Template C++</em></strong> 这是 C++中的泛型编程部分，template 的相关考虑与设计已经弥漫了整个 C++ 而这种编程思想的强大，直接带来了全新的名字 模板元编程，后面得花上大部分时间去专研这个。</p></li><li><p><strong><em>STL</em></strong> 基本上包括 容器，迭代器，算法以及相应的函数对象，一般竞赛可能会直接用到里面的相关容器以及相关算法，熟练使用 STL 也是一名 C++ 程序员应该必备的素质。</p></li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/categories/effective-C/"/>
    
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>条款04：确定对象被使用前已先被初始化</title>
    <link href="http://crazyfnoption.github.io/2018/12/01/%E6%9D%A1%E6%AC%BE04%EF%BC%9A%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://crazyfnoption.github.io/2018/12/01/条款04：确定对象被使用前已先被初始化/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-04T10:24:04.411Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="在-C-语言中对象的初始化可能会变得异常容易，但是在-C-中某些语境下进行对象可能不会存在自动的初始化过程，也许会在使用-C-part-of-C-会自动有一个初始化过程，但是在其他部分下面的-C-就不能保证初始化过程了。"><a href="#在-C-语言中对象的初始化可能会变得异常容易，但是在-C-中某些语境下进行对象可能不会存在自动的初始化过程，也许会在使用-C-part-of-C-会自动有一个初始化过程，但是在其他部分下面的-C-就不能保证初始化过程了。" class="headerlink" title="在 C 语言中对象的初始化可能会变得异常容易，但是在 C++中某些语境下进行对象可能不会存在自动的初始化过程，也许会在使用 C part of C++ 会自动有一个初始化过程，但是在其他部分下面的 C++就不能保证初始化过程了。"></a>在 C 语言中对象的初始化可能会变得异常容易，但是在 C++中某些语境下进行对象可能不会存在自动的初始化过程，也许会在使用 C part of C++ 会自动有一个初始化过程，但是在其他部分下面的 C++就不能保证初始化过程了。</h4><ol><li><p>特别是在类的过程中，初始化的过程一般直接交给构造函数，初始化的过程并不等同于赋值，所以在写类的构造函数的时候，尽量不要在函数体里面写赋值给私有成员的语句，可以直接在列表上面直接写初始化的。</p></li><li><p>对于拥有多个构造函数，且每个构造函数具有自己的成员初值列，如果这些类存在许多成员变量或者基类的话，多种成员初始列表就会导致不受欢迎的重复，那么这个时候可以遗漏一些“赋值跟初始化过程差不读的成员变量”，改用他们的赋值操作，并且把这些操作放置在 private 中。</p></li><li><p>C++有着十分固定的成员初始化过程，基类的初始化会早于派生类，而类的成员变量总是以其声明的次序被初始化。</p></li><li><p>关于类的静态成员的初始化 一般在类内部进行声明，然后再类的外部进行定义，赋值，其的声明周期一般是从程序开始到程序结束。</p></li><li><p>构造函数初始化的次序非常重要，举个例子就是初始化的时候必须要为数组指定大小，所以指定大小的变量必须具有先值</p></li><li><p>对于不同人在不同时间下不同的源码文件建立起来，其的初始化相对次序并没有明确定义，所以解决办法就是将一个对象搬到自己的专属函数里面去，然后声明成静态成员，并且返回一个引用即可，后面用户直接调用这些函数，就可以无视初始化的次序问题了。具体可以看书里面P32面的相关代码。</p></li><li><p>最后总结一句为了免除“跨编译单元之初始化次序”问题，一般用 local static 对象替换 non-local static 对象。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/categories/effective-C/"/>
    
    
      <category term="c++" scheme="http://crazyfnoption.github.io/tags/c/"/>
    
      <category term="effective C++" scheme="http://crazyfnoption.github.io/tags/effective-C/"/>
    
  </entry>
  
</feed>

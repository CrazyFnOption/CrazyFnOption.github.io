<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Super Coding</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wsx1128.xyz/"/>
  <updated>2018-12-01T14:37:23.368Z</updated>
  <id>http://www.wsx1128.xyz/</id>
  
  <author>
    <name>五光君</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>条款11：在 operator 中处理自我赋值的情况</title>
    <link href="http://www.wsx1128.xyz/2018/12/01/%E6%9D%A1%E6%AC%BE11%EF%BC%9A%E5%9C%A8operator%E4%B8%AD%E5%A4%84%E7%90%86%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E7%9A%84%E6%83%85%E5%86%B5/"/>
    <id>http://www.wsx1128.xyz/2018/12/01/条款11：在operator中处理自我赋值的情况/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T14:37:23.368Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本来是可以不用担心拷贝过程中发生自我赋值的情况，但是就是为了防止用户，或者对象自身的这种情况，所以需要完成避免自赋值的情况"><a href="#本来是可以不用担心拷贝过程中发生自我赋值的情况，但是就是为了防止用户，或者对象自身的这种情况，所以需要完成避免自赋值的情况" class="headerlink" title="本来是可以不用担心拷贝过程中发生自我赋值的情况，但是就是为了防止用户，或者对象自身的这种情况，所以需要完成避免自赋值的情况"></a>本来是可以不用担心拷贝过程中发生自我赋值的情况，但是就是为了防止用户，或者对象自身的这种情况，所以需要完成避免自赋值的情况</h4><ol><li><p>比如两个指针对象进行自赋值的时候，为了防止多次删除，需要检查一下自赋值的情况。</p></li><li><p>同时不仅要考虑的是自我赋值的安全性，仍然需要考虑的是异常的安全，也就是前者是需要判断如果前者的地址等于后者的地址话 就直接返回不作为，并且先删除原本的，再赋值新的，而后者则是先构造一个对象赋值给另外一个，然后先赋值，再删除。</p></li></ol><p><img src="//www.wsx1128.xyz/2018/12/01/条款11：在operator中处理自我赋值的情况/1.png" alt=""></p><p>就类似于这样，这样既能保证自赋值的情况，但是又能保证异常安全，不会在new对象的时候发生错误。</p><ol start="3"><li><p>还要记住的是一般在移动赋值运算符的时候也应该注意一下自赋值的情况，不过上面的异常安全很少涉及到，因为上面的相比于前者更费点时间。</p></li><li><p>或者是直接使用自定义的 swap 功能，这样的话对于自赋值的情况以及异常安全的情况来比，更加省事和高效。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;本来是可以不用担心拷贝过程中发生自我赋值的情况，但是就是为了防止用户，或者对象自身的这种情况，所以需要完成避免自赋值的情况&quot;&gt;&lt;a href=&quot;#本来是可以不用担心拷贝过程中发生自我赋值的情况，但是就是为了防止用户，或者对象自身的这种情况，所以需要完成避免自赋值的
      
    
    </summary>
    
      <category term="effective C++" scheme="http://www.wsx1128.xyz/categories/effective-C/"/>
    
    
      <category term="c++" scheme="http://www.wsx1128.xyz/tags/c/"/>
    
      <category term="effective C++" scheme="http://www.wsx1128.xyz/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>关于模拟与搜索的相应简单题目</title>
    <link href="http://www.wsx1128.xyz/2018/12/01/%E5%85%B3%E4%BA%8E%E6%A8%A1%E6%8B%9F%E4%B8%8E%E6%90%9C%E7%B4%A2%E7%9A%84%E7%9B%B8%E5%BA%94%E7%AE%80%E5%8D%95%E9%A2%98%E7%9B%AE/"/>
    <id>http://www.wsx1128.xyz/2018/12/01/关于模拟与搜索的相应简单题目/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T14:49:06.571Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目</strong><br><img src="//www.wsx1128.xyz/2018/12/01/关于模拟与搜索的相应简单题目/15338826192241.jpg" alt=""></p><p><strong>代码如下：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string w,v;</span><br><span class="line">    int x,y,m;</span><br><span class="line">    char ch;</span><br><span class="line">    while(cin&gt;&gt;w&gt;&gt;v)&#123;</span><br><span class="line">        string s;</span><br><span class="line">        int flag=0;</span><br><span class="line">        reverse(w.begin(),w.end());</span><br><span class="line">        reverse(v.begin(),v.end());</span><br><span class="line">        if (w.size()&gt;v.size())&#123;</span><br><span class="line">            m=w.size()-v.size();</span><br><span class="line">            for (int i=0;i!=v.size();i++)&#123;</span><br><span class="line">                x=w[i]-&apos;0&apos;;</span><br><span class="line">                y=v[i]-&apos;0&apos;;</span><br><span class="line">                x+=y;</span><br><span class="line">                if (flag)&#123;</span><br><span class="line">                    flag=0;</span><br><span class="line">                    x++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (x&gt;=10)&#123;</span><br><span class="line">                    flag=1;</span><br><span class="line">                    x=x-10;</span><br><span class="line">                &#125;</span><br><span class="line">                ch=x+&apos;0&apos;;</span><br><span class="line">                s.push_back(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            int i=v.size();</span><br><span class="line">            while (flag==1&amp;&amp;i&lt;=m)&#123;</span><br><span class="line">                flag=0;</span><br><span class="line">                x=w[i]-&apos;0&apos;;</span><br><span class="line">                x++;</span><br><span class="line">                if (x&gt;=10)&#123;</span><br><span class="line">                    flag=1;</span><br><span class="line">                    x=x-10;</span><br><span class="line">                &#125;</span><br><span class="line">                ch=x+&apos;0&apos;;</span><br><span class="line">                s.push_back(ch);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag&amp;&amp;i==w.size())&#123;</span><br><span class="line">                s.push_back(&apos;1&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            m=v.size()-w.size();</span><br><span class="line">            for (int i=0;i!=w.size();i++)&#123;</span><br><span class="line">                x=w[i]-&apos;0&apos;;</span><br><span class="line">                y=v[i]-&apos;0&apos;;</span><br><span class="line">                x+=y;</span><br><span class="line">                if (flag)&#123;</span><br><span class="line">                    flag=0;</span><br><span class="line">                    x++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (x&gt;=10)&#123;</span><br><span class="line">                    flag=1;</span><br><span class="line">                    x=x-10;</span><br><span class="line">                &#125;</span><br><span class="line">                ch=x+&apos;0&apos;;</span><br><span class="line">                s.push_back(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            int i=w.size();</span><br><span class="line">            while (flag&amp;&amp;i&lt;=m)&#123;</span><br><span class="line">                flag=0;</span><br><span class="line">                x=w[i]-&apos;0&apos;;</span><br><span class="line">                x++;</span><br><span class="line">                if (x&gt;=10)&#123;</span><br><span class="line">                    flag=1;</span><br><span class="line">                    x=x-10;</span><br><span class="line">                &#125;</span><br><span class="line">                ch=x+&apos;0&apos;;</span><br><span class="line">                s.push_back(ch);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag&amp;&amp;i==v.size())&#123;</span><br><span class="line">                s.push_back(&apos;1&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(s.begin(),s.end());</span><br><span class="line">        cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>题解：</strong><br>其实这道题目属于一道相应简单的题目，就是要注意相应string与char之间的区别就行了。<br>另外 <code>int</code>转换<code>char</code>是加上‘0’<br><code>char</code>转换<code>int</code>是减去‘0’。</p><h2 id="一道简单的dfs的题目"><a href="#一道简单的dfs的题目" class="headerlink" title="一道简单的dfs的题目"></a>一道简单的dfs的题目</h2><p><img src="//www.wsx1128.xyz/2018/12/01/关于模拟与搜索的相应简单题目/15338976566985.jpg" alt=""></p><p><strong>代码如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 105;</span><br><span class="line">char h[maxn][maxn];</span><br><span class="line">int n,m,cnt=0;</span><br><span class="line">void dfs(int i,int j)&#123;</span><br><span class="line">    if (i&lt;0||i&gt;=n||h[i][j]!=&apos;W&apos;) return ;</span><br><span class="line">    if (j&lt;0||j&gt;=m||h[i][j]!=&apos;W&apos;) return ;</span><br><span class="line">    if (h[i][j]==&apos;W&apos;)&#123;</span><br><span class="line">        h[i][j]=&apos;.&apos;;</span><br><span class="line">        dfs(i-1,j);</span><br><span class="line">        dfs(i-1,j-1);</span><br><span class="line">        dfs(i+1,j);</span><br><span class="line">        dfs(i+1,j+1);</span><br><span class="line">        dfs(i,j-1);</span><br><span class="line">        dfs(i-1,j+1);</span><br><span class="line">        dfs(i,j+1);</span><br><span class="line">        dfs(i+1,j-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int ans=0;</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;(n!=0&amp;&amp;m!=0))&#123;</span><br><span class="line">        for (int i=0;i!=n;i++)</span><br><span class="line">            for (int j=0;j!=m;j++)&#123;</span><br><span class="line">                cin&gt;&gt;h[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        for (int i=0;i!=n;i++)&#123;</span><br><span class="line">            for (int j=0;j!=m;j++)&#123;</span><br><span class="line">                if (h[i][j]==&apos;W&apos;)&#123;</span><br><span class="line">                    dfs(i,j);</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">        ans=0;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题解简单的dfs搜索出每一种情况，然后让其返回就行了。</p><h2 id="一道经典的BFS的题目"><a href="#一道经典的BFS的题目" class="headerlink" title="一道经典的BFS的题目"></a>一道经典的BFS的题目</h2><p><strong>题目</strong><br><img src="//www.wsx1128.xyz/2018/12/01/关于模拟与搜索的相应简单题目/15346617217857.jpg" alt="-w780"></p><p><strong>代码如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int fxy[4][2]=&#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">//朝着四个方向</span><br><span class="line">char dis[101][101];</span><br><span class="line"></span><br><span class="line">int kp[101][101];</span><br><span class="line"></span><br><span class="line">//以下的node就作为每一次前进的节点</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x,y,cnt;</span><br><span class="line">    node(int a=0,int b=0,int c=0)&#123;</span><br><span class="line">        x=a; y=b; cnt=c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m,n,k,g,k1,g1;</span><br><span class="line">    while(~scanf(&quot;%d %d&quot;,&amp;m,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%s&quot;,dis[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        //      用队列整合的思想来完成</span><br><span class="line">        queue&lt;struct node&gt;q;</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">            for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">                kp[i][j]=-1;</span><br><span class="line">            &#125;</span><br><span class="line">        //      两种初始化过程，并且找到起点与终点的所在位置</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">            for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">                if(dis[i][j]==&apos;S&apos;)&#123;</span><br><span class="line">                    k=i;</span><br><span class="line">                    g=j;</span><br><span class="line">                &#125;</span><br><span class="line">                if(dis[i][j]==&apos;E&apos;)&#123;</span><br><span class="line">                    k1=i;</span><br><span class="line">                    g1=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        //        将起点存进去</span><br><span class="line">        node a(k,g,0);</span><br><span class="line">        q.push(a);</span><br><span class="line">        //        下面就是为bfs的相应搜索</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            struct node now=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            kp[now.x][now.y]=now.cnt;</span><br><span class="line">            //            将起点走了多少步数以及起点的坐标点存入到题目中去</span><br><span class="line">            for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">                node next;</span><br><span class="line">                next.x=now.x+fxy[i][0];</span><br><span class="line">                next.y=now.y+fxy[i][1];</span><br><span class="line">                //                判断走的下一步有没有出界，或者使下一步走的不会碰到路障</span><br><span class="line">                    if(next.x&gt;=0&amp;&amp;next.x&lt;m&amp;&amp;next.y&gt;=0&amp;&amp;next.y&lt;n&amp;&amp;dis[next.x][next.y]!=&apos;#&apos;&amp;&amp;kp[next.x][next.y]==-1)&#123;</span><br><span class="line">                    node empt(next.x,next.y,now.cnt+1);</span><br><span class="line">                    q.push(empt);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(kp[k1][g1]==-1) printf(&quot;Trapped!\n&quot;);</span><br><span class="line">        else printf(&quot;Escaped in %d minute(s).\n&quot;,kp[k1][g1]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>记住上面相应的队列思想。</p><h2 id="一道DFS与BFS的综合题"><a href="#一道DFS与BFS的综合题" class="headerlink" title="一道DFS与BFS的综合题"></a>一道DFS与BFS的综合题</h2><p>==需要多花时间来温习一遍==</p><p><strong>题目</strong><br><img src="//www.wsx1128.xyz/2018/12/01/关于模拟与搜索的相应简单题目/15346690956114.jpg" alt=""></p><p><strong>代码如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n,m,k,cnt = 0;</span><br><span class="line">int x_begin,x_end,y_begin,y_end;</span><br><span class="line"></span><br><span class="line">const int maxn = 1005;</span><br><span class="line"></span><br><span class="line">int dis[maxn][maxn];</span><br><span class="line">char ch[maxn][maxn];</span><br><span class="line"></span><br><span class="line">class Position&#123;</span><br><span class="line">public:</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">    int distance;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    Position() = default;</span><br><span class="line">    Position(int a, int b, int c):x(a),y(b),distance(c)&#123;&#125;;</span><br><span class="line">    Position move(int i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Position Position::move(int i)&#123;</span><br><span class="line">    Position post = *this;</span><br><span class="line">    if (i == 0)         post.x = this -&gt; x + 1;</span><br><span class="line">    else if (i == 1)    post.x = this -&gt; x - 1;</span><br><span class="line">    else if (i == 2)    post.y = this -&gt; y + 1;</span><br><span class="line">    else if (i == 3)    post.y = this -&gt; y - 1;</span><br><span class="line">    return post;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void bfs()&#123;</span><br><span class="line">    queue&lt;Position&gt;q_dis;</span><br><span class="line">    Position p_begin (x_begin,y_begin,0);</span><br><span class="line">    q_dis.push(p_begin);</span><br><span class="line">    while(!q_dis.empty())&#123;</span><br><span class="line">        Position now = q_dis.front();</span><br><span class="line">        q_dis.pop();</span><br><span class="line">        dis[now.x][now.y]=now.distance;</span><br><span class="line">        for(int i = 0; i != 4; i++)&#123;</span><br><span class="line">            Position next;</span><br><span class="line">            next = now.move(i);</span><br><span class="line">            if (next.x &gt;= 0 &amp;&amp; next.x &lt; n &amp;&amp; next.y &gt;= 0 &amp;&amp; next.y &lt; m &amp;&amp;</span><br><span class="line">                dis[next.x][next.y] == -1 &amp;&amp; ch[next.x][next.y] != &apos;#&apos;)&#123;</span><br><span class="line">                Position empt (next.x,next.y,now.distance + 1);</span><br><span class="line">                q_dis.push(empt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int x,int y)&#123;</span><br><span class="line">    if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m) return ;</span><br><span class="line">    if (ch[x][y]==&apos;L&apos;)  &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (dis[x][y] == -1) return;</span><br><span class="line">    //  前面已经有dis可以表示每一步走的距离，所以只需要一步一步来看，这样的做法便可以完全规避障碍物，单单从路径上面考虑。</span><br><span class="line">    if (dis[x][y]==dis[x+1][y]+1)   dfs(x+1,y);</span><br><span class="line">    if (dis[x][y]==dis[x-1][y]+1)   dfs(x-1,y);</span><br><span class="line">    if (dis[x][y]==dis[x][y+1]+1)   dfs(x,y+1);</span><br><span class="line">    if (dis[x][y]==dis[x][y-1]+1)   dfs(x,y-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int T,Case = 0;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        Case++;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">        bool f_begin = false,f_end = false;</span><br><span class="line">        for (int i = 0; i != n; i++)&#123;</span><br><span class="line">            for (int j = 0; j != m; j++)&#123;</span><br><span class="line">                cin &gt;&gt; ch[i][j];</span><br><span class="line">                dis[i][j] = -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i != n; i++)&#123;</span><br><span class="line">            for (int j = 0; j != m; j++)&#123;</span><br><span class="line">                if (f_end &amp;&amp; f_begin)   break;</span><br><span class="line">                if (ch[i][j] == &apos;L&apos;)&#123;</span><br><span class="line">                    x_begin = i;</span><br><span class="line">                    y_begin = j;</span><br><span class="line">                    f_begin = true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (ch[i][j] == &apos;C&apos;)&#123;</span><br><span class="line">                    x_end = i;</span><br><span class="line">                    y_end = j;</span><br><span class="line">                    f_end = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bfs();</span><br><span class="line">        if (dis[x_end][y_end] == -1 ||dis[x_end][y_end] &gt; k )</span><br><span class="line">            cout &lt;&lt; &quot;Case #&quot;&lt;&lt;Case&lt;&lt;&quot;: &quot;&lt;&lt;-1&lt;&lt;endl;</span><br><span class="line">        else&#123;</span><br><span class="line">            dfs(x_end,y_end);</span><br><span class="line">            cout&lt;&lt;&quot;Case #&quot;&lt;&lt;Case&lt;&lt;&quot;: &quot;&lt;&lt;dis[x_end][y_end]&lt;&lt;&quot; &quot;&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">            cnt = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注明一下关于==默认实参==的知识点，因为在这个地方可以直接对类的构造函数赋值一个默认实参，可以避免输入默认构造函数了。</p><p>下面则是一道DFS的题目，这道题目看上去可以用bfs来做</p><p><img src="//www.wsx1128.xyz/2018/12/01/关于模拟与搜索的相应简单题目/15351254685296.jpg" alt="-w1003"></p><p><strong>代码如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 100;</span><br><span class="line">int road[maxn][maxn];</span><br><span class="line">int dp[maxn][maxn];</span><br><span class="line">int n, m;</span><br><span class="line"></span><br><span class="line">int dfs (int i,int j)&#123;</span><br><span class="line">    if (dp[i][j] != -1)   return dp[i][j];</span><br><span class="line">    int Max = 0;</span><br><span class="line">    if (i-1&gt;=0 &amp;&amp; road[i][j]&gt;road[i-1][j]&amp;&amp;Max&lt;dfs(i-1,j))</span><br><span class="line">        Max = dfs(i-1,j);</span><br><span class="line">    if(i+1&lt;n &amp;&amp; road[i][j]&gt;road[i+1][j]&amp;&amp;Max&lt;dfs(i+1,j))</span><br><span class="line">        Max=dfs(i+1,j);</span><br><span class="line">    if(j-1&gt;=0 &amp;&amp; road[i][j]&gt;road[i][j-1]&amp;&amp;Max&lt;dfs(i,j-1))</span><br><span class="line">        Max=dfs(i,j-1);</span><br><span class="line">    if(j+1&lt;m &amp;&amp; road[i][j]&gt;road[i][j+1]&amp;&amp;Max&lt;dfs(i,j+1))</span><br><span class="line">        Max=dfs(i,j+1);</span><br><span class="line">    return dp[i][j]=Max+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (cin &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i != n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 0; j != m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cin &gt;&gt; road[i][j];</span><br><span class="line">                dp[i][j] = -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int MAX = -1;</span><br><span class="line">        for (int i = 0; i != n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 0; j != m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                MAX = max (dfs(i,j),MAX);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; MAX &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>此题其实最重要的就在于这个题目不同于其他题目，这个题目找的是最长路径，还不是最短路径，一般来说，BFS找的是最短路径，DFS找的是最短路径的条数。<br>而这里就是利用dfs的返回值（每走一步的最大值，意思就是从各个角度上）记录在dp中，将每一个位置都走到不能走为止，然后存储在dp中，最后找最大值的DP即可。<br>不过自己可以试试遍历的其他方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;//www.wsx1128.xyz/2018/12/01/关于模拟与搜索的相应简单题目/15338826192241.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码如下：&lt;/strong&gt;&lt;br
      
    
    </summary>
    
      <category term="题解" scheme="http://www.wsx1128.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="acm" scheme="http://www.wsx1128.xyz/tags/acm/"/>
    
      <category term="c++" scheme="http://www.wsx1128.xyz/tags/c/"/>
    
      <category term="模拟与搜索" scheme="http://www.wsx1128.xyz/tags/%E6%A8%A1%E6%8B%9F%E4%B8%8E%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>STL的简单总结</title>
    <link href="http://www.wsx1128.xyz/2018/12/01/STL%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <id>http://www.wsx1128.xyz/2018/12/01/STL的简单总结/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T14:37:23.368Z</updated>
    
    <content type="html"><![CDATA[<p>补一个加快C++输入输出速度的方法：<br><img src="//www.wsx1128.xyz/2018/12/01/STL的简单总结/15335220029444.jpg" alt=""></p><p>花上一天的时间来总结 C++ primer 里面的算法以及容器这一章，多余的用法可以上网去查找当做是相应的扩展。</p><h2 id="字符串-string与字符数组"><a href="#字符串-string与字符数组" class="headerlink" title="字符串 string与字符数组"></a>字符串 string与字符数组</h2><ul><li><p><strong>构造<code>string</code>的方法</strong><br><img src="//www.wsx1128.xyz/2018/12/01/STL的简单总结/15335169766308.jpg" alt=""></p></li><li><p><strong>操作<code>string</code>的方法</strong></p></li></ul><p><img src="//www.wsx1128.xyz/2018/12/01/STL的简单总结/15335172798374.jpg" alt=""><br><img src="//www.wsx1128.xyz/2018/12/01/STL的简单总结/15335172954262.jpg" alt=""><br>上面的成员函数有的说要返回，同时，有的也存在不返回值。</p><ul><li><strong>搜索<code>string</code>的方法</strong></li></ul><p><img src="//www.wsx1128.xyz/2018/12/01/STL的简单总结/15335179836529.jpg" alt=""></p><p><img src="//www.wsx1128.xyz/2018/12/01/STL的简单总结/15335179990314.jpg" alt=""></p><p>以上就是find函数的一些用法，在泛型算法一章，还会继续涉及到。<br><strong>题目返回的是下标</strong></p><p>补充一下关于<code>string</code>中的比较函数<br><img src="//www.wsx1128.xyz/2018/12/01/STL的简单总结/15335183199373.jpg" alt=""><br>一般在string中可以直接用运算符进行比较</p><ul><li><strong><code>int</code>与<code>string</code>之间的转化</strong></li></ul><p><img src="//www.wsx1128.xyz/2018/12/01/STL的简单总结/15335184125849.jpg" alt=""></p><ul><li><strong><code>getline()</code>的两种写法</strong><br><img src="//www.wsx1128.xyz/2018/12/01/STL的简单总结/15334343361243.jpg" alt=""><br>注意在<code>cin&gt;&gt;t</code>;必须要一个<code>getchar()</code>来吞掉其前面的回车符号。<br>之后才能用<code>getline()</code>。</li></ul><h2 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h2><ul><li><strong>容器种类</strong><br><img src="//www.wsx1128.xyz/2018/12/01/STL的简单总结/15334679972152.jpg" alt=""></li></ul><p><code>vector&lt;vector&lt;int&gt; &gt;</code>来表示二维数组。</p><ul><li><strong>容器基础操作</strong><br><img src="//www.wsx1128.xyz/2018/12/01/STL的简单总结/15334684459041.jpg" alt=""><br>补充一个assign的用法：<br>允许从一个不同但相容的类型里面去赋值，或者从容器的一个子序列赋值。</li></ul><p><img src="//www.wsx1128.xyz/2018/12/01/STL的简单总结/15334692047908.jpg" alt=""><br>还有第二个版本：<br>接受一个整型值和一个元素值，用指定数目且具有相同给定元素替换容器中原有的元素：<br><img src="//www.wsx1128.xyz/2018/12/01/STL的简单总结/15334693472336.jpg" alt=""></p><p>再补充一个resize的用法：<br><img src="//www.wsx1128.xyz/2018/12/01/STL的简单总结/15335166722769.jpg" alt=""></p><p>需要记住有一些类型声明可以直接用<code>auto</code>。</p><p>初始化有两种一种<strong>直接初始化</strong>和<strong>拷贝初始化</strong>。</p><ul><li><strong>顺序容器添加元素</strong><br><img src="//www.wsx1128.xyz/2018/12/01/STL的简单总结/15334697068572.jpg" alt=""><br>上面已经列出了各种形式的插入。<br>插入是在迭代器指向的元素之前插入。插入想要插入的元素前面，比如说<code>push_back</code>是插入到了尾后迭代器的前面。<br>而返回的是新添加的第一个元素的迭代器，同样也可也==不返回==。</li></ul><p>这里要注意的是<code>push_front</code>会改变整个容器的迭代器指向，而<code>push_back</code>不会。</p><ul><li><strong>访问元素</strong></li></ul><p><img src="//www.wsx1128.xyz/2018/12/01/STL的简单总结/15334703127503.jpg" alt=""></p><p>链表，单向链表，栈，队列都不支持随机访问，也就不支持下标访问了。</p><ul><li><strong>删除元素</strong><br><img src="//www.wsx1128.xyz/2018/12/01/STL的简单总结/15334705958004.jpg" alt=""></li></ul><p>删除的是迭代器指向的元素，返回的是删除元素的后迭代器也就是被删除的元素下一个元素的前面的迭代器，同样也可以不返回。</p><p><em>这里需要注意的就是删除一个元素之后，必定会改变原容器中迭代器的指向，所以务必小心（除了<code>pop_back</code>）</em></p><ul><li><strong>改变容器大小的操作</strong></li></ul><p><img src="//www.wsx1128.xyz/2018/12/01/STL的简单总结/15335167464723.jpg" alt=""></p><ul><li><strong>特殊的forward_list（单向链表）</strong></li></ul><p><img src="//www.wsx1128.xyz/2018/12/01/STL的简单总结/15334712839686.jpg" alt=""></p><p>由于迭代器的添加删除操作都涉及到了首前和尾后，所以对于单向链表来说这里添加了一个首前迭代器<code>before_begin</code><br>而对于单向链表的插入而言 是在元素的后面进行插入，删除也是一样，指向都是迭代器指向元素之后的元素。</p><h2 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h2><p><img src="//www.wsx1128.xyz/2018/12/01/STL的简单总结/15335188187528.jpg" alt=""></p><ul><li>**关联容器里面的<code>pair</code></li></ul><p><img src="//www.wsx1128.xyz/2018/12/01/STL的简单总结/15335191398555.jpg" alt=""></p><ul><li><strong>关联容器的操作</strong></li></ul><p><img src="//www.wsx1128.xyz/2018/12/01/STL的简单总结/15335192848295.jpg" alt=""></p><ul><li><strong>关联容器的添加操作</strong></li></ul><p><img src="//www.wsx1128.xyz/2018/12/01/STL的简单总结/15335195440945.jpg" alt=""></p><p>一般都是直接用下标操作添加<code>map</code>里面的操作。<br><code>at</code>操作只能判断存不存在</p><ul><li><strong>关联容器的删除操作</strong></li></ul><p><img src="//www.wsx1128.xyz/2018/12/01/STL的简单总结/15335202245929.jpg" alt=""></p><ul><li><strong>关联容器的访问操作</strong></li></ul><p><img src="//www.wsx1128.xyz/2018/12/01/STL的简单总结/15335205177307.jpg" alt=""><br>上面关于排序的操作不适用于无序的关联容器。</p><p><strong>当允许关键词重复的multimap中查找元素时，一般使用find函数与count函数同时进行。</strong></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>大部分函数算法都放在<code>&lt;algorithm&gt;</code>的头文件里面了。<br>还有一些数值算法是放在了<code>&lt;numeric&gt;</code>的头文件里面。</p><ul><li><strong>只读算法</strong></li></ul><p>accumulate 求和算法，接受三个参数，前面两个参数是累加范围，第三个是和的初值。<br>equal 判断两个序列里面是否所有的值都相同。<br>后面网上查找 有的再补充。<br>find算法<br>binary_search()二分查找函数<br>find_end()最后一次出现算法<br>find_first_of()第一次出现的算法<br>find_if ()第三个参数就为自定义函数搜索<br>lower_bound()第一个不小于的元素<br>upper_bound()第一个大于的元素<br>count（）算法 计算出现次数<br>count_if（）函数自定义计数</p><ul><li><strong>写容器的算法</strong></li></ul><p>fill 填充算法 类似于memset函数前者在于可以赋值赋任何值，而后者理论上只能赋值0或者1或者0x3f3f3f3f。<br>fill_n也是三个参数，第一个是开始点，第二个是赋值数目，第三个为赋值初始化。<br>copy 拷贝算法，接收三个迭代器，前面两个表示输入范围，第三个为拷贝目标序列的起点。<br>replace 替换算法，将目标序列里面的某些值更改成某些值，接受四个参数，前面两个是目标序列的范围，第三个是要搜索的值，第四个是要将搜索到的第三个的值更改后的值。<br>remove 去除掉函数里面包括的参数的元素。<br>remove_if 自定义。<br>remove_copy 拷贝结果。<br>swap（）交换两个对象的值。<br>swap_range()交换两个序列的值。</p><ul><li><strong>重排容器的算法</strong></li></ul><p>其排序的算法中，定义的排序方式就在于自定义函数传入算法中。<br>有三种自定义函数：</p><ol><li>普通bool型自定义函数，比较排列顺序。</li><li>lambda 匿名小函数。</li><li>bind 函数 绑定谓词。灵活的应用自定义函数。</li></ol><p>unique 将容器中所有重复的值全部排列到后面去，接受目标序列的迭代器范围，返回指向第一个重复元素的迭代器。<br>sort 排序 本质上运用的是快速排序。<br>stable_sort 本质上运动的是归并排序。<br>stable_partition 前面进行排序后，把自定义排列的分割开来。<br>reverse 倒排函数。<br>reverse_copy 倒排函数。<br>rotate 接受三个参数，前面两个是要往后面排的范围。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul><li><p><strong>插入迭代器</strong><br>back_inserter 类似于push_back的迭代器，创建并且使用<br>front_inserter 创建并且使用一个push_front的迭代器<br>inserter 创建一个普通插入的迭代器</p></li><li><p><strong>流迭代器</strong><br>istream_iterator 输入迭代器<br><img src="//www.wsx1128.xyz/2018/12/01/STL的简单总结/15335260532129.jpg" alt=""></p></li></ul><p>ostream_iterator 输出迭代器<br><img src="//www.wsx1128.xyz/2018/12/01/STL的简单总结/15335260817218.jpg" alt=""></p><ul><li><strong>反向迭代器</strong><br>reverse_iterator</li><li><strong>移动迭代器</strong><br>后面复习到在总结 移动、拷贝、右值引用。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;补一个加快C++输入输出速度的方法：&lt;br&gt;&lt;img src=&quot;//www.wsx1128.xyz/2018/12/01/STL的简单总结/15335220029444.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;花上一天的时间来总结 C++ primer 里面的算法以及容器这
      
    
    </summary>
    
      <category term="acm" scheme="http://www.wsx1128.xyz/categories/acm/"/>
    
    
      <category term="acm" scheme="http://www.wsx1128.xyz/tags/acm/"/>
    
      <category term="数据结构" scheme="http://www.wsx1128.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="STL" scheme="http://www.wsx1128.xyz/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>一道STL的题解题目，需要以后花时间理解题目意思</title>
    <link href="http://www.wsx1128.xyz/2018/12/01/%E4%B8%80%E9%81%93STL%E7%9A%84%E9%A2%98%E8%A7%A3%E9%A2%98%E7%9B%AE%EF%BC%8C%E9%9C%80%E8%A6%81%E4%BB%A5%E5%90%8E%E8%8A%B1%E6%97%B6%E9%97%B4%E7%90%86%E8%A7%A3%E9%A2%98%E7%9B%AE%E6%84%8F%E6%80%9D/"/>
    <id>http://www.wsx1128.xyz/2018/12/01/一道STL的题解题目，需要以后花时间理解题目意思/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T14:37:23.367Z</updated>
    
    <content type="html"><![CDATA[<p><img src="//www.wsx1128.xyz/2018/12/01/一道STL的题解题目，需要以后花时间理解题目意思/15334616821861.jpg" alt=""></p><p><strong>代码如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">//#include&lt;function&gt;</span><br><span class="line"></span><br><span class="line">#define ll long long</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int fort = 1314;</span><br><span class="line"></span><br><span class="line">ll a[6];</span><br><span class="line"></span><br><span class="line">//这道题目就换一种思考方式，让基数分贝加上加数，这样一来，就会简化很多步骤</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        cin&gt;&gt;a[0]&gt;&gt;a[1]&gt;&gt;a[2];</span><br><span class="line">        a[3] = 5;</span><br><span class="line">        a[4] = 2;</span><br><span class="line">        a[5] = 0;</span><br><span class="line">        sort(a,  a + 6,</span><br><span class="line">        [](const ll &amp;a,const ll &amp;b)&#123;return a&gt;b;&#125;);</span><br><span class="line">        priority_queue&lt;ll, vector&lt;ll&gt;, greater&lt;ll&gt; &gt; pq;</span><br><span class="line">        set&lt;ll&gt;s;</span><br><span class="line">        set&lt;ll&gt;ans;</span><br><span class="line">        pq.push(1);</span><br><span class="line">        s.insert(1);</span><br><span class="line">        for(int i = 0;;i++)&#123;</span><br><span class="line">            ll x = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            if(i)&#123;</span><br><span class="line">                for(int k = 3;k &lt; 6;k++)&#123;</span><br><span class="line">                    ans.insert(x - a[k]);</span><br><span class="line">                    if(ans.size()==fort)</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">                if(ans.size()==fort)&#123;</span><br><span class="line">                    /*int ttt = 1;</span><br><span class="line">                    for(set&lt;ll&gt;::iterator it = ans.begin();it!=ans.end();it++)</span><br><span class="line">                        cout&lt;&lt;ttt++&lt;&lt;&apos; &apos;&lt;&lt;*it&lt;&lt;endl;*/</span><br><span class="line">                    auto it = ans.rbegin();</span><br><span class="line">                    cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 0;j&lt;3;j++)&#123;</span><br><span class="line">                ll x2=x*a[j];</span><br><span class="line">                if(!s.count(x2))&#123;</span><br><span class="line">                    s.insert(x2);</span><br><span class="line">                    pq.push(x2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;//www.wsx1128.xyz/2018/12/01/一道STL的题解题目，需要以后花时间理解题目意思/15334616821861.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;figure cla
      
    
    </summary>
    
      <category term="题解" scheme="http://www.wsx1128.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="acm" scheme="http://www.wsx1128.xyz/tags/acm/"/>
    
      <category term="c++" scheme="http://www.wsx1128.xyz/tags/c/"/>
    
      <category term="STL" scheme="http://www.wsx1128.xyz/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>一道有趣的题目——逆波兰计算器</title>
    <link href="http://www.wsx1128.xyz/2018/12/01/%E4%B8%80%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A2%98%E7%9B%AE%E2%80%94%E2%80%94%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>http://www.wsx1128.xyz/2018/12/01/一道有趣的题目——逆波兰计算器/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T14:37:23.368Z</updated>
    
    <content type="html"><![CDATA[<p><img src="//www.wsx1128.xyz/2018/12/01/一道有趣的题目——逆波兰计算器/15334382488561.jpg" alt=""></p><p><strong>题解</strong><br>首先这道题毫无疑问是要用到stringstream流的。分别依次读取字符串，并且将其导入到char型的代码中去。比如说a+b可以变成ab+，这里最好运用到栈的知识，来控制出栈与进栈。<br>==注意以下几个地方==</p><ol><li>注意输入<code>cin&gt;&gt;t</code>以后，需要用<code>getchar()</code>来清空上一个步骤留下来的回车符号</li><li>注意此处需要严格进行判断栈内是否为空。</li><li>这里是将乘除求模的运算放在最右边，这样就可以有优先级存在了</li><li>括号会提前进行一步运算，然后消除掉左括号，或者左边的所有运算式，进行一个结算。</li><li>map这里存在的意义就在于 为判断进行提供条件。</li><li>此道题目涉及字符串，栈，模拟的相应算法，需要有空的时候可以多看看。</li></ol><p><strong>代码如下：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">stack&lt;char&gt;ope;</span><br><span class="line">stack&lt;int&gt;num;</span><br><span class="line">string str;</span><br><span class="line">map&lt;char,int&gt;m;</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    m[&apos;+&apos;]=m[&apos;-&apos;]=1;</span><br><span class="line">    m[&apos;*&apos;]=m[&apos;/&apos;]=m[&apos;%&apos;]=m[&apos;(&apos;]=m[&apos;)&apos;]=2;</span><br><span class="line">    while(!num.empty())</span><br><span class="line">        num.pop();</span><br><span class="line">    while(!ope.empty())</span><br><span class="line">        ope.pop();</span><br><span class="line">&#125;</span><br><span class="line">//此处为基本的运算规模。</span><br><span class="line">void op1(int &amp;a,int &amp;b,const char &amp;c)&#123;</span><br><span class="line">    if (c ==&apos;+&apos;)    a += b;</span><br><span class="line">    else if (c == &apos;-&apos;) a=b-a;</span><br><span class="line">    else if (c == &apos;*&apos;) a*=b;</span><br><span class="line">    else if (c == &apos;/&apos;) a=b/a;</span><br><span class="line">    else if (c == &apos;%&apos;) a=b%a;</span><br><span class="line">&#125;</span><br><span class="line">//此处就是控制出栈的运算，一般就是括号内部的计算了。算出每一个括号内部的运算式。</span><br><span class="line">void op2()&#123;</span><br><span class="line">    char ch = ope.top();</span><br><span class="line">    while (ch != &apos;(&apos;&amp;&amp;!ope.empty())&#123;</span><br><span class="line">        ope.pop();</span><br><span class="line">        int a = num.top();</span><br><span class="line">        num.pop();</span><br><span class="line">        int b = num.top();</span><br><span class="line">        num.pop();</span><br><span class="line">        op1(a,b,ch);</span><br><span class="line">        num.push(a);</span><br><span class="line">        if (!ope.empty())</span><br><span class="line">            ch = ope.top();</span><br><span class="line">    &#125;//这个下面要注意的判断条件中一定要加上判断是否为空。</span><br><span class="line"></span><br><span class="line">    if (!ope.empty()&amp;&amp;ope.top() ==&apos;(&apos;)</span><br><span class="line">        ope.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    getchar();</span><br><span class="line">    while (t--)&#123;</span><br><span class="line">        getline(cin,str);</span><br><span class="line">        stringstream s(str);</span><br><span class="line">        init();</span><br><span class="line">        char tmp;</span><br><span class="line">        while (s&gt;&gt;tmp)&#123;</span><br><span class="line">            if(tmp&gt;=&apos;0&apos;&amp;&amp;tmp&lt;=&apos;9&apos;)&#123;</span><br><span class="line">                int x = 0;</span><br><span class="line">                do&#123;</span><br><span class="line">                    if (m[tmp]) break;</span><br><span class="line">                    x *= 10;</span><br><span class="line">                    x += tmp - &apos;0&apos;;//此处是将char转换成int</span><br><span class="line">                &#125;while(s&gt;&gt;tmp);</span><br><span class="line">                num.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">            //注意这个地方的高明之处就在于碰见‘）’的返回，以及判断有没有‘（’，</span><br><span class="line">            比如连加的情况就把加减乘除的优先运算级给表示出来了。</span><br><span class="line">            //最后相当于将运算优先级高的全部放到了右边，然后有括号的就先解决括号，</span><br><span class="line">            及时左括号被提前弄没了也不要紧，存在有右括号就行，然后乘除永远放在加减的左边。</span><br><span class="line">            </span><br><span class="line">            if (tmp==&apos;)&apos;) op2();</span><br><span class="line">            else if (m[tmp]==1)&#123;</span><br><span class="line">                if (!ope.empty()&amp;&amp;ope.top()!=&apos;(&apos;)</span><br><span class="line">                    op2();</span><br><span class="line">                ope.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (m[tmp]) ope.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = num.top();</span><br><span class="line">        num.pop();</span><br><span class="line">        while (!num.empty()&amp;&amp;!ope.empty())&#123;</span><br><span class="line">            op1(ans,num.top(),ope.top());</span><br><span class="line">            ope.pop();</span><br><span class="line">            num.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;//www.wsx1128.xyz/2018/12/01/一道有趣的题目——逆波兰计算器/15334382488561.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题解&lt;/strong&gt;&lt;br&gt;首先这道题毫无疑问是要用到stringstrea
      
    
    </summary>
    
      <category term="题解" scheme="http://www.wsx1128.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="acm" scheme="http://www.wsx1128.xyz/tags/acm/"/>
    
      <category term="c++" scheme="http://www.wsx1128.xyz/tags/c/"/>
    
      <category term="STL" scheme="http://www.wsx1128.xyz/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>一道计算机几何算法相关题目</title>
    <link href="http://www.wsx1128.xyz/2018/12/01/%E4%B8%80%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%87%A0%E4%BD%95%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
    <id>http://www.wsx1128.xyz/2018/12/01/一道计算机几何算法相关题目/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T14:37:23.368Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong></p><p><img src="//www.wsx1128.xyz/2018/12/01/一道计算机几何算法相关题目/15349459741854.jpg" alt=""></p><p><strong>代码如下：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">double v,s,b;</span><br><span class="line">const double pi = acos(-1.0);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(cin&gt;&gt;v&gt;&gt;s&gt;&gt;b)&#123;</span><br><span class="line">        if (s&lt;b)&#123;</span><br><span class="line">            cout&lt;&lt;-1&lt;&lt;endl;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        double x = (v * v) / 9.8;</span><br><span class="line">        if ( x &lt; s ) &#123;</span><br><span class="line">            cout&lt;&lt;&quot;move &quot;&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;s-x&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            double b = (s * 9.8) / (v * v);</span><br><span class="line">            //注意反函数的转换。</span><br><span class="line">            double a = asin(b) * 90 / pi;</span><br><span class="line">            //这里有一个进一的操作，因为此题不太会去四舍五入。</span><br><span class="line">            int a_ = a;</span><br><span class="line">            if (a-a_ &gt;= 0.5) a_++;</span><br><span class="line">            cout&lt;&lt;&quot;a &quot;&lt;&lt;a_&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>关于这道题目的相关要点</strong></p><ol><li><p>反函数相关要点。<br>注意 反函数最后输出的是 一个弧度值，根据相应数学的算法而言<br>记住 ==弧度值=角度*pi/180==</p></li><li><p>关于输出中进1的相关操作。<br>按照第几位，先换算成相应的整形数，最后再强转成int型 最后在判断是否大于0.5来考虑时候来加一。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.wsx1128.xyz/2018/12/01/一道计算机几何算法相关题目/15349459741854.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码如下：&lt;/strong
      
    
    </summary>
    
      <category term="题解" scheme="http://www.wsx1128.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="acm" scheme="http://www.wsx1128.xyz/tags/acm/"/>
    
      <category term="c++" scheme="http://www.wsx1128.xyz/tags/c/"/>
    
      <category term="STL" scheme="http://www.wsx1128.xyz/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>二分法思想</title>
    <link href="http://www.wsx1128.xyz/2018/12/01/%E4%BA%8C%E5%88%86%E6%B3%95%E6%80%9D%E6%83%B3/"/>
    <id>http://www.wsx1128.xyz/2018/12/01/二分法思想/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T14:13:15.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>实现在单调有序的集合中查找元素，每次江集合分为左右两个部分，并且通过判断集合在哪个部分从而调整集合的上下界，重复知道找到目标元素为止。</p><p>举一个简单的例子，我要在1到100里面查找62，先拿62根这个其最中间的一个数进行比较。然后在一步一步的缩小集合的上下界，最后再来一步一步往里面缩</p><p><strong>下面是C++STL里面二分查找的函数：</strong></p><blockquote><p>binary_search  返回bool值,是否存在<br>lower_bound    返回可插入的最小位置的迭代器                                                                  即返回第一个符合条件的元素位置<br>upper_bound    返回可插入的最大位置的迭代器<br>               即返回最后一个符合条件的元素位置</p></blockquote><p>在二分查找里面最典型的题目就是二分逼近求方程式的根了。</p><p><img src="//www.wsx1128.xyz/2018/12/01/二分法思想/15333828636681.jpg" alt=""></p><p><strong>代码如下</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const double pre =1e-4;</span><br><span class="line">double x,y;</span><br><span class="line"></span><br><span class="line">double f(double x)&#123;</span><br><span class="line">    return 8*pow(x,4)+7*pow(x,3)+2*pow(x,2)+3*x+6-y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while (t--)&#123;</span><br><span class="line">        cin&gt;&gt;y;</span><br><span class="line">        double x1=0,x2=100;//先把上下界在这里确定好</span><br><span class="line">        double mid=(x1+x2)/2;</span><br><span class="line">        if (f(x1)*f(x2)&gt;0) cout&lt;&lt;&quot;No solution!&quot;&lt;&lt;endl;</span><br><span class="line">        else &#123;</span><br><span class="line">            while (x2-x1&gt;=pre)&#123;//这里必须写的是上下界线是多少，</span><br><span class="line">            不能写的是用于判断mid的条件。</span><br><span class="line">                if (f(x1)*f(mid)&lt;0)&#123;</span><br><span class="line">                    x2=mid;</span><br><span class="line">                    mid=(x1+x2)/2;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    x1=mid;</span><br><span class="line">                    mid=(x1+x2)/2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;fixed&lt;&lt;setprecision(4)&lt;&lt;mid&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面就是我第二次出错的地方，判断二分循环逼近的的条件不应该看mid的取值，而是应该看得是区间上界减去区间下界的范围从而来限定。</p><p>此处关于三分法的求解：<br>当需要求某凸性或凹形函数的极值，通过函数本身表达式并不容易求解时，就可以用三分法不断逼近求解。</p><p>三分法——求解凸性函数的极值问题<br><a href="http://hi.baidu.com/vfxupdpaipbcpuq/item/81b21d1910ea729c99ce33db" target="_blank" rel="noopener">http://hi.baidu.com/vfxupdpaipbcpuq/item/81b21d1910ea729c99ce33db</a></p><p>经典例题：<br>侵略的奶牛：<br><img src="//www.wsx1128.xyz/2018/12/01/二分法思想/15334016401434.jpg" alt=""></p><p><strong>代码如下：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 100005;</span><br><span class="line">int a[maxn],n,c;</span><br><span class="line"></span><br><span class="line">//此过程就是在判断奶牛之间的间隔为这个值合不合适</span><br><span class="line">bool cc(int d)&#123;</span><br><span class="line">    int t=a[0],cnt=1;</span><br><span class="line">    for (int i=1;i!=n;i++)&#123;</span><br><span class="line">        if (a[i]-t&gt;=d)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            t=a[i];</span><br><span class="line">            if (cnt&gt;=c)</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">//此过程就是在收录每一个值，然后再分别进行判断</span><br><span class="line">int solve()&#123;</span><br><span class="line">    int x=0,y=a[n-1]-a[0];</span><br><span class="line">    while (x&lt;=y)&#123;</span><br><span class="line">        int mid=(x+y)/2;</span><br><span class="line">        if (cc(mid))    x=mid+1;</span><br><span class="line">        else    y=mid-1;</span><br><span class="line">    &#125;</span><br><span class="line">    return x-1;</span><br><span class="line">&#125;</span><br><span class="line">//不过这种最大值最小值的题目需要多花时间想想。</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (cin&gt;&gt;n&gt;&gt;c)&#123;</span><br><span class="line">        for (int i=0;i!=n;i++)</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">        sort(a,a+n);</span><br><span class="line">        cout&lt;&lt;solve()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>==下面则是其他地方关于二分的题目==<br><strong>基础版</strong></p><blockquote><p>POJ 3122 Pie<br>  二分枚举区间是实数<br>POJ 1064 Cable master<br>    二分枚举区间是实数,注意精度<br>POJ 3258 River Hopscotch<br>     最大化最小值<br>POJ 3273 Monthly Expense<br>    最小化最大值<br>LIGHTOJ 1076 Get the Containers<br>    最小化最大值，。和上一个差不多<br>LIGHTOJ 1307 Counting Triangles </p></blockquote><p><strong>进阶版</strong></p><blockquote><p>POJ 3579      二分搜索+二分查找<br>POJ 3685      二分搜索+二分查找<br>ZOJ 3278      也是两个二分嵌套<br>LIGHTOJ 1048<br>和LightOJ 1076一样，不过要输出一组解<br>LIGHTOJ 1383    二分加贪心（区间）<br>ZOJ 3665 某年区域赛题。，二分枚举<br>ZOJ 3726 去年区域赛题，二分查找<br>codeforces 382B 有意思的题<br>codeforces 391D2 难，。。，，、</p></blockquote><p>==下面就是关于三分的题目==</p><blockquote><p>poj3301<br>hdu4454<br>hdu3714<br>hdu2438</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h2&gt;&lt;p&gt;实现在单调有序的集合中查找元素，每次江集合分为左右两个部分，并且通过判断集合在哪个部分从而调整集合的上下界，重复知道找到目标
      
    
    </summary>
    
      <category term="acm" scheme="http://www.wsx1128.xyz/categories/acm/"/>
    
    
      <category term="acm" scheme="http://www.wsx1128.xyz/tags/acm/"/>
    
      <category term="c++" scheme="http://www.wsx1128.xyz/tags/c/"/>
    
      <category term="STL" scheme="http://www.wsx1128.xyz/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>关于STL里面函数简单的应用</title>
    <link href="http://www.wsx1128.xyz/2018/12/01/%E5%85%B3%E4%BA%8ESTL%E9%87%8C%E9%9D%A2%E5%87%BD%E6%95%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://www.wsx1128.xyz/2018/12/01/关于STL里面函数简单的应用/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T14:37:23.368Z</updated>
    
    <content type="html"><![CDATA[<p><img src="//www.wsx1128.xyz/2018/12/01/关于STL里面函数简单的应用/15334646368898.jpg" alt=""></p><p><strong>代码如下：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,t;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    set&lt;int&gt;s;</span><br><span class="line">    s.insert(0);</span><br><span class="line">    for (int i =0;i!=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;t;</span><br><span class="line"></span><br><span class="line">        //这道题目的主要做法是记住几个upper_bound 的STL函数</span><br><span class="line">        if(t &lt; *s.rbegin()) &#123;</span><br><span class="line">            s.erase(*(s.upper_bound(t)));</span><br><span class="line">        &#125;</span><br><span class="line">        s.insert(t);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; s.size() - 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;//www.wsx1128.xyz/2018/12/01/关于STL里面函数简单的应用/15334646368898.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码如下：&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlig
      
    
    </summary>
    
      <category term="题解" scheme="http://www.wsx1128.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="acm" scheme="http://www.wsx1128.xyz/tags/acm/"/>
    
      <category term="c++" scheme="http://www.wsx1128.xyz/tags/c/"/>
    
      <category term="STL" scheme="http://www.wsx1128.xyz/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>关于组合数学，两道思维题目，这里贴两道题目</title>
    <link href="http://www.wsx1128.xyz/2018/12/01/%E5%85%B3%E4%BA%8E%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%8C%E4%B8%A4%E9%81%93%E6%80%9D%E7%BB%B4%E9%A2%98%E7%9B%AE%EF%BC%8C%E8%BF%99%E9%87%8C%E8%B4%B4%E4%B8%A4%E9%81%93%E9%A2%98%E7%9B%AE/"/>
    <id>http://www.wsx1128.xyz/2018/12/01/关于组合数学，两道思维题目，这里贴两道题目/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T14:37:23.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一道-简单的排列组合："><a href="#第一道-简单的排列组合：" class="headerlink" title="第一道 简单的排列组合："></a>第一道 简单的排列组合：</h2><p><img src="//www.wsx1128.xyz/2018/12/01/关于组合数学，两道思维题目，这里贴两道题目/15334551294656.jpg" alt=""></p><p><strong>题解如下：</strong></p><blockquote><p>题目大致可以理解为4堆牌a,b,c,d，每次从一堆牌里拿出牌顶的一张牌，问共有多少种拿法。其实我们可以一堆一堆的分析，假设只有一堆a时只有1种拿法，那两堆a,b时我们可以认为是从a个牌中插入b张牌，用数学表达式就是<strong>==C(b,a+b)==</strong>;那么三堆的话我们可以把前两堆看成一堆，那么表达式就是<strong>==C(c,a+b+c)==</strong>，这是我们需要与前两堆的组成方法相乘，就是<strong>==C(b,a+b)C(c,a+b+c)==</strong>。<br>4堆的话就是<strong>==C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)==</strong>。<br>所以答案就是<strong>==C(a,a)C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)==</strong>。<br>此外，有一公式==<strong>C(a,b)=C(a,b-1)+C(a-1,b-1)</strong>==，所以我们用数组来代替C(m,n)操作</p></blockquote><p><strong>代码如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 501;</span><br><span class="line">const long long mod = 1000000007;</span><br><span class="line"></span><br><span class="line">long long a[4],sum[4]=&#123;0&#125;;</span><br><span class="line">//此处用到记忆化搜索，动态规划。</span><br><span class="line">long long dp[maxn*4][maxn*4];</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    dp[0][0]=0;</span><br><span class="line">    for (int i=1;i!=4*maxn;i++)&#123;</span><br><span class="line">        dp[i][0]=1;</span><br><span class="line">        //根据表格来看的确是每一行的第一个是1</span><br><span class="line">        for (int j=1;j&lt;i;j++)&#123;</span><br><span class="line">            //这个地方就是状态转移方程</span><br><span class="line">            //C(a,b)=C(a,b-1)+C(a-1,b-1)根据公式来做的</span><br><span class="line">            dp[i][j]=dp[i-1][j]+dp[i-1][j-1];</span><br><span class="line">            //dp[i][j]=dp[i][j]%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][i]=1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while (t--)&#123;</span><br><span class="line">        init();//这个地方就开始初始化表格了。</span><br><span class="line">        long long ans =1;</span><br><span class="line">        for (int i = 0; i&lt;4;i++)&#123;</span><br><span class="line">            if (!i) sum[i]=0;</span><br><span class="line">            else sum[i]=sum[i-1];</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">            sum[i] += a[i];</span><br><span class="line">            if (a[i] &gt; sum[i]-a[i]) a[i]=sum[i]-a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1 ; i != 4; i++)&#123;</span><br><span class="line">            ans *= dp[sum[i]][a[i]];</span><br><span class="line">            //ans %=mod;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二题-第一题的变式："><a href="#第二题-第一题的变式：" class="headerlink" title="第二题 第一题的变式："></a>第二题 第一题的变式：</h2><p><img src="//www.wsx1128.xyz/2018/12/01/关于组合数学，两道思维题目，这里贴两道题目/15334588459331.jpg" alt=""></p><p>题解如上，与上面一题有区别的地方就在于要有一个取模的操作</p><p><strong>代码如下</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 501;</span><br><span class="line">const long long mod = 1000000007;</span><br><span class="line"></span><br><span class="line">long long a[4],sum[4]=&#123;0&#125;;</span><br><span class="line">//此处用到记忆化搜索，动态规划。</span><br><span class="line">long long dp[maxn*4][maxn*4];</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    dp[0][0]=0;</span><br><span class="line">    for (int i=1;i!=4*maxn;i++)&#123;</span><br><span class="line">        dp[i][0]=1;</span><br><span class="line">        //根据表格来看的确是每一行的第一个是1</span><br><span class="line">        for (int j=1;j&lt;i;j++)&#123;</span><br><span class="line">            //这个地方就是状态转移方程</span><br><span class="line">            //C(a,b)=C(a,b-1)+C(a-1,b-1)根据公式来做的</span><br><span class="line">            dp[i][j]=dp[i-1][j]+dp[i-1][j-1];</span><br><span class="line">            dp[i][j]=dp[i][j]%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][i]=1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while (t--)&#123;</span><br><span class="line">        init();//这个地方就开始初始化表格了。</span><br><span class="line">        long long ans =1;</span><br><span class="line">        for (int i = 0; i&lt;4;i++)&#123;</span><br><span class="line">            if (!i) sum[i]=0;</span><br><span class="line">            else sum[i]=sum[i-1];</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">            sum[i] += a[i];</span><br><span class="line">            if (a[i] &gt; sum[i]-a[i]) a[i]=sum[i]-a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1 ; i != 4; i++)&#123;</span><br><span class="line">            ans *= dp[sum[i]][a[i]];</span><br><span class="line">            ans %=mod;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==以后学到后面再花时间来深究==</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一道-简单的排列组合：&quot;&gt;&lt;a href=&quot;#第一道-简单的排列组合：&quot; class=&quot;headerlink&quot; title=&quot;第一道 简单的排列组合：&quot;&gt;&lt;/a&gt;第一道 简单的排列组合：&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;//www.wsx1128.xyz/20
      
    
    </summary>
    
      <category term="题解" scheme="http://www.wsx1128.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="acm" scheme="http://www.wsx1128.xyz/tags/acm/"/>
    
      <category term="c++" scheme="http://www.wsx1128.xyz/tags/c/"/>
    
      <category term="组合数学" scheme="http://www.wsx1128.xyz/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>数据结构相应总结</title>
    <link href="http://www.wsx1128.xyz/2018/12/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%BA%94%E6%80%BB%E7%BB%93/"/>
    <id>http://www.wsx1128.xyz/2018/12/01/数据结构相应总结/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T14:37:23.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ol><li><p>栈的概念<br>此处只需要记住栈的思想最重要的就是<strong>先进后出</strong>思想，也就是最先进去的最后出来。<br><img src="//www.wsx1128.xyz/2018/12/01/数据结构相应总结/15332206965126.jpg" alt=""></p></li><li><p>两种方法表示这种栈的实现</p></li></ol><ul><li>第一种则是 直接用c语言实现，采用一个一维数组来存储栈，用两个指针一个指向栈顶，另一个指向栈底。用top=bottom作为栈空的标记或者说是栈遍历完毕的标记。</li><li>第二种就是直接用C++里面STL模板<br>首先先定义一个<code>stack&lt;int&gt; s</code> 然后以下就是其的操作。   </li></ul><p><strong>注意其不能使用push_back只能使用push</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.pop()         删除栈顶元素，也就是出栈的作，把刚刚进来的元素出栈,不返回元素值。</span><br><span class="line">s.push()        创建一个新元素压入栈顶，可以通过拷贝，移动，甚至是构造而来。</span><br><span class="line">s.top()         返回栈顶的元素，也就是刚刚进来的元素。</span><br><span class="line">s.bottom()      返回栈底的元素，也就是最后一个元素</span><br></pre></td></tr></table></figure><h2 id="队列适配器"><a href="#队列适配器" class="headerlink" title="队列适配器"></a>队列适配器</h2><p>队列这里分为两种一种是普通队列，还有一种是特殊排列好的优先队列，但是这二者的区别就在于，虽然都符合先进先出的思想，但是前者是不加任何排序的先进先出，而后者就是让代码编辑者<strong>自己定义一种排序方式</strong>，然后通过这种排序方式，再来出队操作。</p><p>与上面一样，先定义一个<code>queue&lt;int&gt; q</code>与<code>priority_queue&lt;int&gt; q</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">q.pop()         按照先进先出的思想，删除首元素或者优先级最高的元素</span><br><span class="line">q.front()       返回首元素。</span><br><span class="line">q.back()        返回尾元素。</span><br><span class="line">以上两个是只适用于队列。</span><br><span class="line">q.top()         返回优先队列中优先级最高的元素。</span><br><span class="line">q.push()</span><br><span class="line">q.emplace()     加入元素到队尾，或者优先队列中一个恰当的位置，要么构造，要么拷贝。</span><br></pre></td></tr></table></figure><p>这里需要提一下==优先队列的构造方法==以及==优先队列的特殊排序==应该怎么构造</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">下面两种优先队列的定义是等价的</span><br><span class="line">priority_queue&lt;int&gt; q;</span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;;//后面有一个空格</span><br><span class="line">默认都是从小到大排序</span><br><span class="line">接受三个参数，</span><br><span class="line">第一个参数为数据类型，</span><br><span class="line">第二个参数为承载容器的类型，</span><br><span class="line">第三个就是自定义的比较函数了。</span><br><span class="line">可以使lamda匿名函数，也可以是function头文件里面的函数模板。</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>特点：自定义，不连续的。<br>同时链表也是后面相应树形结构的基础<br>实际上就是把每一个不连续的内存空间连在一起，可以认为的控制进程<br>这个需要自己改天把链表的遍历，删除，增加自己再写一遍，因为不是什么新东西，所以这里就不多说了</p><h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>这里就是vector 存在的意义了 vector里面重要的概念 容量，长度。</p><h2 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h2><h3 id="一般的树"><a href="#一般的树" class="headerlink" title="一般的树"></a>一般的树</h3><p><img src="//www.wsx1128.xyz/2018/12/01/数据结构相应总结/15332616324155.jpg" alt=""></p><p><img src="//www.wsx1128.xyz/2018/12/01/数据结构相应总结/15332617338919.jpg" alt=""></p><p>以上就是一般树的形态。<br>下面则是关于树的基本用语。<br><img src="//www.wsx1128.xyz/2018/12/01/数据结构相应总结/15332619052693.jpg" alt=""><br>关于上面重要的概念就是结点和结点的度了。</p><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><h5 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义:"></a>二叉树的定义:</h5><p><img src="//www.wsx1128.xyz/2018/12/01/数据结构相应总结/15332622735630.jpg" alt=""></p><h5 id="二叉树有五种基本形态："><a href="#二叉树有五种基本形态：" class="headerlink" title="二叉树有五种基本形态："></a>二叉树有五种基本形态：</h5><p><img src="//www.wsx1128.xyz/2018/12/01/数据结构相应总结/15332623676250.jpg" alt=""> </p><h6 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质:"></a>二叉树的性质:</h6><p><img src="//www.wsx1128.xyz/2018/12/01/数据结构相应总结/15332624449232.jpg" alt=""><br>上面所写到的==至多==都是由于将其当成了满二叉树来进行计算的。</p><h5 id="满二叉树与完全二叉树"><a href="#满二叉树与完全二叉树" class="headerlink" title="满二叉树与完全二叉树"></a>满二叉树与完全二叉树</h5><p><img src="//www.wsx1128.xyz/2018/12/01/数据结构相应总结/15332628389372.jpg" alt=""><br>前者全部都有子节点，后者基于深度为k的基础上，编号从1到n的结点一一对应。<br><strong>完全二叉树是满二叉树的一部分，而满二叉树是完全二叉树的特例。</strong></p><p>#####二叉树的存储结构：</p><ol><li><p>数组存储：<br><img src="//www.wsx1128.xyz/2018/12/01/数据结构相应总结/15332634147466.jpg" alt=""></p></li><li><p>二叉链式存储（原理类似链表）：<br><img src="//www.wsx1128.xyz/2018/12/01/数据结构相应总结/15332635553287.jpg" alt=""><br>将链表内部的*next，变成了指向两边的子节点的指针。</p></li><li><p>三叉链式存储：<br><img src="//www.wsx1128.xyz/2018/12/01/数据结构相应总结/15332636549533.jpg" alt=""><br><strong>比二叉链式结构多了一个回指向父节点的指针。</strong></p></li></ol><p><img src="//www.wsx1128.xyz/2018/12/01/数据结构相应总结/15332637977616.jpg" alt=""></p><h5 id="遍历二叉树的方法"><a href="#遍历二叉树的方法" class="headerlink" title="遍历二叉树的方法"></a>遍历二叉树的方法</h5><ol><li><p>先序遍历（根-&gt;左-&gt;右）：<br><img src="//www.wsx1128.xyz/2018/12/01/数据结构相应总结/15332639610611.jpg" alt=""></p><p> 代码如下</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void PreOrderTraverse(BiTree *T)</span><br><span class="line">&#123;</span><br><span class="line">    if(T != NULL)&#123;</span><br><span class="line">        printf(&quot;%c&quot;, T-&gt;data);</span><br><span class="line">        PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">        PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 图示：<br> <img src="//www.wsx1128.xyz/2018/12/01/数据结构相应总结/15332640892406.jpg" alt="">        </p><p> 最终结果就是==ABDGHCEIF==。</p></li><li><p>中序遍历（左-&gt;根-&gt;右)：<br> 若二叉树为空，则空操作返回，否则从根节点开始（注意不是先访问根节点），中序遍历根节点的左子树，然后是访问根节点，最后中序遍历右子树。</p><p> 代码：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void InOrderTraverse(BiTree T)</span><br><span class="line">&#123;</span><br><span class="line">   if(T != NULL)&#123;</span><br><span class="line">        PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">        printf(&quot;%c&quot;, T-&gt;data);</span><br><span class="line">        PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 最终结果为==GDHBAEICF==。</p></li><li><p>后序遍历（左-&gt;右-&gt;根）<br> 若二叉树为空，则空操作返回，否则从根节点开始（注意不是先访问根节点），中序遍历根节点的左子树，然后是访问根节点，最后中序遍历右子树。</p><p> 代码：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void PostOrderTraverse(BiTree T)</span><br><span class="line">&#123;</span><br><span class="line">  if(T != NULL)&#123;</span><br><span class="line">      PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">      PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">      printf(&quot;%c&quot;, T-&gt;data);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 最终结果为==GHDBIEFCA==。</p></li></ol><h5 id="关于二叉树的建立代码："><a href="#关于二叉树的建立代码：" class="headerlink" title="关于二叉树的建立代码："></a>关于二叉树的建立代码：</h5><p>代码我等下自己写出来。</p><hr><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><p>   图结构：是研究数据元素之间的多对多的关系。在这种结构中，任意两个元素之间可能存在关系。即结点之间的关系可以是任意的，图中任意元素之间都可能相关。</p><h3 id="图的专业术语："><a href="#图的专业术语：" class="headerlink" title="图的专业术语："></a>图的专业术语：</h3><p><img src="//www.wsx1128.xyz/2018/12/01/数据结构相应总结/15332695761126.jpg" alt="">    </p><p><img src="//www.wsx1128.xyz/2018/12/01/数据结构相应总结/15332695489735.jpg" alt=""></p><p><img src="//www.wsx1128.xyz/2018/12/01/数据结构相应总结/15332696082443.jpg" alt=""></p><p><img src="//www.wsx1128.xyz/2018/12/01/数据结构相应总结/15332696413788.jpg" alt=""></p><p><img src="//www.wsx1128.xyz/2018/12/01/数据结构相应总结/15332696550432.jpg" alt=""></p><h3 id="图-生成树"><a href="#图-生成树" class="headerlink" title="图-生成树"></a>图-生成树</h3><p><img src="//www.wsx1128.xyz/2018/12/01/数据结构相应总结/15332696984237.jpg" alt=""></p><p><img src="//www.wsx1128.xyz/2018/12/01/数据结构相应总结/15332697115073.jpg" alt=""><img src="//www.wsx1128.xyz/2018/12/01/数据结构相应总结/15332697228263.jpg" alt=""></p><h3 id="邻接矩阵的表示方法（数组）"><a href="#邻接矩阵的表示方法（数组）" class="headerlink" title="邻接矩阵的表示方法（数组）"></a>邻接矩阵的表示方法（数组）</h3><h4 id="不带权值的表示方法"><a href="#不带权值的表示方法" class="headerlink" title="不带权值的表示方法"></a>不带权值的表示方法</h4><p><img src="//www.wsx1128.xyz/2018/12/01/数据结构相应总结/15332704000437.jpg" alt=""></p><p><img src="//www.wsx1128.xyz/2018/12/01/数据结构相应总结/15332704263688.jpg" alt=""></p><p><strong>一般就是用二维数组来表示每一个结点之间的关系</strong></p><p><img src="//www.wsx1128.xyz/2018/12/01/数据结构相应总结/15332705567207.jpg" alt=""> <img src="//www.wsx1128.xyz/2018/12/01/数据结构相应总结/15332705659456.jpg" alt=""></p><p>关于图的遍历就最好用一个bool 类型的同二维数组 然后通过这个来标记哪些是否已经被遍历过得。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;栈的概念&lt;br&gt;此处只需要记住栈的思想最重要的就是&lt;strong&gt;先进后出&lt;/strong&gt;思想，也就是最先进去的最后出来。&lt;br
      
    
    </summary>
    
      <category term="acm" scheme="http://www.wsx1128.xyz/categories/acm/"/>
    
    
      <category term="acm" scheme="http://www.wsx1128.xyz/tags/acm/"/>
    
      <category term="数据结构" scheme="http://www.wsx1128.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数论基础第一节</title>
    <link href="http://www.wsx1128.xyz/2018/12/01/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E8%8A%82/"/>
    <id>http://www.wsx1128.xyz/2018/12/01/数论基础第一节/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T14:32:15.084Z</updated>
    
    <content type="html"><![CDATA[<p>初等数论是用初等方法研究的数论，它的研究方法本质上说，就是利用整数环的整除性质，主要包括整除理论、同余理论、连分数理论。</p><h2 id="整除问题引申到同余问题"><a href="#整除问题引申到同余问题" class="headerlink" title="整除问题引申到同余问题"></a>整除问题引申到同余问题</h2><ul><li><strong>同余的性质</strong></li></ul><p><img src="//www.wsx1128.xyz/2018/12/01/数论基础第一节/15343075827029.jpg" alt=""><br>可以换算成以下式子：<br><strong>a=c(<code>mod</code>b) 这里c为余数，而b为除数</strong></p><ul><li><strong>同余的性质</strong></li></ul><ol><li>自反性 a=a <code>mod</code> m</li><li>对称性 a=b <code>mod</code> m 等价于 b=a <code>mod</code> m</li><li>传递性 a=b <code>mod</code> m 与 b=c <code>mod</code> m 等价于 a=c <code>mod</code> m</li><li>线性合成 a=b <code>mod</code> m 与 c= <code>mod</code> m 等价于 a±c=b±d <code>mod</code> m 与 ac= bd <code>mod</code> m</li><li>消去公因子 ac=bc <code>mod</code> m &amp;&amp; gcd(c,m)=1 等价于 a=b <code>mod</code> m </li></ol><h2 id="素数筛"><a href="#素数筛" class="headerlink" title="素数筛"></a>素数筛</h2><ul><li>朴素筛 一般就是循环2~√n次</li><li>埃拉托斯特尼筛</li></ul><p><strong>循环次数</strong><br><img src="//www.wsx1128.xyz/2018/12/01/数论基础第一节/15343091959776.jpg" alt=""></p><ul><li>欧拉筛</li><li><img src="//www.wsx1128.xyz/2018/12/01/数论基础第一节/15343092628399.jpg" alt=""></li></ul><p><strong>相应代码如下：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="最大公约数以及最小公倍数"><a href="#最大公约数以及最小公倍数" class="headerlink" title="最大公约数以及最小公倍数"></a>最大公约数以及最小公倍数</h2><ul><li><p>最大公约数 函数_gcd(a,b)<br>而多个数的最大公约数 就是 _gcd(a,b,c)=_gcd(gcd(a,b),c)</p></li><li><p>最小公倍数<br>_lcm(a,b)=ab/_gcd(a,b)</p></li></ul><h2 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h2><p><img src="//www.wsx1128.xyz/2018/12/01/数论基础第一节/15343099257598.jpg" alt=""></p><ul><li>关于求解线性同余方程<br><img src="//www.wsx1128.xyz/2018/12/01/数论基础第一节/15343099683275.jpg" alt=""></li><li><p>关于求逆元<br><img src="//www.wsx1128.xyz/2018/12/01/数论基础第一节/15343099966167.jpg" alt=""></p></li><li><p>关于快速幂<br><img src="//www.wsx1128.xyz/2018/12/01/数论基础第一节/15343101054154.jpg" alt=""></p></li></ul><h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p><img src="//www.wsx1128.xyz/2018/12/01/数论基础第一节/15343101566104.jpg" alt=""></p><p><strong>另外</strong><br><img src="//www.wsx1128.xyz/2018/12/01/数论基础第一节/15343103411689.jpg" alt=""></p><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><ul><li><strong>欧拉函数定义</strong><br><img src="//www.wsx1128.xyz/2018/12/01/数论基础第一节/15343107143861.jpg" alt=""></li></ul><ul><li><p><strong>欧拉函数性质</strong><br><img src="//www.wsx1128.xyz/2018/12/01/数论基础第一节/15343107974985.jpg" alt=""></p></li><li><p><strong>求值公式</strong> </p></li></ul><ol><li><img src="//www.wsx1128.xyz/2018/12/01/数论基础第一节/15343109562640.jpg" alt=""></li><li><img src="//www.wsx1128.xyz/2018/12/01/数论基础第一节/15343109655205.jpg" alt=""></li><li><img src="//www.wsx1128.xyz/2018/12/01/数论基础第一节/15343109780637.jpg" alt=""><br>上述公式 可以用来：</li></ol><ul><li><p><strong>求逆元</strong><br><img src="//www.wsx1128.xyz/2018/12/01/数论基础第一节/15343110433806.jpg" alt=""></p></li><li><p><strong>欧拉降幂公式</strong><br><img src="//www.wsx1128.xyz/2018/12/01/数论基础第一节/15343111460573.jpg" alt=""></p></li></ul><h2 id="数论函数"><a href="#数论函数" class="headerlink" title="数论函数"></a>数论函数</h2><p><img src="//www.wsx1128.xyz/2018/12/01/数论基础第一节/15343114512818.jpg" alt=""></p><ul><li><strong>中国剩余定理</strong></li></ul><p><img src="//www.wsx1128.xyz/2018/12/01/数论基础第一节/15343114886344.jpg" alt=""></p><p><strong>解法</strong><br><img src="//www.wsx1128.xyz/2018/12/01/数论基础第一节/15343115089655.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;初等数论是用初等方法研究的数论，它的研究方法本质上说，就是利用整数环的整除性质，主要包括整除理论、同余理论、连分数理论。&lt;/p&gt;
&lt;h2 id=&quot;整除问题引申到同余问题&quot;&gt;&lt;a href=&quot;#整除问题引申到同余问题&quot; class=&quot;headerlink&quot; title=&quot;整除
      
    
    </summary>
    
      <category term="acm" scheme="http://www.wsx1128.xyz/categories/acm/"/>
    
    
      <category term="acm" scheme="http://www.wsx1128.xyz/tags/acm/"/>
    
      <category term="算法" scheme="http://www.wsx1128.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数论" scheme="http://www.wsx1128.xyz/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>条款01：视 C++ 为一个语言联邦</title>
    <link href="http://www.wsx1128.xyz/2018/12/01/%E6%9D%A1%E6%AC%BE01%EF%BC%9A%E8%A7%86%20C++%20%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6/"/>
    <id>http://www.wsx1128.xyz/2018/12/01/条款01：视 C++ 为一个语言联邦/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T13:08:22.838Z</updated>
    
    <content type="html"><![CDATA[<p>现在发展的C++已经是一个多重泛型编程语言。</p><hr><p>一个同时<strong>支持过程形式</strong>、<strong>支持面向对象形式</strong>、<strong>函数形式</strong>、<strong>泛型形式</strong>、<strong>元编程形式的语言</strong>，这些能力和弹性使 C++成为了一个无可匹敌的工具。<br>对待其的方式最简单的方法是将其看做是一个由相关语言组成的一个联邦而不是某个次语言。</p><ol><li><p><strong><em>C</em></strong> 说到底 C++ 仍然是 C 的一个延伸，面对过程的编程思想仍然在某些时候很受用，而某些时刻 C++ 的解法只不过就是比 C 高级了一点点，但是当你以 C++的内 C 成分的工作的时候，高效编程则映照出了 C 语言的局限，没有模板，没有异常，没有重载。</p></li><li><p><strong><em>Object-Oriented C++</em></strong> 这部分也就是 C++ 中面对对象编程思想的直接体现，简单来说就是 C with class 比如 类，封装，继承，多态，虚函数的动态绑定。</p></li><li><p><strong><em>Template C++</em></strong> 这是 C++中的泛型编程部分，template 的相关考虑与设计已经弥漫了整个 C++ 而这种编程思想的强大，直接带来了全新的名字 模板元编程，后面得花上大部分时间去专研这个。</p></li><li><p><strong><em>STL</em></strong> 基本上包括 容器，迭代器，算法以及相应的函数对象，一般竞赛可能会直接用到里面的相关容器以及相关算法，熟练使用 STL 也是一名 C++ 程序员应该必备的素质。</p></li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在发展的C++已经是一个多重泛型编程语言。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;一个同时&lt;strong&gt;支持过程形式&lt;/strong&gt;、&lt;strong&gt;支持面向对象形式&lt;/strong&gt;、&lt;strong&gt;函数形式&lt;/strong&gt;、&lt;strong&gt;泛型形式&lt;/strong&gt;、&lt;str
      
    
    </summary>
    
      <category term="effective C++" scheme="http://www.wsx1128.xyz/categories/effective-C/"/>
    
    
      <category term="c++" scheme="http://www.wsx1128.xyz/tags/c/"/>
    
      <category term="effective C++" scheme="http://www.wsx1128.xyz/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>条款02：尽量以const,enum,inline 替换掉#define</title>
    <link href="http://www.wsx1128.xyz/2018/12/01/%E6%9D%A1%E6%AC%BE02%EF%BC%9A%E5%B0%BD%E9%87%8F%E4%BB%A5const,enum,inline%20%E6%9B%BF%E6%8D%A2%E6%8E%89#define/"/>
    <id>http://www.wsx1128.xyz/2018/12/01/条款02：尽量以const,enum,inline 替换掉#define/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T13:08:22.838Z</updated>
    
    <content type="html"><![CDATA[<h3 id="这个条款其实也就相当于宁可编译器替换预处理器比较好"><a href="#这个条款其实也就相当于宁可编译器替换预处理器比较好" class="headerlink" title="这个条款其实也就相当于宁可编译器替换预处理器比较好"></a><strong>这个条款其实也就相当于宁可编译器替换预处理器比较好</strong></h3><hr><h4 id="1-对于单纯常量而言，使用-const-对象或者是-enums-比-define-更加省时间"><a href="#1-对于单纯常量而言，使用-const-对象或者是-enums-比-define-更加省时间" class="headerlink" title="1. 对于单纯常量而言，使用 const 对象或者是 enums 比 #define 更加省时间"></a>1. 对于单纯常量而言，使用 const 对象或者是 enums 比 #define 更加省时间</h4><ul><li>时间上更为节省 作为一个语言常量而不是名称记号，由于在函数体中分配了内存，追寻起来消耗的时间比在函数中使用名称记号所花的时间更少，因为有实处更容易寻找，不像名称记号，可能有的时候并没有进入到记号表中。</li><li>还有一些其他的只能使用 const 情况 定义常量指针和类的专属常量</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;这个条款其实也就相当于宁可编译器替换预处理器比较好&quot;&gt;&lt;a href=&quot;#这个条款其实也就相当于宁可编译器替换预处理器比较好&quot; class=&quot;headerlink&quot; title=&quot;这个条款其实也就相当于宁可编译器替换预处理器比较好&quot;&gt;&lt;/a&gt;&lt;strong&gt;这个条
      
    
    </summary>
    
      <category term="effective C++" scheme="http://www.wsx1128.xyz/categories/effective-C/"/>
    
    
      <category term="c++" scheme="http://www.wsx1128.xyz/tags/c/"/>
    
      <category term="effective C++" scheme="http://www.wsx1128.xyz/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>条款03：尽可能使用 const</title>
    <link href="http://www.wsx1128.xyz/2018/12/01/%E6%9D%A1%E6%AC%BE03%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8%20const/"/>
    <id>http://www.wsx1128.xyz/2018/12/01/条款03：尽可能使用 const/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T13:08:22.838Z</updated>
    
    <content type="html"><![CDATA[<p>首先使用 const 可以防止后期莫名其妙的进行改变原有的意思，相当于一个约束语义，另外编译器不论什么时候都会强制施行这项约束。</p><ol><li><p>const 在 C++ 11 中有底层和顶层之分，前者是作用于指针本身，指针不再改变指向对象，而顶层 const 则<br>是指针所指向的对象则不能发生改变。</p></li><li><p>const 最具威力的用法实在面对函数声明时的用法，在一个函数的声明式里，const 可以和函数的返回值，各自的参数以及函数自身产生关联。</p></li><li><p>将引用参数设置成 const 好处是在后面写代码的过程中如果把==写成=，可以立马甄别出来。</p></li><li><p>const 成员函数存在的两个理由，一个使 class 的接口一目了然，因为知道了哪些可以被改动对象而哪些不可以被改动对象，第二则是基于代码编写的高效性而言，操作 const 对象成为可能，因为可以通过 const 成员函数返回 const 对象。</p></li><li><p>存在一种特殊情况，重载[ ]运算符的时候，如果成员函数是 const 那么其的返回值也必须是 const&amp;类型的。</p></li><li><p>如果对于const 成员函数，想要改变该对象的内部成员的话，但是又不想全部改变的话，可以在类中的数据成员定义中加上 mutable，来保证可以改变该函数，其存在的意义就在于保证了其他数据成员不能被 const 成员函数改变，但是该数据成员却可以。</p></li></ol><p>7.当 const 和 non-const 成员函数有实质等价的实现时，令 non-const 版本调用 const 版本可避免代码重复。     </p><p><strong><em>这一点还不是特别了解，需要看到后面之后花点时间来看看这一点的内容。</em></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先使用 const 可以防止后期莫名其妙的进行改变原有的意思，相当于一个约束语义，另外编译器不论什么时候都会强制施行这项约束。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;const 在 C++ 11 中有底层和顶层之分，前者是作用于指针本身，指针不再改变指向对象，而顶层 const
      
    
    </summary>
    
      <category term="effective C++" scheme="http://www.wsx1128.xyz/categories/effective-C/"/>
    
    
      <category term="c++" scheme="http://www.wsx1128.xyz/tags/c/"/>
    
      <category term="effective C++" scheme="http://www.wsx1128.xyz/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>条款04：确定对象被使用前已先被初始化</title>
    <link href="http://www.wsx1128.xyz/2018/12/01/%E6%9D%A1%E6%AC%BE04%EF%BC%9A%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://www.wsx1128.xyz/2018/12/01/条款04：确定对象被使用前已先被初始化/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T13:08:22.838Z</updated>
    
    <content type="html"><![CDATA[<h4 id="在-C-语言中对象的初始化可能会变得异常容易，但是在-C-中某些语境下进行对象可能不会存在自动的初始化过程，也许会在使用-C-part-of-C-会自动有一个初始化过程，但是在其他部分下面的-C-就不能保证初始化过程了。"><a href="#在-C-语言中对象的初始化可能会变得异常容易，但是在-C-中某些语境下进行对象可能不会存在自动的初始化过程，也许会在使用-C-part-of-C-会自动有一个初始化过程，但是在其他部分下面的-C-就不能保证初始化过程了。" class="headerlink" title="在 C 语言中对象的初始化可能会变得异常容易，但是在 C++中某些语境下进行对象可能不会存在自动的初始化过程，也许会在使用 C part of C++ 会自动有一个初始化过程，但是在其他部分下面的 C++就不能保证初始化过程了。"></a>在 C 语言中对象的初始化可能会变得异常容易，但是在 C++中某些语境下进行对象可能不会存在自动的初始化过程，也许会在使用 C part of C++ 会自动有一个初始化过程，但是在其他部分下面的 C++就不能保证初始化过程了。</h4><ol><li><p>特别是在类的过程中，初始化的过程一般直接交给构造函数，初始化的过程并不等同于赋值，所以在写类的构造函数的时候，尽量不要在函数体里面写赋值给私有成员的语句，可以直接在列表上面直接写初始化的。</p></li><li><p>对于拥有多个构造函数，且每个构造函数具有自己的成员初值列，如果这些类存在许多成员变量或者基类的话，多种成员初始列表就会导致不受欢迎的重复，那么这个时候可以遗漏一些“赋值跟初始化过程差不读的成员变量”，改用他们的赋值操作，并且把这些操作放置在 private 中。</p></li><li><p>C++有着十分固定的成员初始化过程，基类的初始化会早于派生类，而类的成员变量总是以其声明的次序被初始化。</p></li><li><p>关于类的静态成员的初始化 一般在类内部进行声明，然后再类的外部进行定义，赋值，其的声明周期一般是从程序开始到程序结束。</p></li><li><p>构造函数初始化的次序非常重要，举个例子就是初始化的时候必须要为数组指定大小，所以指定大小的变量必须具有先值</p></li><li><p>对于不同人在不同时间下不同的源码文件建立起来，其的初始化相对次序并没有明确定义，所以解决办法就是将一个对象搬到自己的专属函数里面去，然后声明成静态成员，并且返回一个引用即可，后面用户直接调用这些函数，就可以无视初始化的次序问题了。具体可以看书里面P32面的相关代码。</p></li><li><p>最后总结一句为了免除“跨编译单元之初始化次序”问题，一般用 local static 对象替换 non-local static 对象。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;在-C-语言中对象的初始化可能会变得异常容易，但是在-C-中某些语境下进行对象可能不会存在自动的初始化过程，也许会在使用-C-part-of-C-会自动有一个初始化过程，但是在其他部分下面的-C-就不能保证初始化过程了。&quot;&gt;&lt;a href=&quot;#在-C-语言中对象的
      
    
    </summary>
    
      <category term="effective C++" scheme="http://www.wsx1128.xyz/categories/effective-C/"/>
    
    
      <category term="c++" scheme="http://www.wsx1128.xyz/tags/c/"/>
    
      <category term="effective C++" scheme="http://www.wsx1128.xyz/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>条款05：了解 C++默默编写并调用了哪些函数</title>
    <link href="http://www.wsx1128.xyz/2018/12/01/%E6%9D%A1%E6%AC%BE05%EF%BC%9A%E4%BA%86%E8%A7%A3%20C++%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0/"/>
    <id>http://www.wsx1128.xyz/2018/12/01/条款05：了解 C++默默编写并调用了哪些函数/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T13:08:22.838Z</updated>
    
    <content type="html"><![CDATA[<p>几乎每一个 class 都会用一个或多个构造函数，一个析构函数，一个拷贝重载运算符，有些是系统自动生成的合成版本，有些是需要自定义的版本，所以这一条款的目的是为了探寻哪些是需要自己去写，哪一些是需要系统自身合成的。</p><ol><li><p>千万不要写完构造函数或者拷贝构造函数或者是析构函数之后不去定义，那么会造成问题，而且此类问题会造成很多方面上的无法适应问题。</p></li><li><p>另外这里额外需要注意的是 C++11上增加的移动语义，只有在拥有了拷贝构造函数和拷贝赋值运算符之后，编译器才会自动生成移动构造函数，和移动赋值运算符。</p></li><li><p>最后这个条款需要注意的就是编译器自动生成的函数具有普遍性，所以就不具有特异性，一些特殊的操作在合成版本上面可能会出现大问题。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;几乎每一个 class 都会用一个或多个构造函数，一个析构函数，一个拷贝重载运算符，有些是系统自动生成的合成版本，有些是需要自定义的版本，所以这一条款的目的是为了探寻哪些是需要自己去写，哪一些是需要系统自身合成的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;千万不要写完构造函数或者拷
      
    
    </summary>
    
      <category term="effective C++" scheme="http://www.wsx1128.xyz/categories/effective-C/"/>
    
    
      <category term="c++" scheme="http://www.wsx1128.xyz/tags/c/"/>
    
      <category term="effective C++" scheme="http://www.wsx1128.xyz/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>条款06：若不想使用编译器自动生成的函数，就应该明确拒绝</title>
    <link href="http://www.wsx1128.xyz/2018/12/01/%E6%9D%A1%E6%AC%BE06%EF%BC%9A%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E5%BA%94%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D/"/>
    <id>http://www.wsx1128.xyz/2018/12/01/条款06：若不想使用编译器自动生成的函数，就应该明确拒绝/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T13:08:22.838Z</updated>
    
    <content type="html"><![CDATA[<h4 id="有的时候鉴于某些情况，比如智能指针中-unique-str-和-io-库对象无法发生拷贝和赋值，是因为明确在类的内部进行了拒绝操作，所以无法拷贝与赋值，这一个条款就来讲解有哪些方法可以用来拒绝。"><a href="#有的时候鉴于某些情况，比如智能指针中-unique-str-和-io-库对象无法发生拷贝和赋值，是因为明确在类的内部进行了拒绝操作，所以无法拷贝与赋值，这一个条款就来讲解有哪些方法可以用来拒绝。" class="headerlink" title="有的时候鉴于某些情况，比如智能指针中 unique_str 和 io 库对象无法发生拷贝和赋值，是因为明确在类的内部进行了拒绝操作，所以无法拷贝与赋值，这一个条款就来讲解有哪些方法可以用来拒绝。"></a>有的时候鉴于某些情况，比如智能指针中 unique_str 和 io 库对象无法发生拷贝和赋值，是因为明确在类的内部进行了拒绝操作，所以无法拷贝与赋值，这一个条款就来讲解有哪些方法可以用来拒绝。</h4><ol><li><p>把自己不想要的函数，但是系统默认又会生成的函数放到私有成员中，这种方法很简便，但是有一个缺点就是在类的内部定义中仍然是可以使用拷贝与赋值功能的。</p></li><li><p>继承一个基类，使用 private 继承方法，然后将这个基类的函数放入私有成员中，这样就可以保证万无一失的方法，但是缺点就是太复杂，还需要定一个基类。</p></li><li><p>C++11 提出的新办法将函数声明出来，不仅不去定义，而且直接声明成 delete。这样更便捷。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;有的时候鉴于某些情况，比如智能指针中-unique-str-和-io-库对象无法发生拷贝和赋值，是因为明确在类的内部进行了拒绝操作，所以无法拷贝与赋值，这一个条款就来讲解有哪些方法可以用来拒绝。&quot;&gt;&lt;a href=&quot;#有的时候鉴于某些情况，比如智能指针中-uniq
      
    
    </summary>
    
      <category term="effective C++" scheme="http://www.wsx1128.xyz/categories/effective-C/"/>
    
    
      <category term="c++" scheme="http://www.wsx1128.xyz/tags/c/"/>
    
      <category term="effective C++" scheme="http://www.wsx1128.xyz/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>条款07：为多态基类声明 virtual 析构函数</title>
    <link href="http://www.wsx1128.xyz/2018/12/01/%E6%9D%A1%E6%AC%BE07%EF%BC%9A%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8E%20virtual%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    <id>http://www.wsx1128.xyz/2018/12/01/条款07：为多态基类声明 virtual 析构函数/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T13:08:22.839Z</updated>
    
    <content type="html"><![CDATA[<h4 id="在进行基类与派生类之间动态绑定的时候，如果发生对象销毁调用的析构函数不是虚函数的话，那么就会造成析构销毁部分的现象。"><a href="#在进行基类与派生类之间动态绑定的时候，如果发生对象销毁调用的析构函数不是虚函数的话，那么就会造成析构销毁部分的现象。" class="headerlink" title="在进行基类与派生类之间动态绑定的时候，如果发生对象销毁调用的析构函数不是虚函数的话，那么就会造成析构销毁部分的现象。"></a>在进行基类与派生类之间动态绑定的时候，如果发生对象销毁调用的析构函数不是虚函数的话，那么就会造成析构销毁部分的现象。</h4><ol><li><p>C++明确指出，当 derived class 对象经由一个 base class指针被删除，而该 base class 带着一个不是虚函数的析构函数的话，其结果往往都是自定义的，就像上述的说法而言，往往是对象的 derived 成分没有被销毁，而且消除这个问题最简单的办法是在基类的析构函数上面加上虚函数的声明。</p></li><li><p>不要随便继承标准库里面的东西，因为里面大部分东西都不存在虚函数的析构函数，这样一来，如果使用动态绑定的话，那么在销毁对象的过程中就没有办法全部销毁了。</p></li><li><p>而且不一定是基类的析构函数设置成虚函数，只要类里面有一个函数是虚函数的话，那么就需要将析构函数定义成虚函数。</p></li><li><p>类的用途不是作为多态的用途的话，那么请不要将析构函数声明成虚函数，因为那样没有作用。</p></li><li><p>对于一个纯虚函数而言，这个类就是一个抽象类，但是由于存在一个析构函数，所以一般要为这个纯虚函数提供定义，其的运作方式是最深层派生的那个类的析构函数最先被调用，然后就是每一个基类的析构函数被调用，所以编译器会在派生类的析构函数中定一个对基类纯虚析构函数的调用动作，因此，一般都得进行调用。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;在进行基类与派生类之间动态绑定的时候，如果发生对象销毁调用的析构函数不是虚函数的话，那么就会造成析构销毁部分的现象。&quot;&gt;&lt;a href=&quot;#在进行基类与派生类之间动态绑定的时候，如果发生对象销毁调用的析构函数不是虚函数的话，那么就会造成析构销毁部分的现象。&quot; cl
      
    
    </summary>
    
      <category term="effective C++" scheme="http://www.wsx1128.xyz/categories/effective-C/"/>
    
    
      <category term="c++" scheme="http://www.wsx1128.xyz/tags/c/"/>
    
      <category term="effective C++" scheme="http://www.wsx1128.xyz/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>条款08：别让异常逃离析构函数</title>
    <link href="http://www.wsx1128.xyz/2018/12/01/%E6%9D%A1%E6%AC%BE08%EF%BC%9A%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    <id>http://www.wsx1128.xyz/2018/12/01/条款08：别让异常逃离析构函数/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T13:08:22.839Z</updated>
    
    <content type="html"><![CDATA[<p>其实这一项条款没有领悟的很深刻，可以理解成不要再析构函数里面写捕获异常之类的代码。因为某些时候，如果在析构函数里面抓获异常导致程序终止的话，那么就可能造成对象不能完全被销毁</p><ol><li><p>析构函数绝对不要吐出异常，如果一个被析构函数调用的函数可能抛出异常的话，析构函数应该做的应该是捕捉任何异常，然后吞下他们（不传播）或者结束程序。</p></li><li><p>如果对象需要对摸个操作函数运行期间抛出的异常做出反应，那么 class 应该提供一个普通函数（不应该在析构函数里面）执行该任务。但是该析构函数里面仍然要进行双保险的析构过程，可以在类的内部定义里面加上一个 bool 变量来判断到底有没有运行析构行为，相当于一般写程序的一个 flag。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实这一项条款没有领悟的很深刻，可以理解成不要再析构函数里面写捕获异常之类的代码。因为某些时候，如果在析构函数里面抓获异常导致程序终止的话，那么就可能造成对象不能完全被销毁&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;析构函数绝对不要吐出异常，如果一个被析构函数调用的函数可能抛出异常的
      
    
    </summary>
    
      <category term="effective C++" scheme="http://www.wsx1128.xyz/categories/effective-C/"/>
    
    
      <category term="c++" scheme="http://www.wsx1128.xyz/tags/c/"/>
    
      <category term="effective C++" scheme="http://www.wsx1128.xyz/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>条款09：绝不在构造和析构的过程中调用 virtual 函数</title>
    <link href="http://www.wsx1128.xyz/2018/12/01/%E6%9D%A1%E6%AC%BE09%EF%BC%9A%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8%20virtual%20%E5%87%BD%E6%95%B0/"/>
    <id>http://www.wsx1128.xyz/2018/12/01/条款09：绝不在构造和析构的过程中调用 virtual 函数/</id>
    <published>2018-12-01T15:26:24.000Z</published>
    <updated>2018-12-01T13:08:22.839Z</updated>
    
    <content type="html"><![CDATA[<h4 id="绝对不要在构造函数和析构函数期间调用虚函数，因为这样调用的结果不会带来预想的结果。"><a href="#绝对不要在构造函数和析构函数期间调用虚函数，因为这样调用的结果不会带来预想的结果。" class="headerlink" title="绝对不要在构造函数和析构函数期间调用虚函数，因为这样调用的结果不会带来预想的结果。"></a>绝对不要在构造函数和析构函数期间调用虚函数，因为这样调用的结果不会带来预想的结果。</h4><ol><li><p>基类构造函数的时候，虚函数是不会下降到派生类中，原因就是在基类开始构造函数的时候，该类的类型是基类，而不是派生类，简单来说，如果想在构造函数的过程中，直接使用基类的虚函数来折射到派生类，从而帮助派生类完成构造的话，那么这种办法一定行不通。</p></li><li><p>相同的道理同上，在基类析构函数发生的过程中，同样将其他的派生类视作未定义。</p></li><li><p>如果将构造函数或者析构函数调用的函数设立成纯虚函数的话，那么当纯虚函数被调用的时候，大多数执行系统会直接终止程序，唯一避免的此问题的做法就是确定构造和析构期间没有调用虚函数。</p></li><li><p>唯一的替代方案是不设置虚函数，比如在构造一个派生类对象的时候，需要直接调用基类函数的构造函数，然后再完成派生类的构造，而此时最好是将派生类里面一个作用于构造函数的一个成员函数定义成静态函数，这样的话就能在程序刚开始就存在该函数了。</p></li><li><p>由第四点换句话说，你无法使用虚函数直接从基函数向下调用，但是在基类函数中可以由派生类将信息传递到基类从而进行有效调用。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;绝对不要在构造函数和析构函数期间调用虚函数，因为这样调用的结果不会带来预想的结果。&quot;&gt;&lt;a href=&quot;#绝对不要在构造函数和析构函数期间调用虚函数，因为这样调用的结果不会带来预想的结果。&quot; class=&quot;headerlink&quot; title=&quot;绝对不要在构造函数和
      
    
    </summary>
    
      <category term="effective C++" scheme="http://www.wsx1128.xyz/categories/effective-C/"/>
    
    
      <category term="c++" scheme="http://www.wsx1128.xyz/tags/c/"/>
    
      <category term="effective C++" scheme="http://www.wsx1128.xyz/tags/effective-C/"/>
    
  </entry>
  
</feed>

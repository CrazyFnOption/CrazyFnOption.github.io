<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>PTA 1007 最大序列和问题</title>
      <link href="/2019/07/13/PTA-1007-%E6%9C%80%E5%A4%A7%E5%BA%8F%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2019/07/13/PTA-1007-%E6%9C%80%E5%A4%A7%E5%BA%8F%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2019/07/13/PTA-1007-最大序列和问题/1.png" alt="1"></p><p><strong>这道题是一道简单的动态规划，可能是太久没有做这方面的题目了，总是对这一部分忘记，其实最终结果就是一个贪心解决问题。</strong></p><p>贴出代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其实这道题也算是一道特别简单的题目，还是动态规划里面最基础的问题，但是总是容易去弄混。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    记得自己当时的问题就在于 这里每一次相加的和，如何保证后面加了负数之后，再次加上一个正数不被影响呢，</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    下面的注释里面有写，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    因为题目中限制了，如果这道题有多个答案，比如说 前面与后面相加为零，但是后面的那个正数正好作为最后的正确答案的话</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    比如 1 2 -3 8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    1 2 -3 正好相加为0  但是题目中要求的 序列 1 2 -3 8 作为最后的结果序列。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    自己当时也在这一块上面纠结。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> num[m + <span class="number">5</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tmpleft = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> Max = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">        tmp += num[i];</span><br><span class="line">        <span class="comment">//In case that the maximum subsequence is not unique, </span></span><br><span class="line">        <span class="comment">//output the one with the smallest indices i and j (as shown by the sample case).</span></span><br><span class="line">        <span class="keyword">if</span> (tmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            tmp = <span class="number">0</span>;</span><br><span class="line">            tmpleft = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tmp &gt; Max) &#123;</span><br><span class="line">            Max = tmp;</span><br><span class="line">            right = i;</span><br><span class="line">            left = tmpleft;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//If all the K numbers are negative, then its maximum sum is defined to be 0, </span></span><br><span class="line">    <span class="comment">//and you are supposed to output the first and the last numbers of the whole sequence.</span></span><br><span class="line">    <span class="keyword">if</span> (Max &gt;= <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; Max &lt;&lt; <span class="string">" "</span> &lt;&lt; num[left] &lt;&lt; <span class="string">" "</span> &lt;&lt; num[right] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; num[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; num[m - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PTA 1004 简单的dfs</title>
      <link href="/2019/06/27/PTA-1004-%E7%AE%80%E5%8D%95%E7%9A%84dfs/"/>
      <url>/2019/06/27/PTA-1004-%E7%AE%80%E5%8D%95%E7%9A%84dfs/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这里直接贴出题目：</p><p><img src="/2019/06/27/PTA-1004-简单的dfs/111.png" alt="PTA-1004-简单的dfs"></p><p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; kids[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> maxlever = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> nums[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (kids[root].size() == <span class="number">0</span>) &#123;</span><br><span class="line">        maxlever = max(depth,maxlever);</span><br><span class="line">        nums[depth]++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kids[root].size() ; i++) &#123;</span><br><span class="line">        dfs(kids[root][i],depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> fa,num;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="built_in">memset</span>(nums,<span class="number">0</span>,<span class="keyword">sizeof</span> nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; fa &gt;&gt; num;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; num; i ++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">            kids[fa].push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; nums[<span class="number">0</span>] ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxlever; i++ ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我可能是太久没有写代码了，上面这样一道水题，我先开始就被完完全全的弄糊涂了，这道题就是一个简单的dfs，首先先把数之间的对应关系一点一点的打通，然后再根据后面dfs的递归可以得出来，就是一个简单的根据根节点一点一点的往后面递归搜索，然后达到终点之后，记得把这一个层的叶子结点数加一，这里注意两点，可以发现 在cin的处理里面，可以直接将00，01，02，直接变成相应的0，1，2；</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PTA 1003 Dijkstra ---- 关于Dijkstra单源最短路的相应总结</title>
      <link href="/2019/06/25/PTA-1003-Dijkstra-%E5%85%B3%E4%BA%8EDijkstra%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%9A%84%E7%9B%B8%E5%BA%94%E6%80%BB%E7%BB%93/"/>
      <url>/2019/06/25/PTA-1003-Dijkstra-%E5%85%B3%E4%BA%8EDijkstra%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%9A%84%E7%9B%B8%E5%BA%94%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="首先-这里先贴出题目"><a href="#首先-这里先贴出题目" class="headerlink" title="首先 这里先贴出题目"></a>首先 这里先贴出题目</h2><p><img src="/2019/06/25/PTA-1003-Dijkstra-关于Dijkstra单源最短路的相应总结/12.png" alt="PTA-1003-Dijkstra-关于Dijkstra单源最短路的相应总结"></p><p>解题代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">505</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,_beg,_end;</span><br><span class="line"><span class="keyword">int</span> people[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> _map[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> paths[maxn];</span><br><span class="line"><span class="keyword">int</span> Maxvalue[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> beg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,inf,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    dis[beg] = <span class="number">0</span>;</span><br><span class="line">    paths[beg] = <span class="number">1</span>;</span><br><span class="line">    Maxvalue[beg] = people[beg];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> Min = <span class="number">0x3f3f3f</span>, index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; dis[j] &lt; Min) &#123;</span><br><span class="line">                Min = dis[j];</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        vis[index] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; _map[index][j] != inf) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[index] + _map[index][j] &lt; dis[j]) &#123;</span><br><span class="line">                    dis[j] = dis[index] + _map[index][j];</span><br><span class="line">                    paths[j] = paths[index];</span><br><span class="line">                    Maxvalue[j] = Maxvalue[index] + people[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (dis[index] + _map[index][j] == dis[j]) &#123;</span><br><span class="line">                    paths[j] += paths[index];</span><br><span class="line">                    Maxvalue[j] = max(Maxvalue[j],Maxvalue[index] + people[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; _beg &gt;&gt; _end;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; people[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x,y,val;</span><br><span class="line">    <span class="built_in">memset</span>(_map,inf,<span class="keyword">sizeof</span> _map);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; val;</span><br><span class="line">        _map[x][y] = val;</span><br><span class="line">        _map[y][x] = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Dijkstra(_beg);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; paths[_end] &lt;&lt; <span class="string">" "</span> &lt;&lt; Maxvalue[_end] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里明显就是关于Dijkstra的裸题，变化的地方就是加了一两个内置数组，作为状态的变化，类似于动态规划，到后面就可以解题解出来了。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数论总结</title>
      <link href="/2019/05/06/%E6%95%B0%E8%AE%BA%E6%80%BB%E7%BB%93/"/>
      <url>/2019/05/06/%E6%95%B0%E8%AE%BA%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数论总结"><a href="#数论总结" class="headerlink" title="数论总结"></a>数论总结</h1><pre><code>来自西北工业大学的讲义以及题目的总结</code></pre><h2 id="素数运算实验范例"><a href="#素数运算实验范例" class="headerlink" title="素数运算实验范例"></a>素数运算实验范例</h2><pre><code>这里将的就是与素数相关的筛法，这里介绍两种筛法。</code></pre><h3 id="素数的线性筛法"><a href="#素数的线性筛法" class="headerlink" title="素数的线性筛法"></a>素数的线性筛法</h3><p><em>埃式筛法</em><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最普通的埃式筛法</span></span><br><span class="line"><span class="built_in">memset</span>(check, <span class="number">0</span>, <span class="keyword">sizeof</span>(check));</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!check[i])</span><br><span class="line">    &#123;</span><br><span class="line">        prime[tot++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面其实用乘法和用加法都是一样的，而这里就是乘法的原因就在于，减少了循环次数</span></span><br><span class="line">    <span class="comment">// 唯一没有被优化的地方就在于 每一个数字被重复标记了很多次，而后面的欧拉筛就会限制标记次数为一次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt;= n; j *= i)</span><br><span class="line">    &#123;</span><br><span class="line">        check[j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>欧拉筛法</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进阶版的线性筛法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//质数数组</span></span><br><span class="line"><span class="keyword">int</span> prime[MAXN];</span><br><span class="line"><span class="comment">//判断每一个数 数组</span></span><br><span class="line"><span class="keyword">int</span> check[MAXL];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(check, <span class="number">0</span>, <span class="keyword">sizeof</span>(check));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAXL; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!check[i])</span><br><span class="line">    &#123;</span><br><span class="line">        prime[tot++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//大致意思就在于 将每一个数的与质数数组里面的数进行相乘，最后得到的结果存在check中去</span></span><br><span class="line">        <span class="comment">//需要注意的就是 一旦当前的数能被整除的时候 就立马退出，这样代表每一个数字都会被自己的最小质因数给整除出来。</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i * prime[j] &gt; MAXL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        check[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后下面就由上面两种线性筛法引申出来下面两个结论</p><p><em>每一个大于4的偶数可以写成两个奇素数的和。(poj 2262)</em></p><p><em>每一个大于8的数字可以分为4个素数的和。(uva 10168)</em></p><h3 id="大素数的实验范例"><a href="#大素数的实验范例" class="headerlink" title="大素数的实验范例"></a>大素数的实验范例</h3><pre><code>一般这里还存在一些超过给出的素数表的范围，或者是打表到那个地方一定会反超之类的题目，这里都使用一种类似于区间筛法的办法去解决问题。</code></pre><p>比如 uva 10871:</p><p>打出 2 到 根号n范围的表，然后超过这个范围的数，对于这个数里面的数全部去除以前面打表产生的素数表，看能不能除尽，来判断这个大整数是否是素数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这道题 其实利用了素数表之后，就是一个一次遍历的过程了 不过我没有想到的是，</span></span><br><span class="line"><span class="comment">    这道题其实已经提前将每一个sum给记录下来了，就相当于一个打表的方式。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    另外这道题第二个爆点就在于 当超出了表范围内的大数怎么办，这里就可以用分两种，第一种是在这种情况的直接看表，</span></span><br><span class="line"><span class="comment">    另外一种就是用 这个数去mod 表内的每一个质数，这样可以加快时间。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10011</span>;</span><br><span class="line"><span class="keyword">bool</span> u[maxn];</span><br><span class="line"><span class="keyword">int</span> su[maxn];</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="built_in">memset</span>(u, <span class="literal">true</span>, <span class="keyword">sizeof</span>(u));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (u[i])</span><br><span class="line">        &#123;</span><br><span class="line">            su[++num] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= num; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * su[j] &gt; maxn)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            u[i * su[j]] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i % su[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pri</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">10010</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> u[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % su[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    prepare();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">int</span> s[n + <span class="number">1</span>];</span><br><span class="line">        s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;s[i]);</span><br><span class="line">            s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j + i - <span class="number">1</span> &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> k = s[i + j - <span class="number">1</span>] - s[j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (pri(k))</span><br><span class="line">                &#123;</span><br><span class="line">                    ok = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Shortest primed subsequence is length %d:"</span>, i);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= i; ++k)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">" %d"</span>, s[j + k - <span class="number">1</span>] - s[j + k - <span class="number">2</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ok)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ok)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"This sequence is anti-primed.\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求解不定方程和同余的实验范例"><a href="#求解不定方程和同余的实验范例" class="headerlink" title="求解不定方程和同余的实验范例"></a>求解不定方程和同余的实验范例</h2><pre><code>这一个章节的东西基本上可以说是奠定了数论的基础，所以这部分的东西请务必掌握。</code></pre><p>首先这里先贴出 gcd 和 exgcd的代码</p><p><strong>欧几里得算法</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) retuan a;</span><br><span class="line">    <span class="keyword">return</span> gcd(b,a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>exgcd 扩展欧几里得算法</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span> <span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t = exgcd(b,a % b,x,y);</span><br><span class="line">    <span class="keyword">int</span> d = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = d - (a / b) * y;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>欧几里得算法是用来求解最大公约数的<br>由欧几里得公式推出 如果 a与b 互素，那么b * t + a 与 b 也一定互素。</p></blockquote><p>这里贴出一道题 就是对于上面gcd公式的周期性的利用</p><p><em>happy poj 2773</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这道题目就是在于对于gcd的周期性的使用。</span></span><br><span class="line"><span class="comment">    这道题就利用了与m互素的数对m去膜具有周期性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, k;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;k) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (gcd(m, i) == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s[num++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里其实进行了两种情况：一种刚好除尽的情况，</span></span><br><span class="line">        <span class="comment">//和另外一种没有刚好除尽的情况。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k % num == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这里减一的目的是刚刚好除尽，减去一个后面好加上一个ai;</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (k / num - <span class="number">1</span>) * m + s[num - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//后面的则就体现在了余数这个地方。，之所以减去1是因为num不可能算上的最后一个</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, k / num * m + s[k % num - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>扩展欧几里得算法是用来求最大公约数和不定方程的通解</p></blockquote><p>这里同样也贴出一道模板样题作为示范</p><p><em>The Balance poj 2142</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这道题就在于其很厉害的是 解释了ecgcd的真正的用途。</span></span><br><span class="line"><span class="comment">    这道题说难也不是很难，只是教会了一些数论题目全部的代码该如何去写。</span></span><br><span class="line"><span class="comment">    典型的求 不定方程的做法 ax + by = d;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    求解 一个  x，y 的满足条件的特解。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    这里写一下求解步骤 ：</span></span><br><span class="line"><span class="comment">    第一步 首先先得出这个方程，然后对方程两边同时除以gcd(a,b);</span></span><br><span class="line"><span class="comment">    在步入第二步的过程中有一个判断 就是看d 对于 gcd(a,b)的比较情况，决定这个不定方程是否有解；</span></span><br><span class="line"><span class="comment">    第二步 就是直接用未初始化的 x,y 带入exgcd求解 可以得到一个 x,y的其中一个特解 </span></span><br><span class="line"><span class="comment">    第三步 将得到的特解乘以相应的扩大的d_倍，最后按照题目规定的条件进行整改最终得出结果</span></span><br><span class="line"><span class="comment">    其中需要注意的是 上面得到的特解，只有在ax + by 正好等于gcd(a,b)的时候 才会同时满足。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span>  gcd(b,a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = exgcd(b,a % b,x,y);</span><br><span class="line">    <span class="keyword">int</span> _x = x;</span><br><span class="line">    <span class="keyword">int</span> _y = y;</span><br><span class="line">    x = _y;</span><br><span class="line">    y = _x - (a/b) * _y;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a,b,d;</span><br><span class="line"><span class="keyword">int</span> a_,b_,d_;</span><br><span class="line"><span class="keyword">int</span> x,y;<span class="comment">//通解</span></span><br><span class="line"><span class="keyword">int</span> q;</span><br><span class="line"><span class="keyword">int</span> x1,x2,y1,y2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;a,&amp;b,&amp;d) &amp;&amp; a &amp;&amp; b &amp;&amp; d) &#123;</span><br><span class="line">        q = gcd(a,b);</span><br><span class="line">        a_ = a / q;</span><br><span class="line">        b_ = b / q;</span><br><span class="line">        d_ = d / q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k = exgcd(a_,b_,x,y);</span><br><span class="line">        x1 = x * d_;</span><br><span class="line">        x1 = (x1 % b_ + b_) % b_;</span><br><span class="line">        y1 = (d - x1 * a) / b;</span><br><span class="line">        <span class="keyword">if</span> (y1 &lt; <span class="number">0</span>) y1 = -y1;</span><br><span class="line"></span><br><span class="line">        y2 = y * d_;</span><br><span class="line">        y2 = (y2 % a_ + a_) % a_;</span><br><span class="line">        x2 = (d - y2 * b) / a;</span><br><span class="line">        <span class="keyword">if</span> (x2 &lt; <span class="number">0</span>) x2 = -x2;</span><br><span class="line">        <span class="keyword">if</span> (x1 + y1 &lt; x2 + y2) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,x1,y1);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,x2,y2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还是讲求解不定方程的步骤再详细的过一遍</p><ol><li><p>得到不定方程ax + by = m，先判断 m 是否是gcd(a,b)的倍数，如果是说明方程有解，如果不是方程则没有解</p></li><li><p>有解之后，方程两边同时除以gcd(a,b)，然后将重新得到的a,b值带入到扩展欧几里得的方程式中得到两个通解x,y，</p></li><li><p>需要将得到的x 或者 y 值 扩大 经除后的m值，因为扩展欧几里得求的不定方程默认就是等于1的。对于这道题而言，想要求最小的正整数的通解，于是就 (x % b + b) % b, 这里就是防止C++取余带来的负数影响。</p></li></ol><p>下面还有一道题 也是求出不定方程的解，但是有一点点不同。</p><p><em>One Person Game zoj3593</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里的与上面一道题不一样的地方就在于 后面限制条件不太相同。</span></span><br><span class="line"><span class="comment">    前面一道题上面求出的一个特解，但是 取mod之后得到的结果，</span></span><br><span class="line"><span class="comment">    所以用改变后的变量值，来求另外一个。</span></span><br><span class="line"><span class="comment">    而这道题不一样的是是通过求解答案 然后 根据特解来算结构来算。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> _beg,_end,a,b;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> &amp;x,<span class="keyword">long</span> <span class="keyword">long</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> t = exgcd(b,a % b,x,y);</span><br><span class="line">    <span class="keyword">int</span> x_ = x;</span><br><span class="line">    <span class="keyword">int</span> y_ = y;</span><br><span class="line">    x = y_;</span><br><span class="line">    y = x_ - (a / b) * y_;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; _beg &gt;&gt; _end &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = _end - _beg;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> d,x,y;</span><br><span class="line">        d = exgcd(a,b,x,y);</span><br><span class="line">        <span class="keyword">if</span> (res % d != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x *= res / d;</span><br><span class="line">        y *= res / d;</span><br><span class="line">        a = a / d;</span><br><span class="line">        b = b / d;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = inf * inf,tmp;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mid = (y - x) / (a + b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mid - <span class="number">1</span>; i &lt;= mid + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> x1 = x + i * b;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> y1 = y - i * a;</span><br><span class="line">            <span class="keyword">if</span> (x1 * y1 &gt;= <span class="number">0</span>) tmp = max(<span class="built_in">abs</span>(x1),<span class="built_in">abs</span>(y1));</span><br><span class="line">            <span class="keyword">else</span> tmp = <span class="built_in">abs</span>(x1 - y1);</span><br><span class="line">            ans = min(ans,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题不一样的是 他不是像前面求出通解之后求一个最小或者最大，我的理解就是 因为 其算出来的通解为 x = xo + k <em> b,y = yo - k </em> a ,其实将这里两个特解 直接当成0来算，因为题目要求最小，并且 a , b 的差距还不能太大，就直接求出 k的范围 然后 对其进行加1 减1的操作得出最后结果。</p><h3 id="计算同余方程与同余方程组"><a href="#计算同余方程与同余方程组" class="headerlink" title="计算同余方程与同余方程组"></a>计算同余方程与同余方程组</h3><pre><code>关于同余理论，自己的其他相关博客已经存在讲解这里就不在过多介绍了，</code></pre><p>这里有一道经典的题，以后有时间插一下代码。</p><p>这里再次总结一下一元线性同余方程的解法。</p><blockquote><ol><li>首先首先 线性同余方程可以表示为 ax =- b(mod m)  就这样可以表示为一个不定方程式 ax = b + ym;</li><li>先求出 b % gcd(a,m)  判断其是否为0，如果不为0，那么以上的同余方程式或者不定方程式无解。如果 得到的结果为j，那么说明该方程有 j个 mod m 不同余的解 d = gcd(a,m);</li><li>当用欧几里得算法求出以上的解之后 得到其实是  ax=- d(mod m) 这一同余方程中 x 的解。所以说人话就是 当求出了那个特解之后 再去乘以之前 的 B 值 最后mod m得到最终同余方程的解。<br>2</li></ol></blockquote><blockquote><p>关于计算同余方程，其实与求解扩展欧几里得通解的效果是一样的，</p></blockquote><p><em>C_Loop poj2115</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这道题其实再一次涉及到 exgcd的另外一个用法 这个用法仍然是从其中求解不定方程的作用中延伸过来的。</span></span><br><span class="line"><span class="comment">    这道题就是一个简单的一维的线性求余过程，</span></span><br><span class="line"><span class="comment">    对于这道题就显示一下 线性同余的过程</span></span><br><span class="line"><span class="comment">    首先 线性同余方程可以表示为 ax =- b(mod m)  就这样可以表示为一个不定方程式 ax = b + ym;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    所以第一步 先求出 b % gcd(a,m)  判断其是否为0，如果不为0，那么以上的同余方程式或者不定方程式无解。</span></span><br><span class="line"><span class="comment">    如果 得到的结果为j，那么说明该方程有 j个 mod m 不同余的解</span></span><br><span class="line"><span class="comment">    d = gcd(a,m);</span></span><br><span class="line"><span class="comment">    当用欧几里得算法求出以上的解之后 得到其实是  ax` =- d(mod m) 这一同余方程中 x`的解。</span></span><br><span class="line"><span class="comment">    所以根据判断d是否等于0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    可以求出第一个解释x0 = x` * (b / d) mod m; </span></span><br><span class="line"><span class="comment">    而其余d - 1的解就是 xi = (x0 + i *(m / d)) mod m;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    所以说人话就是 当求出了那个特解之后 再去乘以之前 的 B 值 最后mod m得到最终同余方程的解。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> &amp;x,<span class="keyword">long</span> <span class="keyword">long</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> t = exgcd(b,a % b,x,y);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> d = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = d - (a / b) * y;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> gcd(b,a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a,b,c,k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x,y;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld %lld"</span>,&amp;a,&amp;b,&amp;c,&amp;k)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span> &amp; c == <span class="number">0</span> &amp;&amp; k ==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> gap = b - a;</span><br><span class="line">        k = ((<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">1</span> &lt;&lt; k);</span><br><span class="line">        gap = (gap % k + k) % k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gap == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> q = exgcd(c,k,x,y);</span><br><span class="line">        <span class="keyword">if</span> (gap % q) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"FOREVER\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//前面属于判断过程，后面就是正常的ecgcd的 不定方程求解了</span></span><br><span class="line">        <span class="comment">//所以需要做的事情就是 方程两边同时除以gcd</span></span><br><span class="line">        c = c / q;</span><br><span class="line">        gap = gap / q;</span><br><span class="line">        k = k / q;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> xx = exgcd(c,k,x,y);</span><br><span class="line">        x *= gap;</span><br><span class="line">        x = (x % k + k) % k;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是一道求解逆元的问题了。</p><p><strong>定理 同余方程 ax =- 1(mod m)有解 当且仅仅当 gcd(a,m) = 时候成立，且其的所有解都同余</strong></p><p><em>Modular Inverse zoj 3609</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t = exgcd(b,a % b,x,y);</span><br><span class="line">    <span class="keyword">int</span> d = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = d - (a / b) * y;</span><br><span class="line">    <span class="keyword">return</span> t; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a,b,q,x,y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; T) &#123;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        q = exgcd(a,b,x,y);</span><br><span class="line">        <span class="comment">//就是这里多了判断其是否为0的条件。</span></span><br><span class="line">        <span class="keyword">if</span> (q != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Not Exist\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里就是处理0的情况</span></span><br><span class="line">        x = (x % b + b) % b;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同余方程组-（中国剩余定理）"><a href="#同余方程组-（中国剩余定理）" class="headerlink" title="同余方程组 （中国剩余定理）"></a>同余方程组 （中国剩余定理）</h3><p>这里贴出 求解同余方程组的阶梯步骤</p><blockquote><ol><li>将题目中给出的所有同余方程组列出来，形如 a =- ai (mod ni),并且将每一个ni相乘起来 得到一个 n 。（或者是求其全部的最小公倍数）</li><li>然后通过公式 计算出 mi = n / ni，然后再通过mi 计算出mi模 n 的逆  就是通过 扩展欧几里得公式去求解每一个同余方程 mi * x =- 1 (mod ni);</li><li>然后再计算每一个 ci = mi * mi的逆。</li><li>最后通过公式 a = ((全部相加)ai * ci ) mod n…</li></ol></blockquote><p><em>Biorhythms poj 1006</em> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这道题目其实是严格按照中国剩余定理来计算的，最后求解的结果实际上是计算出来的三个同余的结果，同时满足多个同余方程的一个共同的结果</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    不过下面的步骤需要弄清楚，第一步是先求出每一个同余的 m值，然后再通过求m逆，然后将其相乘得到ci 最后乘以每一项的ci</span></span><br><span class="line"><span class="comment">    最后求解的结果去mod上一个最终的mod n就行了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p,e,i,d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span> <span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t = exgcd(b,a % b,x,y);</span><br><span class="line">    <span class="keyword">int</span> d = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = d - (a / b) * y;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m1,m2,m3;</span><br><span class="line"><span class="keyword">int</span> n1,n2,n3;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">21252</span>;</span><br><span class="line"><span class="keyword">int</span> x,x2,x3;</span><br><span class="line"><span class="keyword">int</span> y,y2,y3;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理C++ 中 % 出负数的情况</span></span><br><span class="line"><span class="keyword">int</span> _mod(<span class="keyword">int</span> x,<span class="keyword">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> (x % b + b) % b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Case = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;p,&amp;e,&amp;i,&amp;d)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">-1</span> &amp;&amp; e == <span class="number">-1</span> &amp;&amp; i == <span class="number">-1</span> &amp;&amp; d== <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        m1 = n / <span class="number">23</span>;</span><br><span class="line">        m2 = n / <span class="number">28</span>;</span><br><span class="line">        m3 = n / <span class="number">33</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> q1 = exgcd(m1,<span class="number">23</span>,x,y);</span><br><span class="line">        <span class="keyword">int</span> q2 = exgcd(m2,<span class="number">28</span>,x2,y2);</span><br><span class="line">        <span class="keyword">int</span> q3 = exgcd(m3,<span class="number">33</span>,x3,y3);</span><br><span class="line"></span><br><span class="line">        x = _mod(x,<span class="number">23</span>) * m1;</span><br><span class="line">        x2 = _mod(x2,<span class="number">28</span>) * m2;</span><br><span class="line">        x3 = _mod(x3,<span class="number">33</span>) * m3;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = x * p + x2 * e + x3 * i - d;</span><br><span class="line">        res = res % n;</span><br><span class="line">        <span class="keyword">if</span> (res &lt;= <span class="number">0</span>) res += n;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span>&lt;&lt; Case++ &lt;&lt;<span class="string">": the next triple peak occurs in "</span>&lt;&lt;res &lt;&lt;<span class="string">" days."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特殊的同余式"><a href="#特殊的同余式" class="headerlink" title="特殊的同余式"></a>特殊的同余式</h3><h4 id="威尔逊定理"><a href="#威尔逊定理" class="headerlink" title="威尔逊定理"></a>威尔逊定理</h4><p><strong>如果 p 是素数，(p - 1)! =- -1 (mod p)成立</strong></p><pre><code>意思就是 如果 p是素数的情况，(p - 1)! + 1 mod p 正好可以等于0.</code></pre><p><em>YAPTCHA uva 4382</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 2018</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ULL unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Pair pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a, b) memset(a, b, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ ios_base::sync_with_stdio(0), cin.tie(0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e6</span> + <span class="number">10</span>, INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里是一种简单的筛法,相当于一个简单的埃式筛法。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mem(vis, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(maxn + <span class="number">0.5</span>); i++)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; maxn; j += i)</span><br><span class="line">                vis[j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mem(ans, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1e6</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">3</span> * i + <span class="number">7</span>;</span><br><span class="line">        ans[i] = ans[i - <span class="number">1</span>] + (<span class="number">1</span> - vis[temp]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">int</span> T, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h4><blockquote><p>如果p是素数，a是正整数，gcd(a,p) = 1,则 a的p - 1 次幂 同余 1 mod p.</p></blockquote><p><em>what day is that day zoj 3785</em><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这道题讲述的就是费马小定理，这道题目关键点就是在，前面对于周期mod的求取，应用了费马小定理，最后得出的结论。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">char</span> day[<span class="number">10</span>][<span class="number">10</span>] = &#123;<span class="string">"Saturday"</span>, <span class="string">"Sunday"</span>, <span class="string">"Monday"</span>, <span class="string">"Tuesday"</span>, <span class="string">"Wednesday"</span>, <span class="string">"Thursday"</span>, <span class="string">"Friday"</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; i++)</span><br><span class="line">        ans = (ans * x) % <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">300</span>; i++)</span><br><span class="line">        num[i] = (<span class="built_in">pow</span>(i) + num[i - <span class="number">1</span>]) % <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, day[num[n % <span class="number">294</span>]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="伪素数"><a href="#伪素数" class="headerlink" title="伪素数"></a>伪素数</h4><pre><code>其产生的原因就在于费马小定理的逆不成立，如果a是一个正整数，如果n是一个正合数，并且a的n次幂  同余 a (mod n) 则称n为以a为基的伪素数。</code></pre><p><em>Pseudoprime numbers poj 3641</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这道题不断的出现runtime error 用java 的时候 这个时候我就不太清楚是为什么了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    后面还需要弄清楚一件事情就是 究竟什么时候才能够用欧拉赛的时间去打表，这里就不太清楚 有的时候用欧拉筛打表反而出现错误的答案。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> _mod(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y,<span class="keyword">long</span> <span class="keyword">long</span> mod) &#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)  ans = ans * x % mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x = x * x % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(x) + <span class="number">0.5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> q,a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;q,&amp;a) &amp;&amp; q &amp;&amp; a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_prime(q)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"no\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = _mod(a,q,q);</span><br><span class="line">        <span class="keyword">if</span> (ans == a) <span class="built_in">printf</span>(<span class="string">"yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"no\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来还有一道题，可以根据java的一个函数直接得出结果，但是同样也可以通过C++ 的大素数的检测方法从而得出结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        BigInteger a;</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            n = in.nextInt();</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                a = in.nextBigInteger();</span><br><span class="line">                <span class="keyword">if</span> (a.isProbablePrime(<span class="number">3</span>)) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++ 前面有讲的超出区间的测定方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tp = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(x * <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= tp; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, tp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tp);</span><br><span class="line">            <span class="keyword">if</span> (tp == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tp &amp; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans += is_prime(tp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h4><p>欧拉函数表示的是到n之前与n互素的且不超过n的正整数的个数。</p><p>如果 n和a是互素的正整数，则 a的 欧拉函数n 同余1 mod n</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>背包初级及相应题目总结</title>
      <link href="/2019/05/01/%E8%83%8C%E5%8C%85%E5%88%9D%E7%BA%A7%E5%8F%8A%E7%9B%B8%E5%BA%94%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2019/05/01/%E8%83%8C%E5%8C%85%E5%88%9D%E7%BA%A7%E5%8F%8A%E7%9B%B8%E5%BA%94%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背包初级讲解"><a href="#背包初级讲解" class="headerlink" title="背包初级讲解"></a>背包初级讲解</h2><p>这里对于动态规划里面一个简单基础的问题进行总结，包括 01背包，完全背包，多重背包，混合背包…</p><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p><strong>题目</strong></p><p>有N件物品和一个容量为V 的背包。放入第i件物品耗费的费用是Ci1，得到 的价值是Wi 。求解将哪些物品装入背包可使价值总和最大。</p><p><strong>基本思路</strong></p><p>用子问题定义状态:即F [i, v]表示前i件物品恰放入一个容量为v的背包可 以获得的最大价值。则其状态转移方程便是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**对于二维dp数组的伪代码如下**</span><br><span class="line"></span><br><span class="line">F[0,0..V] ←0 fori ←1toN</span><br><span class="line">forv ←Ci toV</span><br><span class="line">F[i,v] ← max&#123;F[i − 1,v],F[i − 1,v − Ci] + Wi&#125;</span><br><span class="line"></span><br><span class="line">**优化空间的复杂度**</span><br><span class="line">使用滚动数组，以及进行压缩空间。</span><br><span class="line">伪代码如下：</span><br><span class="line">F [0..V ] ←0 fori ←1toN</span><br><span class="line">forv ←V toCi</span><br><span class="line">F[v] ←max&#123;F[v],F[v−Ci]+Wi&#125;</span><br><span class="line"></span><br><span class="line">**初始化的细节**</span><br><span class="line">&gt;我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。 有的题目要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背 包装满。一种区别这两种问法的实现方法是在初始化的时候有所不同。</span><br><span class="line">&gt;如果是第一种问法，要求恰好装满背包，那么在初始化时除了F [0]为0，其 它F [1..V ]均设为−∞，这样就可以保证最终得到的F [V ]是一种恰好装满背包的 最优解。</span><br><span class="line">&gt;如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该 将F [0..V ]全部设为0。</span><br><span class="line"></span><br><span class="line">#### 题目总结 </span><br><span class="line">##### 1.Charm Bracelet  (poj3624)</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">/*</span><br><span class="line">第一道题属于一个简单的01背包模板题目，这里不多说 可以直接套模板。</span><br><span class="line">*/</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line"></span><br><span class="line">int dp[13000];</span><br><span class="line">int w[3500],v[3500];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (cin &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        memset(dp,0,sizeof dp);</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            for (int j = m; j &gt;= w[i]; j--) &#123;</span><br><span class="line">                dp[j] = max(dp[j],dp[j - w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; dp[m] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="2-Bone-Collector-hdu-2602"><a href="#2-Bone-Collector-hdu-2602" class="headerlink" title="2.Bone_Collector(hdu 2602)"></a>2.Bone_Collector(hdu 2602)</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一段简单的模板题目，不过需要弄清楚的 一维数组与二维数组在这里相应的区别，往往这里会产生很大的区别，</span></span><br><span class="line"><span class="comment">    比如第二个循环的开始条件，因为这里是由子问题的堆积，然后一点一点向上升最终得到的问题，所以这李最好控制背包的放与不放的问题、</span></span><br><span class="line"><span class="comment">    就比如我在这道题目的第二个问题中出现的错误，就是将j=0这个条件直接掠过去了，其实这里是不对的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> weight[maxn],value[maxn],dp[maxn][maxn];</span><br><span class="line"><span class="keyword">long</span> v,w;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w &gt;&gt; v;</span><br><span class="line">        value[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        weight[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= w; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; value[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= w; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; weight[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= w; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= v; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= weight[i]) &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j],dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[w][v] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-饭卡"><a href="#3-饭卡" class="headerlink" title="3.饭卡"></a>3.饭卡</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这道题神奇的地方就在于 其的重量限制于价值重合在了一起，所以对于这道题而言就是只能重合的去写状态转移方程了</span></span><br><span class="line"><span class="comment">    另外需要注意的是最后输出结果的办法，是将最后一个物品交给剩下的最大的钱去购买，这样能彻底用光最后的钱财</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> num[maxn],dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">        sort(num + <span class="number">1</span>, num + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m - <span class="number">5</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= num[i]) &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j],dp[i - <span class="number">1</span>][j - num[i]] + num[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; m - dp[n - <span class="number">1</span>][m - <span class="number">5</span>] - num[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>完全背包这里与01背包相类似，但是区别就在于每一个种类的背包可以取无数个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">一般都是将其转化为01背包的方法求解，用一个滚动数组来进行表示，不过需要注意的是，其与01背包的第二个循环不同地方</span><br><span class="line"></span><br><span class="line">完全背包的伪代码：</span><br><span class="line">```py</span><br><span class="line">def CompletePack(F, C, W ) forv ←CtoV</span><br><span class="line">F[v] ←max&#123;F[v],f[v−C]+W&#125;</span><br></pre></td></tr></table></figure><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>下面贴出关于完全背包的题目</p><h5 id="1-减肥"><a href="#1-减肥" class="headerlink" title="1.减肥"></a>1.减肥</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这道题使用二维数组就一直就会超时 具体的我也不太清楚，但是 没有办法 只能使用一维滚动数组，进行了相应的空间优化 不过这里需要补充几个知识点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    第一 关于二维数组的完全背包状态转移方程 dp[i][j] = max (dp[i - 1][j],dp[i - 1][j - k * c[i]] + k * v[i]);</span></span><br><span class="line"><span class="comment">    由上面这个式子就可以得出，状态转移方程  于是 一种空间优化的写法 是直接写成 max(dp[i - 1][j]，dp[i][j - w[i]] + v[i])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    第二 如果换成滚动数组的话 记住 第二个循环的两个顺序，如果是倒叙的话 则就是要保证每一个物品只会取一次，但是如果是正序的话，那么就不需要保证上面所说的顺序了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    而这里官方的解释 就在这里 ：</span></span><br><span class="line"><span class="comment">    让 v 递减是为了保证第i次循环中的状态F[i;v]是由状态F[i-1;v-Ci]递推而来。</span></span><br><span class="line"><span class="comment">    换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第 i 件物品”这件策</span></span><br><span class="line"><span class="comment">    略时，依据的是一个绝无已经选入第 i 件物品的子结果F[i-1;v-Ci]。而现在完全背</span></span><br><span class="line"><span class="comment">    包的特点恰是每种物品可选无限件，所以在考虑“加选一件第 i 种物品”这种策略时，</span></span><br><span class="line"><span class="comment">    却正需要一个可能已选入第 i 种物品的子结果F[i;v-Ci]，所以就可以并且必须采用v</span></span><br><span class="line"><span class="comment">    递增的顺序循环。这就是这个简单的程序为何成立的道理。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a, b, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> happiness[maxn], kaluli[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">110000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;happiness[i],&amp;kaluli[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = kaluli[i]; j &lt;= m; j++) &#123;</span><br><span class="line">                dp[j] = max(dp[j],dp[j - kaluli[i]] + happiness[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[m]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-Dollar-Dayz"><a href="#2-Dollar-Dayz" class="headerlink" title="2.Dollar Dayz"></a>2.Dollar Dayz</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n,k;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            BigInteger[] dp = <span class="keyword">new</span> BigInteger[<span class="number">1005</span>];</span><br><span class="line">            n = in.nextInt();</span><br><span class="line">            k = in.nextInt();</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="keyword">new</span> BigInteger(<span class="string">"1"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                dp[i] = <span class="keyword">new</span> BigInteger(<span class="string">"0"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j++) &#123;</span><br><span class="line">                    dp[j] = dp[j].add(dp[j - i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           System.out.println(dp[n]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-Piggy-Bank"><a href="#3-Piggy-Bank" class="headerlink" title="3.Piggy-Bank"></a>3.Piggy-Bank</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这道题是一个完全背包的裸题，对于这道题而言更加神奇的地方就在于其实求最小值而不是求最大值</span></span><br><span class="line"><span class="comment">    所以在最先开始初始化的时候不应该去初始化为0，而应该初始化为无穷大</span></span><br><span class="line"><span class="comment">    而千万不要忘记了再初始化的时候一定要对第一个状态进行一个单独赋值是等于0，还是等于无穷大，这个等到时候再看。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _beg,_end;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">505</span>;</span><br><span class="line"><span class="keyword">int</span> v[maxn],w[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;_beg,&amp;_end);</span><br><span class="line">        <span class="keyword">int</span> bottle = _end - _beg;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;v[i],&amp;w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0x3f3f3f3f</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = w[i]; j &lt;= bottle; j++) &#123;</span><br><span class="line">                dp[j] = min(dp[j],dp[j - w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[bottle] != <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"The minimum amount of money in the piggy-bank is "</span> &lt;&lt; dp[bottle] &lt;&lt; <span class="string">"."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"This is impossible."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>多重背包与完全背包最大的不同就是在于，完全背包其的每一个背包取值可以取无数个（相对于背包容量而言）<br>而多重背包的意思就是相对于背包容量而言 取不满，在取不满的同时还能够再加入其的背包，故，这里就为多重背包</p><h4 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100005</span>;</span><br><span class="line"><span class="comment">//三个属性值 一个重量 数量 以及价值</span></span><br><span class="line"><span class="keyword">int</span> weight[maxn],number[maxn],value[maxn];</span><br><span class="line"><span class="comment">//状态存储</span></span><br><span class="line"><span class="keyword">int</span> dp[maxn &lt;&lt; <span class="number">4</span>];</span><br><span class="line"><span class="comment">//背包的容量</span></span><br><span class="line"><span class="keyword">int</span> bag; </span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//01背包 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zeroonepack</span><span class="params">(<span class="keyword">int</span> weight,<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = bag; j &gt;= weight; j--) &#123;</span><br><span class="line">        dp[j] = max(dp[j],dp[j - weight] + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完全背包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">completepack</span><span class="params">(<span class="keyword">int</span> weight,<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = weight; j &lt;= bag; j++) &#123;</span><br><span class="line">        dp[j] = max(dp[j],dp[j - weight] + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//多重背包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multilpack</span><span class="params">(<span class="keyword">int</span> weight,<span class="keyword">int</span> number,<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一种情况就是 如果这件物品所有的重量是小于背包的重量的话</span></span><br><span class="line">    <span class="comment">//那么对于背包而言 这个物品是可以取无限大。</span></span><br><span class="line">    <span class="keyword">if</span> (bag &lt;= number * weight) &#123;</span><br><span class="line">        completepack(weight,value);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//而超过的这个范围的就只能使用01背包 然后使用二进制的方法</span></span><br><span class="line">    <span class="comment">//将每一类型的背包进行一个分组</span></span><br><span class="line">    <span class="comment">//后面再依次分别使用多重背包。</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt;= number) &#123;</span><br><span class="line">        zeroonepack(k * weight,k * value);</span><br><span class="line">        number = number - k;</span><br><span class="line">        k = k * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zeroonepack(number * weight, number * value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; bag &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ;i ++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; weight[i] &gt;&gt; number[i] &gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ;i ++) &#123;</span><br><span class="line">        multilpack(weight[i],number[i],value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[bag] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="相应题目总结"><a href="#相应题目总结" class="headerlink" title="相应题目总结"></a>相应题目总结</h4><h5 id="1-Space-Elevator"><a href="#1-Space-Elevator" class="headerlink" title="1. Space Elevator"></a>1. Space Elevator</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一道多重背包的裸题目，这道题虽然并没有去套用多重背包的裸模板，但是这道题神奇的地方就在于其对于</span></span><br><span class="line"><span class="comment">    背包的数量进行了再一次的循环，然后再来看看有没有符合的特点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    然后其的状态转移方程也是特别的有意思：</span></span><br><span class="line"><span class="comment">    dp[k] |= dp[k - node[i].h]</span></span><br><span class="line"><span class="comment">    不过这个 |= 到后面去官网查询一下最后的结果的意思.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> h,a,c;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;n) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; n.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;node[<span class="number">450</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">40050</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> K;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; K) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; node[i].h &gt;&gt; node[i].a &gt;&gt; node[i].c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        sort(node + <span class="number">1</span>, node + <span class="number">1</span> + K);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K ;i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= node[i].c; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = node[i].a; k &gt;= node[i].h; k-- )&#123;</span><br><span class="line">                    dp[k] |= dp[k - node[i].h];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = node[K].a; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i]) &#123;</span><br><span class="line">                cnt = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-Coins"><a href="#2-Coins" class="headerlink" title="2. Coins"></a>2. Coins</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这道题神奇的地方就是将多重背包的裸题进行了改变，</span></span><br><span class="line"><span class="comment">    主要就是每一次增加的价值会发生改变，这才是最关键的地方。</span></span><br><span class="line"><span class="comment">    这里的价值就不再是个数，而是进行一个打表，通过这个打表来判断这个重量是否能够达到。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> bag;</span><br><span class="line"><span class="keyword">bool</span> dp[<span class="number">100040</span>];</span><br><span class="line"><span class="keyword">int</span> value[<span class="number">105</span>],number[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zeroonepack</span><span class="params">(<span class="keyword">int</span> weight, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = bag; j &gt;= weight; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dp[j] &amp;&amp; dp[j - weight])&#123;</span><br><span class="line">            dp[j] = <span class="literal">true</span>;</span><br><span class="line">            cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完全背包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">completepack</span><span class="params">(<span class="keyword">int</span> weight, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = weight; j &lt;= bag; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dp[j] &amp;&amp; dp[j - weight]) &#123;</span><br><span class="line">            dp[j] = <span class="literal">true</span>;</span><br><span class="line">            cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//多重背包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multilpack</span><span class="params">(<span class="keyword">int</span> weight, <span class="keyword">int</span> number, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//第一种情况就是 如果这件物品所有的重量是小于背包的重量的话</span></span><br><span class="line">    <span class="comment">//那么对于背包而言 这个物品是可以取无限大。</span></span><br><span class="line">    <span class="keyword">if</span> (bag &lt;= number * weight)</span><br><span class="line">    &#123;</span><br><span class="line">        completepack(weight, value);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//而超过的这个范围的就只能使用01背包 然后使用二进制的方法</span></span><br><span class="line">    <span class="comment">//将每一类型的背包进行一个分组</span></span><br><span class="line">    <span class="comment">//后面再依次分别使用多重背包。</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; number)</span><br><span class="line">    &#123;</span><br><span class="line">        zeroonepack(k * weight, k * value);</span><br><span class="line">        number = number - k;</span><br><span class="line">        k = k * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zeroonepack(number * weight, number * value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; bag &amp;&amp; n &amp;&amp; bag) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; value[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i ++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; number[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ;i ++) &#123;</span><br><span class="line">            multilpack(value[i],number[i],value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h3><p>将01背包 完全背包 多重背包的三种背包 进行一个混合<br>最简单的解决方法就是将其分开进行来算</p><p>举个例子 就是 一道题可能有多个背包，通过这多个背包来进行判断题目中所要求解的值。</p><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><h5 id="1-Fewest-coins"><a href="#1-Fewest-coins" class="headerlink" title="1.Fewest coins"></a>1.Fewest coins</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这道题目神奇的地方 是两个背包的问题 的总和，其实也算作是一个简单的题目，但是 这道题唯一复杂的地方就在于对于背包问题的理解</span></span><br><span class="line"><span class="comment">    意思就是如何将一个看上去不是背包的问题转换成一个背包问题 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    首先的思路就是来判断是一个什么类型的背包</span></span><br><span class="line"><span class="comment">    映射到这道题上面可以发现 前面付钱的过程是一个多重背包 后面付钱的过程是一个完全背包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    不过深入理解了塞入 状态方程 </span></span><br><span class="line"><span class="comment">    第一次在价值那个地方出现了错误。 最终的价值不应该是相比总是的钱数，而应该是最小能够达到的背包数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">30005</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn],back[maxn];</span><br><span class="line"><span class="keyword">int</span> value[<span class="number">105</span>],number[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bag;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zeroonepack</span><span class="params">(<span class="keyword">int</span> weight,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = bag ; j &gt;= weight; j--) &#123;</span><br><span class="line">        dp[j] = min(dp[j],dp[j - weight] + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">completepack</span><span class="params">(<span class="keyword">int</span> weight,<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = weight; j &lt;= bag; j++) &#123;</span><br><span class="line">        dp[j] = min(dp[j],dp[j - weight] + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mutipack</span><span class="params">(<span class="keyword">int</span> weight,<span class="keyword">int</span> value,<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (number * weight &gt;= bag) &#123;</span><br><span class="line">        completepack(weight,value);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; number) &#123;</span><br><span class="line">        zeroonepack(k * weight,k * value);</span><br><span class="line">        number = number - k;</span><br><span class="line">        k *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zeroonepack(number * weight , number * value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; value[i] ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; number[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0x3f3f3f3f</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="built_in">memset</span>(back,<span class="number">0x3f3f3f3f</span>,<span class="keyword">sizeof</span> back);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        back[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        bag = k + <span class="number">20000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = value[i]; j &lt;= bag; j++) &#123;</span><br><span class="line">                back[j] = min(back[j],back[j - value[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            mutipack(value[i],<span class="number">1</span>,number[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= bag; i++) &#123;</span><br><span class="line">            ans = min(ans,back[i - k] + dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">0x3f3f3f3f</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 背包九讲 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>effective java item 6</title>
      <link href="/2019/03/28/effective-java-item-6/"/>
      <url>/2019/03/28/effective-java-item-6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Item-6-Avoid-creating-unnecessary-objects"><a href="#Item-6-Avoid-creating-unnecessary-objects" class="headerlink" title="Item 6: Avoid creating unnecessary objects"></a>Item 6: Avoid creating unnecessary objects</h2><blockquote><p>It is often appropriate to reuse a single object instead of creating a new function- ally equivalent object each time it is needed. Reuse can be both faster and more stylish. An object can always be reused if it is immutable</p></blockquote><p>去反复的使用一个单一的对象，而不是再次创建一个新对象再需要的时候这样的做法是非常合适的。重复使用可以同时很快有符合现代规则。然后一个对象可以被总是反复使用如果其是不变的话。</p><p>下面有一个基本简单的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"bikini"</span>);  <span class="comment">// DON'T DO THIS!</span></span><br><span class="line">String s = <span class="string">"bikini"</span>;</span><br></pre></td></tr></table></figure><p>前者是不可以采取的，因为其新建了两个对象，并且第二个新建的对象直接赋值给第一个新建的对象，而后者可取的地方就在于其直接赋值给了第一个对象，不存在创建一个新的对象。</p><blockquote><p>You can often avoid creating unnecessary objects by using static factory meth- ods (Item 1) in preference to constructors on immutable classes that provide both.</p></blockquote><p>你可以经常通过用静态的工厂方法禁止创建一个不必要的对象而不是使用不会改变的类或者是一个构造器。</p><blockquote><p>For example, the factory method Boolean.valueOf(String) is preferable to the constructor Boolean(String), which was deprecated in Java 9. The constructor must create a new object each time it’s called, while the factory method is never required to do so and won’t in practice.</p></blockquote><p>这里举个例子，工厂方法就像上面提供的相比于其的构造函数而言，不需要再每次调用的时候构建一个新的对象，而且如果反复利用的是一个不变的对象的话，你可以保证的是，找个对象永远都不会改变。</p><blockquote><p>Unfortunately, it’s not always obvious when you’re creating such an object. Suppose you want to write a method to determine whether a string is a valid Roman numeral. Here’s the easiest way to do this using a regular expression</p></blockquote><p>不幸的是，当你创建一个这样的对象的时候不总是那么的明显，假设你想要写一个方法去判断一个字符串是否是罗马数字，下面有一个简单的办法来进行判断：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Performance can be greatly improved! </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRomanNumeral</span><span class="params">(String s)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> s.matches(<span class="string">"^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)"</span> + <span class="string">"(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>While String.matches is the easiest way to check if a string matches a regular expression, it’s not suitable for repeated use in performance-critical situations.</p></blockquote><p>这通常是一个最简单的方法去判断是否一个字符串去包含常规的语法操作，然而其并不适合多次使用即多次调用的场景下面。</p><blockquote><p>The problem is that it internally creates a Pattern instance for the regular expression and uses it only once, after which it becomes eligible for garbage collection. Creating a Pattern instance is expensive because it requires compiling the regular expression into a finite state machine.</p></blockquote><p>而这个的问题就在于其创建了一个Pattern的实例给相应的正则表达式，而且仅仅只是使用了一次，然后就直接被java垃圾回收器给回收了，而创建一个Pattern的实例的代价是非常昂贵的，因为其需要compiling这个正则表达式到相应的机器里面去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reusing expensive object for improved performance </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RomanNumerals</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern ROMAN = Pattern.compile( <span class="string">"^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)"</span> + <span class="string">"(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$"</span>); </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRomanNumeral</span><span class="params">(String s)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> ROMAN.matcher(s).matches(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>If the class containing the improved version of the isRomanNumeral method is initialized but the method is never invoked, the field ROMAN will be initialized needlessly. It would be possible to eliminate the initialization by lazily initializing the field (Item 83) the first time the isRomanNumeral method is invoked, but this is not recommended. As is often the case with lazy initialization, it would compli- cate the implementation with no measurable performance improvement (Item 67).</p></blockquote><p>还有一种优化的方案就在于，如果上面这个类永远都没有被调用的话，那么上面直接设置成静态的成员变量就会出现构造对象的浪费，意思就是如果没有被调用就会有浪费，于是有一种方法就是按照之前的单实例化类那样，在构造函数里面加上，如果被调用了，那么就会创建一个final的对象。</p><blockquote><p>Another way to create unnecessary objects is autoboxing, which allows the programmer to mix primitive and boxed primitive types, boxing and unboxing automatically as needed. Autoboxing blurs but does not erase the distinction between primitive and boxed primitive types.</p></blockquote><p>还存在一种方式去创建一些不必要的对象，就是自动打包行为，就是将原生的类型，自动打包成了封装类型，这样也会造成许多不需要的对象，有些对象仅仅只是使用了一次。就像下面这个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hideously slow! Can you spot the object creation? </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    Long sum = <span class="number">0L</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++) </span><br><span class="line">        sum += i; </span><br><span class="line">    <span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的这个例子就是在加法的时候使long的类型自动包装成一个Long类型，这样则造成了很多不必要的开销。</p><blockquote><p>The present item says, “Don’t create a new object when you should reuse an existing one,”while Item 50 says, “Don’t reuse an existing object when you should create a new one.” Note that the penalty for reusing an object when defensive copying is called for is far greater than the penalty for needlessly creating a duplicate object. Failing to make defensive copies where required can lead to insidious bugs and security holes; creating objects unnecessarily merely affects style and performance.</p></blockquote><p>总而言之，当你可以并且应该重复利用一个已经存在的一个对象的时候，不要重复创建一个新的对象，而第五十条提醒的是 当你需要一个新的对象的时候不要去重复引用一个存在的旧对象。记住一些保护性质copy实际上是并不可取的，这个在后面会涉及到，其实这里与C++里面的知识有点吻合，关于左值引用与右值引用的知识。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> effective_java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>effective java item 5</title>
      <link href="/2019/03/26/effective-java-item-5/"/>
      <url>/2019/03/26/effective-java-item-5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Item-5-Prefer-dependency-injection-to-hardwiring-resources"><a href="#Item-5-Prefer-dependency-injection-to-hardwiring-resources" class="headerlink" title="Item 5: Prefer dependency injection to hardwiring resources"></a>Item 5: Prefer dependency injection to hardwiring resources</h3><blockquote><p>Many classes depend on one or more underlying resources. For example, a spell checker depends on a dictionary. It is not uncommon to see such classes imple- mented as static utility classes (Item 4):</p></blockquote><p>有一些类依赖一些潜在的资源，就像一个字符串检查器 依靠字典，所以也就不是很特殊见到一些类被翻译成静态的工具类。</p><blockquote><p>Similarly, it’s not uncommon to see them implemented as singletons (Item 3):</p></blockquote><p>就像一些类直接被翻译成单一实例类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inappropriate use of singleton - inflexible &amp; untestable! </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lexicon dictionary = ...; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SpellChecker</span><span class="params">(...)</span> </span>&#123;&#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> INSTANCE = <span class="keyword">new</span> SpellChecker(...); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word)</span> </span>&#123; ... &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">suggestions</span><span class="params">(String typo)</span> </span>&#123; ... &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Static utility classes and singletons are inappropriate for classes whose behavior is parameterized by an underlying resource.</p></blockquote><p>静态的工具类和单一实体类，会在存在多种参数替换给基础资源，（就像上面的检查器有多种版本的字典资源一样），那么这些类就会变得特别不合适。</p><blockquote><p>A simple pattern that satisfies this requirement is to pass the resource into the constructor when creating a new instance. This is one form of dependency injection: the dictionary is a dependency of the spell checker and is injected into the spell checker when it is created.</p></blockquote><p>只有一种办法就是在构建的时候 构建函数里面直接给予相应的构造器，这样既维护了单实例化，又解决了上面多版本的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dependency injection provides flexibility and testability </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lexicon dictionary; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpellChecker</span><span class="params">(Lexicon dictionary)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.dictionary = Objects.requireNonNull(dictionary);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word)</span> </span>&#123; ... &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">suggestions</span><span class="params">(String typo)</span> </span>&#123; ... &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>In summary, do not use a singleton or static utility class to implement a class that depends on one or more underlying resources whose behavior affects that of the class, and do not have the class create these resources directly. Instead, pass the resources, or factories to create them, into the constructor (or static factory or builder). This practice, known as dependency injection, will greatly enhance the flexibility, reusability, and testability of a class.</p></blockquote><p>总而言之，不要在实现一个静态工具类或者一个单实例类的时候的同时去实现一个多个资源替换的类，这样会影响其他的类，并且违背了这个类最先开始的本意，好的解决办法就是在类的构造函数里面加上该资源或者带上该工厂方法。</p><p>另外对于上面一个函数进行讲解<br>Objects.requireNonNull;<br>其的代码形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">requireNonNull</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">   <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> effective_java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>effective java item 4</title>
      <link href="/2019/03/16/effective-java-item-4/"/>
      <url>/2019/03/16/effective-java-item-4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Item-4-Enforce-noninstantiability-with-a-private-constructor"><a href="#Item-4-Enforce-noninstantiability-with-a-private-constructor" class="headerlink" title="Item 4: Enforce noninstantiability with a private constructor"></a>Item 4: Enforce noninstantiability with a private constructor</h3><p>强迫不能实例化的类，拥有一个私有的构造函数。</p><blockquote><p>Occasionally you’ll want to write a class that is just a grouping of static methods and static fields. Such classes have acquired a bad reputation because some people abuse them to avoid thinking in terms of objects, but they do have valid uses.</p></blockquote><p>也许有的时候，你需要写一个类，拥有一些静态的变量与函数，而当有人给这些类实例化的时候，这些类往往就具有一些不太好的口碑。因为这些类并不是当成对象，仅仅只是当成一个工具。</p><blockquote><p>(As of Java 8, you can also put such methods in the interface, assuming it’s yours to modify.) Lastly, such classes can be used to group methods on a final class, since you can’t put them in a subclass</p></blockquote><p>在java8的时候你可以把一些函数直接放在接口里面，而最近一些类可以帮用做是一系列的函数群，不过你不能将他们放到可以继承的子类里面去。</p><blockquote><p>Such utility classes were not designed to be instantiated: an instance would be nonsensical. In the absence of explicit constructors, however, the compiler pro- vides a public, parameterless default constructor. To a user, this constructor is indistinguishable from any other.</p></blockquote><p>而一些功能类型的类不是被设计成可实例化的，是因为实例化往往没有意思，而这个时候编译器会自动的提供公开且没有参数的构造函数，对于客户及其使用者而言，必须使这类构造函数隐藏起来。</p><blockquote><p>Attempting to enforce noninstantiability by making a class abstract does not work. The class can be subclassed and the subclass instantiated.</p></blockquote><p>然后仅仅只是强迫这些类变成抽象类是完全达不到效果的，因为这些类还会被继承，而继承其的子类往往还会被实例化。</p><blockquote><p>A default construc- tor is generated only if a class contains no explicit constructors, so a class can be made noninstantiable by including a private constructor:</p></blockquote><p>然后最后的结果就是只能给类安置一个私有的构造函数才能避免以上问题。</p><p>就像如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Noninstantiable utility class </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UtilityClass</span> </span>&#123; </span><br><span class="line">    <span class="comment">// Suppress default constructor for noninstantiability </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UtilityClass</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(); </span><br><span class="line">    &#125; </span><br><span class="line">    ...<span class="comment">// Remainder omitted </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> effective_java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>effective java item 3</title>
      <link href="/2019/03/15/effective-java-item-3/"/>
      <url>/2019/03/15/effective-java-item-3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Item-3-Enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type"><a href="#Item-3-Enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type" class="headerlink" title="Item 3: Enforce the singleton property with a private constructor or an enum type"></a>Item 3: Enforce the singleton property with a private constructor or an enum type</h3><blockquote><p>A singleton is simply a class that is instantiated exactly once [Gamma95]. Single- tons typically represent either a stateless object such as a function (Item 24) or a system component that is intrinsically unique.</p></blockquote><p>首先先解释一下 singleton 这个是表示一个类只会被实例化一次的类，一般用于一些函数类型的功能，以及某些一同的独一无二的重要组成成分。</p><blockquote><p>There are two common ways to implement singletons. Both are based on keeping the constructor private and exporting a public static member to provide access to the sole instance. In one approach, the member is a final field</p></blockquote><p>现在有两种办法去实现这种单实例的情况，基于保证其的构造函数私有化，和输出公开静态成员来保护唯一的实例，一般这个实例都是final的变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Singleton with public final field </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis(); </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span> </span>&#123; ... &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span> </span>&#123; ... &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的例子就是在静态加载的过程中就直接调用这个实例类的函数，外部无法直接去构造这个类，所以也就直接造成这个类只能够被访问一次。</p><blockquote><p>In the second approach to implementing singletons, the public member is a static factory method</p></blockquote><p>第二种方法获得这种单实例化的类，直接使用一个get类型的函数，也可以使用一种你那个懒惰标记的方法，直到调用的时候才开始实例化这个类。</p><blockquote><p>One advantage of the static factory approach is that it gives you the flexibility to change your mind about whether the class is a singleton without changing its API. The factory method returns the sole instance, but it could be modified to return, say, a separate instance for each thread that invokes it.</p></blockquote><p>第一个函数就是给你灵活性去改变这个类是否是单实例化，其的静态工厂方法是返回这个类的唯一实例，但是其很容易被修改，比如说为每一次调用该方法的线程返回一个唯一的实例。</p><blockquote><p>A second advantage is that you can write a generic singleton factory if your application requires it (Item 30). A final advantage of using a static factory is that a method reference can be used as a supplier, for example Elvis::instance is a Supplier<elvis>. Unless one of these advantages is relevant, the public field approach is preferable</elvis></p></blockquote><p>第二个好事就是你可以写一个泛型类型的单实例化类，如果你的应用就此要求的话。就此的方法可以把这个单实例化当成一种提供者。</p><blockquote><p>To make a singleton class that uses either of these approaches serializable (Chapter 12), it is not sufficient merely to add implements Serializable to its declaration. To maintain the singleton guarantee, declare all instance fields transient and provide a readResolve method (Item 89). Otherwise, each time a serialized instance is deserialized, a new instance will be created, leading, in the case of our example, to spurious Elvis sightings.</p></blockquote><p>为了保证每一次访问到类里面的，去获得一个”只读函数“，这样就防止每一次访问到这个类的时候不会再生成一个新的类，确确实实的保证了类的单一性。</p><blockquote><p>A third way to implement a singleton is to declare a single-element enum:</p></blockquote><p>第三种方法实现单实例化是生成一个单个元素的枚举类</p><blockquote><p>This approach is similar to the public field approach, but it is more concise, provides the serialization machinery for free, and provides an ironclad guarantee against multiple instantiation, even in the face of sophisticated serialization or reflection attacks. This approach may feel a bit unnatural, but a single-element enum type is often the best way to implement a singleton.</p></blockquote><p>这种类型的方法就是类似于类的变量方法，但是这个更精细，提供的机器内存消耗几乎就是免费的，并且提供（这里后面的一句话 英文没怎么看懂 自动标红）。 这种方法可能有点不自然，但是这种方法往往是实现这种单实例化最好的方法。</p><blockquote><p>Note that you can’t use this approach if your singleton must extend a superclass other than Enum (though you can declare an enum to implement interfaces).</p></blockquote><p>记住如果你需要用单实例化类去继承一个类的话，那么就不能使用这种单枚举的方法了。<br>其的样例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enum singleton - the preferred approach </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Elvis &#123; </span><br><span class="line">    INSTANCE; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> effective_java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>effective java item 2</title>
      <link href="/2019/03/14/effective-java-item-2/"/>
      <url>/2019/03/14/effective-java-item-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Item-2-Consider-a-builder-when-faced-with-many-constructor-parameters"><a href="#Item-2-Consider-a-builder-when-faced-with-many-constructor-parameters" class="headerlink" title="Item 2: Consider a builder when faced with many constructor parameters"></a>Item 2: Consider a builder when faced with many constructor parameters</h3><p>条款二 当面临许多构造参数的时候，建议考虑一下一个构造器(builder)</p><blockquote><p>What sort of constructors or static factories should you write for such a class? Traditionally, programmers have used the telescoping constructor pattern, in which you provide a constructor with only the required parameters, another with a single optional parameter, a third with two optional parameters, and so on, culmi- nating in a constructor with all the optional parameters.</p></blockquote><p>经常会遇到构造函数中有多个参数，而这些参数，如果按照标准的方法来写的话，会特别的麻烦，于是就采用C++中的委托构造函数，利用其中一个构造函数，为其他所有的构造函数构造，相当于起到了一个构造器的作用(builder)</p><blockquote><p>Typically this constructor invocation will require many parameters that you don’t want to set, but you’re forced to pass a value for them anyway. In this case, we passed a value of 0 for fat.</p></blockquote><p>很多时候你不想设置那么多的参数，最简单的一个办法是给这个成员直接设置0。</p><blockquote><p>In short, the telescoping constructor pattern works, but it is hard to write client code when there are many parameters, and harder still to read it. The reader is left wondering what all those values mean and must carefully count parameters to find out. Long sequences of identically typed parameters can cause subtle bugs. If the client accidentally reverses two such parameters, the compiler won’t complain, but the program will misbehave at runtime (Item 51).</p></blockquote><p>简而言之，这种委托构造函数虽然可行，但是客户在写代码的时候很容易写错，就算写对了，也很难读出来，并且也会出现一种情况就是当参数够多的时候，写错了参数的顺序，这样造成的错误，编译器是不会轻易报错的。所以这里就很难被找出来。</p><blockquote><p>A second alternative when you’re faced with many optional parameters in a constructor is the JavaBeans pattern, in which you call a parameterless construc- tor to create the object and then call setter methods to set each required parameter and each optional parameter of interest</p></blockquote><p>还有第二种办法就是 给每一个私有成员设置一个set函数，一个外围的函数直接可以作用到内部私有成员，并且直接设置其的值。</p><blockquote><p>Unfortunately, the JavaBeans pattern has serious disadvantages of its own.Because construction is split across multiple calls, a JavaBean may be in an inconsistent state partway through its construction. The class does not have the option of enforcing consistency merely by checking the validity of the constructor parameters. Attempting to use an object when it’s in an inconsistent state may cause failures that are far removed from the code containing the bug and hence difficult to debug.</p></blockquote><p>不幸的是，这种模式的代码写法，将构造过程与赋值过程分开，也就意味着，当构造对象并没有赋值的时候会造成错误，另外，其还会在写一个immutable类的时候花费额外的工作保证线程安全。</p><blockquote><p>Luckily, there is a third alternative that combines the safety of the telescoping constructor pattern with the readability of the JavaBeans pattern. It is a form of the Builder pattern [Gamma95]. Instead of making the desired object directly, the client calls a constructor (or static factory) with all of the required parameters and gets a builder object. Then the client calls setter-like methods on the builder object to set each optional parameter of interest. Finally, the client calls a parameterless build method to generate the object, which is typically immutable.</p></blockquote><p>幸运的是 这里存在第三种构造方式，结合上述两种方法的优点，并且保证了线程安全，也不会有过多的参数的麻烦。按照下述的例子，直接在内的内部构造一个静态的builder的类，用一个其他的类来构造这个类，第一解决了immutable的问题，其次也解决了参数不能特意的问题。</p><blockquote><p>This client code is easy to write and, more importantly, easy to read. The Builder pattern simulates named optional parameters as found in Python and Scala.</p><blockquote><p>NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8) .calories(100).sodium(35).carbohydrate(27).build();<br>Check invariants involving multiple parameters in the constructor invoked by the build method. To ensure these invariants against attack, do the checks on object fields after copying parameters from the builder (Item 50). If a check fails, throw an IllegalArgumentException (Item 72) whose detail message indicates which parameters are invalid (Item 75).</p></blockquote></blockquote><p>这样的做法会造成代码清晰可读，并且最重要的是，可以在构造器这个类型里面进行一个check函数进行异常检查。</p><blockquote><p>The Builder pattern is well suited to class hierarchies. Use a parallel hier- archy of builders, each nested in the corresponding class. Abstract classes have abstract builders; concrete classes have concrete builders.</p></blockquote><p>这种构造模式，其实特别有利于类型继承，利用相应的类内的构造器帮助进行构造。<br>一般利用像如下形式的构造方法即可：记住这个地方时直接用过build 来返回外部的那个类。</p><p><strong>NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8) .calories(100).sodium(35).carbohydrate(27).build();</strong></p><blockquote><p>Here are two concrete subclasses of Pizza, one of which represents a standard New-York-style pizza, the other a calzone.</p></blockquote><p>后面的两种模式属于继承过程中出现的构造，注意构造的这个构造器 一定要满足如下形式。<br>最重要的是下面继承处的处理，调用基类的构造器 super(builder);<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NyPizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Size &#123; SMALL, MEDIUM, LARGE &#125; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Size size; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">extends</span> <span class="title">Pizza</span>.<span class="title">Builder</span>&lt;<span class="title">Builder</span>&gt; </span>&#123; </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Size size; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Size size)</span> </span>&#123; </span><br><span class="line">            <span class="keyword">this</span>.size = Objects.requireNonNull(size); </span><br><span class="line">            &#125; </span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> NyPizza <span class="title">build</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NyPizza(<span class="keyword">this</span>); </span><br><span class="line">            &#125; </span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> Builder <span class="title">self</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NyPizza</span><span class="params">(Builder builder)</span> </span>&#123; <span class="keyword">super</span>(builder); </span><br><span class="line">    size = builder.size; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calzone</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> sauceInside; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">extends</span> <span class="title">Pizza</span>.<span class="title">Builder</span>&lt;<span class="title">Builder</span>&gt; </span>&#123; </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> sauceInside = <span class="keyword">false</span>; <span class="comment">// Default </span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">sauceInside</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            sauceInside = <span class="keyword">true</span>; <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Calzone <span class="title">build</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Calzone(<span class="keyword">this</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> Builder <span class="title">self</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Calzone</span><span class="params">(Builder builder)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">super</span>(builder); sauceInside = builder.sauceInside; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>This technique, wherein a subclass method is declared to return a subtype of the return type declared in the super- class, is known as covariant return typing. It allows clients to use these builders without the need for casting.</p></blockquote><p>这项技术返回的类都是隶属于该类的，这样做的好处可以允许客户使用这些类而不需要使用转型。</p><blockquote><p>A single builder can be used repeatedly to build multiple objects. The parameters of the builder can be tweaked between invocations of the build method to vary the objects that are created. A builder can fill in some fields automatically upon object creation, such as a serial number that increases each time an object is created.</p></blockquote><p>由于是静态的类，所以只需要被构造一次，却可以造成多次使用，这里就是其的好处，，而这个构造器可以在这个对象被创建之后自动赋值。，比较方便。</p><blockquote><p>The Builder pattern has disadvantages as well. In order to create an object, you must first create its builder. While the cost of creating this builder is unlikely to be noticeable in practice, it could be a problem in performance-critical situations. Also, the Builder pattern is more verbose than the telescoping constructor pattern</p></blockquote><p>其存在的坏处就在于，其写出来的代码非常的复杂和冗杂，对于只有一点参数的构造器而言，完全没有这样写的必要，但是对于先开始只有一点参数，但是后面则变成很多参数的工程来说第一次使用这种构造器方便以后来写。</p><blockquote><p>In summary, the Builder pattern is a good choice when designing classes whose constructors or static factories would have more than a handful of parameters</p></blockquote><p>总而言之，使用这种办法的方便在于大工程，且一个类的构造参数过多的情况，即解决了参数冗杂的问题，又再次解决了类不能final的问题。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> effective_java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>effective java item 1</title>
      <link href="/2019/03/13/effective-java-item-1/"/>
      <url>/2019/03/13/effective-java-item-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Item-1-Consider-static-factory-methods-instead-of-constructors"><a href="#Item-1-Consider-static-factory-methods-instead-of-constructors" class="headerlink" title="Item 1: Consider static factory methods instead of constructors"></a>Item 1: Consider static factory methods instead of constructors</h2><p>前面几个条款的内容是关于创建和销毁对象。</p><blockquote><p>The traditional way for a class to allow a client to obtain an instance is to provide a public constructor. There is another technique that should be a part of every programmer’s toolkit. A class can provide a public static factory method, which is simply a static method that returns an instance of the class. Here’s a simple example from Boolean (the boxed primitive class for boolean). This method translates a boolean primitive value into a Boolean object reference:</p></blockquote><p>考虑直接用一个静态的方法来完成构造函数的功能，比如接受一个对象，然后通过这个对象来构造一个新的对象。</p><blockquote><p>A class can provide its clients with static factory methods instead of, or in addition to, public constructors. Providing a static factory method instead of a public constructor has both advantages and disadvantages.</p></blockquote><p>提供一个静态方法作为构造函数的有额外相对于提供公开构造函数的好处以及坏处。</p><hr><blockquote><p>One advantage of static factory methods is that, unlike constructors, they have names. If the parameters to a constructor do not, in and of themselves, describe the object being returned, a static factory with a well-chosen name is easier to use and the resulting client code easier to read. </p></blockquote><p>第一个好处是静态的函数有独特的名字而构造函数没有名字，通过名字将构造函数的参数进行一个分类显示的更加耐用。</p><blockquote><p>the constructor BigInteger(int, int, Random), which returns a BigInteger that is probably prime, would have been better expressed as a static factory method named BigInteger.probablePrime. </p></blockquote><p>就像大整数类在里面就有一个构造一个趋近于自己值的质数的大整数类，然后这里直接用名字命名显得更加方便。</p><blockquote><p>Because they have names, static factory methods don’t share the restriction discussed in the previous paragraph. In cases where a class seems to require multiple constructors with the same signature, replace the constructors with static factory methods and carefully chosen names to highlight their differences.</p></blockquote><p>有的时候一些公开构造函数的参数类型，以及参数的顺序，代表着不同的构造函数，这样会容易弄混淆，于是这也是体现名字第二个好的地方。</p><hr><blockquote><p>A second advantage of static factory methods is that, unlike constructors, they are not required to create a new object each time they’re invoked.</p></blockquote><p>第二个好处就是相比于构造函数每次在被call的时候，会构造一个新的对象，而静态方法有的时候则会节省下这一笔开销。就像之前举了一个例子，Boolean.valueOf 从来没有构造一个新的对象。</p><blockquote><p>. Instance control allows a class to guarantee that it is a singleton (Item 3) or noninstantiable (Item 4). Also, it allows an immutable value class (Item 17) to make the guarantee that no two equal instances exist: a.equals(b) if and only if a == b. This is the basis of the Flyweight pattern . Enum types (Item 34) provide this guarantee.</p></blockquote><p>这种实例化重复使用一个对象，得到的两个好处，第一个好处就是保证其是一个singleton,另一个好处，就是保证在调用equal函数的时候只能允许相等的条件只会有一个，那么就可以直接使用==号进行操作，从而进行性能上面的提升。</p><hr><blockquote><p>A third advantage of static factory methods is that, unlike constructors, they can return an object of any subtype of their return type. This gives you great flexibility in choosing the class of the returned object.</p></blockquote><p>而其的第三点好处就体现在其的返回值可以为任意该类型的子类型对象，这样在类型的返回的时候会提供很大的灵活性。</p><blockquote><p>One application of this flexibility is that an API can return objects without making their classes public. Hiding implementation classes in this fashion leads to a very compact API.</p></blockquote><p>而其中的第一点应用就在于返回API接口的时候可以不需要将这个类弄成公开的，隐藏其的实现。</p><blockquote><p>For example, the Java Collections Framework has forty-five utility implementations of its interfaces, providing unmodifiable collections, synchronized collections, and the like. Nearly all of these implemen- tations are exported via static factory methods in one noninstantiable class (java.util.Collections). The classes of the returned objects are all nonpublic.</p></blockquote><p>java在实现其的接口的时候，在接口里面采用静态的方法，导出的类往往都是没有公有化的，这样实现了 类的实现过程的隐藏。</p><blockquote><p>one for each convenience implemen- tation. It is not just the bulk of the API that is reduced but the conceptual weight: the number and difficulty of the concepts that programmers must master in order to use the API. The programmer knows that the returned object has precisely the API specified by its interface, so there is no need to read additional class docu- mentation for the implementation class. Furthermore, using such a static factory method requires the client to refer to the returned object by interface rather than implementation class, which is generally good practice (Item 64).</p></blockquote><p>开发者在接口的使用过程中，通过其的返回类型可以逐渐了解到其API的真实用途，这样来就不需要阅读额外的开发者文档。</p><blockquote><p>As of Java 8, the restriction that interfaces cannot contain static methods was eliminated, so there is typically little reason to provide a noninstantiable compan- ion class for an interface. Many public static members that would have been at home in such a class should instead be put in the interface itself. Note, however, that it may still be necessary to put the bulk of the implementation code behind these static methods in a separate package-private class. This is because Java 8 requires all static members of an interface to be public. Java 9 allows private static methods, but static fields and static member classes are still required to be public.</p></blockquote><p>java8的时候就同样将 接口里面不能放静态类型的函数规定给消除了，所以这个时候就没有理由去提供一个不可实例化的类给一个接口了，而许多静态成员应该被放在这样一个接口本身里，记住，现在还是最重要的是将实现的代码放在这些静态实现方法之后。这是因为java8 所有的静态成员都必须公开，而java9 则允许私有的静态函数，其他则是公开的。</p><hr><blockquote><p>A fourth advantage of static factories is that the class of the returned object can vary from call to call as a function of the input parameters. Any sub- type of the declared return type is permissible. The class of the returned object can also vary from release to release.</p></blockquote><p>第四个好处就在于返回的子类型中可以根据参数的形式来进行改变 一一对应的关系，这里举出了一个enumset的例子 （我看的不是很懂 所以这里标红，以后有时间再次来了解一下。）</p><hr><blockquote><p>A fifth advantage of static factories is that the class of the returned object need not exist when the class containing the method is written. Such flexible static factory methods form the basis of service provider frameworks, like the Java Database Connectivity API (JDBC). A service provider framework is a system in which providers implement a service, and the system makes the implementations available to clients, decoupling the clients from the implementations.</p></blockquote><p>第五个好处就是当类中包含的函数已经被写了，然后这返回对象不需要存在，（这一点也没有看懂，等以后拜读了中文版再来解释，手动标红）</p><hr><blockquote><p>The main limitation of providing only static factory methods is that classes without public or protected constructors cannot be subclassed. For example, it is impossible to subclass any of the convenience implementation classes in the Collections Framework. Arguably this can be a blessing in disguise because it encourages programmers to use composition instead of inheritance (Item 18), and is required for immutable types (Item 17).</p></blockquote><p>其实这个地方最大的一个局限的地方就在于，如果一个类没有公开或者保护的构造函数的话 那么这个类是不允许被继承的，意思就是对于被静态函数得来的类，因为不具有公开的构造函数 所以不能够被子类化。</p><blockquote><p>A second shortcoming of static factory methods is that they are hard for programmers to find. They do not stand out in API documentation in the way that constructors do, so it can be difficult to figure out how to instantiate a class that provides static factory methods instead of constructors.</p></blockquote><p>第二个缺点就在于可能开发者会很不容易找到这些静态方法，而且他们不会像平常构造函数一样，所以很难理解实例化一个类提供的静态函数而不是此构造函数。</p><p>不过有一些静态函数的样例 类似的模板 可以自己在书中去查找。</p><blockquote><p>In summary, static factory methods and public constructors both have their uses, and it pays to understand their relative merits. Often static factories are preferable, so avoid the reflex to provide public constructors without first consid- ering static factories.</p></blockquote><p>总之 两种构造函数都有相应的好处与坏处，具体样例具体分析。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> effective_java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>大数专题的java方法总结</title>
      <link href="/2019/03/13/%E5%A4%A7%E6%95%B0%E4%B8%93%E9%A2%98%E7%9A%84java%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2019/03/13/%E5%A4%A7%E6%95%B0%E4%B8%93%E9%A2%98%E7%9A%84java%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实这里题目类型都差不多<br>仅仅只贴出几道题的代码，并且对这些题目所用到的函数进行一个总结。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">E</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            BigDecimal r;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            r = in.nextBigDecimal();</span><br><span class="line">            n = in.nextInt();</span><br><span class="line">            BigDecimal ans;</span><br><span class="line">            ans = r.pow(n);</span><br><span class="line">            ans = ans.stripTrailingZeros();</span><br><span class="line">            String res = ans.toPlainString();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (res.startsWith(<span class="string">"0"</span>)) &#123;res =res.substring(<span class="number">1</span>);&#125;</span><br><span class="line">            System.out.println(res);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>stripTrailingZeros()</code> 这个函数的意思是去除多余的0。<br><code>toPlainString()</code> 这个函数的意思是将某些科学计数法，给全部展开。<br><code>startsWith(&quot;0&quot;)</code> 这个函数的意思就是 判断字符串到底以什么函数为前提。<br><code>substring(1)</code> 这个函数的意思就是字符串进行一个有效的替换。</p><p><strong>另外 java 里面大数的大数幂次方必须要规定一个mod对象 实现函数则为modpow()</strong></p><p>最后再累积点 C++ 知识：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A*B % C = (A%C * B%C)%C</span><br><span class="line">(A+B)%C = (A%C + B%C)%C</span><br><span class="line"></span><br><span class="line">如 532 mod 7 =（500%7+30%7+2%7)%7;</span><br><span class="line"></span><br><span class="line">当然还有</span><br><span class="line"></span><br><span class="line">a*b mod c=(a mod c+b mod c)mod c;</span><br><span class="line"></span><br><span class="line">如35 mod 3=((5%3)*(7%3))%3</span><br></pre></td></tr></table></figure></p><h3 id="还有一道题目-具体看代码"><a href="#还有一道题目-具体看代码" class="headerlink" title="还有一道题目 具体看代码"></a>还有一道题目 具体看代码</h3><p>这道题展现了 java在求余数方面的缺陷。</p><p><strong>重要的就是这一步 v = (v * 10 + s[i] - ‘0’) % mod</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        BigInteger a;</span><br><span class="line">        String b,c;</span><br><span class="line">        <span class="keyword">int</span> Case = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cin.hasNext()) &#123;</span><br><span class="line">            </span><br><span class="line">            a = cin.nextBigInteger();</span><br><span class="line">            b = a.mod(<span class="keyword">new</span> BigInteger(<span class="string">"137"</span>)).toString();</span><br><span class="line">            c = a.mod(<span class="keyword">new</span> BigInteger(<span class="string">"73"</span>)).toString();</span><br><span class="line">            <span class="keyword">if</span> (b.equals(<span class="string">"0"</span>) &amp;&amp; c.equals(<span class="string">"0"</span>) )   System.out.println(<span class="string">"Case #"</span> + Case++ + <span class="string">": YES"</span>);</span><br><span class="line">            <span class="keyword">else</span> System.out.println(<span class="string">"Case #"</span> + Case++ + <span class="string">": NO"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关于这道题，不知道为什么用java 提交就是没有办法过，全部都是爆内存，我个人觉得可能在大数，求余数这方面，可能存在缺陷。</span></span><br><span class="line"><span class="comment">下面提供几个 AC的 C++代码</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#include&lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">using namespace std;</span></span><br><span class="line"><span class="comment">const int maxn = 10000000 + 1;</span></span><br><span class="line"><span class="comment">const int mod = 10001;</span></span><br><span class="line"><span class="comment">char s[maxn];</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    int kase = 0;</span></span><br><span class="line"><span class="comment">    while(scanf("%s",s) == 1)&#123;</span></span><br><span class="line"><span class="comment">        int len = strlen(s);</span></span><br><span class="line"><span class="comment">        int v = 0;</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; len; ++i)&#123;</span></span><br><span class="line"><span class="comment">            v = (v*10 + s[i]-48) % mod;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        if (v == 0)printf("Case #%d: YES\n",++kase);</span></span><br><span class="line"><span class="comment">        else printf("Case #%d: NO\n",++kase);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>四道关于BFS的情况变换题目</title>
      <link href="/2019/03/13/%E5%9B%9B%E9%81%93%E5%85%B3%E4%BA%8EBFS%E7%9A%84%E6%83%85%E5%86%B5%E5%8F%98%E6%8D%A2%E9%A2%98%E7%9B%AE/"/>
      <url>/2019/03/13/%E5%9B%9B%E9%81%93%E5%85%B3%E4%BA%8EBFS%E7%9A%84%E6%83%85%E5%86%B5%E5%8F%98%E6%8D%A2%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这个专题 同样还是总结一些BFS的题目，但是这些BFS的题目都存在一个特定的特点，也就是你真的没有办法猜到，原来这道题目最后是通过BFS的方法做的。</p><h3 id="第一题-Fliptile"><a href="#第一题-Fliptile" class="headerlink" title="第一题 Fliptile"></a>第一题 Fliptile</h3><p><a href="https://vjudge.net/problem/POJ-3279" target="_blank" rel="noopener">Fliptile</a></p><p>这道题 个人是觉得很有必要来做一遍，这道题不太属于一个严格的bfs，但是这道题的递归解题思路很有意思。</p><p>题目大意就是两种颜色的格子，给定一个初始图，翻动最小的步数，使得全部为白色，并且最后给出翻动与不翻动的图片</p><p>这道题最好玩的是 我们需要明白一个前提，第i行的格子在竖排上只能被上面的颜色改变，意思是 最后一排的只能根据倒数第二排的位置来确定。<br>那我们通过递归确定第一排便利下去的每一种方法，然后判断是否会进行改变，最后保证最后一排全部为白色，也就达到了全部为白色的效果。</p><p><strong>需要注意的是，里面有一个<code>&amp; 1</code>的操作，这个意思就是对2求余，最终导致的结果就是可以判断该位置的格子该不该重复翻转过来。</strong></p><p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cpy[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> res[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> Min;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = cpy[n][i] + cpy[n][i - <span class="number">1</span>] + cpy[n][i + <span class="number">1</span>] + cpy[n - <span class="number">1</span>][i];</span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">map</span>[n][i] + tmp) &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (num &gt; Min) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (judge() &amp;&amp; Min &gt; num) &#123;</span><br><span class="line">            Min = num;</span><br><span class="line">            <span class="built_in">memcpy</span>(res,cpy,<span class="keyword">sizeof</span> (cpy));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> _time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="built_in">map</span>[a - <span class="number">1</span>][i] + cpy[a - <span class="number">1</span>][i] + cpy[a - <span class="number">2</span>][i] + cpy[a - <span class="number">1</span>][i - <span class="number">1</span>] + cpy[a - <span class="number">1</span>][i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (tmp &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            cpy[a][i] = <span class="number">1</span>;</span><br><span class="line">            _time ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> cpy[a][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(a + <span class="number">1</span>, num + _time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; m) &#123;</span><br><span class="line">        dfs(<span class="number">2</span>,num);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    cpy[<span class="number">1</span>][a] = <span class="number">0</span>;</span><br><span class="line">    solve(a + <span class="number">1</span>,num);</span><br><span class="line">    cpy[<span class="number">1</span>][a] = <span class="number">1</span>;</span><br><span class="line">    solve(a + <span class="number">1</span>,num + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; <span class="built_in">map</span>[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Min = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="built_in">memset</span>(cpy,<span class="number">0</span>,<span class="keyword">sizeof</span>(cpy));</span><br><span class="line">        solve(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (Min == <span class="number">0x3f3f3f3f</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"IMPOSSIBLE"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; res[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    get();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第二题-pots"><a href="#第二题-pots" class="headerlink" title="第二题 pots"></a>第二题 pots</h3><p><a href="https://vjudge.net/problem/POJ-3414" target="_blank" rel="noopener">pots</a></p><p>这道题刚开始看的第一眼完全想象不到这竟然是一个BFS的题目，因为相互之间倒水，当时是完全没有一点思路的，不过后来根据BFS层序查找的性质，可以逐渐发现，原来这个地方的一共有六种情况，然后将已经遍历过的和不符合条件的全部去除，然后将返回到原来的位置的情况直接失败，很容易就可以用BFS给弄出来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A,B,C;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> s[<span class="number">6</span>] = &#123;<span class="string">"FILL(1)"</span>, <span class="string">"FILL(2)"</span>, <span class="string">"DROP(1)"</span>, <span class="string">"DROP(2)"</span>, <span class="string">"POUR(1,2)"</span>, <span class="string">"POUR(2,1)"</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v_a,v_b;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vs;</span><br><span class="line">    Node() &#123;&#125;;</span><br><span class="line">    Node (<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c) : v_a(a), v_b(b), step(c) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">    Node now(0,0,0),next;</span><br><span class="line">    vis[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    q.push(now);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; * tmp;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) </span><br><span class="line">    &#123;</span><br><span class="line">        Node now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (now.v_a == C || now.v_b == C) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; now.step &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> it = <span class="number">0</span>; it != now.vs.size(); it++) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; now.vs[it] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (now.v_a != A) &#123;</span><br><span class="line">            next.v_a = A;</span><br><span class="line">            next.v_b = now.v_b;</span><br><span class="line">            next.step = now.step + <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!vis[next.v_a][next.v_b])&#123;</span><br><span class="line">                vis[next.v_a][next.v_b] = <span class="literal">true</span>;</span><br><span class="line">                next.vs = now.vs;</span><br><span class="line">                next.vs.push_back(s[<span class="number">0</span>]);</span><br><span class="line">                q.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (now.v_b != B) &#123;</span><br><span class="line">            next.v_b = B;</span><br><span class="line">            next.v_a = now.v_a;</span><br><span class="line">            next.step = now.step + <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!vis[next.v_a][next.v_b])</span><br><span class="line">            &#123;</span><br><span class="line">                vis[next.v_a][next.v_b] = <span class="literal">true</span>;</span><br><span class="line">                next.vs = now.vs;</span><br><span class="line">                next.vs.push_back(s[<span class="number">1</span>]);</span><br><span class="line">                q.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (now.v_a != <span class="number">0</span>)&#123;</span><br><span class="line">            next.v_a = <span class="number">0</span>;</span><br><span class="line">            next.v_b = now.v_b;</span><br><span class="line">            next.step = now.step + <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!vis[next.v_a][next.v_b])</span><br><span class="line">            &#123;</span><br><span class="line">                vis[next.v_a][next.v_b] = <span class="literal">true</span>;</span><br><span class="line">                next.vs = now.vs;</span><br><span class="line">                next.vs.push_back(s[<span class="number">2</span>]);</span><br><span class="line">                q.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (now.v_b != <span class="number">0</span>)&#123;</span><br><span class="line">            next.v_b = <span class="number">0</span>;</span><br><span class="line">            next.v_a = now.v_a;</span><br><span class="line">            next.step = now.step + <span class="number">1</span>;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> (!vis[next.v_a][next.v_b])</span><br><span class="line">            &#123;</span><br><span class="line">                vis[next.v_a][next.v_b] = <span class="literal">true</span>;</span><br><span class="line">                next.vs = now.vs;</span><br><span class="line">                next.vs.push_back(s[<span class="number">3</span>]);</span><br><span class="line">                q.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (now.v_a != <span class="number">0</span> &amp;&amp; now.v_b != B) &#123;</span><br><span class="line">            next.v_a = now.v_a - (B - now.v_b);</span><br><span class="line">            next.v_b = now.v_a + now.v_b;</span><br><span class="line">            <span class="keyword">if</span> (next.v_b &gt; B) next.v_b = B;</span><br><span class="line">            <span class="keyword">if</span> (next.v_a &lt; <span class="number">0</span>) next.v_a = <span class="number">0</span>;</span><br><span class="line">            next.step = now.step + <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!vis[next.v_a][next.v_b])</span><br><span class="line">            &#123;</span><br><span class="line">                vis[next.v_a][next.v_b] = <span class="literal">true</span>;</span><br><span class="line">                next.vs = now.vs;</span><br><span class="line">                next.vs.push_back(s[<span class="number">4</span>]);</span><br><span class="line">                q.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (now.v_a != A &amp;&amp; now.v_b != <span class="number">0</span>)&#123;</span><br><span class="line">            next.v_b = now.v_b - (A - now.v_a);</span><br><span class="line">            next.v_a = now.v_a + now.v_b;</span><br><span class="line">            <span class="keyword">if</span> (next.v_a &gt; A) next.v_a = A;</span><br><span class="line">            <span class="keyword">if</span> (next.v_b &lt; <span class="number">0</span>) next.v_b = <span class="number">0</span>;</span><br><span class="line">            next.step = now.step + <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!vis[next.v_a][next.v_b])</span><br><span class="line">            &#123;</span><br><span class="line">                vis[next.v_a][next.v_b] = <span class="literal">true</span>;</span><br><span class="line">                next.vs = now.vs;</span><br><span class="line">                next.vs.push_back(s[<span class="number">5</span>]);</span><br><span class="line">                q.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B &gt;&gt; C) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="keyword">if</span> (!bfs()) <span class="built_in">cout</span> &lt;&lt; <span class="string">"impossible"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三题-非常可乐"><a href="#第三题-非常可乐" class="headerlink" title="第三题 非常可乐"></a>第三题 非常可乐</h3><p><a href="https://vjudge.net/problem/HDU-1495" target="_blank" rel="noopener">非常可乐</a></p><p>这一道题，其实与上面一道题很类似的地方就在于，也是将诸多情况进行一个总结与分布，符合条件的入队列，不符合条件的直接出队列。<br>关键就是这道题的条件设置方面与上面一题有些不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">L_</span>非常可乐 </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line">    <span class="comment">// 标志数组来标记路径，三个杯子三维数组即可</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][][] visited = <span class="keyword">new</span> <span class="keyword">int</span>[maxn][maxn][maxn];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; maxn; ++j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; maxn; ++k)</span><br><span class="line">                    visited[i][j][k] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a b c为三个容器的最大容量</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"NO"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记住这里可以直接写queue的接口 来声明类型 并且在后面 new 的时候 以LinkedList来实现 其的接口</span></span><br><span class="line">        Queue&lt;Node&gt; que = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">        <span class="comment">// 初始</span></span><br><span class="line">        que.add(<span class="keyword">new</span> Node(a, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 取队头并弹出</span></span><br><span class="line">            Node t = que.poll();</span><br><span class="line">            visited[t.a][t.b][t.c] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 判断是否符合条件</span></span><br><span class="line">            <span class="keyword">if</span> (t.a == t.b &amp;&amp; t.c == <span class="number">0</span> || t.a == t.c &amp;&amp; t.b == <span class="number">0</span> || t.b == t.c &amp;&amp; t.a == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(t.step);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 倒水过程，注意倒水的前提是杯子里面有水</span></span><br><span class="line">            <span class="comment">// b -&gt; a</span></span><br><span class="line">            <span class="keyword">if</span> (t.b != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 因为没有刻度， 所以每次倒水都有两种情况</span></span><br><span class="line">                <span class="comment">// 第一种情况是把自己倒完</span></span><br><span class="line">                <span class="keyword">if</span> (t.a + t.b &lt;= a) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (visited[t.a + t.b][<span class="number">0</span>][t.c] == <span class="number">0</span>) &#123;</span><br><span class="line">                        que.add(<span class="keyword">new</span> Node(t.a + t.b, <span class="number">0</span>, t.c, t.step + <span class="number">1</span>));</span><br><span class="line">                        visited[t.a + t.b][<span class="number">0</span>][t.c] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 第二种情况是把对方倒满</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t.a != a) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (visited[a][t.b - (a - t.a)][t.c] == <span class="number">0</span>) &#123;</span><br><span class="line">                        que.add(<span class="keyword">new</span> Node(a, t.b - (a - t.a), t.c, t.step + <span class="number">1</span>));</span><br><span class="line">                        visited[a][t.b - (a - t.a)][t.c] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// c -&gt; a</span></span><br><span class="line">            <span class="keyword">if</span> (t.c != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.a + t.c &lt;= a) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (visited[t.a + t.c][t.b][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                        que.add(<span class="keyword">new</span> Node(t.a + t.c, t.b, <span class="number">0</span>, t.step + <span class="number">1</span>));</span><br><span class="line">                        visited[t.a + t.c][t.b][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t.a != a) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (visited[a][t.b][t.c - (a - t.a)] == <span class="number">0</span>) &#123;</span><br><span class="line">                        que.add(<span class="keyword">new</span> Node(a, t.b, t.c - (a - t.a), t.step + <span class="number">1</span>));</span><br><span class="line">                        visited[a][t.b][t.c - (a - t.a)] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// b -&gt; c</span></span><br><span class="line">            <span class="keyword">if</span> (t.b != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.b + t.c &lt;= c) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (visited[t.a][<span class="number">0</span>][t.b + t.c] == <span class="number">0</span>) &#123;</span><br><span class="line">                        que.add(<span class="keyword">new</span> Node(t.a, <span class="number">0</span>, t.b + t.c, t.step + <span class="number">1</span>));</span><br><span class="line">                        visited[t.a][<span class="number">0</span>][t.b + t.c] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t.c != c) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (visited[t.a][t.b - (c - t.c)][c] == <span class="number">0</span>) &#123;</span><br><span class="line">                        que.add(<span class="keyword">new</span> Node(t.a, t.b - (c - t.c), c, t.step + <span class="number">1</span>));</span><br><span class="line">                        visited[t.a][t.b - (c - t.c)][c] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// c -&gt; b</span></span><br><span class="line">            <span class="keyword">if</span> (t.c != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.c + t.b &lt;= b) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (visited[t.a][t.c + t.b][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                        que.add(<span class="keyword">new</span> Node(t.a, t.c + t.b, <span class="number">0</span>, t.step + <span class="number">1</span>));</span><br><span class="line">                        visited[t.a][t.c + t.b][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t.b != b) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (visited[t.a][b][t.c - (b - t.b)] == <span class="number">0</span>) &#123;</span><br><span class="line">                        que.add(<span class="keyword">new</span> Node(t.a, b, t.c - (b - t.b), t.step + <span class="number">1</span>));</span><br><span class="line">                        visited[t.a][b][t.c - (b - t.b)] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// a -&gt; b</span></span><br><span class="line">            <span class="keyword">if</span> (t.a != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.a + t.b &lt;= b) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (visited[<span class="number">0</span>][t.a + t.b][t.c] == <span class="number">0</span>) &#123;</span><br><span class="line">                        que.add(<span class="keyword">new</span> Node(<span class="number">0</span>, t.a + t.b, t.c, t.step + <span class="number">1</span>));</span><br><span class="line">                        visited[<span class="number">0</span>][t.a + t.b][t.c] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t.b != b) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (visited[t.a - (b - t.b)][b][t.c] == <span class="number">0</span>) &#123;</span><br><span class="line">                        que.add(<span class="keyword">new</span> Node(t.a - (b - t.b), b, t.c, t.step + <span class="number">1</span>));</span><br><span class="line">                        visited[t.a - (b - t.b)][b][t.c] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// a -&gt; c</span></span><br><span class="line">            <span class="keyword">if</span> (t.a != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.a + t.c &lt;= c) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (visited[<span class="number">0</span>][t.b][t.a + t.c] == <span class="number">0</span>) &#123;</span><br><span class="line">                        que.add(<span class="keyword">new</span> Node(<span class="number">0</span>, t.b, t.a + t.c, t.step + <span class="number">1</span>));</span><br><span class="line">                        visited[<span class="number">0</span>][t.b][t.a + t.c] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t.c != c) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (visited[t.a - (c - t.c)][t.b][c] == <span class="number">0</span>) &#123;</span><br><span class="line">                        que.add(<span class="keyword">new</span> Node(t.a - (c - t.c), t.b, c, t.step + <span class="number">1</span>));</span><br><span class="line">                        visited[t.a - (c - t.c)][t.b][c] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = in.nextInt(), b = in.nextInt(), c = in.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span> &amp;&amp; c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            init();</span><br><span class="line">            bfs(a, b, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// a b c 代表实际拥有水的体积</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c, step;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> step) &#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">        <span class="keyword">this</span>.step = step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第四题-prime-path"><a href="#第四题-prime-path" class="headerlink" title="第四题 prime path"></a>第四题 prime path</h3><p><a href="https://vjudge.net/problem/POJ-3126" target="_blank" rel="noopener">prime path</a></p><p>这道题 同样看题目这的没有办法观察到这是一个BFS的题目，只有看到后面才逐渐发现这道题目 其实是通过搜寻每个部位的变化，最终导致输出结果<br>不过这里会借助到一些筛选质数的办法 比如欧拉筛 比如埃式筛</p><p>只不过后面是直接用暴力枚举这部分 我是真的没有想到，暴力枚举了四十种情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> prime[maxn];</span><br><span class="line"><span class="keyword">bool</span> check[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,step;</span><br><span class="line">    Node()&#123;&#125;;</span><br><span class="line">    Node(<span class="keyword">int</span> a,<span class="keyword">int</span> c):x(a),step(c)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(check,<span class="literal">false</span>,<span class="keyword">sizeof</span>(check));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!check[i]) prime[tot++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * prime[j] &gt; maxn) <span class="keyword">break</span>;</span><br><span class="line">            check[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">    Node o1(a,0),o2,o3;</span><br><span class="line">    q.push(o1);</span><br><span class="line">    vis[a] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        o2 = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span> (o2.x == b) <span class="keyword">return</span> o2.step;</span><br><span class="line">        <span class="keyword">int</span> num[<span class="number">4</span>];</span><br><span class="line">        num[<span class="number">0</span>] = o2.x / <span class="number">1000</span>;</span><br><span class="line">        num[<span class="number">1</span>] = o2.x / <span class="number">100</span> % <span class="number">10</span>;</span><br><span class="line">        num[<span class="number">2</span>] = o2.x / <span class="number">10</span> % <span class="number">10</span>;</span><br><span class="line">        num[<span class="number">3</span>] = o2.x % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = num[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                num[i] = j;</span><br><span class="line">                <span class="keyword">int</span> yy = num[<span class="number">0</span>] * <span class="number">1000</span> + num[<span class="number">1</span>] * <span class="number">100</span> + num[<span class="number">2</span>] *<span class="number">10</span> + num[<span class="number">3</span>];</span><br><span class="line">                <span class="keyword">if</span> (!vis[yy] &amp;&amp; !check[yy] &amp;&amp; yy &gt; <span class="number">1000</span> &amp;&amp; yy &lt; <span class="number">9999</span>) &#123;</span><br><span class="line">                    vis[yy] = <span class="literal">true</span>;</span><br><span class="line">                    o3.x = yy;</span><br><span class="line">                    o3.step = o2.step + <span class="number">1</span>;</span><br><span class="line">                    q.push(o3);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num[i] =  tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    get_prime();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        ans = bfs(a,b);</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">-1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Impossible"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>两道与fire有关的基础BFS</title>
      <link href="/2019/03/13/%E4%B8%A4%E9%81%93%E4%B8%8Efire%E6%9C%89%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80BFS/"/>
      <url>/2019/03/13/%E4%B8%A4%E9%81%93%E4%B8%8Efire%E6%9C%89%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80BFS/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="第一道题"><a href="#第一道题" class="headerlink" title="第一道题"></a>第一道题</h3><p><a href="https://vjudge.net/problem/FZU-2150" target="_blank" rel="noopener">fire game</a></p><p>这道题目其实就是一个简单的bfs，但是令我特别困惑的是，我不知道怎么去取每一个火苗向四周扩散的时间，然后最后才知道，原来是直接计算那个最长的路线就行了，这道题目的意思就是根据每一个点的遍历，去寻找最长的那一个点，将每个点放进去，然后找距离这个点最长的距离就是其扩散的最终时间，然后到最后依次枚举两个点，按照各自两个点之间的最快的时间来决定最终的时间。</p><p><strong>其实这道题不难，一道bfs的模拟题目，只不过就是后面决策的那个地方不太好下。</strong></p><p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,pos;</span><br><span class="line">    point ()&#123;&#125;</span><br><span class="line">    point (<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c) : x(a),y(b),pos(c) &#123;&#125;</span><br><span class="line">    <span class="function">point <span class="title">move</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="function">point <span class="title">tmp</span><span class="params">(x,y,pos)</span></span>;</span><br><span class="line">        <span class="keyword">switch</span> (i)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:&#123;</span><br><span class="line">                tmp.x = x + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.x = x - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.y = y + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.y = y - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.pos++;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(point a,point b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;point&gt; q;</span><br><span class="line">    point now,next;</span><br><span class="line">    q.push(a);</span><br><span class="line">    q.push(b);</span><br><span class="line">    <span class="built_in">memset</span>(vis,inf,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    vis[a.x][a.y] = <span class="number">0</span>;</span><br><span class="line">    vis[b.x][b.y] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            next = now.move(i);</span><br><span class="line">            <span class="keyword">if</span> (next.x &gt;= <span class="number">0</span> &amp;&amp; next.x &lt; n &amp;&amp; next.y &gt;= <span class="number">0</span> &amp;&amp; next.y &lt; m </span><br><span class="line">            &amp;&amp; <span class="built_in">map</span>[next.x][next.y] == <span class="string">'#'</span> &amp;&amp; vis[next.x][next.y] == inf) &#123;</span><br><span class="line">                vis[next.x][next.y] = next.pos;</span><br><span class="line">                q.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == <span class="string">'#'</span>) </span><br><span class="line">            <span class="comment">//这里就是找在层序遍历中距离res最大的每一个点，即最后的时间。</span></span><br><span class="line">                res = max(res,vis[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">int</span> Case = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j ++) &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; <span class="built_in">map</span>[i][j];</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == <span class="string">'#'</span>) &#123;</span><br><span class="line">                    cnt ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cnt &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; Case++ &lt;&lt; <span class="string">": "</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == <span class="string">'#'</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; n; l++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; k++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (l &lt;= i &amp;&amp; k &lt;= j) <span class="keyword">continue</span>;</span><br><span class="line">                            <span class="keyword">if</span> (<span class="built_in">map</span>[l][k] == <span class="string">'#'</span>)&#123;</span><br><span class="line">                                <span class="function">point <span class="title">p1</span><span class="params">(i,j,<span class="number">0</span>)</span></span>;</span><br><span class="line">                                <span class="function">point <span class="title">p2</span><span class="params">(l,k,<span class="number">0</span>)</span></span>;</span><br><span class="line">                                <span class="comment">//这里就是找每一个距离最远的点中最小的那个值。</span></span><br><span class="line">                                <span class="keyword">int</span> ans = bfs(p1,p2);</span><br><span class="line">                                res = min(ans,res);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == inf)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; Case++ &lt;&lt; <span class="string">": "</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; Case++ &lt;&lt; <span class="string">": "</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第二道题"><a href="#第二道题" class="headerlink" title="第二道题"></a>第二道题</h3><p><a href="https://vjudge.net/problem/UVA-11624" target="_blank" rel="noopener">Fire!</a></p><p>其实吧，这道题刚出来的时候，我在想，因为两个BFS嘛，会不会用到并发编程,(原谅我的天真烂漫)，后面是直接用两个BFS分开放，用一个二维数组来记录火蔓延的时间，然后再用一个BFS来记录其的走向位置，。</p><p><strong>本质上，还是属于一个bfs的模板题目。</strong></p><p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,step;</span><br><span class="line">    point() &#123;&#125;</span><br><span class="line">    point (<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c) : x(a),y(b), step(c) &#123;&#125;</span><br><span class="line">    <span class="function">point <span class="title">move</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="function">point <span class="title">tmp</span><span class="params">(x, y, step)</span></span>;</span><br><span class="line">        <span class="keyword">switch</span> (i)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            tmp.x = x + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            tmp.x = x - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            tmp.y = y + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            tmp.y = y - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.step++;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> _time[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;point&gt; q_fire;</span><br><span class="line"><span class="built_in">queue</span>&lt;point&gt; q_joe;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs_fire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    point now, next;</span><br><span class="line">    <span class="keyword">while</span> (!q_fire.empty()) &#123;</span><br><span class="line">        now = q_fire.front();</span><br><span class="line">        q_fire.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span> ; i++) &#123;</span><br><span class="line">            next = now.move(i);</span><br><span class="line">            <span class="keyword">if</span> (next.x &gt;= <span class="number">0</span> &amp;&amp; next.y &gt;= <span class="number">0</span> &amp;&amp; next.x &lt; m &amp;&amp; next.y &lt; n </span><br><span class="line">                &amp;&amp; _time[next.x][next.y] &gt; next.step &amp;&amp; (<span class="built_in">map</span>[next.x][next.y] == <span class="string">'.'</span> || <span class="built_in">map</span>[next.x][next.y] == <span class="string">'J'</span>)) &#123;</span><br><span class="line">                    q_fire.push(next);</span><br><span class="line">                    _time[next.x][next.y] = next.step;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_ok</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x == <span class="number">0</span> || y == <span class="number">0</span> || x == m - <span class="number">1</span> || y == n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs_joe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    point now,next;</span><br><span class="line">    <span class="keyword">while</span> (!q_joe.empty()) &#123;</span><br><span class="line">        now = q_joe.front();</span><br><span class="line">        q_joe.pop();</span><br><span class="line">        <span class="keyword">if</span> (is_ok(now.x,now.y)) <span class="keyword">return</span> now.step + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">            next = now.move(i);</span><br><span class="line">            <span class="keyword">if</span> (next.x &gt;= <span class="number">0</span> &amp;&amp; next.y &gt;= <span class="number">0</span> &amp;&amp; next.x &lt; m &amp;&amp; next.y &lt; n </span><br><span class="line">            &amp;&amp; !vis[next.x][next.y] &amp;&amp; <span class="built_in">map</span>[next.x][next.y] == <span class="string">'.'</span> &amp;&amp; next.step &lt; _time[next.x][next.y])&#123;</span><br><span class="line">                q_joe.push(next);</span><br><span class="line">                vis[next.x][next.y] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">while</span> (!q_fire.empty())</span><br><span class="line">        q_fire.pop();</span><br><span class="line">    <span class="keyword">while</span> (!q_joe.empty())</span><br><span class="line">        q_joe.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        clear();</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; <span class="built_in">map</span>[i][j];</span><br><span class="line">                _time[i][j] = inf;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == <span class="string">'J'</span>) &#123;</span><br><span class="line">                    q_joe.push(point (i,j,<span class="number">0</span>));</span><br><span class="line">                    vis[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == <span class="string">'F'</span>) &#123;</span><br><span class="line">                    q_fire.push(point(i,j,<span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        bfs_fire();</span><br><span class="line">        <span class="keyword">int</span> t = bfs_joe();</span><br><span class="line">        <span class="keyword">if</span> (t) <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"IMPOSSIBLE"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>质数筛选问题</title>
      <link href="/2019/03/05/%E8%B4%A8%E6%95%B0%E7%AD%9B%E9%80%89%E9%97%AE%E9%A2%98/"/>
      <url>/2019/03/05/%E8%B4%A8%E6%95%B0%E7%AD%9B%E9%80%89%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>关于质数的筛选问题，就像最先开始学习C语言一样，最先开始都是从1遍历到本身。</p><p>后来的优化版本就体现在遍历到本身的 根号下的倍数关系。但是 后来则发现有太多的重复循环次数，这里反而显得不是特别好，所以就出来一种新的筛选方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最普通的埃式筛法</span></span><br><span class="line"><span class="built_in">memset</span>(check, <span class="number">0</span>, <span class="keyword">sizeof</span>(check));</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!check[i])</span><br><span class="line">    &#123;</span><br><span class="line">        prime[tot++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面其实用乘法和用加法都是一样的，而这里就是乘法的原因就在于，减少了循环次数</span></span><br><span class="line">    <span class="comment">// 唯一没有被优化的地方就在于 每一个数字被重复标记了很多次，而后面的欧拉筛就会限制标记次数为一次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt;= n; j *= i)</span><br><span class="line">    &#123;</span><br><span class="line">        check[j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>鉴于上面所说的在进行一次优化，则优化体现在了减少重复次数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进阶版的线性筛法</span></span><br><span class="line"><span class="comment">//质数数组</span></span><br><span class="line"><span class="keyword">int</span> prime[MAXN];</span><br><span class="line"><span class="comment">//判断每一个数 数组</span></span><br><span class="line"><span class="keyword">int</span> check[MAXL];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(check, <span class="number">0</span>, <span class="keyword">sizeof</span>(check));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAXL; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!check[i])</span><br><span class="line">    &#123;</span><br><span class="line">        prime[tot++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//大致意思就在于 将每一个数的与质数数组里面的数进行相乘，最后得到的结果存在check中去</span></span><br><span class="line">        <span class="comment">//需要注意的就是 一旦当前的数能被整除的时候 就立马退出，这样代表每一个数字都会被自己的最小质因数给整除出来。</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i * prime[j] &gt; MAXL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        check[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接下来就是区间筛</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 质数筛选 </tag>
            
            <tag> 欧拉筛 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分享几道简单搜索题目</title>
      <link href="/2019/03/05/%E5%88%86%E4%BA%AB%E5%87%A0%E9%81%93%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E9%A2%98%E7%9B%AE/"/>
      <url>/2019/03/05/%E5%88%86%E4%BA%AB%E5%87%A0%E9%81%93%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不多做分析，其基本上都是一些 dfs 与 bfs上面的简单题目</p><p><img src="/2019/03/05/分享几道简单搜索题目/11.png" alt="11"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: 棋盘问题.cpp</span></span><br><span class="line"><span class="comment">&gt; Author: wangshuxiao</span></span><br><span class="line"><span class="comment">&gt; Mail: wsx1128@outlook.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: Sun  3 Mar 15:05:54 2019</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">char</span> board  [<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> total;</span><br><span class="line"><span class="keyword">bool</span> booked[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span>  cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>  cur)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cnt == k) &#123;</span><br><span class="line">total ++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur &gt;= n) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (booked[j] == <span class="literal">false</span> &amp;&amp; board[cur][j] == <span class="string">'#'</span>) &#123;</span><br><span class="line">booked[j] = <span class="literal">true</span>;</span><br><span class="line">cnt ++;</span><br><span class="line">dfs(cur + <span class="number">1</span>);</span><br><span class="line">booked[j] = <span class="literal">false</span>;</span><br><span class="line">cnt --;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这种情况是防范 没有在首置位 有满足符合条件的数据</span></span><br><span class="line">dfs(cur + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k) &#123;</span><br><span class="line">   <span class="keyword">if</span> (n ==  <span class="number">-1</span> &amp;&amp; k == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;  i ++)  &#123;</span><br><span class="line">   booked[i] = <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;  n; j ++) &#123;</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; board[i][j];</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   total = <span class="number">0</span>,cnt = <span class="number">0</span>;</span><br><span class="line">   dfs(<span class="number">0</span>);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/03/05/分享几道简单搜索题目/22.png" alt="22"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: DungeonMaster.cpp</span></span><br><span class="line"><span class="comment">&gt; Author: wangshuxiao</span></span><br><span class="line"><span class="comment">&gt; Mail: wsx1128@outlook.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: Sun  3 Mar 16:10:18 2019</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> L,C,R;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[maxn][maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn][maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">position</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line">position () = <span class="keyword">default</span>;</span><br><span class="line">position(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z,<span class="keyword">int</span> pos) :  <span class="keyword">this</span>.x(x),</span><br><span class="line"><span class="keyword">this</span>.y(y),<span class="keyword">this</span>.z(z),<span class="keyword">this</span>.pos(pos) &#123;&#125;;</span><br><span class="line"><span class="function">position <span class="title">move</span> <span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">position position::move(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    position tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">switch</span> (i)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        tmp.x = x + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        tmp.x = x - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        tmp.y = y + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        tmp.y = y - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        tmp.z = z + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        tmp.z = z - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span> <span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="function">position <span class="title">beg</span> <span class="params">(i,j,k,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;position&gt; q;</span><br><span class="line">q.push(beg);</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">position now = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">dis[now.x][now.y][now.z] = now.pos;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">position next = now.move(i);</span><br><span class="line"><span class="keyword">if</span> (next.x &gt;= <span class="number">0</span> &amp;&amp; next.x &lt; L &amp;&amp; next.y &gt;= <span class="number">0</span> &amp;&amp; next.y &lt; R</span><br><span class="line">            &amp;&amp; next.z &gt;= <span class="number">0</span> &amp;&amp; next.z &lt; C &amp;&amp; dis[next.x][next.y][next.z]</span><br><span class="line">== <span class="number">-1</span> &amp;&amp; <span class="built_in">map</span>[next.x][next.y][next.z] != <span class="string">'#'</span>) &#123;</span><br><span class="line"><span class="function">position <span class="title">empt</span> <span class="params">(next.x,next.y,next.z,now.pos + <span class="number">1</span>)</span></span>;</span><br><span class="line">q.push(empt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; L &gt;&gt; R &gt;&gt; C) &#123;</span><br><span class="line"><span class="keyword">if</span> (L == <span class="number">0</span> &amp;&amp; R == <span class="number">0</span> &amp;&amp; C == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">int</span> x1,y1,z1;</span><br><span class="line"><span class="keyword">int</span> x2,y2,z2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != L; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != R; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k != C; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cin</span> &gt;&gt; <span class="built_in">map</span>[i][j][k];</span><br><span class="line">                    dis[i][j][k] = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">map</span>[i][j][k] == <span class="string">'S'</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        x1 = i;</span><br><span class="line">                        y1 = j;</span><br><span class="line">                        z1 = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">map</span>[i][j][k] == <span class="string">'E'</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        x2 = i;</span><br><span class="line">                        y2 = j;</span><br><span class="line">                        z2 = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     bfs(x1, y1, z1);</span><br><span class="line"><span class="keyword">if</span> (dis[x2][y2][z2] == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Trapped!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Escaped in "</span> &lt;&lt; dis[x2][y2][z2] &lt;&lt; <span class="string">" minute(s)."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2019/03/05/分享几道简单搜索题目/33.png" alt="33"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span> [maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> &amp;&amp; i &gt;= m) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; <span class="number">0</span> &amp;&amp; j &gt;= n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == <span class="string">'@'</span>) &#123;</span><br><span class="line">        <span class="built_in">map</span>[i][j] = <span class="string">'.'</span>;</span><br><span class="line">        dfs(i<span class="number">-1</span>,j);</span><br><span class="line">        dfs(i+<span class="number">1</span>,j);</span><br><span class="line">        dfs(i,j<span class="number">-1</span>);</span><br><span class="line">        dfs(i,j+<span class="number">1</span>);</span><br><span class="line">        dfs(i<span class="number">-1</span>,j<span class="number">-1</span>);</span><br><span class="line">        dfs(i<span class="number">-1</span>,j+<span class="number">1</span>);</span><br><span class="line">        dfs(i+<span class="number">1</span>,j<span class="number">-1</span>);</span><br><span class="line">        dfs(i+<span class="number">1</span>,j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; m &amp;&amp; m != <span class="number">0</span> &amp;&amp; <span class="built_in">cin</span> &gt;&gt; n) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; <span class="built_in">map</span>[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == <span class="string">'@'</span>)&#123;</span><br><span class="line">                    dfs(i,j);</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/03/05/分享几道简单搜索题目/44.png" alt="44"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line"><span class="keyword">int</span> dis_Y[<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line"><span class="keyword">int</span> dis_M[<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, pos;</span><br><span class="line">    point()&#123;&#125;;</span><br><span class="line">    point(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) : x(a), y(b), pos(c) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _move[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="built_in">queue</span>&lt;point&gt; *q, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">bool</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">point <span class="title">beg</span><span class="params">(x, y, <span class="number">0</span>)</span></span>;</span><br><span class="line">    q-&gt;push(beg);</span><br><span class="line">    </span><br><span class="line">    point now, next;</span><br><span class="line">    <span class="keyword">while</span> (!q-&gt;empty())</span><br><span class="line">    &#123;</span><br><span class="line">        now = q-&gt;front();</span><br><span class="line">        q-&gt;pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            next.x = now.x + _move[i][<span class="number">0</span>];</span><br><span class="line">            next.y = now.y + _move[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> ( next.x &lt; n &amp;&amp; next.x &gt;= <span class="number">0</span> &amp;&amp; next.y &lt; m &amp;&amp; next.y &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">map</span>[next.x][next.y] != <span class="string">'#'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dis_Y[next.x][next.y] == <span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        next.pos = now.pos + <span class="number">1</span>;</span><br><span class="line">                        q -&gt; push(next);</span><br><span class="line">                        dis_Y[now.x][now.y] = now.pos + <span class="number">1</span>; </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dis_M[next.x][next.y] == <span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        next.pos = now.pos + <span class="number">1</span>;</span><br><span class="line">                        q -&gt; push(next);</span><br><span class="line">                        dis_M[now.x][now.y] = now.pos + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> yi_x, yi_y;</span><br><span class="line">    <span class="keyword">int</span> m_x, m_y;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p;</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;v;</span><br><span class="line">        <span class="built_in">queue</span>&lt;point&gt; qm;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">                dis_M[i][j] = <span class="number">-1</span>;</span><br><span class="line">                dis_Y[i][j] = <span class="number">-1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == <span class="string">'Y'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    yi_x = i;</span><br><span class="line">                    yi_y = j;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == <span class="string">'M'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    m_x = i;</span><br><span class="line">                    m_y = j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == <span class="string">'@'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    </span><br><span class="line">                    v.push_back(make_pair(i,j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        dis_Y[yi_x][yi_y] = <span class="number">0</span>;</span><br><span class="line">        dis_M[m_x][m_y] = <span class="number">0</span>;</span><br><span class="line">        bfs(&amp;qm, yi_x, yi_y, <span class="literal">true</span>);</span><br><span class="line">        bfs(&amp;qm, m_x, m_y, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> Min = <span class="number">9999999</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = v.begin(); it != v.end(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = dis_M[it-&gt;first][it-&gt;second] + dis_Y[it-&gt;first][it-&gt;second];</span><br><span class="line">            <span class="keyword">if</span> (Min &gt; tmp)</span><br><span class="line">                Min = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Min * <span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/03/05/分享几道简单搜索题目/55.png" alt="55"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span> [maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x , y , pos;</span><br><span class="line">    pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span> &gt; p;</span><br><span class="line">    point()&#123;&#125;;</span><br><span class="line">    point(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c) : x(a),y(b),pos(c) &#123;&#125;</span><br><span class="line">    <span class="function">point <span class="title">move</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        point tmp = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                tmp.x += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                tmp.x -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                tmp.y += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">                tmp.y -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    point m[maxn][maxn];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; <span class="built_in">map</span>[i][j];</span><br><span class="line">            m[i][j].x = i;</span><br><span class="line">            m[i][j].y = j;</span><br><span class="line">            m[i][j].pos = <span class="number">-1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;point&gt;q;</span><br><span class="line">    <span class="function">point <span class="title">beg</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    q.push(beg);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        point now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="comment">//m[now.x][now.y].pos = now.pos;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            point next = now.move(i);</span><br><span class="line">            <span class="keyword">if</span> (next.x &lt; <span class="number">5</span> &amp;&amp; next.x &gt;= <span class="number">0</span> &amp;&amp; next.y &lt; <span class="number">5</span> &amp;&amp; next.y &gt;= <span class="number">0</span> </span><br><span class="line">            &amp;&amp; <span class="built_in">map</span>[next.x][next.y] != <span class="number">1</span> &amp;&amp; m[next.x][next.y].pos == <span class="number">-1</span>) &#123;</span><br><span class="line">                m[next.x][next.y].pos = now.pos+<span class="number">1</span>;</span><br><span class="line">                m[next.x][next.y].p = make_pair(now.x,now.y);</span><br><span class="line">                q.push(m[next.x][next.y]);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt; &gt; s;</span><br><span class="line">    s.push(make_pair(<span class="number">4</span>,<span class="number">4</span>));</span><br><span class="line">    pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;x = m[<span class="number">4</span>][<span class="number">4</span>].p;</span><br><span class="line">    <span class="keyword">int</span> y = m[<span class="number">4</span>][<span class="number">4</span>].pos;</span><br><span class="line">    <span class="keyword">while</span> (y --) &#123;</span><br><span class="line">        </span><br><span class="line">        s.push(x);</span><br><span class="line">        x = m[x.first][x.second].p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">        x = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; x.first &lt;&lt; <span class="string">", "</span> &lt;&lt; x.second &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> bfs </tag>
            
            <tag> dfs </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>8_pazzle</title>
      <link href="/2019/02/26/8-pazzle/"/>
      <url>/2019/02/26/8-pazzle/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="此为第四周普林斯顿算法课大作业，基本思路是基于优先队列的A-算法。"><a href="#此为第四周普林斯顿算法课大作业，基本思路是基于优先队列的A-算法。" class="headerlink" title="此为第四周普林斯顿算法课大作业，基本思路是基于优先队列的A*算法。"></a>此为第四周普林斯顿算法课大作业，基本思路是基于优先队列的A*算法。</h2><p>所谓A*算法，就是启发式算法，人工智能基础，就是将每一步周围的一步之类的情况全部存储起来，然后放进优先队列里面进行比较，然后依次出队，算出最终的结果<br>相当于一个小博弈。</p><p>首先，先看题目。<br><img src="/2019/02/26/8-pazzle/11.png" alt="11"><br><img src="/2019/02/26/8-pazzle/22.png" alt="22"><br><img src="/2019/02/26/8-pazzle/33.png" alt="33"></p><p>直接贴出代码</p><p><strong>Board.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Programming_Assignment_4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdRandom;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Board</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][] blocks;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> dimension;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Board</span><span class="params">(<span class="keyword">int</span>[][] blocks)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (blocks == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Null blocks"</span>);</span><br><span class="line">        dimension = blocks.length;</span><br><span class="line">        <span class="keyword">this</span>.blocks = <span class="keyword">new</span> <span class="keyword">int</span>[dimension][dimension];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dimension; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.blocks[i] = blocks[i].clone();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dimension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dimension;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hamming</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dimension; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dimension; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (blocks[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (blocks[i][j] != i  * dimension + j + <span class="number">1</span>) cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">manhattan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dimension; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dimension; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (blocks[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (blocks[i][j] != i  * dimension + j + <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> val = blocks[i][j];</span><br><span class="line">                    <span class="keyword">int</span> row = (val - <span class="number">1</span>) / dimension;</span><br><span class="line">                    <span class="keyword">int</span> col = (val - <span class="number">1</span>) % dimension;</span><br><span class="line">                    <span class="keyword">int</span> dif = Math.abs(row - i)  + Math.abs(col - j);</span><br><span class="line">                    cnt += dif;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isGoal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hamming() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span> <span class="params">(<span class="keyword">int</span> i1,<span class="keyword">int</span> r1,<span class="keyword">int</span> i2,<span class="keyword">int</span> r2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = blocks[i1][r1];</span><br><span class="line">        blocks[i1][r1] = blocks[i2][r2];</span><br><span class="line">        blocks[i2][r2] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Board <span class="title">twin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Board twinBoard = <span class="keyword">new</span> Board(blocks);</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>,col = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (blocks[row][col] == <span class="number">0</span>) col++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dimension; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dimension; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (blocks[i][j] != <span class="number">0</span> &amp;&amp; blocks[i][j] != blocks[row][col]) &#123;</span><br><span class="line">                    twinBoard.swap(i,j,row,col);</span><br><span class="line">                    <span class="keyword">return</span> twinBoard;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> twinBoard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object y)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (y == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">if</span> (y.getClass().isInstance(<span class="keyword">this</span>)) &#123;</span><br><span class="line">             Board tmp = (Board) y;</span><br><span class="line">             <span class="keyword">if</span> (tmp.dimension != <span class="keyword">this</span>.dimension)</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dimension; i++) &#123;</span><br><span class="line">                 <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dimension; j++) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (tmp.blocks[i][j] != <span class="keyword">this</span>.blocks[i][j])</span><br><span class="line">                         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Board&gt; <span class="title">neighbors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Board&gt; neighbors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dimension; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dimension; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (blocks[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Board tmpUp = <span class="keyword">new</span> Board(blocks);</span><br><span class="line">                        tmpUp.swap(i,j,i - <span class="number">1</span>,j);</span><br><span class="line">                        neighbors.add(tmpUp);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (i &lt; dimension - <span class="number">1</span>) &#123;</span><br><span class="line">                        Board tmpDown = <span class="keyword">new</span> Board(blocks);</span><br><span class="line">                        tmpDown.swap(i,j,i + <span class="number">1</span>,j);</span><br><span class="line">                        neighbors.add(tmpDown);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Board tmpLeft = <span class="keyword">new</span> Board(blocks);</span><br><span class="line">                        tmpLeft.swap(i,j,i,j - <span class="number">1</span>);</span><br><span class="line">                        neighbors.add(tmpLeft);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (j &lt; dimension - <span class="number">1</span>) &#123;</span><br><span class="line">                        Board tmpRight = <span class="keyword">new</span> Board(blocks);</span><br><span class="line">                        tmpRight.swap(i,j,i,j + <span class="number">1</span>);</span><br><span class="line">                        neighbors.add(tmpRight);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> neighbors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(dimension + <span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; dimension; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; dimension; col++) &#123;</span><br><span class="line">                sb.append(String.format(<span class="string">"%2d "</span>, blocks[row][col]));</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> Programming_Assignment_4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.In;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.MinPQ;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.Stack;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdOut;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BoardNode current;</span><br><span class="line">    <span class="keyword">private</span> BoardNode twinCurrent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">BoardNode</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">BoardNode</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Board item;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> priority;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> move;</span><br><span class="line">        <span class="keyword">private</span> BoardNode preBoard;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BoardNode</span> <span class="params">(Board item,BoardNode preBoard)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.preBoard = preBoard;</span><br><span class="line">            <span class="keyword">if</span> (preBoard == <span class="keyword">null</span>) <span class="keyword">this</span>.move = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">this</span>.move = preBoard.move + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.priority = <span class="keyword">this</span>.move + item.manhattan();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(BoardNode b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.priority,b.priority);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putNeighbors</span> <span class="params">(BoardNode current,MinPQ&lt;BoardNode&gt;pq)</span> </span>&#123;</span><br><span class="line">        Iterable&lt;Board&gt; neighbors = current.item.neighbors();</span><br><span class="line">        <span class="keyword">for</span> (Board it : neighbors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.preBoard == <span class="keyword">null</span> || !it.equals(current.preBoard.item)) &#123;</span><br><span class="line">                pq.insert(<span class="keyword">new</span> BoardNode(it,current));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solver</span><span class="params">(Board initial)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initial == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Constructor argument Board is null!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        current = <span class="keyword">new</span> BoardNode(initial,<span class="keyword">null</span>);</span><br><span class="line">        twinCurrent = <span class="keyword">new</span> BoardNode(initial.twin(),<span class="keyword">null</span>);</span><br><span class="line">        MinPQ&lt;BoardNode&gt; pq = <span class="keyword">new</span> MinPQ&lt;BoardNode&gt;();</span><br><span class="line">        MinPQ&lt;BoardNode&gt; twinpq = <span class="keyword">new</span> MinPQ&lt;BoardNode&gt;();</span><br><span class="line">        pq.insert(current);</span><br><span class="line">        twinpq.insert(twinCurrent);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            current = pq.delMin();</span><br><span class="line">            <span class="keyword">if</span> (current.item.isGoal()) <span class="keyword">break</span>;</span><br><span class="line">            putNeighbors(current,pq);</span><br><span class="line"></span><br><span class="line">            twinCurrent = twinpq.delMin();</span><br><span class="line">            <span class="keyword">if</span> (twinCurrent.item.isGoal()) <span class="keyword">break</span>;</span><br><span class="line">            putNeighbors(twinCurrent,twinpq);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSolvable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> current.item.isGoal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">moves</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (current.item.isGoal())   <span class="keyword">return</span> current.move;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Board&gt; <span class="title">solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isSolvable()) &#123;</span><br><span class="line">            Stack&lt;Board&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            BoardNode node = current;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.item);</span><br><span class="line">                node = node.preBoard;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stack;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 普林斯顿算法课 </tag>
            
            <tag> A*算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于java的碰撞物理引擎</title>
      <link href="/2019/02/26/%E5%9F%BA%E4%BA%8Ejava%E7%9A%84%E7%A2%B0%E6%92%9E%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/"/>
      <url>/2019/02/26/%E5%9F%BA%E4%BA%8Ejava%E7%9A%84%E7%A2%B0%E6%92%9E%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="首先，贴出效果图，基于java的物理引擎。"><a href="#首先，贴出效果图，基于java的物理引擎。" class="headerlink" title="首先，贴出效果图，基于java的物理引擎。"></a>首先，贴出效果图，基于java的物理引擎。</h3><p><img src="/2019/02/26/基于java的碰撞物理引擎/11.png" alt="11"></p><p><strong>完成这个效果需要考虑几件事情。</strong></p><h3 id="第一步显示定义出每一个颗粒，具体的形状，颜色，位置，速度…"><a href="#第一步显示定义出每一个颗粒，具体的形状，颜色，位置，速度…" class="headerlink" title="第一步显示定义出每一个颗粒，具体的形状，颜色，位置，速度…"></a>第一步显示定义出每一个颗粒，具体的形状，颜色，位置，速度…</h3><p>具体API如下：<br><img src="/2019/02/26/基于java的碰撞物理引擎/22.png" alt="22"></p><p>其实这里最关键的是上面的预测碰撞时间的算法，应用了大学物理的相关知识。<br>将三种碰撞的预测时间算出来，另外并依次赋予三种碰撞的效果。<br>然后将其放入一个可比较的事件中，通过遍历每一个球与其他球预测碰撞情况，放入优先队列中再依次处理。</p><h4 id="第一种-两球相撞"><a href="#第一种-两球相撞" class="headerlink" title="第一种 两球相撞"></a>第一种 两球相撞</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//时间</span></span><br><span class="line"><span class="comment">//注意下面几个地方的剪枝</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">timeToHitBall</span> <span class="params">(Ball that)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == that) <span class="keyword">return</span> INFINITY;</span><br><span class="line">        <span class="keyword">double</span> dx = that.pos_x - <span class="keyword">this</span>.pos_x;</span><br><span class="line">        <span class="keyword">double</span> dy = that.pos_y - <span class="keyword">this</span>.pos_y;</span><br><span class="line">        <span class="keyword">double</span> dvx = that.vec_x - <span class="keyword">this</span>.vec_x;</span><br><span class="line">        <span class="keyword">double</span> dvy = that.vec_y - <span class="keyword">this</span>.vec_y;</span><br><span class="line">        <span class="keyword">double</span> dvdr = dx * dvx + dy * dvy;</span><br><span class="line">        <span class="keyword">if</span> (dvdr &gt; <span class="number">0</span>) <span class="keyword">return</span> INFINITY;</span><br><span class="line">        <span class="keyword">double</span> dvdv = dvx * dvx + dvy * dvy;</span><br><span class="line">        <span class="keyword">if</span> (dvdv == <span class="number">0</span>) <span class="keyword">return</span> INFINITY;</span><br><span class="line">        <span class="keyword">double</span> drdr = dx * dx + dy * dy;</span><br><span class="line">        <span class="keyword">double</span> sigma = <span class="keyword">this</span>.radius + that.radius;</span><br><span class="line">        <span class="keyword">double</span> d = (dvdr * dvdr) - dvdv * (drdr - sigma * sigma);</span><br><span class="line">        <span class="keyword">if</span> (d &lt; <span class="number">0</span>) <span class="keyword">return</span> INFINITY;</span><br><span class="line">        <span class="keyword">return</span> -(dvdr + Math.sqrt(d)) / dvdv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//碰撞后的效果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bounceOff</span> <span class="params">(Ball that)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> dx = that.pos_x - <span class="keyword">this</span>.pos_x;</span><br><span class="line">        <span class="keyword">double</span> dy = that.pos_y - <span class="keyword">this</span>.pos_y;</span><br><span class="line">        <span class="keyword">double</span> dvx = that.vec_x - <span class="keyword">this</span>.vec_x;</span><br><span class="line">        <span class="keyword">double</span> dvy = that.vec_y - <span class="keyword">this</span>.vec_y;</span><br><span class="line">        <span class="keyword">double</span> dvdr = dx * dvx + dy * dvy;</span><br><span class="line">        <span class="keyword">double</span> dist = <span class="keyword">this</span>.radius + that.radius;</span><br><span class="line">        <span class="keyword">double</span> J = <span class="number">2</span> * <span class="keyword">this</span>.mass * that.mass * dvdr / ((<span class="keyword">this</span>.mass + that.mass) * dist);</span><br><span class="line">        <span class="keyword">double</span> Jx = J * dx / dist;</span><br><span class="line">        <span class="keyword">double</span> Jy = J * dy / dist;</span><br><span class="line">        <span class="keyword">this</span>.vec_x += Jx / <span class="keyword">this</span>.mass;</span><br><span class="line">        <span class="keyword">this</span>.vec_y += Jy / <span class="keyword">this</span>.mass;</span><br><span class="line">        that.vec_x -= Jx / that.mass;</span><br><span class="line">        that.vec_y -= Jy / that.mass;</span><br><span class="line">        <span class="keyword">this</span>.cnt ++;</span><br><span class="line">        that.cnt ++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="第二种与墙体发生碰撞"><a href="#第二种与墙体发生碰撞" class="headerlink" title="第二种与墙体发生碰撞"></a>第二种与墙体发生碰撞</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//碰撞垂直墙的时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">timeToHitVerticalWall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vec_x &gt; <span class="number">0</span>)  <span class="keyword">return</span> (border - pos_x - radius) / vec_x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (vec_x &lt; <span class="number">0</span>) <span class="keyword">return</span> (radius - pos_x) / vec_x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> INFINITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//碰撞水平墙的时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">timeToHitHorizontalWall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vec_y &gt; <span class="number">0</span>)  <span class="keyword">return</span> (border - pos_y - radius) / vec_y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (vec_y &lt; <span class="number">0</span>) <span class="keyword">return</span> (radius - pos_y) / vec_y;</span><br><span class="line">    <span class="keyword">return</span>  INFINITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//碰撞效果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bounceOffVerticalWall</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.cnt ++;</span><br><span class="line">   <span class="keyword">this</span>.vec_x = - <span class="keyword">this</span>.vec_x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bounceoffHorizontalWall</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cnt ++;</span><br><span class="line">    <span class="keyword">this</span>.vec_y = - <span class="keyword">this</span>.vec_y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="以下便是第一个球体类型的完整代码"><a href="#以下便是第一个球体类型的完整代码" class="headerlink" title="以下便是第一个球体类型的完整代码"></a>以下便是第一个球体类型的完整代码</h3><p><strong>Ball.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdDraw;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdRandom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ball</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//球的横纵坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> pos_x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> pos_y;</span><br><span class="line">    <span class="comment">//球的横纵方向上面的速度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> vec_x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> vec_y;</span><br><span class="line">    <span class="comment">//球的半径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="comment">//球的质量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> mass;</span><br><span class="line">    <span class="comment">//边界长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> border;</span><br><span class="line">    <span class="comment">//球的颜色</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Color color;</span><br><span class="line">    <span class="comment">//碰撞次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//限定一个最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> INFINITY = Double.POSITIVE_INFINITY;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Ball</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        pos_x     = StdRandom.uniform(<span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        pos_y     = StdRandom.uniform(<span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        vec_x     = StdRandom.uniform(-<span class="number">0.005</span>, <span class="number">0.005</span>);</span><br><span class="line">        vec_y     = StdRandom.uniform(-<span class="number">0.005</span>, <span class="number">0.005</span>);</span><br><span class="line">        radius    = <span class="number">0.01</span>;</span><br><span class="line">        mass      = <span class="number">0.5</span>;</span><br><span class="line">        border    = <span class="number">1</span>;</span><br><span class="line">        color     = Color.BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Ball</span> <span class="params">(<span class="keyword">double</span> px,<span class="keyword">double</span> py,<span class="keyword">double</span> vx,<span class="keyword">double</span> vy,<span class="keyword">double</span> radius,<span class="keyword">double</span> mass,<span class="keyword">double</span> border,Color color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pos_x = px;</span><br><span class="line">        <span class="keyword">this</span>.pos_y = py;</span><br><span class="line">        <span class="keyword">this</span>.vec_x = vx;</span><br><span class="line">        <span class="keyword">this</span>.vec_y = vy;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">        <span class="keyword">this</span>.mass = mass;</span><br><span class="line">        <span class="keyword">this</span>.border = border;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StdDraw.filledCircle(pos_x,pos_y,radius);</span><br><span class="line">        StdDraw.setPenColor(color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span> <span class="params">(<span class="keyword">double</span> dt)</span> </span>&#123;</span><br><span class="line">        pos_x = pos_x + vec_x * dt;</span><br><span class="line">        pos_y = pos_y + vec_y * dt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">timeToHitBall</span> <span class="params">(Ball that)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == that) <span class="keyword">return</span> INFINITY;</span><br><span class="line">        <span class="keyword">double</span> dx = that.pos_x - <span class="keyword">this</span>.pos_x;</span><br><span class="line">        <span class="keyword">double</span> dy = that.pos_y - <span class="keyword">this</span>.pos_y;</span><br><span class="line">        <span class="keyword">double</span> dvx = that.vec_x - <span class="keyword">this</span>.vec_x;</span><br><span class="line">        <span class="keyword">double</span> dvy = that.vec_y - <span class="keyword">this</span>.vec_y;</span><br><span class="line">        <span class="keyword">double</span> dvdr = dx * dvx + dy * dvy;</span><br><span class="line">        <span class="keyword">if</span> (dvdr &gt; <span class="number">0</span>) <span class="keyword">return</span> INFINITY;</span><br><span class="line">        <span class="keyword">double</span> dvdv = dvx * dvx + dvy * dvy;</span><br><span class="line">        <span class="keyword">if</span> (dvdv == <span class="number">0</span>) <span class="keyword">return</span> INFINITY;</span><br><span class="line">        <span class="keyword">double</span> drdr = dx * dx + dy * dy;</span><br><span class="line">        <span class="keyword">double</span> sigma = <span class="keyword">this</span>.radius + that.radius;</span><br><span class="line">        <span class="keyword">double</span> d = (dvdr * dvdr) - dvdv * (drdr - sigma * sigma);</span><br><span class="line">        <span class="keyword">if</span> (d &lt; <span class="number">0</span>) <span class="keyword">return</span> INFINITY;</span><br><span class="line">        <span class="keyword">return</span> -(dvdr + Math.sqrt(d)) / dvdv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">timeToHitVerticalWall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (vec_x &gt; <span class="number">0</span>)  <span class="keyword">return</span> (border - pos_x - radius) / vec_x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vec_x &lt; <span class="number">0</span>) <span class="keyword">return</span> (radius - pos_x) / vec_x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> INFINITY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">timeToHitHorizontalWall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (vec_y &gt; <span class="number">0</span>)  <span class="keyword">return</span> (border - pos_y - radius) / vec_y;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vec_y &lt; <span class="number">0</span>) <span class="keyword">return</span> (radius - pos_y) / vec_y;</span><br><span class="line">        <span class="keyword">return</span>  INFINITY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bounceOff</span> <span class="params">(Ball that)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> dx = that.pos_x - <span class="keyword">this</span>.pos_x;</span><br><span class="line">        <span class="keyword">double</span> dy = that.pos_y - <span class="keyword">this</span>.pos_y;</span><br><span class="line">        <span class="keyword">double</span> dvx = that.vec_x - <span class="keyword">this</span>.vec_x;</span><br><span class="line">        <span class="keyword">double</span> dvy = that.vec_y - <span class="keyword">this</span>.vec_y;</span><br><span class="line">        <span class="keyword">double</span> dvdr = dx * dvx + dy * dvy;</span><br><span class="line">        <span class="keyword">double</span> dist = <span class="keyword">this</span>.radius + that.radius;</span><br><span class="line">        <span class="keyword">double</span> J = <span class="number">2</span> * <span class="keyword">this</span>.mass * that.mass * dvdr / ((<span class="keyword">this</span>.mass + that.mass) * dist);</span><br><span class="line">        <span class="keyword">double</span> Jx = J * dx / dist;</span><br><span class="line">        <span class="keyword">double</span> Jy = J * dy / dist;</span><br><span class="line">        <span class="keyword">this</span>.vec_x += Jx / <span class="keyword">this</span>.mass;</span><br><span class="line">        <span class="keyword">this</span>.vec_y += Jy / <span class="keyword">this</span>.mass;</span><br><span class="line">        that.vec_x -= Jx / that.mass;</span><br><span class="line">        that.vec_y -= Jy / that.mass;</span><br><span class="line">        <span class="keyword">this</span>.cnt ++;</span><br><span class="line">        that.cnt ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bounceOffVerticalWall</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cnt ++;</span><br><span class="line">        <span class="keyword">this</span>.vec_x = - <span class="keyword">this</span>.vec_x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bounceoffHorizontalWall</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cnt ++;</span><br><span class="line">        <span class="keyword">this</span>.vec_y = - <span class="keyword">this</span>.vec_y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="其次，我们需要对以上球体类进行一个包装，将其赋予可比较的特性。"><a href="#其次，我们需要对以上球体类进行一个包装，将其赋予可比较的特性。" class="headerlink" title="其次，我们需要对以上球体类进行一个包装，将其赋予可比较的特性。"></a>其次，我们需要对以上球体类进行一个包装，将其赋予可比较的特性。</h3><p>因为从宏观上来看，我们需要比较的是每一个球体的碰撞情况，所以，用一个事件包含其诸多特性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Collison_Event</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Collison_Event</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Ball a,b;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> time;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> countA,countB;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Collison_Event</span> <span class="params">(Ball a,Ball b,<span class="keyword">double</span> time)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.time = time;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">            <span class="keyword">this</span>.b = b;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="keyword">null</span>) countA = a.count();</span><br><span class="line">            <span class="keyword">else</span>           countA = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) countB = b.count();</span><br><span class="line">            <span class="keyword">else</span>           countB = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Collison_Event that)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Double.compare(<span class="keyword">this</span>.time,that.time);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.time == Double.POSITIVE_INFINITY) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a != <span class="keyword">null</span> &amp;&amp; a.count() != countA) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (b != <span class="keyword">null</span> &amp;&amp; b.count() != countB) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="最后就是整个包含类，就称为一个系统"><a href="#最后就是整个包含类，就称为一个系统" class="headerlink" title="最后就是整个包含类，就称为一个系统"></a>最后就是整个包含类，就称为一个系统</h3><p>思路就是预测碰撞的时间，放入优先队列中，另外，需要注意的核心的一点就是，其采用了时间限制，大于某个时间的球体碰撞即不放进队列中，避免开销。<br>还有，不要忘记重绘的条件，在这里加入一个HZ变量控制帧数。</p><h4 id="以下是第二个类的全部代码"><a href="#以下是第二个类的全部代码" class="headerlink" title="以下是第二个类的全部代码"></a>以下是第二个类的全部代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.MinPQ;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdDraw;</span><br><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollisionSystem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> MinPQ&lt;Collison_Event&gt; pq;</span><br><span class="line">    <span class="comment">//相当于一个总控时间的一个参数，后面所有关于时间的参数都需要加上一个这个</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> t = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">protected</span> Ball[] balls;</span><br><span class="line">    <span class="comment">//这里就相当于一个控制每一帧数的频率控制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> HZ = <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CollisionSystem</span><span class="params">(Ball[] balls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balls = balls.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里新加上的一个参数 limit 是控制一些完全没必要的事件</span></span><br><span class="line">    <span class="comment">//意思就是剔除那些需要太长时间才会相撞的球体</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pridict</span> <span class="params">(Ball b,<span class="keyword">double</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; balls.length;i++)&#123;</span><br><span class="line">            <span class="keyword">double</span> dt = b.timeToHitBall(balls[i]);</span><br><span class="line">            <span class="keyword">if</span> (t + dt &lt;= limit)</span><br><span class="line">                pq.insert(<span class="keyword">new</span> Collison_Event(b,balls[i],dt + t));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> dxt = b.timeToHitHorizontalWall() + t;</span><br><span class="line">        <span class="keyword">double</span> dyt = b.timeToHitVerticalWall() + t;</span><br><span class="line">        <span class="keyword">if</span> (dxt &lt;= limit)</span><br><span class="line">            pq.insert(<span class="keyword">new</span> Collison_Event(b,<span class="keyword">null</span>,dxt));</span><br><span class="line">        <span class="keyword">if</span> (dyt &lt;= limit)</span><br><span class="line">            pq.insert(<span class="keyword">new</span> Collison_Event(<span class="keyword">null</span>,b,dyt));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">redrew</span><span class="params">(<span class="keyword">double</span> limit)</span> </span>&#123;</span><br><span class="line">        StdDraw.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; balls.length;i++) &#123;</span><br><span class="line">            balls[i].draw();</span><br><span class="line">        &#125;</span><br><span class="line">        StdDraw.show();</span><br><span class="line">        StdDraw.pause(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; limit) &#123;</span><br><span class="line">            pq.insert(<span class="keyword">new</span> Collison_Event(<span class="keyword">null</span>,<span class="keyword">null</span>,t + <span class="number">1.0</span> / HZ));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">simulate</span> <span class="params">(<span class="keyword">double</span> limit)</span> </span>&#123;</span><br><span class="line">        pq = <span class="keyword">new</span> MinPQ&lt;Collison_Event&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; balls.length; i++) &#123;</span><br><span class="line">            pridict(balls[i],limit);</span><br><span class="line">        &#125;</span><br><span class="line">        pq.insert(<span class="keyword">new</span> Collison_Event(<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            Collison_Event event = pq.delMin();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!event.isValid()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将其他的点全部移动</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; balls.length; i++) &#123;</span><br><span class="line">                balls[i].move(event.time - t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            t = event.time;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (event.a != <span class="keyword">null</span> &amp;&amp; event.b != <span class="keyword">null</span>) event.a.bounceOff(event.b);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (event.a == <span class="keyword">null</span> &amp;&amp; event.b != <span class="keyword">null</span>) event.b.bounceOffVerticalWall();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (event.a != <span class="keyword">null</span> &amp;&amp; event.b == <span class="keyword">null</span>) event.a.bounceoffHorizontalWall();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (event.a == <span class="keyword">null</span> &amp;&amp; event.b == <span class="keyword">null</span>) redrew(limit);</span><br><span class="line"></span><br><span class="line">            pridict(event.a,limit);</span><br><span class="line">            pridict(event.b,limit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Collison_Event</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Collison_Event</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Ball a,b;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> time;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> countA,countB;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Collison_Event</span> <span class="params">(Ball a,Ball b,<span class="keyword">double</span> time)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.time = time;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">            <span class="keyword">this</span>.b = b;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="keyword">null</span>) countA = a.count();</span><br><span class="line">            <span class="keyword">else</span>           countA = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) countB = b.count();</span><br><span class="line">            <span class="keyword">else</span>           countB = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Collison_Event that)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Double.compare(<span class="keyword">this</span>.time,that.time);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.time == Double.POSITIVE_INFINITY) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a != <span class="keyword">null</span> &amp;&amp; a.count() != countA) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (b != <span class="keyword">null</span> &amp;&amp; b.count() != countB) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        StdDraw.setCanvasSize(<span class="number">600</span>,<span class="number">600</span>);</span><br><span class="line">        <span class="comment">//这个是清楚缓冲 帮助改善运动的</span></span><br><span class="line">        StdDraw.enableDoubleBuffering();</span><br><span class="line">        Ball[] balls = <span class="keyword">new</span> Ball[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            balls[i] = <span class="keyword">new</span> Ball();</span><br><span class="line">        &#125;</span><br><span class="line">        CollisionSystem system = <span class="keyword">new</span> CollisionSystem(balls);</span><br><span class="line">        system.simulate(<span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 物理引擎 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>普林斯顿算法课第四周小作业</title>
      <link href="/2019/02/24/%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%B0%8F%E4%BD%9C%E4%B8%9A/"/>
      <url>/2019/02/24/%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%B0%8F%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第四周的小作业主要围绕优先队列以及基于优先队列的Taxicabnumber。"><a href="#第四周的小作业主要围绕优先队列以及基于优先队列的Taxicabnumber。" class="headerlink" title="第四周的小作业主要围绕优先队列以及基于优先队列的Taxicabnumber。"></a>第四周的小作业主要围绕优先队列以及基于优先队列的<code>Taxicabnumber</code>。</h2><p>先贴出关于优先队列的代码<br><strong>MaxPQ.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Interview_Question_Week4.PQ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdIn;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdOut;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxPQ</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Key</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Key[] key;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">private</span> Comparator&lt;Key&gt; comparator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxPQ</span><span class="params">(<span class="keyword">int</span> init)</span></span>&#123;</span><br><span class="line">        key = (Key[]) <span class="keyword">new</span> Object[<span class="number">1</span> + init];</span><br><span class="line">        len = <span class="number">0</span> + init;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxPQ</span> <span class="params">(<span class="keyword">int</span> init , Comparator&lt;Key&gt; rule)</span></span>&#123;</span><br><span class="line">        comparator = rule;</span><br><span class="line">        key = (Key[]) <span class="keyword">new</span> Object[<span class="number">1</span> + init];</span><br><span class="line">        len = <span class="number">0</span> + init;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> key[i].compareTo(key[j]) &lt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> comparator.compare(key[i],key[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Key temp = key[i];</span><br><span class="line">        key[i] = key[j];</span><br><span class="line">        key[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k * <span class="number">2</span> &lt;= len) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = k * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; len &amp;&amp; less(j,j+<span class="number">1</span>)) j++;</span><br><span class="line">            <span class="keyword">if</span> (!less(k,j)) <span class="keyword">break</span>;</span><br><span class="line">            change(k,j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k / <span class="number">2</span>,k)) &#123;</span><br><span class="line">            change(k, k / <span class="number">2</span>);</span><br><span class="line">            k = k / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Key[] temp = (Key[]) <span class="keyword">new</span> Object[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len;i++) &#123;</span><br><span class="line">            temp[i] = key[i];</span><br><span class="line">        &#125;</span><br><span class="line">        key = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> len == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"wrong"</span>);</span><br><span class="line">        <span class="keyword">if</span> (len + <span class="number">1</span> == key.length)  resize(<span class="number">2</span> * key.length);</span><br><span class="line">        key[++len] = item;</span><br><span class="line">        up(len);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isMaxHeap</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是帮助后面完成一个assert判断而存在的</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMaxHeap</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; len) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span>*k;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span>*k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (left  &lt;= len &amp;&amp; less(k, left))  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= len &amp;&amp; less(k, right)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isMaxHeap(left) &amp;&amp; isMaxHeap(right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">delMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())  <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        Key item = key[<span class="number">1</span>];</span><br><span class="line">        key[<span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">        change(<span class="number">1</span>,len--);</span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (len + <span class="number">1</span> &lt;= key.length / <span class="number">4</span> &amp;&amp; len &gt; <span class="number">0</span> ) resize(key.length / <span class="number">2</span>);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isMaxHeap</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Key&gt; <span class="title">iterator</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> heapIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">heapIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Key</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> MaxPQ&lt;Key&gt; copy;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">heapIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (comparator == <span class="keyword">null</span>) &#123;</span><br><span class="line">                copy = <span class="keyword">new</span> MaxPQ&lt;Key&gt;(len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> copy = <span class="keyword">new</span> MaxPQ&lt;Key&gt;(len,comparator);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">                copy.insert(key[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isEmpty()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Key <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasNext()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            <span class="keyword">return</span> copy.delMax();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        edu.princeton.cs.algs4.MaxPQ&lt;String&gt; pq = <span class="keyword">new</span> edu.princeton.cs.algs4.MaxPQ&lt;String&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!StdIn.isEmpty()) &#123;</span><br><span class="line">            String item = StdIn.readString();</span><br><span class="line">            <span class="keyword">if</span> (!item.equals(<span class="string">"-"</span>)) pq.insert(item);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!pq.isEmpty()) StdOut.print(pq.delMax() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        StdOut.println(<span class="string">"("</span> + pq.size() + <span class="string">" left on pq)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随机优先队列</p><p><strong>RandomPQ.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Interview_Question_Week4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Interview_Question_Week4.PQ.MaxPQ;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdRandom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomPQ</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">MaxPQ</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomPQ</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(n);</span><br><span class="line">        <span class="keyword">this</span>.len = <span class="keyword">super</span>.len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Comparable&lt;Key&gt; <span class="title">sample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = StdRandom.uniform(len + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.get(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Comparable&lt;Key&gt; <span class="title">randomRemove</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = StdRandom.uniform(len + <span class="number">1</span>);</span><br><span class="line">        Comparable&lt;Key&gt; item = key[n];</span><br><span class="line">        change(n,len--);</span><br><span class="line">        key[len + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">        sink(n);</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优先队列的一些应用<br><strong>PriorityQueue.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MaxPQ&lt;Integer&gt; left;</span><br><span class="line">    <span class="keyword">private</span> MinPQ&lt;Integer&gt; right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        left = <span class="keyword">new</span> MaxPQ&lt;Integer&gt;();</span><br><span class="line">        right = <span class="keyword">new</span> MinPQ&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = left.size();</span><br><span class="line">        <span class="keyword">int</span> R = right.size();</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> (left.max() + right.min()) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> left.max();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> right.min();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> median = findMedian();</span><br><span class="line">        <span class="keyword">int</span> L = left.size();</span><br><span class="line">        <span class="keyword">int</span> R = right.size();</span><br><span class="line">        <span class="keyword">if</span> (key &lt;= median) &#123;</span><br><span class="line">            left.insert(key);</span><br><span class="line">            <span class="keyword">if</span> (L - R &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                right.insert(left.delMax());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            right.insert(key);</span><br><span class="line">            <span class="keyword">if</span> (R - L &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                left.insert(right.delMin());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = left.size();</span><br><span class="line">        <span class="keyword">int</span> R = right.size();</span><br><span class="line">        <span class="keyword">if</span> (L &gt; R) &#123;</span><br><span class="line">            left.delMax();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            right.delMin();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>有四个数 a,b,c,d 满足 a^3 + b^3 = c^3 +d^3，然后再给一个数 n，求出 n之内所有满足上述等式的四个数</p></blockquote><p><strong>思路</strong><br>此处就是运用优先队列，将没两个数的立方和加起来，然后再以立方和的大小来进行排序，作为最后排序的标准，最后进行比较，可做优化。</p><p>代码如下：</p><p><strong>Taxicab</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Interview_Question_Week4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.MinPQ;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdOut;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Taxicab</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Taxicab</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> cube;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Taxicab</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = x;</span><br><span class="line">        <span class="keyword">this</span>.b = y;</span><br><span class="line">        <span class="keyword">this</span>.cube = x * x * x + y * y * y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Taxicab a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.cube &lt; a.cube) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.cube &gt; a.cube) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.a &lt; a.a) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.a &gt; a.a) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"number: "</span> + cube + <span class="string">" ("</span> + a + <span class="string">", "</span> + b + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findTaxicabNumber</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        MinPQ&lt;Taxicab&gt; candidate = <span class="keyword">new</span> MinPQ&lt;Taxicab&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= N;i++) &#123;</span><br><span class="line">            candidate.insert(<span class="keyword">new</span> Taxicab(i,i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        Taxicab pre = <span class="keyword">new</span> Taxicab(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!candidate.isEmpty()) &#123;</span><br><span class="line">            Taxicab curr = candidate.delMin();</span><br><span class="line">            <span class="keyword">if</span> (curr == pre) &#123;</span><br><span class="line">                cnt ++;</span><br><span class="line">                <span class="keyword">if</span> (cnt == <span class="number">2</span>) &#123;</span><br><span class="line">                    StdOut.print(pre.cube + <span class="string">"="</span> + pre);</span><br><span class="line">                &#125;</span><br><span class="line">                StdOut.print(<span class="string">" = "</span> + curr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt; <span class="number">1</span>) StdOut.println();</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = curr;</span><br><span class="line">            <span class="keyword">if</span> (curr.a &lt; N) candidate.insert(<span class="keyword">new</span> Taxicab(curr.a,curr.b + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 普林斯顿算法课 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CollinearPoint</title>
      <link href="/2019/02/24/CollinearPoint/"/>
      <url>/2019/02/24/CollinearPoint/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="CollinearPoint—–普林斯顿第三周大作业"><a href="#CollinearPoint—–普林斯顿第三周大作业" class="headerlink" title="CollinearPoint—–普林斯顿第三周大作业"></a>CollinearPoint—–普林斯顿第三周大作业</h2><p>第三周的大作业 有点意思，基于排序的一次简单优化，先看题目。</p><p><img src="/2019/02/24/CollinearPoint/11.png" alt="11"><br><img src="/2019/02/24/CollinearPoint/22.png" alt="22"><br><img src="/2019/02/24/CollinearPoint/33.png" alt="33"><br><img src="/2019/02/24/CollinearPoint/44.png" alt="44"></p><p>一步一步来，根据题目首先写出一个点的类，这个类要包含比较，并且，要包含求出两个类之间斜率的方法。<br><strong>Point.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Programming_Assignment_3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdDraw;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdRandom;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Point</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StdDraw.point(x,y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>   <span class="keyword">void</span> <span class="title">drawTo</span><span class="params">(Point that)</span> </span>&#123;</span><br><span class="line">        StdDraw.line(x,y,that.x,that.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span> + x + <span class="string">", "</span> + y + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Point that)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (y &gt; that.y)         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y &lt; that.y)    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; that.x)    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; that.x)    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">slopeTo</span><span class="params">(Point that)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == that.x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (y == that.y) <span class="keyword">return</span> Double.NEGATIVE_INFINITY;</span><br><span class="line">            <span class="keyword">else</span>             <span class="keyword">return</span> Double.POSITIVE_INFINITY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y == that.y) <span class="keyword">return</span> <span class="number">0</span> / <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">return</span> (y - that.y) * <span class="number">1.0</span> / (x - that.x);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SlopeOrder</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Point</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Point p, Point q)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (slopeTo(p) &lt; slopeTo(q)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (slopeTo(p) &gt; slopeTo(q)) <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Comparator&lt;Point&gt; <span class="title">slopeOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span>  SlopeOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x0 = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> y0 = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(args[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        StdDraw.setCanvasSize(<span class="number">800</span>, <span class="number">800</span>);</span><br><span class="line">        StdDraw.setXscale(<span class="number">0</span>, <span class="number">50</span>);</span><br><span class="line">        StdDraw.setYscale(<span class="number">0</span>, <span class="number">50</span>);</span><br><span class="line">        StdDraw.setPenRadius(<span class="number">0.005</span>);</span><br><span class="line">        StdDraw.enableDoubleBuffering();</span><br><span class="line"></span><br><span class="line">        Point[] points = <span class="keyword">new</span> Point[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = StdRandom.uniform(<span class="number">50</span>);</span><br><span class="line">            <span class="keyword">int</span> y = StdRandom.uniform(<span class="number">50</span>);</span><br><span class="line">            points[i] = <span class="keyword">new</span> Point(x, y);</span><br><span class="line">            points[i].draw();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// draw p = (x0, x1) in red</span></span><br><span class="line">        Point p = <span class="keyword">new</span> Point(x0, y0);</span><br><span class="line"></span><br><span class="line">        StdDraw.setPenColor(StdDraw.RED);</span><br><span class="line">        StdDraw.setPenRadius(<span class="number">0.02</span>);</span><br><span class="line">        p.draw();</span><br><span class="line">        <span class="comment">// draw line segments from p to each point, one at a time, in polar order</span></span><br><span class="line">        StdDraw.setPenRadius();</span><br><span class="line">        StdDraw.setPenColor(StdDraw.BLUE);</span><br><span class="line">        Arrays.sort(points, p.slopeOrder());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p.drawTo(points[i]);</span><br><span class="line">            StdDraw.show();</span><br><span class="line">            StdDraw.pause(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来就是直线的类，这两个类都比较简单，这里就直接贴出代码<br><strong>LineSegment.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Programming_Assignment_3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LineSegment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Point a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Point b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LineSegment</span><span class="params">(Point p, Point q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.IllegalArgumentException();</span><br><span class="line">        a = p;</span><br><span class="line">        b = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a.drawTo(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + <span class="string">" -&gt; "</span> + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hasCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后就是问题的求解方法。<br>问题 需要知道平面上的点，有哪些点是在一条直线上的，第一种方法，暴力法，直接用四种循环写出答案。</p><p><strong>BruteCollinearPoints.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Programming_Assignment_3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BruteCollinearPoints</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Point[] copies;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;LineSegment&gt; lineSegments = <span class="keyword">new</span> ArrayList&lt;LineSegment&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// finds all line segments containing 4 points</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BruteCollinearPoints</span><span class="params">(<span class="keyword">final</span> Point[] points)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (points == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">        copies = <span class="keyword">new</span> Point[points.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">            copies[i] = points[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sort by y-coordinate</span></span><br><span class="line">        <span class="comment">// the endpoints are the first and last points</span></span><br><span class="line">        Arrays.sort(copies);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// after sort then can check if duplicate</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; copies.length - <span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (copies[i].compareTo(copies[i+<span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ip = <span class="number">0</span>; ip &lt; copies.length-<span class="number">3</span>; ip++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> iq = ip + <span class="number">1</span>; iq &lt; copies.length-<span class="number">2</span>; iq++) &#123;</span><br><span class="line">                <span class="keyword">double</span> slopeP2Q = copies[ip].slopeTo(copies[iq]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> ir = iq + <span class="number">1</span>; ir &lt; copies.length-<span class="number">1</span>; ir++) &#123;</span><br><span class="line">                    <span class="keyword">double</span> slopeQ2R = copies[iq].slopeTo(copies[ir]);</span><br><span class="line">                    <span class="keyword">if</span> (slopeP2Q != slopeQ2R) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> is = ir + <span class="number">1</span>; is &lt; copies.length; is++) &#123;</span><br><span class="line">                        <span class="keyword">double</span> slopeR2S = copies[ir].slopeTo(copies[is]);</span><br><span class="line">                        <span class="comment">// if 3 of 4's slopes are equal then 4 points are colllinear</span></span><br><span class="line">                        <span class="keyword">if</span> (slopeP2Q == slopeR2S)</span><br><span class="line">                            lineSegments.add(<span class="keyword">new</span> LineSegment(copies[ip], copies[is]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the number of line segments</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfSegments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lineSegments.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the line segments</span></span><br><span class="line">    <span class="keyword">public</span> LineSegment[] segments() &#123;</span><br><span class="line">        LineSegment[] result = <span class="keyword">new</span> LineSegment[lineSegments.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lineSegments.size(); i++) &#123;</span><br><span class="line">            result[i] = lineSegments.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>优化的方法就是基于排序，将每一个点都与已经排好序的点集进行比较，按照一定的顺序进行比较可以省略很多。<br><strong>FastCollinearPoints.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> Programming_Assignment_3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastCollinearPoints</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Point[] copies;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;LineSegment&gt; lineSegments = <span class="keyword">new</span> ArrayList&lt;LineSegment&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// finds all line segments containing 4 or more points</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastCollinearPoints</span><span class="params">(Point[] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (points == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">        copies = <span class="keyword">new</span> Point[points.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">            copies[i] = points[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sort by y-coordinate</span></span><br><span class="line">        <span class="comment">// the endpoints are the first and last points</span></span><br><span class="line">        Arrays.sort(copies);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// after sort then can check if duplicate</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; copies.length - <span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (copies[i].compareTo(copies[i+<span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; copies.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            Point origin = copies[i];             <span class="comment">// Think of p as the origin.</span></span><br><span class="line">            <span class="keyword">double</span>[] slopes = <span class="keyword">new</span> <span class="keyword">double</span>[copies.length - <span class="number">1</span> - i];</span><br><span class="line">            Point[] others = <span class="keyword">new</span> Point[copies.length - <span class="number">1</span> - i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; copies.length - <span class="number">1</span> - i; j++)</span><br><span class="line">                others[j] = copies[j + <span class="number">1</span> + i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// For each other point q, determine the slope it makes with p</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; others.length; j++)</span><br><span class="line">                slopes[j] = origin.slopeTo(others[j]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Sort the points according to the slopes they makes with p</span></span><br><span class="line">            Arrays.sort(others, origin.slopeOrder());</span><br><span class="line"></span><br><span class="line">            Arrays.sort(slopes);</span><br><span class="line">            <span class="comment">// Check if any 3 (or more) adjacent points in the</span></span><br><span class="line">            <span class="comment">// sorted order have equal slopes with respect to p</span></span><br><span class="line">            <span class="comment">// If so, these points, together with p, are collinear</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> cnt_same = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; slopes.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (slopes[j] == slopes[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                    cnt_same++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cnt_same &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    lineSegments.add(<span class="keyword">new</span> LineSegment(origin, others[j + <span class="number">1</span>]));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the number of line segments</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfSegments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lineSegments.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the line segments</span></span><br><span class="line">    <span class="keyword">public</span> LineSegment[] segments() &#123;</span><br><span class="line">        LineSegment[] result = <span class="keyword">new</span> LineSegment[lineSegments.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lineSegments.size(); i++) &#123;</span><br><span class="line">            result[i] = lineSegments.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于暴力做法运算了很多原本不需要的循环，相当于是做了很多重复功，所以不招收待见，而基于优化的版本进行了优化，所以在实际应用中是可取的。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 普林斯顿算法课 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>普林斯顿算法课第三周小作业</title>
      <link href="/2019/02/24/%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E4%B8%89%E5%91%A8%E5%B0%8F%E4%BD%9C%E4%B8%9A/"/>
      <url>/2019/02/24/%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E4%B8%89%E5%91%A8%E5%B0%8F%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第三周主要讲的是归并排序和快速排序，这里在C-里面已经总结过，直接贴出代码。"><a href="#第三周主要讲的是归并排序和快速排序，这里在C-里面已经总结过，直接贴出代码。" class="headerlink" title="第三周主要讲的是归并排序和快速排序，这里在C++里面已经总结过，直接贴出代码。"></a>第三周主要讲的是归并排序和快速排序，这里在C++里面已经总结过，直接贴出代码。</h2><p><strong>CountInversions</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Interview_Question_Week3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountInversions</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Comparable[] aux;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> inversion = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span> <span class="params">(Comparable a,Comparable b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.compareTo(b) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">get_num</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">        sort(a,<span class="number">0</span>,a.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> inversion;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt;= high) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + high) / <span class="number">2</span>;</span><br><span class="line">        sort(a,lo,mid);</span><br><span class="line">        sort(a,mid+<span class="number">1</span>,high);</span><br><span class="line">        merge(a,lo,mid,high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = lo;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= high;k++)&#123;</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = lo;k &lt;= high;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; mid) a[k] = aux[j++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; high) a[k] = aux[i++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (less (aux[i],aux[j]))&#123;</span><br><span class="line">                <span class="comment">// 这一步的目的就在于逆序对的个数，前面有多少个大于自己个数，就有多少个逆序对</span></span><br><span class="line">                inversion += mid + <span class="number">1</span> - i;</span><br><span class="line">                a[k] = aux[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> a[k] = aux[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        Integer []a = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="keyword">new</span> CountInversions().get_num(a));</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LinkedMergedArrays</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Interview_Question_Week3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedMergedArrays</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Node last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Node next;</span><br><span class="line">        T item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span> <span class="params">(Comparable a,Comparable b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.compareTo(b) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node current = first;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> current != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">            T t = current.item;</span><br><span class="line">            current = current.next;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node();</span><br><span class="line">        node.item = t;</span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(first == <span class="keyword">null</span> &amp;&amp; last == <span class="keyword">null</span>)&#123;</span><br><span class="line">            first = node;</span><br><span class="line">            last = node;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(first != <span class="keyword">null</span> &amp;&amp; first == last)&#123;</span><br><span class="line">            first.next = node;</span><br><span class="line">            last = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            last.next = node;</span><br><span class="line">            last = node;</span><br><span class="line">        &#125;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Iterator&lt;T&gt; iter = iterator();</span><br><span class="line">        String ret = iter.next().toString();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">            ret += <span class="string">", "</span>+ iter.next().toString() ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下代码是第一种方式的归并 还有第二种形式的归并 明天可以写一下。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">        first = sort(first);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">sort</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        Node slow = head;</span><br><span class="line">        Node fast = head;</span><br><span class="line">        <span class="comment">//取中间节点</span></span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node left = head;</span><br><span class="line">        Node right = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>; <span class="comment">//将左右链表分开</span></span><br><span class="line">        left = sort(left);</span><br><span class="line">        right = sort(right);</span><br><span class="line">        <span class="keyword">return</span> merge(left,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">merge</span><span class="params">(Node left, Node right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println("left="+left.element+",right="+right.element);</span></span><br><span class="line">        Node aux = <span class="keyword">new</span> Node(); <span class="comment">//需要耗费logn的额外空间</span></span><br><span class="line">        Node l= left;</span><br><span class="line">        Node r = right;</span><br><span class="line">        Node current = aux;</span><br><span class="line">        <span class="keyword">while</span>(l != <span class="keyword">null</span> &amp;&amp; r!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(less(r.item,l.item)) &#123;</span><br><span class="line">                current.next = r;</span><br><span class="line">                current = current.next;</span><br><span class="line">                r = r.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                current.next = l;</span><br><span class="line">                current = current.next;</span><br><span class="line">                l= l.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l!=<span class="keyword">null</span>) current.next = l; <span class="comment">// 如果左侧没遍历完，将其连接至current后</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(r != <span class="keyword">null</span>) current.next = r; <span class="comment">//如果右侧没遍历完，将其连接至current后</span></span><br><span class="line">        <span class="keyword">return</span> aux.next; <span class="comment">//返回归并好的链表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>MergeSortedSubArray</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Interview_Question_Week3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdRandom;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSortedSubArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span> <span class="params">(Comparable a,Comparable b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.compareTo(b) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = array.length / <span class="number">2</span>;</span><br><span class="line">        Comparable[] aux = <span class="keyword">new</span> Comparable[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            aux[i] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(aux));</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k&lt;<span class="number">2</span>*n;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l &gt;= n) <span class="keyword">break</span>;<span class="comment">//辅助元素数组全部用完，array右侧不需要挪动位置了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(r&gt;=<span class="number">2</span>*n) array[k]=aux[l++];<span class="comment">//array原右侧元素全部放置合适位置，后面只需把辅助数组的元素挪到array右侧</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(less(array[r],aux[l])) array[k] = array[r++];</span><br><span class="line">            <span class="keyword">else</span> array[k] = aux[l++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 普林斯顿算法课 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>普林斯顿第二周小作业</title>
      <link href="/2019/02/24/%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%B0%8F%E4%BD%9C%E4%B8%9A/"/>
      <url>/2019/02/24/%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%B0%8F%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第二周是关于队列与栈的相关实现，由于C-里面早就涉及到了，这里并不多说，直接贴代码"><a href="#第二周是关于队列与栈的相关实现，由于C-里面早就涉及到了，这里并不多说，直接贴代码" class="headerlink" title="第二周是关于队列与栈的相关实现，由于C++里面早就涉及到了，这里并不多说，直接贴代码"></a>第二周是关于队列与栈的相关实现，由于C++里面早就涉及到了，这里并不多说，直接贴代码</h1><p><strong>Elementary_Sorts</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Interview_Question_Week2.Elementary_Sorts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdRandom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Ball &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Blue,</span><br><span class="line">    White;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Backets</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Ball backets[];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Ball <span class="title">color</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> backets[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span> <span class="params">(<span class="keyword">int</span> i , <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Ball tmp = backets[i];</span><br><span class="line">        backets[i] = backets[j];</span><br><span class="line">        backets[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Backets</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        backets = <span class="keyword">new</span> Ball[n];</span><br><span class="line">        <span class="keyword">for</span> (Ball i : backets)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = StdRandom.uniform(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">switch</span> (x)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: &#123;i = Ball.Blue;<span class="keyword">break</span>;&#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: &#123; i = Ball.Red;<span class="keyword">break</span>;&#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: &#123;i = Ball.White;<span class="keyword">break</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = backets.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt;= high)&#123;</span><br><span class="line">            <span class="keyword">switch</span> (color(cur))&#123;</span><br><span class="line">                <span class="keyword">case</span> Red: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cur != low) &#123;</span><br><span class="line">                        swap(cur, low);</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur++;</span><br><span class="line">                    low++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> White: &#123;</span><br><span class="line">                    cur++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> Blue: &#123;</span><br><span class="line">                    swap (high,cur);</span><br><span class="line">                    high--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> Interview_Question_Week2.Elementary_Sorts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.Point;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Intersection_of_two_sets</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Point&gt; same;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sameTimes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Intersection_of_two_sets</span><span class="params">(Point[]a , Point[]b,<span class="keyword">int</span> times)</span></span>&#123;</span><br><span class="line">        same = <span class="keyword">new</span> HashSet&lt;Point&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; times;i++)&#123;</span><br><span class="line">            same.add(a[i]);</span><br><span class="line">            same.add(b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sameTimes = times * <span class="number">2</span> - same.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sameTimes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">        Random ra = <span class="keyword">new</span> Random();</span><br><span class="line">        Point[] a = <span class="keyword">new</span> Point[<span class="number">10</span>];</span><br><span class="line">        Point[] b = <span class="keyword">new</span> Point[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            a[i] = <span class="keyword">new</span> Point();</span><br><span class="line">            b[i] = <span class="keyword">new</span> Point();</span><br><span class="line">            a[i].setLocation(ra.nextInt(<span class="number">10</span>)+<span class="number">1</span>,ra.nextInt(<span class="number">10</span>)+<span class="number">1</span>);</span><br><span class="line">            b[i].setLocation(ra.nextInt(<span class="number">10</span>)+<span class="number">1</span>,ra.nextInt(<span class="number">10</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Intersection_of_two_sets i = <span class="keyword">new</span> Intersection_of_two_sets(a,b,n);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        System.out.println(Arrays.toString(b));</span><br><span class="line">        System.out.println(i.same);</span><br><span class="line">        System.out.println(i.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>MaxArrayStack</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Interview_Question_Week2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxArrayStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> Max;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sz;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> []a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxArrayStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Max = -<span class="number">999999999</span>;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">1</span>];</span><br><span class="line">        sz = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span> [capacity];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i != sz;i++)&#123;</span><br><span class="line">            tmp[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        a = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sz == a.length) resize(a.length * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (item &gt; Max) Max = item;</span><br><span class="line">        check();</span><br><span class="line">        a[sz++] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[--sz];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        MaxArrayStack mStack = <span class="keyword">new</span> MaxArrayStack();</span><br><span class="line">        mStack.push(<span class="number">4</span>);</span><br><span class="line">        mStack.push(<span class="number">5</span>);</span><br><span class="line">        mStack.push(<span class="number">6</span>);</span><br><span class="line">        mStack.push(<span class="number">2</span>);</span><br><span class="line">        mStack.push(<span class="number">1</span>);</span><br><span class="line">        mStack.push(<span class="number">10</span>);</span><br><span class="line">        mStack.push(<span class="number">7</span>);</span><br><span class="line">        mStack.push(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(mStack);</span><br><span class="line">        System.out.println(mStack.getMax());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>MaxLinkedStack</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Interview_Question_Week2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxLinkedStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">private</span> Node first;</span><br><span class="line">    <span class="keyword">private</span> Node max;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> item;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxLinkedStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">        max = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> max.item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">double</span> item)</span> </span>&#123;</span><br><span class="line">        Node oldfirst = first;</span><br><span class="line">        first = <span class="keyword">new</span> Node();</span><br><span class="line">        first.item = item;</span><br><span class="line">        first.next = oldfirst;</span><br><span class="line">        N++;</span><br><span class="line">        <span class="keyword">if</span> (item &gt;= getMax()) &#123;</span><br><span class="line">            Node oldmax = max;</span><br><span class="line">            max = <span class="keyword">new</span> Node();</span><br><span class="line">            max.next = oldmax;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> tmp = first.item;</span><br><span class="line">        first = first.next;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">if</span> (tmp == getMax()) &#123;</span><br><span class="line">            max = max.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>StackQueue</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> Interview_Question_Week2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackQueue</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Item&gt; input = <span class="keyword">new</span> Stack &lt;Item&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Item&gt; output = <span class="keyword">new</span> Stack &lt;Item&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.size() + output.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StackQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"wrong enquene"</span>);</span><br><span class="line">        input.push(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"out of range"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (output.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!input.isEmpty())&#123;</span><br><span class="line">                output.push(input.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        StackQueue&lt;Integer&gt; squeue = <span class="keyword">new</span> StackQueue&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line">        System.out.println(<span class="string">"Size: "</span> + squeue.size());</span><br><span class="line">        squeue.enqueue(i);</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= N) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Dequeue: "</span> + squeue.dequeue());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                squeue.enqueue(i);</span><br><span class="line">                System.out.println(<span class="string">"Enqueue: "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Size: "</span> + squeue.size());</span><br><span class="line">        <span class="keyword">while</span> (!squeue.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Dequeue: "</span> + squeue.dequeue());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Size: "</span> + squeue.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 普林斯顿算法课 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Permutation</title>
      <link href="/2019/02/24/Permutation/"/>
      <url>/2019/02/24/Permutation/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Permutation——普林斯顿算法大作业第二次"><a href="#Permutation——普林斯顿算法大作业第二次" class="headerlink" title="Permutation——普林斯顿算法大作业第二次"></a>Permutation——普林斯顿算法大作业第二次</h1><p>总的来说第二次算法大作业比较简单，实现以下双端队列，以及随机出队的队列。<br>鉴于这个难度系数，我这里直接写了两种，基于数组与基于链表两种方式，首先先看题目。</p><p><img src="/2019/02/24/Permutation/11.png" alt="1"><br><img src="/2019/02/24/Permutation/22.png" alt="2"></p><p>由于比较简单 这里不多说 直接开始贴代码。</p><p><strong>Deque</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Programming_Assignment_2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deque</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node first,last;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Item item;</span><br><span class="line">        Node next;</span><br><span class="line">        Node previous;</span><br><span class="line">        Node (Item i)&#123;</span><br><span class="line">            item = i;</span><br><span class="line">            next = <span class="keyword">null</span>;</span><br><span class="line">            previous = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Deque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        first = last = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        Node oldFirst = first;</span><br><span class="line">        first = <span class="keyword">new</span> Node(item);</span><br><span class="line">        first.previous = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            last = first;</span><br><span class="line">            first.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            first.next = oldFirst;</span><br><span class="line">            oldFirst.previous = first;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        Node tmp = <span class="keyword">new</span> Node(item);</span><br><span class="line">        tmp.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            first = tmp;</span><br><span class="line">            last = tmp;</span><br><span class="line">            last.previous = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            last.next = tmp;</span><br><span class="line">            tmp.previous = last;</span><br><span class="line">            last = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        Item cnt = first.item;</span><br><span class="line">        first = first.next;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">             last = first =<span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            first.previous = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        Item cnt = last.item;</span><br><span class="line">        last = last.previous;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            first = last = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            last.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DequeIterator(first);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DequeIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Item</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node current;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DequeIterator</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">            current = first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> current != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasNext())&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            &#125;</span><br><span class="line">            Item cnt = current.item;</span><br><span class="line">            current = current.next;</span><br><span class="line">            <span class="keyword">return</span> cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>RandomizedQueue</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Programming_Assignment_2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"><span class="keyword">import</span> java.lang.UnsupportedOperationException;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdRandom;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//原本最初的打算是直接用链表进行实现的，</span></span><br><span class="line"><span class="comment">//但是后来才发现性能要求迭代器的next的方法必须是常数时间，</span></span><br><span class="line"><span class="comment">//而用链表实现不了，所以改用数组实现。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomizedQueue</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Item[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        array = (Item[]) <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt;= array.length)&#123;</span><br><span class="line">            resize(array.length * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (size &lt; array.length / <span class="number">4</span>)&#123;</span><br><span class="line">            resize(array.length / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Item[] tmp = (Item[]) <span class="keyword">new</span> Object[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">            tmp[i] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        array = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"wrong input"</span>);</span><br><span class="line">        check();</span><br><span class="line">        array[size++] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">int</span> random = StdRandom.uniform(size);</span><br><span class="line">        Item cnt =array[random];</span><br><span class="line">        array[random] = array[size - <span class="number">1</span>];</span><br><span class="line">        array[--size] = <span class="keyword">null</span>;</span><br><span class="line">        check();</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">sample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> array[StdRandom.uniform(size)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> rank;</span><br><span class="line">        <span class="keyword">private</span> Item[] iarray;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RandomIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            rank = size;</span><br><span class="line">            iarray = (Item[]) <span class="keyword">new</span> Object[rank];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rank;i++)&#123;</span><br><span class="line">                iarray[i] = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> rank &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Item <span class="title">next</span> <span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasNext())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            <span class="keyword">int</span> random = StdRandom.uniform(rank);</span><br><span class="line">            rank--;</span><br><span class="line">            Item item = iarray[random];</span><br><span class="line">            iarray[random] = iarray[rank];</span><br><span class="line">            <span class="comment">//这里需要注意的是 与上面直接在原数组上面操作的区别就在于不能直接令后面等于null</span></span><br><span class="line">            <span class="comment">//如 iarray[rank] = null 这样造成的后果是多用几次迭代器使用不了了。</span></span><br><span class="line">            iarray[rank] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Permutation</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Programming_Assignment_2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdIn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Permutation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RandomizedQueue&lt;String&gt; rq = <span class="keyword">new</span> RandomizedQueue&lt;String&gt;();</span><br><span class="line">        <span class="keyword">int</span> k = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span> (!StdIn.isEmpty()) &#123;</span><br><span class="line">            rq.enqueue(StdIn.readString());</span><br><span class="line">            <span class="comment">// System.out.println(StdIn.readString());</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(rq.dequeue());</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 普林斯顿算法课 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Percolation</title>
      <link href="/2019/02/08/Percolation/"/>
      <url>/2019/02/08/Percolation/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Programming-Assignment-1-Percolation"><a href="#Programming-Assignment-1-Percolation" class="headerlink" title="Programming Assignment 1: Percolation"></a>Programming Assignment 1: Percolation</h2><p>第一次提交这样的全英文大作业，先开始完全看不懂题目，然后在网上看懂题目之后，于是写代码的时候也是混乱的，完全不知道该怎么用，看了别人提交的写了之后，自己也提交了几次，都是60分70分左右，到最后才发现数组的溢出，以及java输入输出的一些问题。</p><h2 id="接下来看题目"><a href="#接下来看题目" class="headerlink" title="接下来看题目"></a>接下来看题目</h2><p><strong>首先先看英文版的题目</strong></p><p><img src="/2019/02/08/Percolation/11.png" alt="11"><br><img src="/2019/02/08/Percolation/12.png" alt="12"></p><p><strong>看懂的大神可以不用看下面的中文版的题目了：</strong></p><p>通过蒙特卡洛模拟方法来估计渗流阈值。</p><p>Percolation. 给一个有随机分布的绝缘和金属材料的组成的复合系统。例如我们想知道哪些部分必须是金属材料才能让这个复合系统是一个电导体。或者在一个多孔的地形，在表面有水或者油，在什么情况下水或者油能够从最表面渗透到最底层。科学家把这种过程的模型叫做Percolation。</p><p>The model. 在Assignment中，用一个NxN的格子表示percolation系统，每一个格子是打开或者关闭，打开是白色关闭是黑色。如果一个格子是full，首先他必须是打开额，然后表示从最顶上通过相连(4方向)的打开的格子可以渗透到这个位置。当一个系统是percolates，表示能从最顶层渗透到最底层，也就是说，最底层存在打开的格子是full。</p><p><img src="/2019/02/08/Percolation/13.png" alt="13"></p><p>The Problem. 研究人员对一下的问题感兴趣，如果每一个格子是独立的，并且被打开的概率为p，那么系统percolates的概率是多少？p=0，percolates概率为0，p=100，percolates的概率为100。下图是20x20和100x100格子的概率p的分布：</p><p><img src="/2019/02/08/Percolation/14.png" alt="14"></p><p>当N足够大时, 有一个阈值P<em>, 使得当p &lt; p</em>时候，任意的N<em>N网格，几乎不能被渗透, 并且当p &gt; p</em>, 基本能够被渗透。p<em>没有准确的数值解。任务是写一个计算估计p</em>的算法。</p><p>题目给出了两个样版分别作为题目开始写的两个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Percolation</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Percolation</span><span class="params">(<span class="keyword">int</span> N)</span>              <span class="comment">// create N-by-N grid, with all sites blocked</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span>         <span class="comment">// open site (row i, column j) if it is not already</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span>    <span class="comment">// is site (row i, column j) open?</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span>    <span class="comment">// is site (row i, column j) full?</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">percolates</span><span class="params">()</span>            <span class="comment">// does the system percolate?</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PercolationStats</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">PercolationStats</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> trials)</span>    <span class="comment">// perform trials independent experiments on an n-by-n grid</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">mean</span><span class="params">()</span>                          <span class="comment">// sample mean of percolation threshold</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">stddev</span><span class="params">()</span>                        <span class="comment">// sample standard deviation of percolation threshold</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">confidenceLo</span><span class="params">()</span>                  <span class="comment">// low  endpoint of 95% confidence interval</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">confidenceHi</span><span class="params">()</span>                  <span class="comment">// high endpoint of 95% confidence interval</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>        <span class="comment">// test client (described below)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="第一部分建立起一个数学模型来模拟这个系统"><a href="#第一部分建立起一个数学模型来模拟这个系统" class="headerlink" title="第一部分建立起一个数学模型来模拟这个系统"></a>第一部分建立起一个数学模型来模拟这个系统</h2><h3 id="class-Percolation"><a href="#class-Percolation" class="headerlink" title="class Percolation"></a><strong>class Percolation</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.WeightedQuickUnionUF;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Percolation</span> </span>&#123;</span><br><span class="line">    <span class="comment">//建立两个并查集 来控制 backwash 的虚拟节点所产生的问题</span></span><br><span class="line">    <span class="keyword">private</span> WeightedQuickUnionUF uf;</span><br><span class="line">    <span class="keyword">private</span> WeightedQuickUnionUF backwash;</span><br><span class="line">    <span class="comment">//打开的数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="comment">//这里用一维数组来表示整张图</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] percolation;</span><br><span class="line">    <span class="comment">//总数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Percolation</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illeagal Argument"</span>);</span><br><span class="line">        len = n;</span><br><span class="line">        percolation = <span class="keyword">new</span> <span class="keyword">boolean</span>[n * n + <span class="number">2</span>];</span><br><span class="line">        uf = <span class="keyword">new</span> WeightedQuickUnionUF(n * n + <span class="number">2</span>);</span><br><span class="line">        backwash = <span class="keyword">new</span> WeightedQuickUnionUF(n * n + <span class="number">1</span>);</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n * n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            percolation[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        percolation[<span class="number">0</span>] = percolation[n * n + <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; len || j &lt; <span class="number">1</span> || j &gt; len)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"out of the range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">get_position</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i - <span class="number">1</span>) * len + j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        check(row,col);</span><br><span class="line">        <span class="keyword">if</span> (isOpen(row,col)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> index = get_position(row,col);</span><br><span class="line">        percolation[index] = <span class="keyword">true</span>;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="comment">//处理虚拟节点与实际中的点的关系</span></span><br><span class="line">        <span class="comment">//并且同时处理一下前后左右点之间的关系</span></span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">1</span>)&#123;</span><br><span class="line">            uf.union(<span class="number">0</span>,index);</span><br><span class="line">            backwash.union(<span class="number">0</span>,index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isOpen(index - len))&#123;</span><br><span class="line">            uf.union(index,index - len);</span><br><span class="line">            backwash.union(index,index - len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (row == len) uf.union(len * len + <span class="number">1</span>,index);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isOpen(index + len))&#123;</span><br><span class="line">            uf.union(index,index + len);</span><br><span class="line">            backwash.union(index,index + len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (col != <span class="number">1</span> &amp;&amp; isOpen(index - <span class="number">1</span>))&#123;</span><br><span class="line">            uf.union(index,index - <span class="number">1</span>);</span><br><span class="line">            backwash.union(index,index - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (col != len &amp;&amp; isOpen(index + <span class="number">1</span>))&#123;</span><br><span class="line">            uf.union(index,index + <span class="number">1</span>);</span><br><span class="line">            backwash.union(index,index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> percolation[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        check(row,col);</span><br><span class="line">        <span class="keyword">return</span> isOpen(get_position(row,col));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        check(row,col);</span><br><span class="line">        <span class="keyword">int</span> index = get_position(row,col);</span><br><span class="line">        <span class="keyword">if</span> (backwash.connected(index,<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfOpenSites</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">percolates</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uf.connected(<span class="number">0</span>,len * len + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于以上这个类 其实最初思考之处，完全就是借鉴并查集的思想，使用一个数组来存储当前的模块有没有被打开，然后根据这个模块进行改变，然后再使用并查集将第一个与当前位置相连接，前后左右都打开就相当于链接了，然后根据遍历就可以找出是否会遍历到最后一个位置去了。</p><p><strong>上面所说的办法有些麻烦，有一种方法所产生的两个问题，也就是上面所使用的方法</strong><br>使用虚拟节点，相当于预设一个起点和一个终点，最后只需要判断起点与终点是否是并查集相连接的即可</p><ol><li>并查集的使用方法，可以直接写一个类也可以使用自带好的类型。</li><li>会产生终点处的backwash问题，意思就是终点位置可能会与许多没有连接到起点的支点相连接，所以采用的解决办法就是使用两个并查集。</li></ol><h2 id="第二部分就是-解决数据的位置"><a href="#第二部分就是-解决数据的位置" class="headerlink" title="第二部分就是 解决数据的位置"></a>第二部分就是 解决数据的位置</h2><p>估计percolation的阈值，初始化时候格子都是关闭的，随机寻找一个关闭的位置打开，直到系统可以渗透为止，打开的格子比上总格子数就是阈值。</p><p><img src="/2019/02/08/Percolation/15.jpg" alt="15"><br><strong>运用一下这些公式：</strong><br><img src="/2019/02/08/Percolation/16.png" alt="16"></p><p>这个问题仅仅就是数学处理的问题，以及控制格式上面的输入输出。</p><h3 id="class-PercolationStats"><a href="#class-PercolationStats" class="headerlink" title="class PercolationStats"></a><strong>class PercolationStats</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdIn;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdOut;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdRandom;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdStats;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.Stopwatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PercolationStats</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] results; <span class="comment">// estimated threshold for each trial</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> avg;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> std;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PercolationStats</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> trials)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span> || trials &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">        results = <span class="keyword">new</span> <span class="keyword">double</span>[trials];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; trials; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">            Percolation pr = <span class="keyword">new</span> Percolation(n);</span><br><span class="line">            <span class="keyword">while</span>(!pr.percolates())&#123;</span><br><span class="line">                <span class="keyword">int</span> row = StdRandom.uniform(n) + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> col = StdRandom.uniform(n) + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(!pr.isOpen(row, col))&#123;</span><br><span class="line">                    pr.open(row, col);</span><br><span class="line">                    step++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            results[i] = (<span class="keyword">double</span>)step / (n * n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.avg = StdStats.mean(results);</span><br><span class="line">        <span class="keyword">this</span>.std = StdStats.stddev(results);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        StdOut.printf(<span class="string">"%-25s\n"</span>, <span class="string">"Please input 2 integers"</span>);</span><br><span class="line">        <span class="keyword">int</span> N = StdIn.readInt();</span><br><span class="line">        <span class="keyword">int</span> T = StdIn.readInt();</span><br><span class="line"></span><br><span class="line">        Stopwatch wt = <span class="keyword">new</span> Stopwatch();</span><br><span class="line"></span><br><span class="line">        PercolationStats ps = <span class="keyword">new</span> PercolationStats(N, T);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// elapsed CPU time in seconds</span></span><br><span class="line">        <span class="keyword">double</span> elapsed = wt.elapsedTime();</span><br><span class="line"></span><br><span class="line">        StdOut.printf(<span class="string">"%-25s= %.15f\n"</span>, <span class="string">"elapsed CPU time"</span>, elapsed);</span><br><span class="line">        StdOut.printf(<span class="string">"%-25s= %.7f\n"</span>, <span class="string">"mean"</span>, ps.mean());</span><br><span class="line">        StdOut.printf(<span class="string">"%-25s= %.17f\n"</span>, <span class="string">"stddev"</span>, ps.stddev());</span><br><span class="line">        StdOut.printf(<span class="string">"%-25s= [%.15f, %.15f]\n"</span>, <span class="string">"%95 confidence interval"</span>,</span><br><span class="line">                ps.confidenceLo(), ps.confidenceHi());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">mean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.avg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">stddev</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.std;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">confidenceLo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mean() - <span class="number">1.96</span> * stddev() / Math.sqrt(results.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">confidenceHi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mean() + <span class="number">1.96</span> * stddev() / Math.sqrt(results.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> java </tag>
            
            <tag> 普林斯顿算法课 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>普林斯顿算法课之并查集</title>
      <link href="/2019/02/08/%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B9%8B%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2019/02/08/%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B9%8B%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="普林斯顿算法之并查集"><a href="#普林斯顿算法之并查集" class="headerlink" title="普林斯顿算法之并查集"></a>普林斯顿算法之并查集</h2><p>个人理解 并查集就是运用在联通路径中，需要压缩路径，从而快速判断接下里的几个位置是否相连.</p><p>根据以上的需求可以写出简单类似于并查集的操作</p><p>建立数学模型，用一维甚至是多维数组来表示两个位置是否相连，相连则用相同数字来进行表示，然后经过遍历来筛查。</p><p><strong>以上这种办法简单粗暴会花费很多无用功，所以这才产生了并查集的前身</strong></p><h3 id="简单来说就是根据叠加效应，如若两者相连，就将前者作为后者的值，然后依次累积，就会产生类似树形结构的根节点，也就是下面将会提到的root函数"><a href="#简单来说就是根据叠加效应，如若两者相连，就将前者作为后者的值，然后依次累积，就会产生类似树形结构的根节点，也就是下面将会提到的root函数" class="headerlink" title="简单来说就是根据叠加效应，如若两者相连，就将前者作为后者的值，然后依次累积，就会产生类似树形结构的根节点，也就是下面将会提到的root函数"></a>简单来说就是根据叠加效应，如若两者相连，就将前者作为后者的值，然后依次累积，就会产生类似树形结构的根节点，也就是下面将会提到的<code>root</code>函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">root</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i != point[i])</span><br><span class="line">        &#123;</span><br><span class="line">            i = point[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上代码在二者没有相连接的时候，每一个人的根节点都是自己，当使用<code>union</code>操作的时候，就是将前者接到后者上面即后者就变成前者的节点，而这里就进行循环，知道找到根节点（根节点的祖先是自己）</p><h3 id="接下来就是union操作"><a href="#接下来就是union操作" class="headerlink" title="接下来就是union操作"></a>接下来就是<code>union</code>操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> roota = root(a);</span><br><span class="line">        <span class="keyword">int</span> rootb = root(b);</span><br><span class="line">        <span class="keyword">if</span> (roota == rootb) <span class="keyword">return</span> ;</span><br><span class="line">        point[rootb] = roota;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>找到两个所给点的祖先，并且把他们的祖先做一个连接行为，这样就完成了并查集的核心，而往往最多的变式就产生在这其中，一般涉及到祖先的赋值情况，后面优化的时候再说。</p><h3 id="最后一个就是connected的函数，主要用来判断是否两个点是否连接，直接判断他们两个的祖先点是否相等即可。"><a href="#最后一个就是connected的函数，主要用来判断是否两个点是否连接，直接判断他们两个的祖先点是否相等即可。" class="headerlink" title="最后一个就是connected的函数，主要用来判断是否两个点是否连接，直接判断他们两个的祖先点是否相等即可。"></a>最后一个就是<code>connected</code>的函数，主要用来判断是否两个点是否连接，直接判断他们两个的祖先点是否相等即可。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root(a)==root(b);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>优化主要分为两个方面<strong>路径压缩</strong>和<strong>路径树平衡</strong>。</p><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">root</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i != point[i])</span><br><span class="line">        &#123;</span><br><span class="line">            point[i] = point[point[i]];</span><br><span class="line">            i = point[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此处与上面相比仅仅只是多了一行代码，但是却可以让代码提高速度5倍以上，这里就是将本来要一个一个叠加的节点，变成了多支叠加，这样树的深度少了很多，所带来的结果就是效率的提高。</p><h3 id="路径树平衡"><a href="#路径树平衡" class="headerlink" title="路径树平衡"></a>路径树平衡</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> roota = root(a);</span><br><span class="line">        <span class="keyword">int</span> rootb = root(b);</span><br><span class="line">        <span class="keyword">if</span> (roota == rootb) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (sz[roota] &lt; sz[rootb])&#123;</span><br><span class="line">            <span class="comment">//下面的意思就是让 roota 接到 rootb 上面</span></span><br><span class="line">            point[roota] = rootb;</span><br><span class="line">            sz[rootb] += sz[roota];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            point[rootb] = roota;</span><br><span class="line">            <span class="comment">//下面这个意思就是继续接头接上去</span></span><br><span class="line">            sz[roota] += sz[rootb];</span><br><span class="line">            <span class="keyword">if</span> (Max[rootb] &gt; Max[roota]) Max[roota] = Max[rootb];</span><br><span class="line">        &#125;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里所带来的改变就是 使用了一个sz数组来记录每一个点在这个位置的深度，从而在每一次<code>union</code>操作的时候，都会有一个判断，就是树层次小的往树层次大的节点上面接，这样一来，同样减少了树的开销，加快效率。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 普林斯顿算法课 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java中this和super的用法总结</title>
      <link href="/2019/01/21/Java%E4%B8%ADthis%E5%92%8Csuper%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/21/Java%E4%B8%ADthis%E5%92%8Csuper%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p><p><strong>this的用法在java中大体可以分为3种：</strong></p><h4 id="1-类似于C-里面对于自身普通的引用，这种情况就不在多讲了"><a href="#1-类似于C-里面对于自身普通的引用，这种情况就不在多讲了" class="headerlink" title="1. 类似于C++里面对于自身普通的引用，这种情况就不在多讲了"></a>1. 类似于C++里面对于自身普通的引用，这种情况就不在多讲了</h4><h4 id="2-形参与成员名字重名，用this来区分"><a href="#2-形参与成员名字重名，用this来区分" class="headerlink" title="2. 形参与成员名字重名，用this来区分"></a>2. 形参与成员名字重名，用this来区分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"初始化年龄："</span>+age);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person Harry = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(<span class="string">"Harry's age is "</span>+Harry.GetAge(<span class="number">12</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>运行结果：<br>初始化年龄：10<br>Harry’s age is 12</em></p><p><strong>可以看到，这里age是GetAge成员方法的形参，this.age是Person类的成员变量。</strong></p><h4 id="3-引用构造函数"><a href="#3-引用构造函数" class="headerlink" title="3. 引用构造函数"></a>3. 引用构造函数</h4><p>这个就放在下面与super一起讲。</p><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p><strong>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</strong></p><h4 id="1-类似于C-的普通对父类对象的引用。（这里也不在多说）"><a href="#1-类似于C-的普通对父类对象的引用。（这里也不在多说）" class="headerlink" title="1. 类似于C++的普通对父类对象的引用。（这里也不在多说）"></a>1. 类似于C++的普通对父类对象的引用。（这里也不在多说）</h4><h4 id="2-子类中的成员变量或方法与父类中的成员变量或方法同名（可以用该办法区分）"><a href="#2-子类中的成员变量或方法与父类中的成员变量或方法同名（可以用该办法区分）" class="headerlink" title="2. 子类中的成员变量或方法与父类中的成员变量或方法同名（可以用该办法区分）"></a>2. 子类中的成员变量或方法与父类中的成员变量或方法同名（可以用该办法区分）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       name = <span class="string">"China"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">City</span> <span class="keyword">extends</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    name = <span class="string">"Shanghai"</span>;</span><br><span class="line">    <span class="keyword">super</span>.value();      <span class="comment">//调用父类的方法</span></span><br><span class="line">    System.out.println(name);</span><br><span class="line">    System.out.println(<span class="keyword">super</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       City c=<span class="keyword">new</span> City();</span><br><span class="line">       c.value();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>运行结果:<br>Shanghai<br>China</em></p><p>可以看到，这里既调用了父类的方法，也调用了父类的变量。若不调用父类方法value()，只调用父类变量name的话，则父类name值为默认值null。</p><h4 id="3-引用构造函数-1"><a href="#3-引用构造函数-1" class="headerlink" title="3.引用构造函数"></a>3.引用构造函数</h4><p>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。<br>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prt</span><span class="params">(String s)</span> </span>&#123; </span><br><span class="line">       System.out.println(s); </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">    Person() &#123; </span><br><span class="line">       prt(<span class="string">"父类·无参数构造方法： "</span>+<span class="string">"A Person."</span>); </span><br><span class="line">    &#125;<span class="comment">//构造方法(1) </span></span><br><span class="line">    </span><br><span class="line">    Person(String name) &#123; </span><br><span class="line">       prt(<span class="string">"父类·含一个参数的构造方法： "</span>+<span class="string">"A person's name is "</span> + name); </span><br><span class="line">    &#125;<span class="comment">//构造方法(2) </span></span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    Chinese() &#123; </span><br><span class="line">       <span class="keyword">super</span>(); <span class="comment">// 调用父类构造方法（1） </span></span><br><span class="line">       prt(<span class="string">"子类·调用父类”无参数构造方法“： "</span>+<span class="string">"A chinese coder."</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    Chinese(String name) &#123; </span><br><span class="line">       <span class="keyword">super</span>(name);<span class="comment">// 调用父类具有相同形参的构造方法（2） </span></span><br><span class="line">       prt(<span class="string">"子类·调用父类”含一个参数的构造方法“： "</span>+<span class="string">"his name is "</span> + name); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    Chinese(String name, <span class="keyword">int</span> age) &#123; </span><br><span class="line">       <span class="keyword">this</span>(name);<span class="comment">// 调用具有相同形参的构造方法（3） </span></span><br><span class="line">       prt(<span class="string">"子类：调用子类具有相同形参的构造方法：his age is "</span> + age); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">       Chinese cn = <span class="keyword">new</span> Chinese(); </span><br><span class="line">       cn = <span class="keyword">new</span> Chinese(<span class="string">"codersai"</span>); </span><br><span class="line">       cn = <span class="keyword">new</span> Chinese(<span class="string">"codersai"</span>, <span class="number">18</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```</span><br></pre></td></tr></table></figure><p><em>运行结果:<br>父类·无参数构造方法： A Person.<br>子类·调用父类”无参数构造方法“： A chinese coder.<br>父类·含一个参数的构造方法： A person’s name is codersai<br>子类·调用父类”含一个参数的构造方法“： his name is codersai<br>父类·含一个参数的构造方法： A person’s name is codersai<br>子类·调用父类”含一个参数的构造方法“： his name is codersai<br>子类：调用子类具有相同形参的构造方法：his age is 18</em></p><p>从本例可以看到，可以用super和this分别调用父类的构造方法和本类中其他形式的构造方法。</p><p>例子中Chinese类第三种构造方法调用的是本类中第二种构造方法，而第二种构造方法是调用父类的，因此也要先调用父类的构造方法，再调用本类中第二种，最后是重写第三种构造方法。</p><h2 id="super和this的异同："><a href="#super和this的异同：" class="headerlink" title="super和this的异同："></a>super和this的异同：</h2><ul><li>super（参数）：调用基类中的某一个构造函数（应该为构造函数中的第一条语句）</li><li>this（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句）</li><li>super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名    super.成员函数据名（实参）</li><li>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）</li><li>调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。</li><li>super()和this()类似,区别是，super()从子类中调用父类的构造方法，this()在同一类内调用其它方法。</li><li>super()和this()均需放在构造方法内第一行。</li><li>尽管可以用this调用一个构造器，但却不能调用两个。</li><li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li><li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</li><li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构之排序总结</title>
      <link href="/2018/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2018/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据结构的排序总结"><a href="#数据结构的排序总结" class="headerlink" title="数据结构的排序总结"></a>数据结构的排序总结</h1><h2 id="首先先展示一张图，来说明每一个排序之间的复杂度和稳定性"><a href="#首先先展示一张图，来说明每一个排序之间的复杂度和稳定性" class="headerlink" title="首先先展示一张图，来说明每一个排序之间的复杂度和稳定性"></a>首先先展示一张图，来说明每一个排序之间的复杂度和稳定性</h2><p><img src="/2018/12/18/数据结构之排序总结/640.png" alt="数据结构"></p><hr><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>这种排序往往属于最基本的排序了，比较稳定，而且代码也比较简单，这里不做多讲，直接贴代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maopao</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=maxn;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j!=maxn;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*(p+i)&gt;*(p+j))&#123;</span><br><span class="line"><span class="keyword">int</span> temp = *(p+i);</span><br><span class="line">*(p+i) = *(p+j);</span><br><span class="line">*(p+j) = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">print(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote><p>进阶版的冒泡排序，即对冒泡排序进行算法优化过得结果</p></blockquote><p><strong>快速排序的基本思想就是，通过找到一个中间值(枢纽值)，然后比枢纽值小的放到枢纽值的左边，比枢纽值大的放在枢纽值的右边，然后通过枢纽值来进行划分，一次往下面划分，利用递归或者是非递归的栈来实现，最终实现相应的排序。</strong></p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>首先找到一个枢纽,一般找最中间的一个值，或者找最左边的一个值，或者最右边的值，但是这样就会有缺陷，在某些特殊情况下会会存在很多不必要的开销。<blockquote><p>如果最后这个值刚好是整段序列最大或者最小的值，那么这次划分就是没意义的。 所以当序列是正序或者逆序时，每次选到的枢轴都是没有起到划分的作用。快排的效率会极速退化。所以可以每次在选枢轴时，在序列的第一，中间，最后三个值里面选一个中间值出来作为枢轴，保证每次划分接近均等。</p></blockquote></li></ol><p>所以采用的是<code>三值取中法</code>：</p><p><img src="/2018/12/18/数据结构之排序总结/1.png" alt="三值取中法"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_mid</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (a[left] &lt;= a[right])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[mid] &lt; a[left]) <span class="keyword">return</span> left;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; a[right]) <span class="keyword">return</span> right;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[mid] &lt; a[right]) <span class="keyword">return</span> right;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; a[left]) <span class="keyword">return</span> left;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>当取到中间的枢纽值之后，接下来需要完成的是将枢纽值放到最右边，并且一次进行比较排序，将比枢纽值小的放在左边，比枢纽值大的放在右边。最后返回最终枢纽值所在的位置，按照此位置进行划分子区，从而完成一次快速排序，然后再到每一个子区进行重复上述过程。</li></ol><p><img src="/2018/12/18/数据结构之排序总结/2.png" alt=""></p><p>以下介绍两种方法，而这两种方法代码类似，而两者唯一的区别也就在于对于key的处理了，一个是直接将key当做是引用，而另一个则是直接拷贝。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左右指针交换的办法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">part_sort1</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = get_mid(a,left,right);</span><br><span class="line">swap(a[mid],a[right]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;key = a[right];</span><br><span class="line"><span class="keyword">while</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= key)</span><br><span class="line">++left;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= key)</span><br><span class="line">--right;</span><br><span class="line">        <span class="comment">//交换左右两个的值，分别根据key值进行一个有效的划分</span></span><br><span class="line">swap (a[left],a[right]);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//由于这里的key是一个引用，直接附在了枢纽值上面，无论怎么移动，都可以在这个地方直接进行交换</span></span><br><span class="line">swap(a[right],key);</span><br><span class="line">    <span class="comment">//然而这里需要注意就是，无论这里是写right还是left，到最后right与left一定会相同的，因为每一次划分最后到不能划分之后，左右指针就会进行一个重叠。</span></span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//挖坑填补法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">part_sort2</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = get_mid(a,left,right);</span><br><span class="line">swap (a[mid],a[right]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里实际上就是直接将枢纽值进行拷贝给temp上面</span></span><br><span class="line"><span class="keyword">int</span> key = a[right];</span><br><span class="line"><span class="keyword">while</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= key)</span><br><span class="line">++left;</span><br><span class="line">a[right] = a[left];</span><br><span class="line">        <span class="comment">//每一步骤就进行占位</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= key)</span><br><span class="line">--right;</span><br><span class="line">        <span class="comment">//相当于此处进行一个有效的位置互换</span></span><br><span class="line">a[left] = a[right];</span><br><span class="line">&#125;</span><br><span class="line">a[right] = key;</span><br><span class="line">    <span class="comment">//然后这里right指向的元素就应该是多余且本应该存放枢纽值的位置</span></span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>当每一步结束之后，可以利用递归，也可以使用非递归的栈来实现对每一步的分区进行快排的操作。<br><img src="/2018/12/18/数据结构之排序总结/3.png" alt=""></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> index = part_sort1(a,left,right);</span><br><span class="line">quick_sort(a,left,index<span class="number">-1</span>);</span><br><span class="line">quick_sort(a,index+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>简单选择排序是最简单直观的一种算法，基本思想为每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，直到所有元素排完为止，简单选择排序是不稳定排序。</p><h3 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h3><p>每一趟确定最小元素的时候会通过不断地比较交换来使得首位置为当前最小，交换是个比较耗时的操作。通过设置一个变量min，每一次比较仅存储较小元素的数组下标，当轮循环结束之后，那这个变量存储的就是当前最小元素的下标，此时再执行交换操作即可。（这里不做过多阐述）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xuanze</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=maxn;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> Min = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j!=maxn ;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*(p+Min) &gt; *(p+j))</span><br><span class="line">Min = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Min != i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = *(p + Min);</span><br><span class="line">*(p + Min) = * (p + i);</span><br><span class="line">*(p + i) = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">print(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种<code>选择排序</code>，（可以理解成特殊的选择排序，相当于完全二叉树型的选择排序）它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。</p><p>首先简单了解下堆结构。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：</p><p><img src="/2018/12/18/数据结构之排序总结/4.png" alt=""></p><h3 id="堆排序的思想："><a href="#堆排序的思想：" class="headerlink" title="堆排序的思想："></a>堆排序的思想：</h3><p>首先先将给出的序列进行一个调整，调整成一个大顶堆或者一个小顶堆，调整之后，再把栈顶的元素与最后一个元素进行交换，交换完成之后在进行调整，最后完成堆排序。</p><h3 id="堆排序步骤"><a href="#堆排序步骤" class="headerlink" title="堆排序步骤:"></a>堆排序步骤:</h3><ol><li><p>构造大顶堆或者小顶堆，通过调整的方式</p><ul><li><p>最初模样<br><img src="/2018/12/18/数据结构之排序总结/5.png" alt=""></p></li><li><p>从最后一个非叶子节点开始，从左到右，从上到下进行调整<br><img src="/2018/12/18/数据结构之排序总结/6.png" alt=""></p></li><li><p>找到根节点，左孩子，右孩子，中的最大的一个，使其放在根节点的位置。<br><img src="/2018/12/18/数据结构之排序总结/7.png" alt=""></p></li><li><p>继续向上面调整，一步一步的更替到下面<br><img src="/2018/12/18/数据结构之排序总结/8.png" alt=""></p></li></ul></li></ol><h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> root,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = a[root];</span><br><span class="line"><span class="keyword">int</span> child = <span class="number">2</span> * root + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (child &lt; len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (child + <span class="number">1</span> &lt; len &amp;&amp; a[child] &lt; a[child + <span class="number">1</span>])</span><br><span class="line">child ++;</span><br><span class="line"><span class="keyword">if</span> (temp &gt;= a[child]) <span class="keyword">break</span>;</span><br><span class="line">a[root] = a[child];</span><br><span class="line">root = child;</span><br><span class="line">child = <span class="number">2</span> * child;</span><br><span class="line">&#125;</span><br><span class="line">a[root] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>将栈顶元素与最后一个元素进行交换，使末尾元素最大，然后再来慢慢调整。</li></ol><p><strong>以下的四张图就是交换元素，并且每交换一次都会调整元素一次</strong><br><img src="/2018/12/18/数据结构之排序总结/9.png" alt=""></p><p><img src="/2018/12/18/数据结构之排序总结/10.png" alt=""></p><p><img src="/2018/12/18/数据结构之排序总结/11.png" alt=""></p><p><img src="/2018/12/18/数据结构之排序总结/12.png" alt=""></p><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//注意这里必须从后面开始往前面递归的意思就在于便于改变上面之后可以有效的推至下面，相当于一个小型递归</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = maxn / <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">adjust(a,i,maxn);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = maxn - <span class="number">1</span>;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">swap (a[<span class="number">0</span>],a[i]);</span><br><span class="line">adjust(a,<span class="number">0</span>,i);</span><br><span class="line">&#125;</span><br><span class="line">print (a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="算法思想：-1"><a href="#算法思想：-1" class="headerlink" title="算法思想："></a>算法思想：</h3><blockquote><p>从后面往前面递进，将每一个树直接插入到前面已经排好序的序列里面去。(后面再详细阐明)</p></blockquote><p><img src="/2018/12/18/数据结构之排序总结/15.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">charu</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i!=maxn;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = *(p+i);</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span> (j&gt;<span class="number">0</span> &amp;&amp; temp &lt; *(p+j<span class="number">-1</span>) )</span><br><span class="line">&#123;</span><br><span class="line">*(p+j) = *(p+j<span class="number">-1</span>);</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i != j)</span><br><span class="line">&#123;</span><br><span class="line">*(p+j) = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">print(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><blockquote><p>其实希尔排序也就是基于插入排序的优化版本，而插入排序则可以看做是增值为1的希尔排序</p></blockquote><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><strong>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止</strong></p><p>可以观看下面<code>图示</code>：</p><p><img src="/2018/12/18/数据结构之排序总结/16.png" alt=""></p><h3 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a>算法步骤：</h3><p>首先找出每一个gap值（增值），然后根据增值进行相除，找到每一个间隔位置的元素，来比较大小然后排序，而gap值所造成的间隔会越来越小，直到最后增值为一，成为最后的插入排序。</p><blockquote><p>一般gap值为2，即用2去整除，但是有的算法表示同样也可以用到3</p></blockquote><h3 id="代码如下：-1"><a href="#代码如下：-1" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xier</span><span class="params">(<span class="keyword">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> gap = maxn/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap=gap/<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//从后面往前面进行递增，获取gap的值，然后依次除以2.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=gap;i&lt;maxn;i++)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="comment">//下面就类似于插入排序了，只不过增值要从1变成gap。</span></span><br><span class="line"><span class="keyword">int</span> temp = a[i];</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="comment">//这个地方需要注意的是对于插入排序 最后一个值是需要到j&gt;=1，而这里要到gap，注意清楚范围。</span></span><br><span class="line"><span class="keyword">while</span> (j&gt;gap<span class="number">-1</span> &amp;&amp; temp &lt; *(a+j-gap))</span><br><span class="line">&#123;</span><br><span class="line">*(a+j) = *(a+j-gap);</span><br><span class="line">j -= gap;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//上一步每一个都伦换过后，将最初这里的值换到相应的位置上面</span></span><br><span class="line">*(a+j) = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">print(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote><p>归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略（分治法将问题<code>分</code>成一些小的问题然后递归求解，而<code>治</code>的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p></blockquote><p><img src="/2018/12/18/数据结构之排序总结/17.png" alt=""></p><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想:"></a>算法思想:</h3><pre><code>其实有点像完全二叉树的结构，但是又有很大的不同,主要就是借助另外一个同样长的数组来存储合并之后的结果，合并的时候可以使用递归或者使用栈来决定合并部位。然后合并的过程中分成无数个小部分，然后一一往新的数组上面添加，最后拷贝到原来的数组上面。</code></pre><p><img src="/2018/12/18/数据结构之排序总结/18.png" alt=""></p><h3 id="算法步骤：-1"><a href="#算法步骤：-1" class="headerlink" title="算法步骤："></a>算法步骤：</h3><ol><li>决定合并部位，这里贴出两个，一个是直接利用递归，另一个是利用循环，用1，2，4，8…乘数扩大进行操作。</li></ol><ul><li>递归版本：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gui_sort</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> *temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">gui_sort(a,left,mid,temp);</span><br><span class="line">gui_sort(a,mid+<span class="number">1</span>,right,temp);</span><br><span class="line">merge(a,left,mid,right,temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>非递归版本：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fei_gui_sort</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> size=<span class="number">1</span>,low,mid,high;</span><br><span class="line"><span class="keyword">while</span>(size&lt;=maxn<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">low=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//这个步骤就相当于上面递归内部进行的步骤了，从1到2到4到8到16，依次进行。</span></span><br><span class="line">        <span class="comment">//但是这种非递归的版本可以带来节省很多由栈带来的递归开销。</span></span><br><span class="line"><span class="keyword">while</span>(low+size&lt;=maxn<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">mid=low+size<span class="number">-1</span>;</span><br><span class="line">high=mid+size;</span><br><span class="line"><span class="keyword">if</span>(high&gt;maxn<span class="number">-1</span>)</span><br><span class="line">high=maxn<span class="number">-1</span>;</span><br><span class="line">merge(a,low,mid,high,temp); </span><br><span class="line"></span><br><span class="line">low=high+<span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//这里乘以2。</span></span><br><span class="line">size*=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>然后就是合并操作了，设置几个指针节点，然后依次比较大小，把小的那个先放入排序中。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="keyword">int</span> *temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i =left;</span><br><span class="line"><span class="keyword">int</span> j = mid +<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//左边与右边开始进行比较</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt; a[j])</span><br><span class="line">temp[t++] = a[i++];</span><br><span class="line"><span class="keyword">else</span> temp[t++] = a[j++];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//左边剩下的</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">temp[t++] = a[i++];</span><br><span class="line">    <span class="comment">//右边剩下的</span></span><br><span class="line"><span class="keyword">while</span> (j &lt;= right)</span><br><span class="line">temp[t++] = a[j++];</span><br><span class="line">t = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//拷贝到原数组中去</span></span><br><span class="line"><span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">a[left++] = temp[t++];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="全部代码-可直接运行"><a href="#全部代码-可直接运行" class="headerlink" title="全部代码(可直接运行)"></a>全部代码(可直接运行)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: 排序代码.cpp</span></span><br><span class="line"><span class="comment">&gt; Author: wangshuxiao</span></span><br><span class="line"><span class="comment">&gt; Mail: wsx1128@outlook.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: Mon 17 Dec 11:23:48 2018</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里使用STL算法中的shuffle来使最初的排序全部随机</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">20</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p++ &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">random</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">random_shuffle(p,p+maxn);</span><br><span class="line">print(p);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maopao</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=maxn;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j!=maxn;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*(p+i)&gt;*(p+j))&#123;</span><br><span class="line"><span class="keyword">int</span> temp = *(p+i);</span><br><span class="line">*(p+i) = *(p+j);</span><br><span class="line">*(p+j) = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">print(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xuanze</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=maxn;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> Min = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j!=maxn ;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*(p+Min) &gt; *(p+j))</span><br><span class="line">Min = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Min != i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = *(p + Min);</span><br><span class="line">*(p + Min) = * (p + i);</span><br><span class="line">*(p + i) = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">print(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">charu</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i!=maxn;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = *(p+i);</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span> (j&gt;<span class="number">0</span> &amp;&amp; temp &lt; *(p+j<span class="number">-1</span>) )</span><br><span class="line">&#123;</span><br><span class="line">*(p+j) = *(p+j<span class="number">-1</span>);</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i != j)</span><br><span class="line">&#123;</span><br><span class="line">*(p+j) = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">print(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xier</span><span class="params">(<span class="keyword">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> gap = maxn/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap=gap/<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=gap;i&lt;maxn;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = a[i];</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span> (j&gt;gap<span class="number">-1</span> &amp;&amp; temp &lt; *(a+j-gap))</span><br><span class="line">&#123;</span><br><span class="line">*(a+j) = *(a+j-gap);</span><br><span class="line">j -= gap;</span><br><span class="line">&#125;</span><br><span class="line">*(a+j) = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">print(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="keyword">int</span> *temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i =left;</span><br><span class="line"><span class="keyword">int</span> j = mid +<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt; a[j])</span><br><span class="line">temp[t++] = a[i++];</span><br><span class="line"><span class="keyword">else</span> temp[t++] = a[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">temp[t++] = a[i++];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= right)</span><br><span class="line">temp[t++] = a[j++];</span><br><span class="line">t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">a[left++] = temp[t++];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gui_sort</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> *temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">gui_sort(a,left,mid,temp);</span><br><span class="line">gui_sort(a,mid+<span class="number">1</span>,right,temp);</span><br><span class="line">merge(a,left,mid,right,temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">guibing</span><span class="params">(<span class="keyword">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *temp = <span class="keyword">new</span> <span class="keyword">int</span> [maxn];</span><br><span class="line">gui_sort(a,<span class="number">0</span>,maxn<span class="number">-1</span>,temp);</span><br><span class="line">print(a);</span><br><span class="line"><span class="keyword">delete</span> [] temp;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fei_gui_sort</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> size=<span class="number">1</span>,low,mid,high;</span><br><span class="line"><span class="keyword">while</span>(size&lt;=maxn<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">low=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(low+size&lt;=maxn<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">mid=low+size<span class="number">-1</span>;</span><br><span class="line">high=mid+size;</span><br><span class="line"><span class="keyword">if</span>(high&gt;maxn<span class="number">-1</span>)</span><br><span class="line">high=maxn<span class="number">-1</span>;</span><br><span class="line">merge(a,low,mid,high,temp); </span><br><span class="line"></span><br><span class="line">low=high+<span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line">size*=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fei_guibing</span><span class="params">(<span class="keyword">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *temp = <span class="keyword">new</span> <span class="keyword">int</span> [maxn];</span><br><span class="line">fei_gui_sort(a,temp);</span><br><span class="line">print(a);</span><br><span class="line"><span class="keyword">if</span> (temp != <span class="literal">NULL</span>) <span class="keyword">delete</span> [] temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_mid</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (a[left] &lt;= a[right])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[mid] &lt; a[left]) <span class="keyword">return</span> left;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; a[right]) <span class="keyword">return</span> right;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[mid] &lt; a[right]) <span class="keyword">return</span> right;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; a[left]) <span class="keyword">return</span> left;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左右指针交换的办法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">part_sort1</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = get_mid(a,left,right);</span><br><span class="line">swap(a[mid],a[right]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;key = a[right];</span><br><span class="line"><span class="keyword">while</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= key)</span><br><span class="line">++left;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= key)</span><br><span class="line">--right;</span><br><span class="line">swap (a[left],a[right]);</span><br><span class="line">&#125;</span><br><span class="line">swap(a[right],key);</span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//挖坑填补法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">part_sort2</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = get_mid(a,left,right);</span><br><span class="line">swap (a[mid],a[right]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> key = a[right];</span><br><span class="line"><span class="keyword">while</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= key)</span><br><span class="line">++left;</span><br><span class="line">a[right] = a[left];</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= key)</span><br><span class="line">--right;</span><br><span class="line">a[left] = a[right];</span><br><span class="line">&#125;</span><br><span class="line">a[right] = key;</span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> index = part_sort1(a,left,right);</span><br><span class="line">quick_sort(a,left,index<span class="number">-1</span>);</span><br><span class="line">quick_sort(a,index+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kuaisu</span><span class="params">(<span class="keyword">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">quick_sort(a,<span class="number">0</span>,maxn<span class="number">-1</span>);</span><br><span class="line">print(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> root,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = a[root];</span><br><span class="line"><span class="keyword">int</span> child = <span class="number">2</span> * root + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (child &lt; len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (child + <span class="number">1</span> &lt; len &amp;&amp; a[child] &lt; a[child + <span class="number">1</span>])</span><br><span class="line">child ++;</span><br><span class="line"><span class="keyword">if</span> (temp &gt;= a[child]) <span class="keyword">break</span>;</span><br><span class="line">a[root] = a[child];</span><br><span class="line">root = child;</span><br><span class="line">child = <span class="number">2</span> * child;</span><br><span class="line">&#125;</span><br><span class="line">a[root] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = maxn / <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">adjust(a,i,maxn);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = maxn - <span class="number">1</span>;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">swap (a[<span class="number">0</span>],a[i]);</span><br><span class="line">adjust(a,<span class="number">0</span>,i);</span><br><span class="line">&#125;</span><br><span class="line">print (a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,</span><br><span class="line"><span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"最初的顺序为"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">print(a);</span><br><span class="line"><span class="comment">//以上为初始化过后，并且进行打乱顺序的排列顺序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"冒泡排序"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">random(a);</span><br><span class="line">maopao(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"选择排序"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">random(a);</span><br><span class="line">xuanze(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"插入排序"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">random(a);</span><br><span class="line">charu(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"希尔排序"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">random(a);</span><br><span class="line">xier(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"递归版本归并排序"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">random(a);</span><br><span class="line">guibing(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"非递归版本的归并排序"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">random (a);</span><br><span class="line">fei_guibing(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"快速排序"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">random(a);</span><br><span class="line">kuaisu(a);</span><br><span class="line">   </span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"堆排序"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">random(a);</span><br><span class="line">heap_sort(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文中图片转载自多个博客，这里不贴出来源了，如若侵权，即刻删除，谢谢。"><a href="#文中图片转载自多个博客，这里不贴出来源了，如若侵权，即刻删除，谢谢。" class="headerlink" title="文中图片转载自多个博客，这里不贴出来源了，如若侵权，即刻删除，谢谢。"></a><strong>文中图片转载自多个博客，这里不贴出来源了，如若侵权，即刻删除，谢谢。</strong></h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二叉树总结</title>
      <link href="/2018/12/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93/"/>
      <url>/2018/12/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="今天花时间整理一下二叉树的一切内容"><a href="#今天花时间整理一下二叉树的一切内容" class="headerlink" title="今天花时间整理一下二叉树的一切内容"></a>今天花时间整理一下二叉树的一切内容</h1><h2 id="下面的部分包括："><a href="#下面的部分包括：" class="headerlink" title="下面的部分包括："></a>下面的部分包括：</h2><ul><li><h3 id="二叉树的创建"><a href="#二叉树的创建" class="headerlink" title="二叉树的创建"></a>二叉树的创建</h3></li><li><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ul><li>二叉树的层序遍历</li><li>二叉树的深度遍历<ul><li>二叉树递归先序遍历</li><li>二叉树递归中序遍历</li><li>二叉树递归后序遍历</li><li>二叉树非递归先序遍历</li><li>二叉树非递归中序遍历</li><li>二叉树非递归后序遍历</li></ul></li></ul></li><li><h3 id="线索树"><a href="#线索树" class="headerlink" title="线索树"></a>线索树</h3></li></ul><h2 id="下面直接贴代码（在代码内部进行注释）："><a href="#下面直接贴代码（在代码内部进行注释）：" class="headerlink" title="下面直接贴代码（在代码内部进行注释）："></a>下面直接贴代码（在代码内部进行注释）：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: tree.cpp</span></span><br><span class="line"><span class="comment">&gt; Author: wangshuxiao</span></span><br><span class="line"><span class="comment">&gt; Mail: wsx1128@outlook.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 二 11/20 18:51:16 2018</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node():left(<span class="number">0</span>),right(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">    Node(<span class="keyword">char</span> e):</span><br><span class="line">    value(e)&#123;left = <span class="number">0</span>;right = <span class="number">0</span>;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> value;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bi_tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bi_tree()=<span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    ~Bi_tree()</span><br><span class="line">    &#123;</span><br><span class="line">        clear();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//由于建树与析构都要使用到递归，所以对于类而言，必须使用另外一个函数来进行递归，才不会影响私有成员</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bulid</span> <span class="params">()</span></span>;</span><br><span class="line">    Node* _bulid (Node *); </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> root == <span class="number">0</span>; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">breath_order</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(Node *t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node *t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(Node *t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">iter_preorder</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">iter_inorder</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">iter_postorder</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Node * <span class="title">get_root</span><span class="params">()</span>    </span>&#123;<span class="keyword">return</span> root;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node *p)</span></span>;</span><br><span class="line">    Node *root;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Bi_tree::clear()</span><br><span class="line">&#123;</span><br><span class="line">    clear(root);</span><br><span class="line">    root = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Bi_tree::clear(Node *n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n-&gt;left)    clear(n-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (n-&gt;right)    clear(n-&gt;right);</span><br><span class="line">        <span class="keyword">delete</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Bi_tree::print(Node *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p-&gt;value &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Bi_tree::bulid()</span><br><span class="line">&#123;</span><br><span class="line">    root = _bulid(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另外这里还是需要注意到的是，由于类的逻辑与C语言的不太相同，所以再循环的时候不能直接返回为空，所以必须要返回一个`Node*`，这样才可以把之前的给联系在一起。</span></span><br><span class="line"><span class="comment">//或者还有一种办法是，使用指针的引用，这样也就是所谓的二级指针，才能造成效果。</span></span><br><span class="line">Node * Bi_tree::_bulid(Node *t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//creat the tree by preorder</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ch ==<span class="string">'#'</span>)</span><br><span class="line">        t = <span class="literal">nullptr</span> ;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        t = <span class="keyword">new</span> Node;</span><br><span class="line">        t-&gt;value = ch;</span><br><span class="line">        t-&gt;left = _bulid(t-&gt;left);</span><br><span class="line">        t-&gt;right = _bulid(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 层序遍历</span></span><br><span class="line"><span class="keyword">void</span> Bi_tree::breath_order()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;Node*&gt; q_tree;</span><br><span class="line">Node *t = root;</span><br><span class="line"><span class="keyword">if</span> ( t != <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">q_tree.push(t);</span><br><span class="line"><span class="keyword">while</span> (!q_tree.empty())</span><br><span class="line">&#123;</span><br><span class="line">t = q_tree.front();</span><br><span class="line">q_tree.pop();</span><br><span class="line">print(t);</span><br><span class="line"><span class="keyword">if</span> (t-&gt;left != <span class="number">0</span>)</span><br><span class="line">q_tree.push(t-&gt;left);</span><br><span class="line"><span class="keyword">if</span> (t-&gt;right != <span class="number">0</span>)</span><br><span class="line">q_tree.push(t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归 先序遍历</span></span><br><span class="line"><span class="keyword">void</span> Bi_tree::preorder(Node *t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t)</span><br><span class="line">    &#123;</span><br><span class="line">        print(t);</span><br><span class="line">        preorder(t-&gt;left);</span><br><span class="line">        preorder(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归 中序遍历</span></span><br><span class="line"><span class="keyword">void</span> Bi_tree::inorder(Node *t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t)</span><br><span class="line">    &#123;</span><br><span class="line">        inorder(t-&gt;left);</span><br><span class="line">        print(t);</span><br><span class="line">        inorder(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归 后序遍历</span></span><br><span class="line"><span class="keyword">void</span> Bi_tree::postorder(Node *t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t)</span><br><span class="line">    &#123;</span><br><span class="line">        postorder(t-&gt;left);</span><br><span class="line">        postorder(t-&gt;right);</span><br><span class="line">        print(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归 先序遍历 使用栈</span></span><br><span class="line"><span class="keyword">void</span> Bi_tree::iter_preorder()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Node*&gt; s_tree;</span><br><span class="line">    Node *t = root;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s_tree.push(t);</span><br><span class="line">        <span class="keyword">while</span> (!s_tree.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            t = s_tree.top();</span><br><span class="line">            s_tree.pop();</span><br><span class="line">            print(t);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (t-&gt;right != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s_tree.push(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s_tree.push(t-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归 中序遍历 使用栈</span></span><br><span class="line"><span class="keyword">void</span> Bi_tree::iter_postorder()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Node*&gt; s_tree;</span><br><span class="line">    Node *p = root , *q = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> ( ;p-&gt;left != <span class="number">0</span>;p = p-&gt;left)</span><br><span class="line">            s_tree.push(p);</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;right == <span class="number">0</span> || p-&gt;right == q)</span><br><span class="line">        &#123;</span><br><span class="line">            print(p);</span><br><span class="line">            q = p;</span><br><span class="line">            <span class="keyword">if</span> (s_tree.empty()) <span class="keyword">return</span> ;</span><br><span class="line">            p = s_tree.top();</span><br><span class="line">            s_tree.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        s_tree.push(p);</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归 后序遍历 使用栈</span></span><br><span class="line"><span class="keyword">void</span> Bi_tree::iter_inorder()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">stack</span> &lt;Node*&gt; s_tree;</span><br><span class="line">    Node *p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right)</span><br><span class="line">                s_tree.push(p-&gt;right);</span><br><span class="line">            s_tree.push(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = s_tree.top();</span><br><span class="line">        s_tree.pop();</span><br><span class="line">        <span class="keyword">while</span> (!s_tree.empty() &amp;&amp; p-&gt;right == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            print (p);</span><br><span class="line">            p = s_tree.top();</span><br><span class="line">            s_tree.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        print(p);</span><br><span class="line">        <span class="keyword">if</span> (!s_tree.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            p = s_tree.top();</span><br><span class="line">            s_tree.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> p = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Bi_tree b;</span><br><span class="line">    b.bulid();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (b.isEmpty()) <span class="built_in">cout</span> &lt;&lt; <span class="string">"空的"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"下面是递归形式的遍历方式"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"递归形式先序遍历"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    b.preorder(b.get_root());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"递归形式后续遍历"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    b.postorder(b.get_root());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" 非递归形式的中序遍历"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    b.iter_inorder();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" 非递归形式的后序遍历"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    b.iter_postorder();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线索树-1"><a href="#线索树-1" class="headerlink" title="线索树"></a>线索树</h3><h4 id="线索二叉树原理"><a href="#线索二叉树原理" class="headerlink" title="线索二叉树原理"></a>线索二叉树原理</h4><p>通过考察各种二叉链表，不管儿叉树的形态如何，空链域的个数总是多过非空链域的个数。准确的说，n各结点的二叉链表共有2n个链域，非空链域为n-1个，但其中的空链域却有n+1个。因此，提出了一种方法，利用原来的空链域存放指针，指向树中其他结点。这种指针称为线索。</p><blockquote><p>记ptr指向二叉链表中的一个结点，以下是建立线索的规则：</p><ol><li>如果ptr-&gt;lchild为空，则存放指向中序遍历序列中该结点的<code>前驱结点</code>。这个结点称为ptr的中序前驱；</li><li>如果ptr-&gt;rchild为空，则存放指向中序遍历序列中该结点的<code>后继结点</code>。这个结点称为ptr的中序后继；</li></ol></blockquote><p>显然，在决定lchild是指向左孩子还是前驱，rchild是指向右孩子还是后继，需要一个区分标志的。因此，我们在每个结点再增设两个标志域ltag和rtag，注意ltag和rtag只是区分0或1数字的布尔型变量，其占用内存空间要小于像lchild和rchild的指针变量。</p><p>其中：</p><ol><li>ltag为0时指向该结点的左孩子，为1时指向该结点的前驱；</li><li>rtag为0时指向该结点的右孩子，为1时指向该结点的后继；</li><li>因此对于上图的二叉链表图可以修改为下图的养子。</li></ol><p><img src="http://blog.chinaunix.net/attachment/201301/17/26548237_1358403668csC7.jpg" alt=""></p><h3 id="线索二叉树的代码实现"><a href="#线索二叉树的代码实现" class="headerlink" title="线索二叉树的代码实现"></a>线索二叉树的代码实现</h3><p>对接下来的例子中，线索二叉树的中序遍历。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 遍历 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>海边的卡夫卡的短书评</title>
      <link href="/2018/12/02/%E6%B5%B7%E8%BE%B9%E7%9A%84%E5%8D%A1%E5%A4%AB%E5%8D%A1%E7%9A%84%E7%9F%AD%E4%B9%A6%E8%AF%84/"/>
      <url>/2018/12/02/%E6%B5%B7%E8%BE%B9%E7%9A%84%E5%8D%A1%E5%A4%AB%E5%8D%A1%E7%9A%84%E7%9F%AD%E4%B9%A6%E8%AF%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>《海边的卡夫卡》这本书以一个悲剧戏剧为蓝本，进行双线构造，相互交织，相互迎合，从而使一个十五岁的少年的成长历程逐渐完善。虽然取自于俄狄浦斯王中杀父奸母的桥段，但是结局导向以及传达出来的意义绝不一样，前者是悲剧式的自我毁灭以及无常命运的慨叹，而后者则是彻彻底底的自我救赎式的成长。<br>不知有多少人曾在那里流血，你本身也会流血，温暖而又鲜红的血。你的双手将会接住它们，那既是你的血，又是别人的血，而沙尘暴偃旗息鼓的时候，你恐怕还不能完全明白自己是如同从中穿过而得以逃生的。甚至它是否过去都无从判断，不过有一点是你一定是非常清楚的，从沙尘暴中逃生的不再是跨入沙尘暴的你。<br>每一个人的成长都是自由的，但同时却也是不可预测的。村上君用一个十五岁少年的成长史告诉我们在命运的妥协与抗争之间还存在救赎和成长。但是如果仅仅写出少年的成长史的话只能算一般小说。但是村上君肯定不会这样落入俗套，于是他巧妙利用第二条故事线，一个十五岁之后丧失一切的老爷爷的奇遇，这位老爷爷拥有着诸多神奇的能力，但是就是无法思考，记不清楚发生在自己身上的一切，甚至是与整个世界脱轨。看似与第一条故事线没有任何关联，实则丝丝入扣，一个十五岁之后拥有无限可能的人生经历和一个十五岁之后一切都是空白的人生经历相对比，更加深了本文成长与救赎的主题。<br>这本书另一个引人注目的地方也就是作者村上春树对成长中最大的敌人的定义：<br>缺乏想象力的狭隘，苛刻，自以为是的命题，空洞的术语，被篡夺的理想，僵化的思想体系，这些才是最可怕的，但是何为正确，何为不正确，这些都是值得深思的话题，但是某种个体的判断失误，在很多情况下事后不是不可能挽回，只要有勇气主动承认错误，都是可以补救。<br>村上春树这本书以一个全新的视角诠释我们在成长之行上必定会遇到的善与恶，以及一步步走向顽强的心路历程，不要畏惧前方有未知的风暴，因为你是世界上最顽强的是19岁的少年。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 书评 </tag>
            
            <tag> 村上春树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条款07：为多态基类声明 virtual 析构函数</title>
      <link href="/2018/12/01/%E6%9D%A1%E6%AC%BE07%EF%BC%9A%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8E%20virtual%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
      <url>/2018/12/01/%E6%9D%A1%E6%AC%BE07%EF%BC%9A%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8E%20virtual%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="在进行基类与派生类之间动态绑定的时候，如果发生对象销毁调用的析构函数不是虚函数的话，那么就会造成析构销毁部分的现象。"><a href="#在进行基类与派生类之间动态绑定的时候，如果发生对象销毁调用的析构函数不是虚函数的话，那么就会造成析构销毁部分的现象。" class="headerlink" title="在进行基类与派生类之间动态绑定的时候，如果发生对象销毁调用的析构函数不是虚函数的话，那么就会造成析构销毁部分的现象。"></a>在进行基类与派生类之间动态绑定的时候，如果发生对象销毁调用的析构函数不是虚函数的话，那么就会造成析构销毁部分的现象。</h4><ol><li><p>C++明确指出，当 derived class 对象经由一个 base class指针被删除，而该 base class 带着一个不是虚函数的析构函数的话，其结果往往都是自定义的，就像上述的说法而言，往往是对象的 derived 成分没有被销毁，而且消除这个问题最简单的办法是在基类的析构函数上面加上虚函数的声明。</p></li><li><p>不要随便继承标准库里面的东西，因为里面大部分东西都不存在虚函数的析构函数，这样一来，如果使用动态绑定的话，那么在销毁对象的过程中就没有办法全部销毁了。</p></li><li><p>而且不一定是基类的析构函数设置成虚函数，只要类里面有一个函数是虚函数的话，那么就需要将析构函数定义成虚函数。</p></li><li><p>类的用途不是作为多态的用途的话，那么请不要将析构函数声明成虚函数，因为那样没有作用。</p></li><li><p>对于一个纯虚函数而言，这个类就是一个抽象类，但是由于存在一个析构函数，所以一般要为这个纯虚函数提供定义，其的运作方式是最深层派生的那个类的析构函数最先被调用，然后就是每一个基类的析构函数被调用，所以编译器会在派生类的析构函数中定一个对基类纯虚析构函数的调用动作，因此，一般都得进行调用。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> effective C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>STL的简单总结</title>
      <link href="/2018/12/01/STL%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
      <url>/2018/12/01/STL%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>补一个加快C++输入输出速度的方法：<br><img src="/2018/12/01/STL的简单总结/15335220029444.jpg" alt=""></p><p>花上一天的时间来总结 C++ primer 里面的算法以及容器这一章，多余的用法可以上网去查找当做是相应的扩展。</p><h2 id="字符串-string与字符数组"><a href="#字符串-string与字符数组" class="headerlink" title="字符串 string与字符数组"></a>字符串 string与字符数组</h2><ul><li><p><strong>构造<code>string</code>的方法</strong><br><img src="/2018/12/01/STL的简单总结/15335169766308.jpg" alt=""></p></li><li><p><strong>操作<code>string</code>的方法</strong></p></li></ul><p><img src="/2018/12/01/STL的简单总结/15335172798374.jpg" alt=""><br><img src="/2018/12/01/STL的简单总结/15335172954262.jpg" alt=""><br>上面的成员函数有的说要返回，同时，有的也存在不返回值。</p><ul><li><strong>搜索<code>string</code>的方法</strong></li></ul><p><img src="/2018/12/01/STL的简单总结/15335179836529.jpg" alt=""></p><p><img src="/2018/12/01/STL的简单总结/15335179990314.jpg" alt=""></p><p>以上就是find函数的一些用法，在泛型算法一章，还会继续涉及到。<br><strong>题目返回的是下标</strong></p><p>补充一下关于<code>string</code>中的比较函数<br><img src="/2018/12/01/STL的简单总结/15335183199373.jpg" alt=""><br>一般在string中可以直接用运算符进行比较</p><ul><li><strong><code>int</code>与<code>string</code>之间的转化</strong></li></ul><p><img src="/2018/12/01/STL的简单总结/15335184125849.jpg" alt=""></p><ul><li><strong><code>getline()</code>的两种写法</strong><br><img src="/2018/12/01/STL的简单总结/15334343361243.jpg" alt=""><br>注意在<code>cin&gt;&gt;t</code>;必须要一个<code>getchar()</code>来吞掉其前面的回车符号。<br>之后才能用<code>getline()</code>。</li></ul><h2 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h2><ul><li><strong>容器种类</strong><br><img src="/2018/12/01/STL的简单总结/15334679972152.jpg" alt=""></li></ul><p><code>vector&lt;vector&lt;int&gt; &gt;</code>来表示二维数组。</p><ul><li><strong>容器基础操作</strong><br><img src="/2018/12/01/STL的简单总结/15334684459041.jpg" alt=""><br>补充一个assign的用法：<br>允许从一个不同但相容的类型里面去赋值，或者从容器的一个子序列赋值。</li></ul><p><img src="/2018/12/01/STL的简单总结/15334692047908.jpg" alt=""><br>还有第二个版本：<br>接受一个整型值和一个元素值，用指定数目且具有相同给定元素替换容器中原有的元素：<br><img src="/2018/12/01/STL的简单总结/15334693472336.jpg" alt=""></p><p>再补充一个resize的用法：<br><img src="/2018/12/01/STL的简单总结/15335166722769.jpg" alt=""></p><p>需要记住有一些类型声明可以直接用<code>auto</code>。</p><p>初始化有两种一种<strong>直接初始化</strong>和<strong>拷贝初始化</strong>。</p><ul><li><strong>顺序容器添加元素</strong><br><img src="/2018/12/01/STL的简单总结/15334697068572.jpg" alt=""><br>上面已经列出了各种形式的插入。<br>插入是在迭代器指向的元素之前插入。插入想要插入的元素前面，比如说<code>push_back</code>是插入到了尾后迭代器的前面。<br>而返回的是新添加的第一个元素的迭代器，同样也可也==不返回==。</li></ul><p>这里要注意的是<code>push_front</code>会改变整个容器的迭代器指向，而<code>push_back</code>不会。</p><ul><li><strong>访问元素</strong></li></ul><p><img src="/2018/12/01/STL的简单总结/15334703127503.jpg" alt=""></p><p>链表，单向链表，栈，队列都不支持随机访问，也就不支持下标访问了。</p><ul><li><strong>删除元素</strong><br><img src="/2018/12/01/STL的简单总结/15334705958004.jpg" alt=""></li></ul><p>删除的是迭代器指向的元素，返回的是删除元素的后迭代器也就是被删除的元素下一个元素的前面的迭代器，同样也可以不返回。</p><p><em>这里需要注意的就是删除一个元素之后，必定会改变原容器中迭代器的指向，所以务必小心（除了<code>pop_back</code>）</em></p><ul><li><strong>改变容器大小的操作</strong></li></ul><p><img src="/2018/12/01/STL的简单总结/15335167464723.jpg" alt=""></p><ul><li><strong>特殊的forward_list（单向链表）</strong></li></ul><p><img src="/2018/12/01/STL的简单总结/15334712839686.jpg" alt=""></p><p>由于迭代器的添加删除操作都涉及到了首前和尾后，所以对于单向链表来说这里添加了一个首前迭代器<code>before_begin</code><br>而对于单向链表的插入而言 是在元素的后面进行插入，删除也是一样，指向都是迭代器指向元素之后的元素。</p><h2 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h2><p><img src="/2018/12/01/STL的简单总结/15335188187528.jpg" alt=""></p><ul><li>**关联容器里面的<code>pair</code></li></ul><p><img src="/2018/12/01/STL的简单总结/15335191398555.jpg" alt=""></p><ul><li><strong>关联容器的操作</strong></li></ul><p><img src="/2018/12/01/STL的简单总结/15335192848295.jpg" alt=""></p><ul><li><strong>关联容器的添加操作</strong></li></ul><p><img src="/2018/12/01/STL的简单总结/15335195440945.jpg" alt=""></p><p>一般都是直接用下标操作添加<code>map</code>里面的操作。<br><code>at</code>操作只能判断存不存在</p><ul><li><strong>关联容器的删除操作</strong></li></ul><p><img src="/2018/12/01/STL的简单总结/15335202245929.jpg" alt=""></p><ul><li><strong>关联容器的访问操作</strong></li></ul><p><img src="/2018/12/01/STL的简单总结/15335205177307.jpg" alt=""><br>上面关于排序的操作不适用于无序的关联容器。</p><p><strong>当允许关键词重复的multimap中查找元素时，一般使用find函数与count函数同时进行。</strong></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>大部分函数算法都放在<code>&lt;algorithm&gt;</code>的头文件里面了。<br>还有一些数值算法是放在了<code>&lt;numeric&gt;</code>的头文件里面。</p><ul><li><strong>只读算法</strong></li></ul><p>accumulate 求和算法，接受三个参数，前面两个参数是累加范围，第三个是和的初值。<br>equal 判断两个序列里面是否所有的值都相同。<br>后面网上查找 有的再补充。<br>find算法<br>binary_search()二分查找函数<br>find_end()最后一次出现算法<br>find_first_of()第一次出现的算法<br>find_if ()第三个参数就为自定义函数搜索<br>lower_bound()第一个不小于的元素<br>upper_bound()第一个大于的元素<br>count（）算法 计算出现次数<br>count_if（）函数自定义计数</p><ul><li><strong>写容器的算法</strong></li></ul><p>fill 填充算法 类似于memset函数前者在于可以赋值赋任何值，而后者理论上只能赋值0或者1或者0x3f3f3f3f。<br>fill_n也是三个参数，第一个是开始点，第二个是赋值数目，第三个为赋值初始化。<br>copy 拷贝算法，接收三个迭代器，前面两个表示输入范围，第三个为拷贝目标序列的起点。<br>replace 替换算法，将目标序列里面的某些值更改成某些值，接受四个参数，前面两个是目标序列的范围，第三个是要搜索的值，第四个是要将搜索到的第三个的值更改后的值。<br>remove 去除掉函数里面包括的参数的元素。<br>remove_if 自定义。<br>remove_copy 拷贝结果。<br>swap（）交换两个对象的值。<br>swap_range()交换两个序列的值。</p><ul><li><strong>重排容器的算法</strong></li></ul><p>其排序的算法中，定义的排序方式就在于自定义函数传入算法中。<br>有三种自定义函数：</p><ol><li>普通bool型自定义函数，比较排列顺序。</li><li>lambda 匿名小函数。</li><li>bind 函数 绑定谓词。灵活的应用自定义函数。</li></ol><p>unique 将容器中所有重复的值全部排列到后面去，接受目标序列的迭代器范围，返回指向第一个重复元素的迭代器。<br>sort 排序 本质上运用的是快速排序。<br>stable_sort 本质上运动的是归并排序。<br>stable_partition 前面进行排序后，把自定义排列的分割开来。<br>reverse 倒排函数。<br>reverse_copy 倒排函数。<br>rotate 接受三个参数，前面两个是要往后面排的范围。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul><li><p><strong>插入迭代器</strong><br>back_inserter 类似于push_back的迭代器，创建并且使用<br>front_inserter 创建并且使用一个push_front的迭代器<br>inserter 创建一个普通插入的迭代器</p></li><li><p><strong>流迭代器</strong><br>istream_iterator 输入迭代器<br><img src="/2018/12/01/STL的简单总结/15335260532129.jpg" alt=""></p></li></ul><p>ostream_iterator 输出迭代器<br><img src="/2018/12/01/STL的简单总结/15335260817218.jpg" alt=""></p><ul><li><strong>反向迭代器</strong><br>reverse_iterator</li><li><strong>移动迭代器</strong><br>后面复习到在总结 移动、拷贝、右值引用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二分法思想</title>
      <link href="/2018/12/01/%E4%BA%8C%E5%88%86%E6%B3%95%E6%80%9D%E6%83%B3/"/>
      <url>/2018/12/01/%E4%BA%8C%E5%88%86%E6%B3%95%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>实现在单调有序的集合中查找元素，每次江集合分为左右两个部分，并且通过判断集合在哪个部分从而调整集合的上下界，重复知道找到目标元素为止。</p><p>举一个简单的例子，我要在1到100里面查找62，先拿62根这个其最中间的一个数进行比较。然后在一步一步的缩小集合的上下界，最后再来一步一步往里面缩</p><p><strong>下面是C++STL里面二分查找的函数：</strong></p><blockquote><p>binary_search  返回bool值,是否存在<br>lower_bound    返回可插入的最小位置的迭代器                                                                  即返回第一个符合条件的元素位置<br>upper_bound    返回可插入的最大位置的迭代器<br>               即返回最后一个符合条件的元素位置</p></blockquote><p>在二分查找里面最典型的题目就是二分逼近求方程式的根了。</p><p><img src="/2018/12/01/二分法思想/15333828636681.jpg" alt=""></p><p><strong>代码如下</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pre =<span class="number">1e-4</span>;</span><br><span class="line"><span class="keyword">double</span> x,y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">8</span>*<span class="built_in">pow</span>(x,<span class="number">4</span>)+<span class="number">7</span>*<span class="built_in">pow</span>(x,<span class="number">3</span>)+<span class="number">2</span>*<span class="built_in">pow</span>(x,<span class="number">2</span>)+<span class="number">3</span>*x+<span class="number">6</span>-y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;y;</span><br><span class="line">        <span class="keyword">double</span> x1=<span class="number">0</span>,x2=<span class="number">100</span>;<span class="comment">//先把上下界在这里确定好</span></span><br><span class="line">        <span class="keyword">double</span> mid=(x1+x2)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (f(x1)*f(x2)&gt;<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"No solution!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (x2-x1&gt;=pre)&#123;<span class="comment">//这里必须写的是上下界线是多少，</span></span><br><span class="line">            不能写的是用于判断mid的条件。</span><br><span class="line">                <span class="keyword">if</span> (f(x1)*f(mid)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    x2=mid;</span><br><span class="line">                    mid=(x1+x2)/<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    x1=mid;</span><br><span class="line">                    mid=(x1+x2)/<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">4</span>)&lt;&lt;mid&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面就是我第二次出错的地方，判断二分循环逼近的的条件不应该看mid的取值，而是应该看得是区间上界减去区间下界的范围从而来限定。</p><p>此处关于三分法的求解：<br>当需要求某凸性或凹形函数的极值，通过函数本身表达式并不容易求解时，就可以用三分法不断逼近求解。</p><p>三分法——求解凸性函数的极值问题<br><a href="http://hi.baidu.com/vfxupdpaipbcpuq/item/81b21d1910ea729c99ce33db" target="_blank" rel="noopener">http://hi.baidu.com/vfxupdpaipbcpuq/item/81b21d1910ea729c99ce33db</a></p><p>经典例题：<br>侵略的奶牛：<br><img src="/2018/12/01/二分法思想/15334016401434.jpg" alt=""></p><p><strong>代码如下：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn],n,c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此过程就是在判断奶牛之间的间隔为这个值合不合适</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cc</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=a[<span class="number">0</span>],cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i!=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i]-t&gt;=d)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            t=a[i];</span><br><span class="line">            <span class="keyword">if</span> (cnt&gt;=c)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此过程就是在收录每一个值，然后再分别进行判断</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,y=a[n<span class="number">-1</span>]-a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span> (x&lt;=y)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(x+y)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (cc(mid))    x=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>    y=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不过这种最大值最小值的题目需要多花时间想想。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;c)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=n;i++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        sort(a,a+n);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;solve()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>==下面则是其他地方关于二分的题目==<br><strong>基础版</strong></p><blockquote><p>POJ 3122 Pie<br>  二分枚举区间是实数<br>POJ 1064 Cable master<br>    二分枚举区间是实数,注意精度<br>POJ 3258 River Hopscotch<br>     最大化最小值<br>POJ 3273 Monthly Expense<br>    最小化最大值<br>LIGHTOJ 1076 Get the Containers<br>    最小化最大值，。和上一个差不多<br>LIGHTOJ 1307 Counting Triangles </p></blockquote><p><strong>进阶版</strong></p><blockquote><p>POJ 3579      二分搜索+二分查找<br>POJ 3685      二分搜索+二分查找<br>ZOJ 3278      也是两个二分嵌套<br>LIGHTOJ 1048<br>和LightOJ 1076一样，不过要输出一组解<br>LIGHTOJ 1383    二分加贪心（区间）<br>ZOJ 3665 某年区域赛题。，二分枚举<br>ZOJ 3726 去年区域赛题，二分查找<br>codeforces 382B 有意思的题<br>codeforces 391D2 难，。。，，、</p></blockquote><p>==下面就是关于三分的题目==</p><blockquote><p>poj3301<br>hdu4454<br>hdu3714<br>hdu2438</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> c++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条款01：视 C++ 为一个语言联邦</title>
      <link href="/2018/12/01/%E6%9D%A1%E6%AC%BE01%EF%BC%9A%E8%A7%86%20C++%20%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6/"/>
      <url>/2018/12/01/%E6%9D%A1%E6%AC%BE01%EF%BC%9A%E8%A7%86%20C++%20%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>现在发展的C++已经是一个多重泛型编程语言。</p><hr><p>一个同时<strong>支持过程形式</strong>、<strong>支持面向对象形式</strong>、<strong>函数形式</strong>、<strong>泛型形式</strong>、<strong>元编程形式的语言</strong>，这些能力和弹性使 C++成为了一个无可匹敌的工具。<br>对待其的方式最简单的方法是将其看做是一个由相关语言组成的一个联邦而不是某个次语言。</p><ol><li><p><strong><em>C</em></strong> 说到底 C++ 仍然是 C 的一个延伸，面对过程的编程思想仍然在某些时候很受用，而某些时刻 C++ 的解法只不过就是比 C 高级了一点点，但是当你以 C++的内 C 成分的工作的时候，高效编程则映照出了 C 语言的局限，没有模板，没有异常，没有重载。</p></li><li><p><strong><em>Object-Oriented C++</em></strong> 这部分也就是 C++ 中面对对象编程思想的直接体现，简单来说就是 C with class 比如 类，封装，继承，多态，虚函数的动态绑定。</p></li><li><p><strong><em>Template C++</em></strong> 这是 C++中的泛型编程部分，template 的相关考虑与设计已经弥漫了整个 C++ 而这种编程思想的强大，直接带来了全新的名字 模板元编程，后面得花上大部分时间去专研这个。</p></li><li><p><strong><em>STL</em></strong> 基本上包括 容器，迭代器，算法以及相应的函数对象，一般竞赛可能会直接用到里面的相关容器以及相关算法，熟练使用 STL 也是一名 C++ 程序员应该必备的素质。</p></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> effective C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条款02：尽量以const,enum,inline 替换掉#define</title>
      <link href="/2018/12/01/%E6%9D%A1%E6%AC%BE02%EF%BC%9A%E5%B0%BD%E9%87%8F%E4%BB%A5const,enum,inline%20%E6%9B%BF%E6%8D%A2%E6%8E%89#define/"/>
      <url>/2018/12/01/%E6%9D%A1%E6%AC%BE02%EF%BC%9A%E5%B0%BD%E9%87%8F%E4%BB%A5const,enum,inline%20%E6%9B%BF%E6%8D%A2%E6%8E%89#define/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="这个条款其实也就相当于宁可编译器替换预处理器比较好"><a href="#这个条款其实也就相当于宁可编译器替换预处理器比较好" class="headerlink" title="这个条款其实也就相当于宁可编译器替换预处理器比较好"></a><strong>这个条款其实也就相当于宁可编译器替换预处理器比较好</strong></h3><hr><h4 id="1-对于单纯常量而言，使用-const-对象或者是-enums-比-define-更加省时间"><a href="#1-对于单纯常量而言，使用-const-对象或者是-enums-比-define-更加省时间" class="headerlink" title="1. 对于单纯常量而言，使用 const 对象或者是 enums 比 #define 更加省时间"></a>1. 对于单纯常量而言，使用 const 对象或者是 enums 比 #define 更加省时间</h4><ul><li>时间上更为节省 作为一个语言常量而不是名称记号，由于在函数体中分配了内存，追寻起来消耗的时间比在函数中使用名称记号所花的时间更少，因为有实处更容易寻找，不像名称记号，可能有的时候并没有进入到记号表中。</li><li>还有一些其他的只能使用 const 情况 定义常量指针和类的专属常量</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> effective C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条款03：尽可能使用 const</title>
      <link href="/2018/12/01/%E6%9D%A1%E6%AC%BE03%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8%20const/"/>
      <url>/2018/12/01/%E6%9D%A1%E6%AC%BE03%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8%20const/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先使用 const 可以防止后期莫名其妙的进行改变原有的意思，相当于一个约束语义，另外编译器不论什么时候都会强制施行这项约束。</p><ol><li><p>const 在 C++ 11 中有底层和顶层之分，前者是作用于指针本身，指针不再改变指向对象，而顶层 const 则<br>是指针所指向的对象则不能发生改变。</p></li><li><p>const 最具威力的用法实在面对函数声明时的用法，在一个函数的声明式里，const 可以和函数的返回值，各自的参数以及函数自身产生关联。</p></li><li><p>将引用参数设置成 const 好处是在后面写代码的过程中如果把==写成=，可以立马甄别出来。</p></li><li><p>const 成员函数存在的两个理由，一个使 class 的接口一目了然，因为知道了哪些可以被改动对象而哪些不可以被改动对象，第二则是基于代码编写的高效性而言，操作 const 对象成为可能，因为可以通过 const 成员函数返回 const 对象。</p></li><li><p>存在一种特殊情况，重载[ ]运算符的时候，如果成员函数是 const 那么其的返回值也必须是 const&amp;类型的。</p></li><li><p>如果对于const 成员函数，想要改变该对象的内部成员的话，但是又不想全部改变的话，可以在类中的数据成员定义中加上 mutable，来保证可以改变该函数，其存在的意义就在于保证了其他数据成员不能被 const 成员函数改变，但是该数据成员却可以。</p></li></ol><p>7.当 const 和 non-const 成员函数有实质等价的实现时，令 non-const 版本调用 const 版本可避免代码重复。     </p><p><strong><em>这一点还不是特别了解，需要看到后面之后花点时间来看看这一点的内容。</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> effective C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条款05：了解 C++默默编写并调用了哪些函数</title>
      <link href="/2018/12/01/%E6%9D%A1%E6%AC%BE05%EF%BC%9A%E4%BA%86%E8%A7%A3%20C++%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0/"/>
      <url>/2018/12/01/%E6%9D%A1%E6%AC%BE05%EF%BC%9A%E4%BA%86%E8%A7%A3%20C++%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>几乎每一个 class 都会用一个或多个构造函数，一个析构函数，一个拷贝重载运算符，有些是系统自动生成的合成版本，有些是需要自定义的版本，所以这一条款的目的是为了探寻哪些是需要自己去写，哪一些是需要系统自身合成的。</p><ol><li><p>千万不要写完构造函数或者拷贝构造函数或者是析构函数之后不去定义，那么会造成问题，而且此类问题会造成很多方面上的无法适应问题。</p></li><li><p>另外这里额外需要注意的是 C++11上增加的移动语义，只有在拥有了拷贝构造函数和拷贝赋值运算符之后，编译器才会自动生成移动构造函数，和移动赋值运算符。</p></li><li><p>最后这个条款需要注意的就是编译器自动生成的函数具有普遍性，所以就不具有特异性，一些特殊的操作在合成版本上面可能会出现大问题。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> effective C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条款04：确定对象被使用前已先被初始化</title>
      <link href="/2018/12/01/%E6%9D%A1%E6%AC%BE04%EF%BC%9A%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2018/12/01/%E6%9D%A1%E6%AC%BE04%EF%BC%9A%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="在-C-语言中对象的初始化可能会变得异常容易，但是在-C-中某些语境下进行对象可能不会存在自动的初始化过程，也许会在使用-C-part-of-C-会自动有一个初始化过程，但是在其他部分下面的-C-就不能保证初始化过程了。"><a href="#在-C-语言中对象的初始化可能会变得异常容易，但是在-C-中某些语境下进行对象可能不会存在自动的初始化过程，也许会在使用-C-part-of-C-会自动有一个初始化过程，但是在其他部分下面的-C-就不能保证初始化过程了。" class="headerlink" title="在 C 语言中对象的初始化可能会变得异常容易，但是在 C++中某些语境下进行对象可能不会存在自动的初始化过程，也许会在使用 C part of C++ 会自动有一个初始化过程，但是在其他部分下面的 C++就不能保证初始化过程了。"></a>在 C 语言中对象的初始化可能会变得异常容易，但是在 C++中某些语境下进行对象可能不会存在自动的初始化过程，也许会在使用 C part of C++ 会自动有一个初始化过程，但是在其他部分下面的 C++就不能保证初始化过程了。</h4><ol><li><p>特别是在类的过程中，初始化的过程一般直接交给构造函数，初始化的过程并不等同于赋值，所以在写类的构造函数的时候，尽量不要在函数体里面写赋值给私有成员的语句，可以直接在列表上面直接写初始化的。</p></li><li><p>对于拥有多个构造函数，且每个构造函数具有自己的成员初值列，如果这些类存在许多成员变量或者基类的话，多种成员初始列表就会导致不受欢迎的重复，那么这个时候可以遗漏一些“赋值跟初始化过程差不读的成员变量”，改用他们的赋值操作，并且把这些操作放置在 private 中。</p></li><li><p>C++有着十分固定的成员初始化过程，基类的初始化会早于派生类，而类的成员变量总是以其声明的次序被初始化。</p></li><li><p>关于类的静态成员的初始化 一般在类内部进行声明，然后再类的外部进行定义，赋值，其的声明周期一般是从程序开始到程序结束。</p></li><li><p>构造函数初始化的次序非常重要，举个例子就是初始化的时候必须要为数组指定大小，所以指定大小的变量必须具有先值</p></li><li><p>对于不同人在不同时间下不同的源码文件建立起来，其的初始化相对次序并没有明确定义，所以解决办法就是将一个对象搬到自己的专属函数里面去，然后声明成静态成员，并且返回一个引用即可，后面用户直接调用这些函数，就可以无视初始化的次序问题了。具体可以看书里面P32面的相关代码。</p></li><li><p>最后总结一句为了免除“跨编译单元之初始化次序”问题，一般用 local static 对象替换 non-local static 对象。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> effective C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条款06：若不想使用编译器自动生成的函数，就应该明确拒绝</title>
      <link href="/2018/12/01/%E6%9D%A1%E6%AC%BE06%EF%BC%9A%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E5%BA%94%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D/"/>
      <url>/2018/12/01/%E6%9D%A1%E6%AC%BE06%EF%BC%9A%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E5%BA%94%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="有的时候鉴于某些情况，比如智能指针中-unique-str-和-io-库对象无法发生拷贝和赋值，是因为明确在类的内部进行了拒绝操作，所以无法拷贝与赋值，这一个条款就来讲解有哪些方法可以用来拒绝。"><a href="#有的时候鉴于某些情况，比如智能指针中-unique-str-和-io-库对象无法发生拷贝和赋值，是因为明确在类的内部进行了拒绝操作，所以无法拷贝与赋值，这一个条款就来讲解有哪些方法可以用来拒绝。" class="headerlink" title="有的时候鉴于某些情况，比如智能指针中 unique_str 和 io 库对象无法发生拷贝和赋值，是因为明确在类的内部进行了拒绝操作，所以无法拷贝与赋值，这一个条款就来讲解有哪些方法可以用来拒绝。"></a>有的时候鉴于某些情况，比如智能指针中 unique_str 和 io 库对象无法发生拷贝和赋值，是因为明确在类的内部进行了拒绝操作，所以无法拷贝与赋值，这一个条款就来讲解有哪些方法可以用来拒绝。</h4><ol><li><p>把自己不想要的函数，但是系统默认又会生成的函数放到私有成员中，这种方法很简便，但是有一个缺点就是在类的内部定义中仍然是可以使用拷贝与赋值功能的。</p></li><li><p>继承一个基类，使用 private 继承方法，然后将这个基类的函数放入私有成员中，这样就可以保证万无一失的方法，但是缺点就是太复杂，还需要定一个基类。</p></li><li><p>C++11 提出的新办法将函数声明出来，不仅不去定义，而且直接声明成 delete。这样更便捷。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> effective C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于STL里面函数简单的应用</title>
      <link href="/2018/12/01/%E5%85%B3%E4%BA%8ESTL%E9%87%8C%E9%9D%A2%E5%87%BD%E6%95%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2018/12/01/%E5%85%B3%E4%BA%8ESTL%E9%87%8C%E9%9D%A2%E5%87%BD%E6%95%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2018/12/01/关于STL里面函数简单的应用/15334646368898.jpg" alt=""></p><p><strong>代码如下：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line">    s.insert(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i!=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这道题目的主要做法是记住几个upper_bound 的STL函数</span></span><br><span class="line">        <span class="keyword">if</span>(t &lt; *s.rbegin()) &#123;</span><br><span class="line">            s.erase(*(s.upper_bound(t)));</span><br><span class="line">        &#125;</span><br><span class="line">        s.insert(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> c++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条款08：别让异常逃离析构函数</title>
      <link href="/2018/12/01/%E6%9D%A1%E6%AC%BE08%EF%BC%9A%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
      <url>/2018/12/01/%E6%9D%A1%E6%AC%BE08%EF%BC%9A%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实这一项条款没有领悟的很深刻，可以理解成不要再析构函数里面写捕获异常之类的代码。因为某些时候，如果在析构函数里面抓获异常导致程序终止的话，那么就可能造成对象不能完全被销毁</p><ol><li><p>析构函数绝对不要吐出异常，如果一个被析构函数调用的函数可能抛出异常的话，析构函数应该做的应该是捕捉任何异常，然后吞下他们（不传播）或者结束程序。</p></li><li><p>如果对象需要对摸个操作函数运行期间抛出的异常做出反应，那么 class 应该提供一个普通函数（不应该在析构函数里面）执行该任务。但是该析构函数里面仍然要进行双保险的析构过程，可以在类的内部定义里面加上一个 bool 变量来判断到底有没有运行析构行为，相当于一般写程序的一个 flag。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> effective C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条款09：绝不在构造和析构的过程中调用 virtual 函数</title>
      <link href="/2018/12/01/%E6%9D%A1%E6%AC%BE09%EF%BC%9A%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8%20virtual%20%E5%87%BD%E6%95%B0/"/>
      <url>/2018/12/01/%E6%9D%A1%E6%AC%BE09%EF%BC%9A%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8%20virtual%20%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="绝对不要在构造函数和析构函数期间调用虚函数，因为这样调用的结果不会带来预想的结果。"><a href="#绝对不要在构造函数和析构函数期间调用虚函数，因为这样调用的结果不会带来预想的结果。" class="headerlink" title="绝对不要在构造函数和析构函数期间调用虚函数，因为这样调用的结果不会带来预想的结果。"></a>绝对不要在构造函数和析构函数期间调用虚函数，因为这样调用的结果不会带来预想的结果。</h4><ol><li><p>基类构造函数的时候，虚函数是不会下降到派生类中，原因就是在基类开始构造函数的时候，该类的类型是基类，而不是派生类，简单来说，如果想在构造函数的过程中，直接使用基类的虚函数来折射到派生类，从而帮助派生类完成构造的话，那么这种办法一定行不通。</p></li><li><p>相同的道理同上，在基类析构函数发生的过程中，同样将其他的派生类视作未定义。</p></li><li><p>如果将构造函数或者析构函数调用的函数设立成纯虚函数的话，那么当纯虚函数被调用的时候，大多数执行系统会直接终止程序，唯一避免的此问题的做法就是确定构造和析构期间没有调用虚函数。</p></li><li><p>唯一的替代方案是不设置虚函数，比如在构造一个派生类对象的时候，需要直接调用基类函数的构造函数，然后再完成派生类的构造，而此时最好是将派生类里面一个作用于构造函数的一个成员函数定义成静态函数，这样的话就能在程序刚开始就存在该函数了。</p></li><li><p>由第四点换句话说，你无法使用虚函数直接从基函数向下调用，但是在基类函数中可以由派生类将信息传递到基类从而进行有效调用。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> effective C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条款10：令 operator= 返回一个 自身的返回</title>
      <link href="/2018/12/01/%E6%9D%A1%E6%AC%BE10%EF%BC%9A%E4%BB%A4%20operator=%20%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%20%E8%87%AA%E8%BA%AB%E7%9A%84%E8%BF%94%E5%9B%9E/"/>
      <url>/2018/12/01/%E6%9D%A1%E6%AC%BE10%EF%BC%9A%E4%BB%A4%20operator=%20%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%20%E8%87%AA%E8%BA%AB%E7%9A%84%E8%BF%94%E5%9B%9E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一般重载赋值运算符号的时候一般都会返回一个自身的引用，这样可以更方面操作自身，如果仅仅只是返回一个拷贝的对象的话，那么将会在连续使用运算符的时候发生错误，而且在一些较大的类型的话，可能速度会慢些，所以一般返回自身的引用。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> effective C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条款11：在 operator 中处理自我赋值的情况</title>
      <link href="/2018/12/01/%E6%9D%A1%E6%AC%BE11%EF%BC%9A%E5%9C%A8operator%E4%B8%AD%E5%A4%84%E7%90%86%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E7%9A%84%E6%83%85%E5%86%B5/"/>
      <url>/2018/12/01/%E6%9D%A1%E6%AC%BE11%EF%BC%9A%E5%9C%A8operator%E4%B8%AD%E5%A4%84%E7%90%86%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E7%9A%84%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="本来是可以不用担心拷贝过程中发生自我赋值的情况，但是就是为了防止用户，或者对象自身的这种情况，所以需要完成避免自赋值的情况"><a href="#本来是可以不用担心拷贝过程中发生自我赋值的情况，但是就是为了防止用户，或者对象自身的这种情况，所以需要完成避免自赋值的情况" class="headerlink" title="本来是可以不用担心拷贝过程中发生自我赋值的情况，但是就是为了防止用户，或者对象自身的这种情况，所以需要完成避免自赋值的情况"></a>本来是可以不用担心拷贝过程中发生自我赋值的情况，但是就是为了防止用户，或者对象自身的这种情况，所以需要完成避免自赋值的情况</h4><ol><li><p>比如两个指针对象进行自赋值的时候，为了防止多次删除，需要检查一下自赋值的情况。</p></li><li><p>同时不仅要考虑的是自我赋值的安全性，仍然需要考虑的是异常的安全，也就是前者是需要判断如果前者的地址等于后者的地址话 就直接返回不作为，并且先删除原本的，再赋值新的，而后者则是先构造一个对象赋值给另外一个，然后先赋值，再删除。</p></li></ol><p><img src="/2018/12/01/条款11：在operator中处理自我赋值的情况/1.png" alt=""></p><p>就类似于这样，这样既能保证自赋值的情况，但是又能保证异常安全，不会在new对象的时候发生错误。</p><ol start="3"><li><p>还要记住的是一般在移动赋值运算符的时候也应该注意一下自赋值的情况，不过上面的异常安全很少涉及到，因为上面的相比于前者更费点时间。</p></li><li><p>或者是直接使用自定义的 swap 功能，这样的话对于自赋值的情况以及异常安全的情况来比，更加省事和高效。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> effective C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条款12：复制对象时勿忘其每一个成分</title>
      <link href="/2018/12/01/%E6%9D%A1%E6%AC%BE12%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%8B%BF%E5%BF%98%E5%85%B6%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%88%90%E5%88%86/"/>
      <url>/2018/12/01/%E6%9D%A1%E6%AC%BE12%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%8B%BF%E5%BF%98%E5%85%B6%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%88%90%E5%88%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这个条款而言，是无论类发生什么样的内部变化，都必须重写类的管理行为。<br>下面直接分为两个方面进行诠释：</p><ol><li><p>类的内部增加或者减少数据成员，如果未重新编写构造函数的话，那么编译器也不会提醒，这样就会造成不太被需要的局部拷贝。</p></li><li><p>一旦发生继承，如果还是按照以前的方法仅仅是对函数内部的所有数据成员进行拷贝的是不对的，因为派生类不仅仅是包含着派生类的部分，还仍然包含着基类的部分，所以需要调用基类的拷贝行为，如下图：<br><img src="/2018/12/01/条款12：复制对象时勿忘其每一个成分/2.png" alt=""></p></li><li><p>另外拷贝构造函数定义内部是不能直接调用赋值运算符，反之亦然，前者就相当于对一个尚未构造好的对象进行赋值，而后者就相当于对一个已经构造对象再进行重新构造。所以千万不要这么做。</p></li><li><p>如果发现两个拷贝行为有类似的代码时，应该把这个相同的代码放到一个函数中区，然后由两个拷贝行为共同调用。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> effective C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条款13：以对象管理资源</title>
      <link href="/2018/12/01/%E6%9D%A1%E6%AC%BE13%EF%BC%9A%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90/"/>
      <url>/2018/12/01/%E6%9D%A1%E6%AC%BE13%EF%BC%9A%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="系统资源的管理规则就是，一旦使用完毕，那么就一定要归还给系统，免得造成内存泄漏的问题，而-C-中需要自己去管理内存，那么为了防止在对象销毁以及内存释放之间发生异常，以及某些其他原因，一种新的基于对象的资源管理办法就应运而生。"><a href="#系统资源的管理规则就是，一旦使用完毕，那么就一定要归还给系统，免得造成内存泄漏的问题，而-C-中需要自己去管理内存，那么为了防止在对象销毁以及内存释放之间发生异常，以及某些其他原因，一种新的基于对象的资源管理办法就应运而生。" class="headerlink" title="系统资源的管理规则就是，一旦使用完毕，那么就一定要归还给系统，免得造成内存泄漏的问题，而 C++中需要自己去管理内存，那么为了防止在对象销毁以及内存释放之间发生异常，以及某些其他原因，一种新的基于对象的资源管理办法就应运而生。"></a>系统资源的管理规则就是，一旦使用完毕，那么就一定要归还给系统，免得造成内存泄漏的问题，而 C++中需要自己去管理内存，那么为了防止在对象销毁以及内存释放之间发生异常，以及某些其他原因，一种新的基于对象的资源管理办法就应运而生。</h4><ol><li><p>使用智能指针， C++11之后智能指针分为三种一种是 share_ptr 指针 智能型的应用计数，共享底层数据。weak_ptr 依附于 share_ptr 作为一种核查类指针存在，最后就是 unique_ptr 指针，仅仅只是为了对象的析构函数自动销毁，上述两种主要的智能指针可以定义自己的删除器（析构函数）</p></li><li><p>获得资源后立刻放到管理对象中，其所代表的观念就是 “资源取得的时机，就是直接初始化的时机”。</p></li><li><p>需要注意的就是智能指针默认的删除器是不能删除固定的连续内存空间，意思就是说，需要自定义的删除器才能完成 delete[]。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> effective C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条款14：在资源管理类中小心拷贝行为</title>
      <link href="/2018/12/01/%E6%9D%A1%E6%AC%BE14%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83%E6%8B%B7%E8%B4%9D%E8%A1%8C%E4%B8%BA/"/>
      <url>/2018/12/01/%E6%9D%A1%E6%AC%BE14%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83%E6%8B%B7%E8%B4%9D%E8%A1%8C%E4%B8%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="一般在自定义类中会遇到多种多样的拷贝行为，所以一般会采取下面的一些策略"><a href="#一般在自定义类中会遇到多种多样的拷贝行为，所以一般会采取下面的一些策略" class="headerlink" title="一般在自定义类中会遇到多种多样的拷贝行为，所以一般会采取下面的一些策略"></a>一般在自定义类中会遇到多种多样的拷贝行为，所以一般会采取下面的一些策略</h4><ol><li><p><strong>禁止复制</strong> 向前面条款06一样，有多种办法，一般对于那些逻辑上拷贝不合理的函数。</p></li><li><p><strong>对底层数据的共享控制</strong> 那么此处这就需要使用智能指针 share_ptr，或者自定义引用计数。并且拥有自定义的删除器，因为某些类的删除操作并不一定是释放内存、销毁对象。</p></li><li><p><strong>转移底部资源的拥有权</strong> 移动操作，C++11 右值引用的移动过程。</p></li><li><p><strong>复制分为浅层复制以及深层复制</strong> 前者是复制其的指针或者引用，达到共享资源的目的，这个时候使用 share_ptr 来进行控制，后者赋值的是全部内存，最好是用 unique_ptr 来保管，但是复制操作得把每一个对象所指向的对象进行拷贝之后，放进 unique_ptr 中进行管理。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> effective C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条款15：在资源管理类中提供对原始资源的访问</title>
      <link href="/2018/12/01/%E6%9D%A1%E6%AC%BE15%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE/"/>
      <url>/2018/12/01/%E6%9D%A1%E6%AC%BE15%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一般使用了智能指针之后就不会在建议使用内置指针，以免发生错乱，但是就是有一些类需要在使用智能指针的过程中需要返回内置指针来完成某些函数的参数传递过程，但是需要注意的一点就是</p><p>在使用内置指针的过程中 千万不需要 delete，直接让智能指针进行删除操作。</p><p>另外除了返回内置指针这种方式来进行对原始资源的访问，还有一种方法就是重载隐式转换运算符，来完成类到资源的转换，但是这样做会加大错误的可能性，因为某些不可控的隐式类型发生转换。</p><p>上述的第一种办法属于显示转换，直接使用 get 获得资源，而下面的那种是隐式转换类型，前者比较安全，后者比较方便。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> effective C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条款16：成对使用new和delete时需要采取相同的形式</title>
      <link href="/2018/12/01/%E6%9D%A1%E6%AC%BE16%EF%BC%9A%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8new%E5%92%8Cdelete%E6%97%B6%E9%9C%80%E8%A6%81%E9%87%87%E5%8F%96%E7%9B%B8%E5%90%8C%E7%9A%84%E5%BD%A2%E5%BC%8F/"/>
      <url>/2018/12/01/%E6%9D%A1%E6%AC%BE16%EF%BC%9A%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8new%E5%92%8Cdelete%E6%97%B6%E9%9C%80%E8%A6%81%E9%87%87%E5%8F%96%E7%9B%B8%E5%90%8C%E7%9A%84%E5%BD%A2%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实我根本不知道这个为什么会成为一个单独的条款<br>鉴于此，所以就简单的讲两句话：</p><ol><li><p>new 一个数组，那么一定要 delete 一个数组</p></li><li><p>智能指针默认没有 delete 数组，所以需要自定义删除器。</p></li></ol><p><img src="/2018/12/01/条款16：成对使用new和delete时需要采取相同的形式/3.png" alt=""></p><p><img src="/2018/12/01/条款16：成对使用new和delete时需要采取相同的形式/4.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> effective C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条款17：以独立语句将new过得对象放入智能指针中</title>
      <link href="/2018/12/01/%E6%9D%A1%E6%AC%BE17%EF%BC%9A%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86-new-%E8%BF%87%E5%BE%97%E5%AF%B9%E8%B1%A1%E6%94%BE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%AD/"/>
      <url>/2018/12/01/%E6%9D%A1%E6%AC%BE17%EF%BC%9A%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86-new-%E8%BF%87%E5%BE%97%E5%AF%B9%E8%B1%A1%E6%94%BE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>编译器的编译次序是说不定的，就想下图的</p><p><img src="/2018/12/01/条款17：以独立语句将-new-过得对象放入智能指针中/5.png" alt=""></p><p>上述的三个次序一旦顺序不对就会发生错误，所以一个最好避免的办法就是想如图所示：</p><p><img src="/2018/12/01/条款17：以独立语句将-new-过得对象放入智能指针中/6.png" alt=""></p><p>先将对象存储在智能指针中（先完成智能指针的构造），在完成对智能指针的调用。</p><h4 id="上述举的例子说明的问题是一定要把对象存入智能指针的过程独立成一个语句"><a href="#上述举的例子说明的问题是一定要把对象存入智能指针的过程独立成一个语句" class="headerlink" title="上述举的例子说明的问题是一定要把对象存入智能指针的过程独立成一个语句"></a>上述举的例子说明的问题是一定要把对象存入智能指针的过程独立成一个语句</h4>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> effective C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条款18：让接口容易被正确使用，不易被误用</title>
      <link href="/2018/12/01/%E6%9D%A1%E6%AC%BE18%EF%BC%9A%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%AE%B9%E6%98%93%E8%A2%AB%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8D%E6%98%93%E8%A2%AB%E8%AF%AF%E7%94%A8/"/>
      <url>/2018/12/01/%E6%9D%A1%E6%AC%BE18%EF%BC%9A%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%AE%B9%E6%98%93%E8%A2%AB%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8D%E6%98%93%E8%A2%AB%E8%AF%AF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="注意类的隐式转换，并且智能指针与内置指针的区别，以及以对象管理的思想来管理资源。"><a href="#注意类的隐式转换，并且智能指针与内置指针的区别，以及以对象管理的思想来管理资源。" class="headerlink" title="注意类的隐式转换，并且智能指针与内置指针的区别，以及以对象管理的思想来管理资源。"></a>注意类的隐式转换，并且智能指针与内置指针的区别，以及以对象管理的思想来管理资源。</h4><hr><ul><li><p>好的接口很容易被正确使用，不容易被误用，应该在接口里面努力达成这些性质。</p></li><li><p>促进正确使用的办法 包括接口的一致性，与其内置类型的行为一致。</p></li><li><p>阻止误用的办法包括建立新类型，限制类型上面的操作，以及束缚对象值，以及消除客户的资源管理责任</p></li><li><p>智能指针支持定制删除器，这样可以防范动态链接程序库的问题</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> effective C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条款19：设计 class 犹如设计 type</title>
      <link href="/2018/12/01/%E6%9D%A1%E6%AC%BE19%EF%BC%9A%E8%AE%BE%E8%AE%A1%20class%20%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1%20type/"/>
      <url>/2018/12/01/%E6%9D%A1%E6%AC%BE19%EF%BC%9A%E8%AE%BE%E8%AE%A1%20class%20%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1%20type/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="一般设计一个优秀的类，实际上也就是设计一个优秀的类型，而往往需要满足下面这些疑问。"><a href="#一般设计一个优秀的类，实际上也就是设计一个优秀的类型，而往往需要满足下面这些疑问。" class="headerlink" title="一般设计一个优秀的类，实际上也就是设计一个优秀的类型，而往往需要满足下面这些疑问。"></a>一般设计一个优秀的类，实际上也就是设计一个优秀的类型，而往往需要满足下面这些疑问。</h4><ul><li><p>新 type 对象应该如何创建和销毁</p><blockquote><p>关系到类的构造函数与析构函数如何建立</p></blockquote></li><li><p>对象的初始化和对象的赋值之间的差别</p><blockquote><p>主要是为了区分构造函数与赋值运算符之间的区别</p></blockquote></li><li><p>该类参数传递中有传值也有传引用</p><blockquote><p>传引用与传值之间的区别，以及如何实现，以及究竟何时会去调用这一类的函数。</p></blockquote></li><li><p>新 type 的和法制</p><blockquote><p>构造这个类的时候一些合法值，要不要对应自己的私有数据成员，或者是类型转换，通常其都会影响构造函数、赋值操作，以及 setter 函数，甚至还会影响到函数抛出的异常。</p></blockquote></li><li><p>是否需要配合某一个继承体系</p><blockquote><p>需要记住的是继承体系的构成一定要满足的是 is - a 的条件，另外虚函数与非虚函数之间的影响，并且还要考虑的时候 是否应该把自己的析构函数也设计成虚函数。</p></blockquote></li><li><p>是否需要类型转换</p><blockquote><p>类型转换一般会分为显式转换和隐式转换，实现方式一般有直接在其中一个函数内些类型转换的重载运算符函数，和没有声明 explicit 的单一参数的构造函数。</p></blockquote></li><li><p>重载的操作符以及其他相应的函数，是否合理</p><blockquote><p>这里看重载的函数是否符合逻辑条件，不仅仅是代码之间的严禁性质，还需要考虑的就是生活层面的实用性。</p></blockquote></li><li><p>哪些成员应该封装？</p><blockquote><p>这里就设计到哪些成员应该设置成私有，而哪一些函数应该设置成公有函数，并且一些不想编译器生成的函数应该定义成删除。</p></blockquote></li><li><p>类型的未声明接口</p><blockquote><p>它对效率、异常安全性以及资源运用提供什么样保证，以及为类的实现代码应该提供什么的约束条件。</p></blockquote></li><li><p>是否应该定义成模板</p><blockquote><p>这里就看类的一般性究竟有多大，是否具有普遍价值。</p></blockquote></li><li><p>考虑是否会继承与其他的类</p><blockquote><p>有的时候考虑过后，也许这个类就不需要凭空创造出，仅仅只是需要从其他类上面派生出来即可。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> effective C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条款20：宁以传 const 引用也不要传值</title>
      <link href="/2018/12/01/%E6%9D%A1%E6%AC%BE20%EF%BC%9A%E5%AE%81%E4%BB%A5%E4%BC%A0%20const%20%E5%BC%95%E7%94%A8%E4%B9%9F%E4%B8%8D%E8%A6%81%E4%BC%A0%E5%80%BC/"/>
      <url>/2018/12/01/%E6%9D%A1%E6%AC%BE20%EF%BC%9A%E5%AE%81%E4%BB%A5%E4%BC%A0%20const%20%E5%BC%95%E7%94%A8%E4%B9%9F%E4%B8%8D%E8%A6%81%E4%BC%A0%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="这个传值行为是继承与-C-语言的，基本上传引用更加方便，且付出的代价更小，不过需要注意下面了两点。"><a href="#这个传值行为是继承与-C-语言的，基本上传引用更加方便，且付出的代价更小，不过需要注意下面了两点。" class="headerlink" title="这个传值行为是继承与 C 语言的，基本上传引用更加方便，且付出的代价更小，不过需要注意下面了两点。"></a>这个传值行为是继承与 C 语言的，基本上传引用更加方便，且付出的代价更小，不过需要注意下面了两点。</h5><ul><li><p>传引用有的时候会碰到切割问题，比如传参的时候，本来应该传入一个基类对象，但是实际上传入了一个派生类对象，这个时候就会把派生类基类的部分切割出去，其他部分就直接丢了</p></li><li><p>以上规则不适合某些特殊规则，比如内置类型以及 STL 的迭代器，对它们而言 ，传值往往是最恰当的。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> effective C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条款22：将成员变量声明为 private</title>
      <link href="/2018/12/01/%E6%9D%A1%E6%AC%BE22%EF%BC%9A%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BA%20private/"/>
      <url>/2018/12/01/%E6%9D%A1%E6%AC%BE22%EF%BC%9A%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BA%20private/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="这里就是要记住封装的好处"><a href="#这里就是要记住封装的好处" class="headerlink" title="这里就是要记住封装的好处"></a>这里就是要记住封装的好处</h4><hr><ul><li>切记要将成员变量声明为 private 。这样可以减少改动成员之后的破坏性，可细微划分访问控制、允诺约束条件获得保证，并且提供 class 作者以充分实现弹性。</li><li>protected 并不比 public 更具有封装性</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> effective C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条款21：必须返回对象的时候，不要妄想返回其的引用</title>
      <link href="/2018/12/01/%E6%9D%A1%E6%AC%BE21%EF%BC%9A%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%B8%8D%E8%A6%81%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6%E7%9A%84%E5%BC%95%E7%94%A8/"/>
      <url>/2018/12/01/%E6%9D%A1%E6%AC%BE21%EF%BC%9A%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%B8%8D%E8%A6%81%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6%E7%9A%84%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>该条款一般适用于某些特殊情况下必须返回值的情况</p><ul><li>关于这个条款只需要注意一点，绝不要返回 pointer 或 reference 或者返回引用指向一个全局变量，或者返回指针引用指向一个静态成员，但是同时又需要多个这样的静态成员。在条款4中已经提供了一份设计实例。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> effective C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条款23：宁以非成员友元函数代替成员函数</title>
      <link href="/2018/12/01/%E6%9D%A1%E6%AC%BE23%EF%BC%9A%E5%AE%81%E4%BB%A5%E9%9D%9E%E6%88%90%E5%91%98%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E4%BB%A3%E6%9B%BF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
      <url>/2018/12/01/%E6%9D%A1%E6%AC%BE23%EF%BC%9A%E5%AE%81%E4%BB%A5%E9%9D%9E%E6%88%90%E5%91%98%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E4%BB%A3%E6%9B%BF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="同样还是为了封装"><a href="#同样还是为了封装" class="headerlink" title="同样还是为了封装"></a>同样还是为了封装</h4><hr><ul><li>宁可拿非成员非友元函数来代替成员函数，这样做可以增加封装性，和包裹弹性，以及机能扩充性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> effective C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条款24：若所有参数需要类型转换的时候，请设置非成员函数</title>
      <link href="/2018/12/01/%E6%9D%A1%E6%AC%BE24%EF%BC%9A%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E8%AF%B7%E8%AE%BE%E7%BD%AE%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
      <url>/2018/12/01/%E6%9D%A1%E6%AC%BE24%EF%BC%9A%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E8%AF%B7%E8%AE%BE%E7%BD%AE%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="该条款就是需要注意一点"><a href="#该条款就是需要注意一点" class="headerlink" title="该条款就是需要注意一点"></a>该条款就是需要注意一点</h4><ul><li>如果需要为某个函数的所有参数，包括this 指针所指的隐喻参数，进行类型转换的时候，那么这个函数就必须是非成员函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> effective C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条款25：考虑写出一个不抛异常的swap函数</title>
      <link href="/2018/12/01/%E6%9D%A1%E6%AC%BE25%EF%BC%9A%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0/"/>
      <url>/2018/12/01/%E6%9D%A1%E6%AC%BE25%EF%BC%9A%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>所谓 swap 两对象值，意思就是将两个对象的值彼此赋予对方，缺省的情况下 swap 的动作可以由标准库程序提供的 swap来完成。<br><img src="/2018/12/01/条款25：考虑写出一个不抛异常的swap函数/9.png" alt=""></p><hr><p>其中有一个最主要的方法就是，以指针指向一个对象，内含真正的数据“ 即”pimpl 手法”<br>所以一般对于一个对象而言，直接交换里面的指针对象即可。就如同以下的写法：</p><p><img src="/2018/12/01/条款25：考虑写出一个不抛异常的swap函数/10.png" alt=""></p><p>以上就是该对象的特化版本。这同时也是一个模板类的偏特化的例子。</p><p>如果想特化一个函数模板的话，通常的做法就是添加一个重载版本。</p><p><img src="/2018/12/01/条款25：考虑写出一个不抛异常的swap函数/11.png" alt=""></p><p>但是这种特化存在问题：</p><ol><li><p>我们可以全特化 std 内的模板，但是不可以添加新的模板到 std 里面去，因为 std 的内容完全由 C++标准委员会决定的。</p></li><li><p>有的时候不能直接访问私有成员，因为封装层面的相关权限缺失。</p></li></ol><p>解决的办法很简单，声明一个非成员版本的 swap 函数，然后让他调用其的成员函数，而不是将那个不是成员函数的 swap 声明为 std：：中的特化版本或者是重载版本。下面就是相关步骤：</p><ol><li><p>提供一个 public swap 成员函数，让它高效地置换你的类型的两个对象（注意这个地方时高效的置换），但是这个函数不应该抛出异常。</p></li><li><p>在你的类或者模板所在的命名空间内，提供一个非成员函数的 swap，并且另其调用 swap 成员函数。</p></li><li><p>如果你正在编写一个 class 而不是一个模板类的时候，为你的类特化std：：swap。并令其调用你的 swap 成员函数。</p></li></ol><p><strong>最后</strong>，在调用奇函数的时候，请确定包含一个 using 生命是，以便于让 std：：swap 在你的函数内曝光可见，直接赤裸裸的调用 swap。</p><hr><p><img src="/2018/12/01/条款25：考虑写出一个不抛异常的swap函数/12.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> effective C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条款25：考虑写出一个不抛异常的 swap 函数</title>
      <link href="/2018/12/01/%E6%9D%A1%E6%AC%BE26%EF%BC%9A%E5%B0%BD%E9%87%8F%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E5%87%BA%E7%8E%B0%E7%9A%84%E6%97%B6%E9%97%B4/"/>
      <url>/2018/12/01/%E6%9D%A1%E6%AC%BE26%EF%BC%9A%E5%B0%BD%E9%87%8F%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E5%87%BA%E7%8E%B0%E7%9A%84%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实该条款总结下来就是再讲一个东西，而这个东西分成两点：</p><ol><li><p>如果类的赋值成本低于一组构造和析构成本，那么将对象的定义定义到循环体外部去，尤其是在循环次数很多的情况下。否则就是将定义循环体内部中去。</p></li><li><p>尽可能延后变量定义式出现的时间，最好达到需要什么才去定义什么，这样做可以增加程序的清晰度并改善程序效率。另外最好在程序定义的时候就直接构造（初始化）。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> effective C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条款27：尽量少做转型动作</title>
      <link href="/2018/12/01/%E6%9D%A1%E6%AC%BE27%EF%BC%9A%E5%B0%BD%E9%87%8F%E5%B0%91%E5%81%9A%E8%BD%AC%E5%9E%8B%E5%8A%A8%E4%BD%9C/"/>
      <url>/2018/12/01/%E6%9D%A1%E6%AC%BE27%EF%BC%9A%E5%B0%BD%E9%87%8F%E5%B0%91%E5%81%9A%E8%BD%AC%E5%9E%8B%E5%8A%A8%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C++ 规则的设计目标之一就是，保证“类型错误” 绝不可能发生，但是在 C++的某些特殊的情形下面不得不去使用转型这一特性，而 C 语言的转型语句则类似于以下：<br><img src="/2018/12/01/条款27：尽量少做转型动作/20.png" alt=""></p><p>然而 C++提供四种新式的类型转换</p><p><img src="/2018/12/01/条款27：尽量少做转型动作/21.png" alt=""></p><p><strong>注意</strong> 在真正进行类型转换的时候，我们不能仅仅认为编译器到最后仅仅只是更改一个文件名字，编译器改变的底层的编码，比如 int 转型到 double 之间底层描述是不一样的。</p><p>另外 C++中的一个特性使得多重继承的时候，一个对象含有多个地址。</p><ul><li><p>所以需要注意的是以下几点，如果可以的话，尽量避免转型，特别是在注重代码中避免dynamic_cast. 如果有设计需要转型动作的话，去试试无需转型的替代设计。</p></li><li><p>如果转型是必要的，那么试着将其隐藏在某个函数背后。客户随后可以调用该函数，而不需要讲转型放进他们自己的代码中。</p></li><li><p>宁可使用 C++新式的转型，也不要使用旧式的转型，前者很容易识别出来，而且也有着不叫分们别类的职掌。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> effective C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>树相关题目</title>
      <link href="/2018/12/01/%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
      <url>/2018/12/01/%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="复原二叉树"><a href="#复原二叉树" class="headerlink" title="复原二叉树"></a>复原二叉树</h2><p><img src="/2018/12/01/树相关题目/15337273413710.jpg" alt=""></p><p><strong>题解</strong><br>此道题目就是要注意先序排序与中序排序，一个是根左右，一个是左根右，先序排序的第一个为根，利用递推关系输出每一个根（由于其的递推出口并没有等于号，意思就是说这里同样输出叶子节点）</p><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> pre;</span><br><span class="line"><span class="built_in">string</span> in;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//递归打印这棵树的后序，递归出口为 start &gt; end</span></span><br><span class="line">    <span class="comment">//注意这里不带等于号的原因就是要把叶子节点一样给输出来</span></span><br><span class="line"> <span class="keyword">if</span>(start&gt;end) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> i=start;<span class="comment">//i为 root所代表的值在中序中的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;end&amp;&amp;in[i]!=pre[root])</span><br><span class="line">     i++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt=i-start;<span class="comment">//左子树结点个数</span></span><br><span class="line">    <span class="comment">//由于是先序排序，顺序永远都是根左右，</span></span><br><span class="line">    post(root+<span class="number">1</span>,start,i<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//左节点 因为是后序排序，先把左节点先弄出顺序，在左节点内部在来后序排序，直到两边左边节点大于右边节点</span></span><br><span class="line"></span><br><span class="line">    post(root+<span class="number">1</span>+cnt,i+<span class="number">1</span>,end);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pre[root];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;pre&gt;&gt;in)&#123;</span><br><span class="line">        <span class="keyword">int</span> len=pre.length();</span><br><span class="line">        post(<span class="number">0</span>,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于树的一个简单DFS运用"><a href="#关于树的一个简单DFS运用" class="headerlink" title="关于树的一个简单DFS运用"></a>关于树的一个简单DFS运用</h2><p><img src="/2018/12/01/树相关题目/15338198112868.jpg" alt=""></p><p>题解 简单的dfs运用 可以模拟树的组成，但是特别耗时间，只用用相应的搜索方法来做才容易一点，这道题有必要再做一遍。</p><p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此处实际上是充分利用了vector的特性</span></span><br><span class="line"><span class="comment">//如果此处是二维数组的话，那么一定会浪费许多没必要的空间开支</span></span><br><span class="line"><span class="comment">//所以用一个vector的数组，每个vector存储其对应的祖先</span></span><br><span class="line"><span class="comment">//而一共有题目给出数量的vector</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;people[maxn];</span><br><span class="line"><span class="keyword">char</span> sex[maxn*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line"><span class="keyword">int</span> que[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里e的值只是用来判断到底是该植入值还是该判断值</span></span><br><span class="line"><span class="comment">//换算到这个题目中的意思就是前面一个人不需要看起祖先只需要输入其祖先就行了</span></span><br><span class="line"><span class="comment">//后面一个人则需要做的是根据已有的对方祖先进行判断</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> s,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s&gt;=<span class="number">5</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (e==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=top;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (x==que[i])&#123;</span><br><span class="line">                ans=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> que[top++]=x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=people[x].size();i++)</span><br><span class="line">        dfs(people[x][i],s+<span class="number">1</span>,e);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的递归搜索可以用来因为是从底层向上面进行搜索</span></span><br><span class="line"><span class="comment">//由于孩子祖先有两个所以上面搜索方式每一个孩子的祖先作为单独的节点再次进行搜索，直到递推出口为止</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> x,fa,ma;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;sex[x];</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;fa&gt;&gt;ma;</span><br><span class="line">        <span class="keyword">if</span> (fa!=<span class="number">-1</span>) people[x].push_back(fa);</span><br><span class="line">        <span class="keyword">if</span> (ma!=<span class="number">-1</span>) people[x].push_back(ma);</span><br><span class="line">        sex[fa]=<span class="string">'M'</span>;</span><br><span class="line">        sex[ma]=<span class="string">'F'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=k;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;fa&gt;&gt;ma;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (sex[fa]==sex[ma]) <span class="built_in">cout</span>&lt;&lt;<span class="string">"Never Mind"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            top=<span class="number">0</span>;</span><br><span class="line">            dfs(fa,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">            dfs(ma,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (ans) <span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> c++ </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一道STL的题解题目，需要以后花时间理解题目意思</title>
      <link href="/2018/12/01/%E4%B8%80%E9%81%93STL%E7%9A%84%E9%A2%98%E8%A7%A3%E9%A2%98%E7%9B%AE%EF%BC%8C%E9%9C%80%E8%A6%81%E4%BB%A5%E5%90%8E%E8%8A%B1%E6%97%B6%E9%97%B4%E7%90%86%E8%A7%A3%E9%A2%98%E7%9B%AE%E6%84%8F%E6%80%9D/"/>
      <url>/2018/12/01/%E4%B8%80%E9%81%93STL%E7%9A%84%E9%A2%98%E8%A7%A3%E9%A2%98%E7%9B%AE%EF%BC%8C%E9%9C%80%E8%A6%81%E4%BB%A5%E5%90%8E%E8%8A%B1%E6%97%B6%E9%97%B4%E7%90%86%E8%A7%A3%E9%A2%98%E7%9B%AE%E6%84%8F%E6%80%9D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2018/12/01/一道STL的题解题目，需要以后花时间理解题目意思/15334616821861.jpg" alt=""></p><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">//#include&lt;function&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> fort = <span class="number">1314</span>;</span><br><span class="line"></span><br><span class="line">ll a[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//这道题目就换一种思考方式，让基数分贝加上加数，这样一来，就会简化很多步骤</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[<span class="number">0</span>]&gt;&gt;a[<span class="number">1</span>]&gt;&gt;a[<span class="number">2</span>];</span><br><span class="line">        a[<span class="number">3</span>] = <span class="number">5</span>;</span><br><span class="line">        a[<span class="number">4</span>] = <span class="number">2</span>;</span><br><span class="line">        a[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">        sort(a,  a + <span class="number">6</span>,</span><br><span class="line">        [](<span class="keyword">const</span> ll &amp;a,<span class="keyword">const</span> ll &amp;b)&#123;<span class="keyword">return</span> a&gt;b;&#125;);</span><br><span class="line">        priority_queue&lt;ll, <span class="built_in">vector</span>&lt;ll&gt;, greater&lt;ll&gt; &gt; pq;</span><br><span class="line">        <span class="built_in">set</span>&lt;ll&gt;s;</span><br><span class="line">        <span class="built_in">set</span>&lt;ll&gt;ans;</span><br><span class="line">        pq.push(<span class="number">1</span>);</span><br><span class="line">        s.insert(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;;i++)&#123;</span><br><span class="line">            ll x = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            <span class="keyword">if</span>(i)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">3</span>;k &lt; <span class="number">6</span>;k++)&#123;</span><br><span class="line">                    ans.insert(x - a[k]);</span><br><span class="line">                    <span class="keyword">if</span>(ans.size()==fort)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ans.size()==fort)&#123;</span><br><span class="line">                    <span class="comment">/*int ttt = 1;</span></span><br><span class="line"><span class="comment">                    for(set&lt;ll&gt;::iterator it = ans.begin();it!=ans.end();it++)</span></span><br><span class="line"><span class="comment">                        cout&lt;&lt;ttt++&lt;&lt;' '&lt;&lt;*it&lt;&lt;endl;*/</span></span><br><span class="line">                    <span class="keyword">auto</span> it = ans.rbegin();</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">                ll x2=x*a[j];</span><br><span class="line">                <span class="keyword">if</span>(!s.count(x2))&#123;</span><br><span class="line">                    s.insert(x2);</span><br><span class="line">                    pq.push(x2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> c++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于模拟与搜索的相应简单题目</title>
      <link href="/2018/12/01/%E5%85%B3%E4%BA%8E%E6%A8%A1%E6%8B%9F%E4%B8%8E%E6%90%9C%E7%B4%A2%E7%9A%84%E7%9B%B8%E5%BA%94%E7%AE%80%E5%8D%95%E9%A2%98%E7%9B%AE/"/>
      <url>/2018/12/01/%E5%85%B3%E4%BA%8E%E6%A8%A1%E6%8B%9F%E4%B8%8E%E6%90%9C%E7%B4%A2%E7%9A%84%E7%9B%B8%E5%BA%94%E7%AE%80%E5%8D%95%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>题目</strong><br><img src="/2018/12/01/关于模拟与搜索的相应简单题目/15338826192241.jpg" alt=""></p><p><strong>代码如下：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> w,v;</span><br><span class="line">    <span class="keyword">int</span> x,y,m;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;w&gt;&gt;v)&#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        reverse(w.begin(),w.end());</span><br><span class="line">        reverse(v.begin(),v.end());</span><br><span class="line">        <span class="keyword">if</span> (w.size()&gt;v.size())&#123;</span><br><span class="line">            m=w.size()-v.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=v.size();i++)&#123;</span><br><span class="line">                x=w[i]-<span class="string">'0'</span>;</span><br><span class="line">                y=v[i]-<span class="string">'0'</span>;</span><br><span class="line">                x+=y;</span><br><span class="line">                <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                    flag=<span class="number">0</span>;</span><br><span class="line">                    x++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (x&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    x=x<span class="number">-10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ch=x+<span class="string">'0'</span>;</span><br><span class="line">                s.push_back(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i=v.size();</span><br><span class="line">            <span class="keyword">while</span> (flag==<span class="number">1</span>&amp;&amp;i&lt;=m)&#123;</span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">                x=w[i]-<span class="string">'0'</span>;</span><br><span class="line">                x++;</span><br><span class="line">                <span class="keyword">if</span> (x&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    x=x<span class="number">-10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ch=x+<span class="string">'0'</span>;</span><br><span class="line">                s.push_back(ch);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag&amp;&amp;i==w.size())&#123;</span><br><span class="line">                s.push_back(<span class="string">'1'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            m=v.size()-w.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=w.size();i++)&#123;</span><br><span class="line">                x=w[i]-<span class="string">'0'</span>;</span><br><span class="line">                y=v[i]-<span class="string">'0'</span>;</span><br><span class="line">                x+=y;</span><br><span class="line">                <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                    flag=<span class="number">0</span>;</span><br><span class="line">                    x++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (x&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    x=x<span class="number">-10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ch=x+<span class="string">'0'</span>;</span><br><span class="line">                s.push_back(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i=w.size();</span><br><span class="line">            <span class="keyword">while</span> (flag&amp;&amp;i&lt;=m)&#123;</span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">                x=w[i]-<span class="string">'0'</span>;</span><br><span class="line">                x++;</span><br><span class="line">                <span class="keyword">if</span> (x&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    x=x<span class="number">-10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ch=x+<span class="string">'0'</span>;</span><br><span class="line">                s.push_back(ch);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag&amp;&amp;i==v.size())&#123;</span><br><span class="line">                s.push_back(<span class="string">'1'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(s.begin(),s.end());</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>题解：</strong><br>其实这道题目属于一道相应简单的题目，就是要注意相应string与char之间的区别就行了。<br>另外 <code>int</code>转换<code>char</code>是加上‘0’<br><code>char</code>转换<code>int</code>是减去‘0’。</p><h2 id="一道简单的dfs的题目"><a href="#一道简单的dfs的题目" class="headerlink" title="一道简单的dfs的题目"></a>一道简单的dfs的题目</h2><p><img src="/2018/12/01/关于模拟与搜索的相应简单题目/15338976566985.jpg" alt=""></p><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">char</span> h[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;=n||h[i][j]!=<span class="string">'W'</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (j&lt;<span class="number">0</span>||j&gt;=m||h[i][j]!=<span class="string">'W'</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (h[i][j]==<span class="string">'W'</span>)&#123;</span><br><span class="line">        h[i][j]=<span class="string">'.'</span>;</span><br><span class="line">        dfs(i<span class="number">-1</span>,j);</span><br><span class="line">        dfs(i<span class="number">-1</span>,j<span class="number">-1</span>);</span><br><span class="line">        dfs(i+<span class="number">1</span>,j);</span><br><span class="line">        dfs(i+<span class="number">1</span>,j+<span class="number">1</span>);</span><br><span class="line">        dfs(i,j<span class="number">-1</span>);</span><br><span class="line">        dfs(i<span class="number">-1</span>,j+<span class="number">1</span>);</span><br><span class="line">        dfs(i,j+<span class="number">1</span>);</span><br><span class="line">        dfs(i+<span class="number">1</span>,j<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&amp;&amp;(n!=<span class="number">0</span>&amp;&amp;m!=<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=n;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j!=m;j++)&#123;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;h[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j!=m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (h[i][j]==<span class="string">'W'</span>)&#123;</span><br><span class="line">                    dfs(i,j);</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题解简单的dfs搜索出每一种情况，然后让其返回就行了。</p><h2 id="一道经典的BFS的题目"><a href="#一道经典的BFS的题目" class="headerlink" title="一道经典的BFS的题目"></a>一道经典的BFS的题目</h2><p><strong>题目</strong><br><img src="/2018/12/01/关于模拟与搜索的相应简单题目/15346617217857.jpg" alt="-w780"></p><p><strong>代码如下:</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fxy[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//朝着四个方向</span></span><br><span class="line"><span class="keyword">char</span> dis[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> kp[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下的node就作为每一次前进的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,cnt;</span><br><span class="line">    node(<span class="keyword">int</span> a=<span class="number">0</span>,<span class="keyword">int</span> b=<span class="number">0</span>,<span class="keyword">int</span> c=<span class="number">0</span>)&#123;</span><br><span class="line">        x=a; y=b; cnt=c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n,k,g,k1,g1;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;m,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,dis[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//      用队列整合的思想来完成</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;struct node&gt;q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                kp[i][j]=<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//      两种初始化过程，并且找到起点与终点的所在位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[i][j]==<span class="string">'S'</span>)&#123;</span><br><span class="line">                    k=i;</span><br><span class="line">                    g=j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dis[i][j]==<span class="string">'E'</span>)&#123;</span><br><span class="line">                    k1=i;</span><br><span class="line">                    g1=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//        将起点存进去</span></span><br><span class="line">        <span class="function">node <span class="title">a</span><span class="params">(k,g,<span class="number">0</span>)</span></span>;</span><br><span class="line">        q.push(a);</span><br><span class="line">        <span class="comment">//        下面就是为bfs的相应搜索</span></span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">now</span>=<span class="title">q</span>.<span class="title">front</span>();</span></span><br><span class="line">            q.pop();</span><br><span class="line">            kp[now.x][now.y]=now.cnt;</span><br><span class="line">            <span class="comment">//            将起点走了多少步数以及起点的坐标点存入到题目中去</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                node next;</span><br><span class="line">                next.x=now.x+fxy[i][<span class="number">0</span>];</span><br><span class="line">                next.y=now.y+fxy[i][<span class="number">1</span>];</span><br><span class="line">                <span class="comment">//                判断走的下一步有没有出界，或者使下一步走的不会碰到路障</span></span><br><span class="line">                    <span class="keyword">if</span>(next.x&gt;=<span class="number">0</span>&amp;&amp;next.x&lt;m&amp;&amp;next.y&gt;=<span class="number">0</span>&amp;&amp;next.y&lt;n&amp;&amp;dis[next.x][next.y]!=<span class="string">'#'</span>&amp;&amp;kp[next.x][next.y]==<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="function">node <span class="title">empt</span><span class="params">(next.x,next.y,now.cnt+<span class="number">1</span>)</span></span>;</span><br><span class="line">                    q.push(empt);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(kp[k1][g1]==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"Trapped!\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Escaped in %d minute(s).\n"</span>,kp[k1][g1]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>记住上面相应的队列思想。</p><h2 id="一道DFS与BFS的综合题"><a href="#一道DFS与BFS的综合题" class="headerlink" title="一道DFS与BFS的综合题"></a>一道DFS与BFS的综合题</h2><p>==需要多花时间来温习一遍==</p><p><strong>题目</strong><br><img src="/2018/12/01/关于模拟与搜索的相应简单题目/15346690956114.jpg" alt=""></p><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k,cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x_begin,x_end,y_begin,y_end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[maxn][maxn];</span><br><span class="line"><span class="keyword">char</span> ch[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Position</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> distance;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Position() = <span class="keyword">default</span>;</span><br><span class="line">    Position(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c):x(a),y(b),distance(c)&#123;&#125;;</span><br><span class="line">    <span class="function">Position <span class="title">move</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Position Position::move(<span class="keyword">int</span> i)&#123;</span><br><span class="line">    Position post = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)         post.x = <span class="keyword">this</span> -&gt; x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>)    post.x = <span class="keyword">this</span> -&gt; x - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>)    post.y = <span class="keyword">this</span> -&gt; y + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">3</span>)    post.y = <span class="keyword">this</span> -&gt; y - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> post;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Position&gt;q_dis;</span><br><span class="line">    <span class="function">Position <span class="title">p_begin</span> <span class="params">(x_begin,y_begin,<span class="number">0</span>)</span></span>;</span><br><span class="line">    q_dis.push(p_begin);</span><br><span class="line">    <span class="keyword">while</span>(!q_dis.empty())&#123;</span><br><span class="line">        Position now = q_dis.front();</span><br><span class="line">        q_dis.pop();</span><br><span class="line">        dis[now.x][now.y]=now.distance;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">4</span>; i++)&#123;</span><br><span class="line">            Position next;</span><br><span class="line">            next = now.move(i);</span><br><span class="line">            <span class="keyword">if</span> (next.x &gt;= <span class="number">0</span> &amp;&amp; next.x &lt; n &amp;&amp; next.y &gt;= <span class="number">0</span> &amp;&amp; next.y &lt; m &amp;&amp;</span><br><span class="line">                dis[next.x][next.y] == <span class="number">-1</span> &amp;&amp; ch[next.x][next.y] != <span class="string">'#'</span>)&#123;</span><br><span class="line">                <span class="function">Position <span class="title">empt</span> <span class="params">(next.x,next.y,now.distance + <span class="number">1</span>)</span></span>;</span><br><span class="line">                q_dis.push(empt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ch[x][y]==<span class="string">'L'</span>)  &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dis[x][y] == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//  前面已经有dis可以表示每一步走的距离，所以只需要一步一步来看，这样的做法便可以完全规避障碍物，单单从路径上面考虑。</span></span><br><span class="line">    <span class="keyword">if</span> (dis[x][y]==dis[x+<span class="number">1</span>][y]+<span class="number">1</span>)   dfs(x+<span class="number">1</span>,y);</span><br><span class="line">    <span class="keyword">if</span> (dis[x][y]==dis[x<span class="number">-1</span>][y]+<span class="number">1</span>)   dfs(x<span class="number">-1</span>,y);</span><br><span class="line">    <span class="keyword">if</span> (dis[x][y]==dis[x][y+<span class="number">1</span>]+<span class="number">1</span>)   dfs(x,y+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (dis[x][y]==dis[x][y<span class="number">-1</span>]+<span class="number">1</span>)   dfs(x,y<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,Case = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        Case++;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">        <span class="keyword">bool</span> f_begin = <span class="literal">false</span>,f_end = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != m; j++)&#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; ch[i][j];</span><br><span class="line">                dis[i][j] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != m; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (f_end &amp;&amp; f_begin)   <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (ch[i][j] == <span class="string">'L'</span>)&#123;</span><br><span class="line">                    x_begin = i;</span><br><span class="line">                    y_begin = j;</span><br><span class="line">                    f_begin = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ch[i][j] == <span class="string">'C'</span>)&#123;</span><br><span class="line">                    x_end = i;</span><br><span class="line">                    y_end = j;</span><br><span class="line">                    f_end = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bfs();</span><br><span class="line">        <span class="keyword">if</span> (dis[x_end][y_end] == <span class="number">-1</span> ||dis[x_end][y_end] &gt; k )</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span>&lt;&lt;Case&lt;&lt;<span class="string">": "</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            dfs(x_end,y_end);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;Case&lt;&lt;<span class="string">": "</span>&lt;&lt;dis[x_end][y_end]&lt;&lt;<span class="string">" "</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注明一下关于==默认实参==的知识点，因为在这个地方可以直接对类的构造函数赋值一个默认实参，可以避免输入默认构造函数了。</p><p>下面则是一道DFS的题目，这道题目看上去可以用bfs来做</p><p><img src="/2018/12/01/关于模拟与搜索的相应简单题目/15351254685296.jpg" alt="-w1003"></p><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> road[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[i][j] != <span class="number">-1</span>)   <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    <span class="keyword">int</span> Max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (i<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; road[i][j]&gt;road[i<span class="number">-1</span>][j]&amp;&amp;Max&lt;dfs(i<span class="number">-1</span>,j))</span><br><span class="line">        Max = dfs(i<span class="number">-1</span>,j);</span><br><span class="line">    <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n &amp;&amp; road[i][j]&gt;road[i+<span class="number">1</span>][j]&amp;&amp;Max&lt;dfs(i+<span class="number">1</span>,j))</span><br><span class="line">        Max=dfs(i+<span class="number">1</span>,j);</span><br><span class="line">    <span class="keyword">if</span>(j<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; road[i][j]&gt;road[i][j<span class="number">-1</span>]&amp;&amp;Max&lt;dfs(i,j<span class="number">-1</span>))</span><br><span class="line">        Max=dfs(i,j<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(j+<span class="number">1</span>&lt;m &amp;&amp; road[i][j]&gt;road[i][j+<span class="number">1</span>]&amp;&amp;Max&lt;dfs(i,j+<span class="number">1</span>))</span><br><span class="line">        Max=dfs(i,j+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dp[i][j]=Max+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; road[i][j];</span><br><span class="line">                dp[i][j] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> MAX = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                MAX = max (dfs(i,j),MAX);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; MAX &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>此题其实最重要的就在于这个题目不同于其他题目，这个题目找的是最长路径，还不是最短路径，一般来说，BFS找的是最短路径，DFS找的是最短路径的条数。<br>而这里就是利用dfs的返回值（每走一步的最大值，意思就是从各个角度上）记录在dp中，将每一个位置都走到不能走为止，然后存储在dp中，最后找最大值的DP即可。<br>不过自己可以试试遍历的其他方法。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> c++ </tag>
            
            <tag> 模拟与搜索 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>贪心算法</title>
      <link href="/2018/12/01/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>/2018/12/01/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>贪心算法的本质目的也就在于对于一个问题来看，我可以用最简单的办法算出局部的解集，并且按照这个最简单的办法同样可以算出该问题的最终解决办法，即贪心算法。</p><h3 id="三个经典的贪心算法问题"><a href="#三个经典的贪心算法问题" class="headerlink" title="三个经典的贪心算法问题"></a>三个经典的贪心算法问题</h3><ol><li>事件的序列问题：<br> <img src="/2018/12/01/贪心算法/15333634457989.jpg" alt=""><br><img src="/2018/12/01/贪心算法/15333634528118.jpg" alt=""></li></ol><p>遇到这样的题目，首先就是要想着能不能找到最长的子序列的前提，到底是按节目的开始时间进行排序，还是按照节目的结束时间进行排序。<br><strong>下面就是核心代码</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Show</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> beg;</span><br><span class="line">    <span class="keyword">int</span> en;</span><br><span class="line">&#125;show[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;show[i].beg&gt;&gt;show[i].en;</span><br><span class="line">        &#125;</span><br><span class="line">        stable_sort(show,show+n,</span><br><span class="line">        [](<span class="keyword">const</span> Show &amp;a, <span class="keyword">const</span> Show &amp;b)&#123;<span class="keyword">return</span> a.en&lt;b.en;&#125;);</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (show[i].beg&gt;=show[j].en)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                j=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此处的关键就是从第一个开始把结束时间最早的进行一个相对位置的排序，然后把第一个结束的与后面开始的时间进行挨个挨个的比较，最终得出的结果就是在这里。</p><ol start="2"><li>区间覆盖问题<br><img src="/2018/12/01/贪心算法/15333675702356.jpg" alt=""><br><strong>下面就是这道题目的核心代码：</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">greedy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="keyword">int</span> i,sum = <span class="number">1</span>,n=x.size();</span><br><span class="line">　　sort(x.begin(),x.end());</span><br><span class="line">　　<span class="keyword">int</span> temp = x[<span class="number">0</span>];<span class="comment">//区间的起始位置</span></span><br><span class="line">　　<span class="keyword">for</span>(i=<span class="number">1</span>;i &lt; n; ++i)</span><br><span class="line">　　　　<span class="keyword">if</span>(x[i] - temp &gt; k)　　&#123;sum++,temp=x[i]&#125;;</span><br><span class="line">　　<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>题目这里就是<br>分别计数，用一个最简单的思维做出一整道题目的思路。</p><ol start="3"><li>区间相交问题：<br><img src="/2018/12/01/贪心算法/15333716368154.jpg" alt=""><br>其实就是跟第一道题目类似</li></ol><p>算连续的序列 并且把总长度减去这些连续的序列之后得到的是剩余的区间，即得到题目答案。</p><p>==以后若还有关于贪心类型的题目可以继续往上面加==</p><p><strong>一下就是贪心的习题</strong></p><p><img src="/2018/12/01/贪心算法/15333719681518.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于组合数学，两道思维题目，这里贴两道题目</title>
      <link href="/2018/12/01/%E5%85%B3%E4%BA%8E%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%8C%E4%B8%A4%E9%81%93%E6%80%9D%E7%BB%B4%E9%A2%98%E7%9B%AE%EF%BC%8C%E8%BF%99%E9%87%8C%E8%B4%B4%E4%B8%A4%E9%81%93%E9%A2%98%E7%9B%AE/"/>
      <url>/2018/12/01/%E5%85%B3%E4%BA%8E%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%8C%E4%B8%A4%E9%81%93%E6%80%9D%E7%BB%B4%E9%A2%98%E7%9B%AE%EF%BC%8C%E8%BF%99%E9%87%8C%E8%B4%B4%E4%B8%A4%E9%81%93%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第一道-简单的排列组合："><a href="#第一道-简单的排列组合：" class="headerlink" title="第一道 简单的排列组合："></a>第一道 简单的排列组合：</h2><p><img src="/2018/12/01/关于组合数学，两道思维题目，这里贴两道题目/15334551294656.jpg" alt=""></p><p><strong>题解如下：</strong></p><blockquote><p>题目大致可以理解为4堆牌a,b,c,d，每次从一堆牌里拿出牌顶的一张牌，问共有多少种拿法。其实我们可以一堆一堆的分析，假设只有一堆a时只有1种拿法，那两堆a,b时我们可以认为是从a个牌中插入b张牌，用数学表达式就是<strong>==C(b,a+b)==</strong>;那么三堆的话我们可以把前两堆看成一堆，那么表达式就是<strong>==C(c,a+b+c)==</strong>，这是我们需要与前两堆的组成方法相乘，就是<strong>==C(b,a+b)C(c,a+b+c)==</strong>。<br>4堆的话就是<strong>==C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)==</strong>。<br>所以答案就是<strong>==C(a,a)C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)==</strong>。<br>此外，有一公式==<strong>C(a,b)=C(a,b-1)+C(a-1,b-1)</strong>==，所以我们用数组来代替C(m,n)操作</p></blockquote><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">501</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">4</span>],sum[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//此处用到记忆化搜索，动态规划。</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[maxn*<span class="number">4</span>][maxn*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i!=<span class="number">4</span>*maxn;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//根据表格来看的确是每一行的第一个是1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="comment">//这个地方就是状态转移方程</span></span><br><span class="line">            <span class="comment">//C(a,b)=C(a,b-1)+C(a-1,b-1)根据公式来做的</span></span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="comment">//dp[i][j]=dp[i][j]%mod;</span></span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">        init();<span class="comment">//这个地方就开始初始化表格了。</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!i) sum[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> sum[i]=sum[i<span class="number">-1</span>];</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">            sum[i] += a[i];</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; sum[i]-a[i]) a[i]=sum[i]-a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i != <span class="number">4</span>; i++)&#123;</span><br><span class="line">            ans *= dp[sum[i]][a[i]];</span><br><span class="line">            <span class="comment">//ans %=mod;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二题-第一题的变式："><a href="#第二题-第一题的变式：" class="headerlink" title="第二题 第一题的变式："></a>第二题 第一题的变式：</h2><p><img src="/2018/12/01/关于组合数学，两道思维题目，这里贴两道题目/15334588459331.jpg" alt=""></p><p>题解如上，与上面一题有区别的地方就在于要有一个取模的操作</p><p><strong>代码如下</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">501</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">4</span>],sum[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//此处用到记忆化搜索，动态规划。</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[maxn*<span class="number">4</span>][maxn*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i!=<span class="number">4</span>*maxn;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//根据表格来看的确是每一行的第一个是1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="comment">//这个地方就是状态转移方程</span></span><br><span class="line">            <span class="comment">//C(a,b)=C(a,b-1)+C(a-1,b-1)根据公式来做的</span></span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            dp[i][j]=dp[i][j]%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">        init();<span class="comment">//这个地方就开始初始化表格了。</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!i) sum[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> sum[i]=sum[i<span class="number">-1</span>];</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">            sum[i] += a[i];</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; sum[i]-a[i]) a[i]=sum[i]-a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i != <span class="number">4</span>; i++)&#123;</span><br><span class="line">            ans *= dp[sum[i]][a[i]];</span><br><span class="line">            ans %=mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==以后学到后面再花时间来深究==</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> c++ </tag>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一道有趣的题目——逆波兰计算器</title>
      <link href="/2018/12/01/%E4%B8%80%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A2%98%E7%9B%AE%E2%80%94%E2%80%94%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
      <url>/2018/12/01/%E4%B8%80%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A2%98%E7%9B%AE%E2%80%94%E2%80%94%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2018/12/01/一道有趣的题目——逆波兰计算器/15334382488561.jpg" alt=""></p><p><strong>题解</strong><br>首先这道题毫无疑问是要用到stringstream流的。分别依次读取字符串，并且将其导入到char型的代码中去。比如说a+b可以变成ab+，这里最好运用到栈的知识，来控制出栈与进栈。<br>==注意以下几个地方==</p><ol><li>注意输入<code>cin&gt;&gt;t</code>以后，需要用<code>getchar()</code>来清空上一个步骤留下来的回车符号</li><li>注意此处需要严格进行判断栈内是否为空。</li><li>这里是将乘除求模的运算放在最右边，这样就可以有优先级存在了</li><li>括号会提前进行一步运算，然后消除掉左括号，或者左边的所有运算式，进行一个结算。</li><li>map这里存在的意义就在于 为判断进行提供条件。</li><li>此道题目涉及字符串，栈，模拟的相应算法，需要有空的时候可以多看看。</li></ol><p><strong>代码如下：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt;ope;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;num;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m[<span class="string">'+'</span>]=m[<span class="string">'-'</span>]=<span class="number">1</span>;</span><br><span class="line">    m[<span class="string">'*'</span>]=m[<span class="string">'/'</span>]=m[<span class="string">'%'</span>]=m[<span class="string">'('</span>]=m[<span class="string">')'</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(!num.empty())</span><br><span class="line">        num.pop();</span><br><span class="line">    <span class="keyword">while</span>(!ope.empty())</span><br><span class="line">        ope.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此处为基本的运算规模。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">op1</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b,<span class="keyword">const</span> <span class="keyword">char</span> &amp;c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c ==<span class="string">'+'</span>)    a += b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'-'</span>) a=b-a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'*'</span>) a*=b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'/'</span>) a=b/a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'%'</span>) a=b%a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此处就是控制出栈的运算，一般就是括号内部的计算了。算出每一个括号内部的运算式。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">op2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = ope.top();</span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">'('</span>&amp;&amp;!ope.empty())&#123;</span><br><span class="line">        ope.pop();</span><br><span class="line">        <span class="keyword">int</span> a = num.top();</span><br><span class="line">        num.pop();</span><br><span class="line">        <span class="keyword">int</span> b = num.top();</span><br><span class="line">        num.pop();</span><br><span class="line">        op1(a,b,ch);</span><br><span class="line">        num.push(a);</span><br><span class="line">        <span class="keyword">if</span> (!ope.empty())</span><br><span class="line">            ch = ope.top();</span><br><span class="line">    &#125;<span class="comment">//这个下面要注意的判断条件中一定要加上判断是否为空。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ope.empty()&amp;&amp;ope.top() ==<span class="string">'('</span>)</span><br><span class="line">        ope.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">        getline(<span class="built_in">cin</span>,str);</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">s</span><span class="params">(str)</span></span>;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">char</span> tmp;</span><br><span class="line">        <span class="keyword">while</span> (s&gt;&gt;tmp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;=<span class="string">'0'</span>&amp;&amp;tmp&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">do</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (m[tmp]) <span class="keyword">break</span>;</span><br><span class="line">                    x *= <span class="number">10</span>;</span><br><span class="line">                    x += tmp - <span class="string">'0'</span>;<span class="comment">//此处是将char转换成int</span></span><br><span class="line">                &#125;<span class="keyword">while</span>(s&gt;&gt;tmp);</span><br><span class="line">                num.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//注意这个地方的高明之处就在于碰见‘）’的返回，以及判断有没有‘（’，</span></span><br><span class="line">            比如连加的情况就把加减乘除的优先运算级给表示出来了。</span><br><span class="line">            <span class="comment">//最后相当于将运算优先级高的全部放到了右边，然后有括号的就先解决括号，</span></span><br><span class="line">            及时左括号被提前弄没了也不要紧，存在有右括号就行，然后乘除永远放在加减的左边。</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (tmp==<span class="string">')'</span>) op2();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m[tmp]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!ope.empty()&amp;&amp;ope.top()!=<span class="string">'('</span>)</span><br><span class="line">                    op2();</span><br><span class="line">                ope.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m[tmp]) ope.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = num.top();</span><br><span class="line">        num.pop();</span><br><span class="line">        <span class="keyword">while</span> (!num.empty()&amp;&amp;!ope.empty())&#123;</span><br><span class="line">            op1(ans,num.top(),ope.top());</span><br><span class="line">            ope.pop();</span><br><span class="line">            num.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> c++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数论基础第一节</title>
      <link href="/2018/12/01/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E8%8A%82/"/>
      <url>/2018/12/01/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>初等数论是用初等方法研究的数论，它的研究方法本质上说，就是利用整数环的整除性质，主要包括整除理论、同余理论、连分数理论。</p><h2 id="整除问题引申到同余问题"><a href="#整除问题引申到同余问题" class="headerlink" title="整除问题引申到同余问题"></a>整除问题引申到同余问题</h2><ul><li><strong>同余的性质</strong></li></ul><p><img src="/2018/12/01/数论基础第一节/15343075827029.jpg" alt=""><br>可以换算成以下式子：<br><strong>a=c(<code>mod</code>b) 这里c为余数，而b为除数</strong></p><ul><li><strong>同余的性质</strong></li></ul><ol><li>自反性 a=a <code>mod</code> m</li><li>对称性 a=b <code>mod</code> m 等价于 b=a <code>mod</code> m</li><li>传递性 a=b <code>mod</code> m 与 b=c <code>mod</code> m 等价于 a=c <code>mod</code> m</li><li>线性合成 a=b <code>mod</code> m 与 c= <code>mod</code> m 等价于 a±c=b±d <code>mod</code> m 与 ac= bd <code>mod</code> m</li><li>消去公因子 ac=bc <code>mod</code> m &amp;&amp; gcd(c,m)=1 等价于 a=b <code>mod</code> m </li></ol><h2 id="素数筛"><a href="#素数筛" class="headerlink" title="素数筛"></a>素数筛</h2><ul><li>朴素筛 一般就是循环2~√n次</li><li>埃拉托斯特尼筛</li></ul><p><strong>循环次数</strong><br><img src="/2018/12/01/数论基础第一节/15343091959776.jpg" alt=""></p><ul><li>欧拉筛</li><li><img src="/2018/12/01/数论基础第一节/15343092628399.jpg" alt=""></li></ul><p><strong>相应代码如下：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="最大公约数以及最小公倍数"><a href="#最大公约数以及最小公倍数" class="headerlink" title="最大公约数以及最小公倍数"></a>最大公约数以及最小公倍数</h2><ul><li><p>最大公约数 函数_gcd(a,b)<br>而多个数的最大公约数 就是 _gcd(a,b,c)=_gcd(gcd(a,b),c)</p></li><li><p>最小公倍数<br>_lcm(a,b)=ab/_gcd(a,b)</p></li></ul><h2 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h2><p><img src="/2018/12/01/数论基础第一节/15343099257598.jpg" alt=""></p><ul><li>关于求解线性同余方程<br><img src="/2018/12/01/数论基础第一节/15343099683275.jpg" alt=""></li><li><p>关于求逆元<br><img src="/2018/12/01/数论基础第一节/15343099966167.jpg" alt=""></p></li><li><p>关于快速幂<br><img src="/2018/12/01/数论基础第一节/15343101054154.jpg" alt=""></p></li></ul><h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p><img src="/2018/12/01/数论基础第一节/15343101566104.jpg" alt=""></p><p><strong>另外</strong><br><img src="/2018/12/01/数论基础第一节/15343103411689.jpg" alt=""></p><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><ul><li><strong>欧拉函数定义</strong><br><img src="/2018/12/01/数论基础第一节/15343107143861.jpg" alt=""></li></ul><ul><li><p><strong>欧拉函数性质</strong><br><img src="/2018/12/01/数论基础第一节/15343107974985.jpg" alt=""></p></li><li><p><strong>求值公式</strong> </p></li></ul><ol><li><img src="/2018/12/01/数论基础第一节/15343109562640.jpg" alt=""></li><li><img src="/2018/12/01/数论基础第一节/15343109655205.jpg" alt=""></li><li><img src="/2018/12/01/数论基础第一节/15343109780637.jpg" alt=""><br>上述公式 可以用来：</li></ol><ul><li><p><strong>求逆元</strong><br><img src="/2018/12/01/数论基础第一节/15343110433806.jpg" alt=""></p></li><li><p><strong>欧拉降幂公式</strong><br><img src="/2018/12/01/数论基础第一节/15343111460573.jpg" alt=""></p></li></ul><h2 id="数论函数"><a href="#数论函数" class="headerlink" title="数论函数"></a>数论函数</h2><p><img src="/2018/12/01/数论基础第一节/15343114512818.jpg" alt=""></p><ul><li><strong>中国剩余定理</strong></li></ul><p><img src="/2018/12/01/数论基础第一节/15343114886344.jpg" alt=""></p><p><strong>解法</strong><br><img src="/2018/12/01/数论基础第一节/15343115089655.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构相应总结</title>
      <link href="/2018/12/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%BA%94%E6%80%BB%E7%BB%93/"/>
      <url>/2018/12/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%BA%94%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ol><li><p>栈的概念<br>此处只需要记住栈的思想最重要的就是<strong>先进后出</strong>思想，也就是最先进去的最后出来。<br><img src="/2018/12/01/数据结构相应总结/15332206965126.jpg" alt=""></p></li><li><p>两种方法表示这种栈的实现</p></li></ol><ul><li>第一种则是 直接用c语言实现，采用一个一维数组来存储栈，用两个指针一个指向栈顶，另一个指向栈底。用top=bottom作为栈空的标记或者说是栈遍历完毕的标记。</li><li>第二种就是直接用C++里面STL模板<br>首先先定义一个<code>stack&lt;int&gt; s</code> 然后以下就是其的操作。   </li></ul><p><strong>注意其不能使用push_back只能使用push</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.pop()         删除栈顶元素，也就是出栈的作，把刚刚进来的元素出栈,不返回元素值。</span><br><span class="line">s.push()        创建一个新元素压入栈顶，可以通过拷贝，移动，甚至是构造而来。</span><br><span class="line">s.top()         返回栈顶的元素，也就是刚刚进来的元素。</span><br><span class="line">s.bottom()      返回栈底的元素，也就是最后一个元素</span><br></pre></td></tr></table></figure><h2 id="队列适配器"><a href="#队列适配器" class="headerlink" title="队列适配器"></a>队列适配器</h2><p>队列这里分为两种一种是普通队列，还有一种是特殊排列好的优先队列，但是这二者的区别就在于，虽然都符合先进先出的思想，但是前者是不加任何排序的先进先出，而后者就是让代码编辑者<strong>自己定义一种排序方式</strong>，然后通过这种排序方式，再来出队操作。</p><p>与上面一样，先定义一个<code>queue&lt;int&gt; q</code>与<code>priority_queue&lt;int&gt; q</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">q.pop()         按照先进先出的思想，删除首元素或者优先级最高的元素</span><br><span class="line">q.front()       返回首元素。</span><br><span class="line">q.back()        返回尾元素。</span><br><span class="line">以上两个是只适用于队列。</span><br><span class="line">q.top()         返回优先队列中优先级最高的元素。</span><br><span class="line">q.push()</span><br><span class="line">q.emplace()     加入元素到队尾，或者优先队列中一个恰当的位置，要么构造，要么拷贝。</span><br></pre></td></tr></table></figure><p>这里需要提一下==优先队列的构造方法==以及==优先队列的特殊排序==应该怎么构造</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">下面两种优先队列的定义是等价的</span><br><span class="line">priority_queue&lt;int&gt; q;</span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;;//后面有一个空格</span><br><span class="line">默认都是从小到大排序</span><br><span class="line">接受三个参数，</span><br><span class="line">第一个参数为数据类型，</span><br><span class="line">第二个参数为承载容器的类型，</span><br><span class="line">第三个就是自定义的比较函数了。</span><br><span class="line">可以使lamda匿名函数，也可以是function头文件里面的函数模板。</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>特点：自定义，不连续的。<br>同时链表也是后面相应树形结构的基础<br>实际上就是把每一个不连续的内存空间连在一起，可以认为的控制进程<br>这个需要自己改天把链表的遍历，删除，增加自己再写一遍，因为不是什么新东西，所以这里就不多说了</p><h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>这里就是vector 存在的意义了 vector里面重要的概念 容量，长度。</p><h2 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h2><h3 id="一般的树"><a href="#一般的树" class="headerlink" title="一般的树"></a>一般的树</h3><p><img src="/2018/12/01/数据结构相应总结/15332616324155.jpg" alt=""></p><p><img src="/2018/12/01/数据结构相应总结/15332617338919.jpg" alt=""></p><p>以上就是一般树的形态。<br>下面则是关于树的基本用语。<br><img src="/2018/12/01/数据结构相应总结/15332619052693.jpg" alt=""><br>关于上面重要的概念就是结点和结点的度了。</p><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><h5 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义:"></a>二叉树的定义:</h5><p><img src="/2018/12/01/数据结构相应总结/15332622735630.jpg" alt=""></p><h5 id="二叉树有五种基本形态："><a href="#二叉树有五种基本形态：" class="headerlink" title="二叉树有五种基本形态："></a>二叉树有五种基本形态：</h5><p><img src="/2018/12/01/数据结构相应总结/15332623676250.jpg" alt=""> </p><h6 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质:"></a>二叉树的性质:</h6><p><img src="/2018/12/01/数据结构相应总结/15332624449232.jpg" alt=""><br>上面所写到的==至多==都是由于将其当成了满二叉树来进行计算的。</p><h5 id="满二叉树与完全二叉树"><a href="#满二叉树与完全二叉树" class="headerlink" title="满二叉树与完全二叉树"></a>满二叉树与完全二叉树</h5><p><img src="/2018/12/01/数据结构相应总结/15332628389372.jpg" alt=""><br>前者全部都有子节点，后者基于深度为k的基础上，编号从1到n的结点一一对应。<br><strong>完全二叉树是满二叉树的一部分，而满二叉树是完全二叉树的特例。</strong></p><p>#####二叉树的存储结构：</p><ol><li><p>数组存储：<br><img src="/2018/12/01/数据结构相应总结/15332634147466.jpg" alt=""></p></li><li><p>二叉链式存储（原理类似链表）：<br><img src="/2018/12/01/数据结构相应总结/15332635553287.jpg" alt=""><br>将链表内部的*next，变成了指向两边的子节点的指针。</p></li><li><p>三叉链式存储：<br><img src="/2018/12/01/数据结构相应总结/15332636549533.jpg" alt=""><br><strong>比二叉链式结构多了一个回指向父节点的指针。</strong></p></li></ol><p><img src="/2018/12/01/数据结构相应总结/15332637977616.jpg" alt=""></p><h5 id="遍历二叉树的方法"><a href="#遍历二叉树的方法" class="headerlink" title="遍历二叉树的方法"></a>遍历二叉树的方法</h5><ol><li><p>先序遍历（根-&gt;左-&gt;右）：<br><img src="/2018/12/01/数据结构相应总结/15332639610611.jpg" alt=""></p><p> 代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</span><br><span class="line">        PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">        PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 图示：<br> <img src="/2018/12/01/数据结构相应总结/15332640892406.jpg" alt="">        </p><p> 最终结果就是==ABDGHCEIF==。</p></li><li><p>中序遍历（左-&gt;根-&gt;右)：<br> 若二叉树为空，则空操作返回，否则从根节点开始（注意不是先访问根节点），中序遍历根节点的左子树，然后是访问根节点，最后中序遍历右子树。</p><p> 代码：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</span><br><span class="line">        PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 最终结果为==GDHBAEICF==。</p></li><li><p>后序遍历（左-&gt;右-&gt;根）<br> 若二叉树为空，则空操作返回，否则从根节点开始（注意不是先访问根节点），中序遍历根节点的左子树，然后是访问根节点，最后中序遍历右子树。</p><p> 代码：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">      PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">      PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 最终结果为==GHDBIEFCA==。</p></li></ol><h5 id="关于二叉树的建立代码："><a href="#关于二叉树的建立代码：" class="headerlink" title="关于二叉树的建立代码："></a>关于二叉树的建立代码：</h5><p>代码我等下自己写出来。</p><hr><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><p>   图结构：是研究数据元素之间的多对多的关系。在这种结构中，任意两个元素之间可能存在关系。即结点之间的关系可以是任意的，图中任意元素之间都可能相关。</p><h3 id="图的专业术语："><a href="#图的专业术语：" class="headerlink" title="图的专业术语："></a>图的专业术语：</h3><p><img src="/2018/12/01/数据结构相应总结/15332695761126.jpg" alt="">    </p><p><img src="/2018/12/01/数据结构相应总结/15332695489735.jpg" alt=""></p><p><img src="/2018/12/01/数据结构相应总结/15332696082443.jpg" alt=""></p><p><img src="/2018/12/01/数据结构相应总结/15332696413788.jpg" alt=""></p><p><img src="/2018/12/01/数据结构相应总结/15332696550432.jpg" alt=""></p><h3 id="图-生成树"><a href="#图-生成树" class="headerlink" title="图-生成树"></a>图-生成树</h3><p><img src="/2018/12/01/数据结构相应总结/15332696984237.jpg" alt=""></p><p><img src="/2018/12/01/数据结构相应总结/15332697115073.jpg" alt=""><img src="/2018/12/01/数据结构相应总结/15332697228263.jpg" alt=""></p><h3 id="邻接矩阵的表示方法（数组）"><a href="#邻接矩阵的表示方法（数组）" class="headerlink" title="邻接矩阵的表示方法（数组）"></a>邻接矩阵的表示方法（数组）</h3><h4 id="不带权值的表示方法"><a href="#不带权值的表示方法" class="headerlink" title="不带权值的表示方法"></a>不带权值的表示方法</h4><p><img src="/2018/12/01/数据结构相应总结/15332704000437.jpg" alt=""></p><p><img src="/2018/12/01/数据结构相应总结/15332704263688.jpg" alt=""></p><p><strong>一般就是用二维数组来表示每一个结点之间的关系</strong></p><p><img src="/2018/12/01/数据结构相应总结/15332705567207.jpg" alt=""> <img src="/2018/12/01/数据结构相应总结/15332705659456.jpg" alt=""></p><p>关于图的遍历就最好用一个bool 类型的同二维数组 然后通过这个来标记哪些是否已经被遍历过得。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一道计算机几何算法相关题目</title>
      <link href="/2018/12/01/%E4%B8%80%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%87%A0%E4%BD%95%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
      <url>/2018/12/01/%E4%B8%80%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%87%A0%E4%BD%95%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>题目：</strong></p><p><img src="/2018/12/01/一道计算机几何算法相关题目/15349459741854.jpg" alt=""></p><p><strong>代码如下：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> v,s,b;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;v&gt;&gt;s&gt;&gt;b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s&lt;b)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> x = (v * v) / <span class="number">9.8</span>;</span><br><span class="line">        <span class="keyword">if</span> ( x &lt; s ) &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"move "</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">2</span>)&lt;&lt;s-x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> b = (s * <span class="number">9.8</span>) / (v * v);</span><br><span class="line">            <span class="comment">//注意反函数的转换。</span></span><br><span class="line">            <span class="keyword">double</span> a = <span class="built_in">asin</span>(b) * <span class="number">90</span> / pi;</span><br><span class="line">            <span class="comment">//这里有一个进一的操作，因为此题不太会去四舍五入。</span></span><br><span class="line">            <span class="keyword">int</span> a_ = a;</span><br><span class="line">            <span class="keyword">if</span> (a-a_ &gt;= <span class="number">0.5</span>) a_++;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"a "</span>&lt;&lt;a_&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>关于这道题目的相关要点</strong></p><ol><li><p>反函数相关要点。<br>注意 反函数最后输出的是 一个弧度值，根据相应数学的算法而言<br>记住 ==弧度值=角度*pi/180==</p></li><li><p>关于输出中进1的相关操作。<br>按照第几位，先换算成相应的整形数，最后再强转成int型 最后在判断是否大于0.5来考虑时候来加一。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> c++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ACM集训相关知识</title>
      <link href="/2018/12/01/ACM%E9%9B%86%E8%AE%AD%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/12/01/ACM%E9%9B%86%E8%AE%AD%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基本的数据结构-扩充"><a href="#基本的数据结构-扩充" class="headerlink" title="基本的数据结构 扩充"></a>基本的数据结构 扩充</h2><h3 id="顺序表-（我的理解就是连续的顺序容器）"><a href="#顺序表-（我的理解就是连续的顺序容器）" class="headerlink" title="顺序表 （我的理解就是连续的顺序容器）"></a>顺序表 （我的理解就是连续的顺序容器）</h3><p>存储方法就是在内存中开辟一段连续的空间。</p><p>而数据元素的位置确认：<br><img src="/2018/12/01/ACM集训相关知识/15337111111637.jpg" alt="1"></p><p>常见的线性表运算：<br><img src="/2018/12/01/ACM集训相关知识/15337113312937.jpg" alt="2"></p><p>此处一般都是用数组来实现，其的插入运算和删除运算都是基于连续内存空间上面所实现的。<br><img src="/2018/12/01/ACM集训相关知识/15337115889842.jpg" alt="3"></p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>定义：<br><img src="/2018/12/01/ACM集训相关知识/15337119273530.jpg" alt="4"><br>链表的存储方式：<br><img src="/2018/12/01/ACM集训相关知识/15337119963518.jpg" alt="5"></p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p><img src="/2018/12/01/ACM集训相关知识/15337127020900.jpg" alt="6"></p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>简单来说就是首尾相连接的单向链表。</p><p>以上有时间再来进行详细的全面总结。</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><img src="/2018/12/01/ACM集训相关知识/15337133357734.jpg" alt="7"></p><p>如果用C语言来表示栈的话，得以数组作为基础，秉持先进后出的思想就行了。<br>可以用int值作为下标值作为当时存储的栈的位置。<br>也可以用两个指针来指示当前下标值。<br>可以借用栈的思想来做题目。</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p><img src="/2018/12/01/ACM集训相关知识/15337139178700.jpg" alt="8"></p><p>队列的基本逻辑运算：<br><img src="/2018/12/01/ACM集训相关知识/15337140792268.jpg" alt="9"></p><p>这里也是运用两个int型的值当做是变量，分别指向头指针以及尾指针，然后执行添加减少的操作。一般到最后全部用做到下标上面。</p><p>而<strong>循环队列</strong>也是建立两个指针，但是不同的是其是将首尾进行连接之后，也就是说，其直接将每次得到的新结果对队列的总长度进行一个求余数（求mod）。</p><p>下学期上课的时候可以用C语言代码实现以下。</p><p>循环队列其实可以干和循环链表一样的事情。<br>比如一道例题：<br><img src="/2018/12/01/ACM集训相关知识/15337150969186.jpg" alt="10"></p><p><strong>代码如下：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt; </span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;string&gt; </span><br><span class="line">#include&lt;stdio.h&gt; </span><br><span class="line">using namespace std; </span><br><span class="line">int main()&#123;</span><br><span class="line">    int n; </span><br><span class="line">    while(cin&gt;&gt;n)&#123;</span><br><span class="line">        queue&lt;string&gt; a; </span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            string name; </span><br><span class="line">            cin&gt;&gt;name; </span><br><span class="line">            a.push(name);</span><br><span class="line">        &#125;</span><br><span class="line">    int w,s;</span><br><span class="line">    scanf(&quot;%d,%d&quot;,&amp;w,&amp;s); </span><br><span class="line">    for(int i=0;i&lt;w-1;i++)&#123;</span><br><span class="line">        string temp = a.front(); </span><br><span class="line">        a.pop();</span><br><span class="line">        a.push(temp);</span><br><span class="line">    &#125; </span><br><span class="line">    while(a.size())&#123;</span><br><span class="line">        for(int i=0;i&lt;s-1;i++)&#123;</span><br><span class="line">            string temp = a.front();</span><br><span class="line">            a.pop()</span><br><span class="line">            a.push(temp); </span><br><span class="line">            &#125;</span><br><span class="line">        cout&lt;&lt;a.front()&lt;&lt;endl;</span><br><span class="line">        a.pop(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><p>串的定义：<br><img src="/2018/12/01/ACM集训相关知识/15337166865050.jpg" alt="11"></p><p>此处则可以理解成是字符串。</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>树的定义：<br><img src="/2018/12/01/ACM集训相关知识/15337171556317.jpg" alt="12"></p><p>二叉树的性质：<br><img src="/2018/12/01/ACM集训相关知识/15337179533132.jpg" alt="13"></p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="简单的冒泡排序"><a href="#简单的冒泡排序" class="headerlink" title="简单的冒泡排序"></a>简单的冒泡排序</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018年生日重庆之旅</title>
      <link href="/2018/11/30/2018%E5%B9%B4%E7%94%9F%E6%97%A5%E9%87%8D%E5%BA%86%E4%B9%8B%E6%97%85/"/>
      <url>/2018/11/30/2018%E5%B9%B4%E7%94%9F%E6%97%A5%E9%87%8D%E5%BA%86%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>说句实话，自己也不知道应该写些什么东西，转眼之间似乎已经21岁了，知道自己内心不甘心的地方，但是唯一不太知道的是如何去改善这些不甘心的地方。<br>问问自己的内心，其实自己一直想要的就是别人的关注。我觉得我个人的心路成长分成了几个阶段。</p><ol><li>第一个阶段就是拼命的展现自我，追求其他人的认可与关爱。</li></ol><blockquote><p>如果在这个阶段里面获取了足够的认可，也许就会一直在这个阶段里面不断，要求满足，然后被满足的过程中进行沉沦。我个人的想法就是，如果没有进入到下一个阶段，那么永远得不到成长。</p></blockquote><ol start="2"><li>第二个阶段就是知道了这个世界上不会轻易的给自己满足的，知道了原来自己是会被拒绝的。</li></ol><blockquote><p>这个时期如果没有处理好的话，那么特别容易走向一个极端，走向一个“佛系”的一个极端，假意成为一个无欲无求的人，这个时期的我们就会厌恶一切“争宠”的行为，反而还会将那些争取优秀的人看作是特别低级的人类，从而厌恶一切优秀，但同时自己会在暗中做出很多自认为独一无二的事情，来彰显自己与别人不一样的地方。</p></blockquote><ol start="3"><li>第三个阶段往往是在经历了很长阶段的第二阶段，经历过打击，重新并且深刻的认知到这个世界并不是围绕着自己转动，一个人真的没办法获取周围每个人的关注。</li></ol><blockquote><p>也许甚至自己没办法获取周围一个朋友的全部的关注，其实换位思考一下，自己也没有全身心的投入自己去关注别人，其实到最后自己还是以一个自己都达不到的标准全部要求别人，有点自欺欺人的感觉。</p></blockquote><hr><p>其实自己就在上面所说的第二阶段中无力翻腾着。虽然自己没有去蔑视努力，知道自己一切改变都是努力的结果，这是好的，但是从进入大学的一年多来，自己觉得自己很累，每天过得也很充实，也有一个固定的目标，但是自己却好像从来不能得到满足。</p><p>其实最近发生的一切不安，一切困惑，问问自己，其实全部来源于自我认知的偏差。真的以为自己是无所不能的超人，认为所有事情，只要自己认真去做，那么就一定可以实现，但是却忘记了一个很重要的前提，人的精力是有限的，真的没有办法做到面面俱到。</p><p>从最先开始的选择程序员这条路，到后面编程语言的选择，然后又到了工具，开发环境，以及编程之路方向上面的选择，我最近做出了很多很多的选择。很高兴自己做出了很多的选择，但是同样又很悲伤自己做出的选择。</p><ul><li><p>外因</p><blockquote><p>每个人的人生只有一次，对于个人而言，发生的一切，其实都是一个全新的体验，所以不知道该怎么做，产生迷茫的情绪是一件很正常的事情，另外对于自己而言，周围也没有陪伴自己成长的长者，没有人可以体会到自己生命中每一个抉择背后所要承担的东西。再加上本着想把一切做好的目的，这个时候就会产生即使做出选择也会产生后悔的不确定感。</p></blockquote></li><li><p>内因</p><blockquote><p>我觉得归根到内心的话，还是有对自己不够自信这个心态存在的，还记得上次在经开一中一个科技展览会的时候，被一个学妹说不自信的时候，当时震惊的同时，其实更多的还是认可，我的确对自己不是特别的自信。不做选择的时候，怀疑自己是不是做不了选择了，当自己做出选择之后，又在怀疑自己是不是做出了一个错误的选择，我觉得这都是自己内心中需要克服的地方。</p></blockquote></li></ul><p>上面综合起来带来了 <strong>焦虑</strong>。</p><p>焦虑，一遍一遍的怀疑自己，一遍一遍的苛刻完美的标准，一遍一遍夸大其他人的成就而贬低自己的成就。以至于没有动力，没有耐心，没有毅力，以至于最后任欲望侵袭，堕落。</p><p>其实自己的初心是好的，但是为什么在初心之后的前行道路上会有如此大的阻碍呢，我觉得就是急功近利的心态，心急吃不了热豆腐，这句话适用于人生道路上面的每一寸。</p><p><em>不要因为走的太远，而忘记为什么出发</em></p><hr><p>本来只是一个生日的小总结，不知不觉就说了这么多，本来只是想写写在重庆遇到了什么人，遇到了什么样的事情，但是还是抵御不住欲望的诱惑，主要还是焦虑，急功近利的心态毁了自己，自己在重庆得到的最大的收获便是在热闹的外界环境下，保持一份静谧，就像火锅配料上面的耗油，虽然起不到任何好吃的作用，但是却能在自己最辣的时候，给自己一点静谧。</p><pre><code>这次的重庆之旅，有遗憾，有可惜，有没有完成的心愿，也有没有尽兴的地方，但是越长大越发现，我们总是希望人生中没有遗憾，可是到后来才发现，人生的遗憾才是人生中最有魅力的地方，因为有遗憾，才会有所向往。所有完美的东西最致命的弱点就是没有遗憾，从而也就没有了向往。现在是凌晨的一点钟，自己还坐在火车上面颠簸，但是自己却有点享受这个时候的氛围，过道里时不时有人走过，有人上车，有人下车，旁边呼呼打鼾声音，还有时不时飘来的香烟味，提醒我 原来一直以来追求的生活就在周围。</code></pre><p>希望自己回去以后可以好好的安排自己的人生，不要焦虑，不要急功近利，健身计划，英语六级，编程之路，成长之路，太过于追求结果就会导致失去自己想要的结果。</p><p><strong>生活里最妙的永远不是按部就班，规划好的结果，而是转角里不经意的惊喜</strong></p><p>祝自己21岁生日快乐。</p>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人经历 </tag>
            
            <tag> 旅行 </tag>
            
            <tag> 重庆 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2017~2018.5.1个人小结</title>
      <link href="/2018/05/01/2017-2018-5-1%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%BB%93/"/>
      <url>/2018/05/01/2017-2018-5-1%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实心知肚明自己的拖延症是非常强大的，总是在有意无意的拖延着，本来最先开始的预计是每一年都会写一个年终总结，然后2017年的年终总结直到现在才开始下笔，每次都有理由是最近的自己很忙很累，没有办法静下心来认真的写一写自己的总结，同时也秉持着“下一次一定有时间，其实后面的时间还多些呢？”然后就是这一些想法使自己拖延习惯变得越来越严重。也就有了今天”排除万难“在五一假期的第一天，在大家都出去郊游的情况下选择自己在宿舍里面好好整理。</p><p>从当初上大学一直到现在，说实话自己还是有点自命清高，也就是不太喜欢现在的环境，不过这种心态发展到现在，已经剔除了这种心态里面不太好的一面。这种想超脱环境的心态，我不知道该不该评价其的好与不好，但是我只知道的是，如果要超脱到现在原有的环境的话，得比周围的人付出200%的努力。</p><p>但是鉴于自己的表现，真的达到了200%的表现吗？我不知道，因为不知道自己努力的方向在哪，什么都想学，什么都想出人头地，但是却又什么都做不好，其实我现在越来越觉得人生最难的就是再控制好广度的同时钻研好深度。我觉得这才是难以控制的。落实到我现在的生活里面来看。上个学期的事情不去谈论过多，毕竟上个学期是来到学校的第一个学期，什么都很新鲜，由于好奇心的相互探索，自己找到了很多有趣的朋友，并且接触到了辩论，然后上个学期在保持学习进度的同时，在辩论上面进行了发展。上个学期就大学第一个学期而言，就算有太多的目标没有完成，但是这也都是可以值得原谅的。</p><p>现在我就要说的是大学的第二个学期，大道理每个人都懂，每个人都不是特别喜欢对自己说教的人，尤其是那个对你说教的人还是你的同级的时候，就更不容易接受，特别是自己做了一件事情，渴求肯定的时候，这个时候别人的”善意性质的批评“我觉得一定是听不下去的，但是对于自己而言，也许别人不会来说自己这一方面的事情，但是自己心里一定还是要有一些自知自明的，我知道对于自己这半个学期而来，很不满意，分几个块来说，由于自己每一方面都想要顾到，然后到最后自己每一方面都没有顾到。健身，辩论，编程，绩点学习奖学金，志愿者，旅游，自媒体写作，个人感觉这每一块都没有做好，因为每一件事情都想做好，但是每一件事都需要大量的时间基础很沉淀，于是我觉得目前最好的解决办法就是进行时间上面的优先级排序，把现阶段最重要的事情拿出来排到前面，自己想做，但是又不是必须做的事情放到后面。于是我就做了一下这张思维导图。</p><p><img src="/2018/05/01/2017-2018-5-1个人小结/1.jpg" alt=""></p><p><img src="/2018/05/01/2017-2018-5-1个人小结/2.jpg" alt=""></p><p>我目前的想法是想把计算机专业层面的学习放在第一位<br>然后就是英语方面的学习，然后就是大学课程上面的学习。然后就是之后的兴趣发展。但是发展到现在，讲真的自己还是有点松懈了，没有以前的那股劲，但是就是羡慕那些有本事，有能力的人。之前的生活就是每天编点程序，学计算机方面的东西，然后也就是因为这些导致了翘课，导致了松懈，导致了现在会在宿舍里面发呆也不去教室上课，这些统统是导致的。我觉得这仍旧是自己开始松懈的标志，但是更是由于这些，我的生活也变得不太规律，之前一个星期每天估计一两点睡觉，而且早上不会再像以前一样去教室自习。我觉得我也不会像以前一样暗示自己这都不是个事，因为天然默认未来一切都是好的。然后就莫名其妙的给自己发一大段一大段的鸡汤 。这次的总结 我不想给自己讲大道理，因为全部都懂，我只想批评自己，只想反省。自己做的不对的地方就应该去改正。</p><p>未来还有一块是关于辩论队是去是留的问题，由于时间以及自己按照排序想做的事情冲突，不得不退了校队，并且极力减少自己再院队里面的比赛，但是自己还是比较喜欢这方面。但是没有办法，因为只要打乱了那个优先级排名的话，那么自己所有的事情都会乱。并且我喜欢自己做事情能够专一，最近发现自己在专一度上面没有很用功，后面可能会考虑尝试一下番茄时间。总之对于辩论队的诸多事宜，我最终决定还是仅仅是当作一个爱好，为自己的本命学科让路。</p><p>下一个问题是关于坚持，本来我觉得在这个层面是不存在的问题的，但是最近感觉的自己的自制力越来越差，其实毅力也就像肌肉，你只有多练练，才能使毅力这块肌肉越来越硬。所以以后跑步健身都要勤快点，去锻炼毅力这块肌肉。</p><p>最后是关于人际交往，有室友层面的，也有朋友层面的，交往一定要懂得度，这个度的把握，不仅要体现在自己身上，还要体现在别人身上。对于某些自以为是，只会偏激并且片面评价别人的人，我觉得还是把他们当作大神供起来吧。</p><p>贱人自有贱人收，我没办法弄他们，因为我不是贱人。</p><p>最后的最后希望从这个五一假期开始就带来改变，记住自己的优先级安排表，同时也记住坚持和努力，永远与自己的懒惰和松懈战斗下去。</p><p>总之对于现在而言​​，从5月1日到接下来放假的时间里，需要完成的目标有：</p><p>1、计算机编程语言C++的相关补充（尽量来看，还有暑假可以用来看）。</p><p>2、英语四级必须得过，接下来时间把英语听力弄好，每天尽力完成一套英语卷子。</p><p>3、体育锻炼 运动，马上夏天了，如果不想显示出自己的肥肉的话，得好好努力了。</p><p>​4、保证接下来不挂科。允许不再以拿奖学金为主要目的。</p><p>5​、闲暇时间都看点自己感兴趣的书籍，不要再刷电视剧了。（这一点尽量控制）</p>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2017年中秋节感慨</title>
      <link href="/2017/10/05/2017%E5%B9%B4%E4%B8%AD%E7%A7%8B%E8%8A%82%E6%84%9F%E6%85%A8/"/>
      <url>/2017/10/05/2017%E5%B9%B4%E4%B8%AD%E7%A7%8B%E8%8A%82%E6%84%9F%E6%85%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我一直以来觉得生活的意义就是上进，就是毫无理由的提升自己，让自己变的更有价值，更有意义。这种思想产生于小时候受到的好好学习，努力考上大学的功利思想吧。但是也就是这种思想促使我一步一步走到现在，虽然没有太大的成就，但是也与周围的人拉开了距离。很久以前自己的这种思想也经常延申出另外一种表现方式。那就是比较。我觉得现阶段在我生活里的所有上进，所有快乐和所有成就感全部都来自于比较。我的大学比某些人好，我某些优点比某些人好，我比某些人更懂得生活，这些都会让我感到一种优越性质的快乐，就是我比别人行，我比别人厉害的快乐。但是反观这种快乐的来源，虽然从一定的角度上，他可能促进了我对上进意义的探索，但是也限制了我对未来意义上的追逐。比如说，我今天看到一个以我所谓的评判标准比我差劲的一个人，我会开心。但是当我看到一个比我厉害，或者说是我认为没有我厉害但是却做了一件我觉得很了不起的一件事情，这个时候我会难过，因为我不知道自己能不能做的跟他一样好，或者说是比他还要好。我之前觉得这是一种嫉妒心里，羡慕妒忌别人比我好的，却殊不知别人是付出了多大的代价达到这一步的。我知道有的时候妒忌心真的没有办法避免，至少我是没有办法去避免这种不好的心里，但是将这一点往深层次去考虑，这何尝不是一种自卑心里呢？曾经的我极度鄙视嫉妒心里，所以认为一切比较都是没有必要的，一切比较都是满足自己虚无的虚荣心，但是这样做的后果又是什么样的呢？这样做的后果是害怕比较，厌恶上进，难道这一切真的只是比较错了吗，还是说那种虚无的妒忌心真的毁灭一切的根源吗？<br>我觉得可能还是内心深处弱点，我觉得这可能需要我接下来几十年的经历和历练去完善的问题，自卑。这里说的自卑可能不是那种口头上的什么我不行，我真的不行。我觉得这不叫做自卑，那叫做自暴自弃。自卑的心理我觉得纯粹是来自于价值观中的悲观体系，和性格中无法避免的软弱以及懦弱。可能这一系列的说法特别宽泛和抽象，那我举个例子。比如说我现在热衷于唱歌，如果我发现一个不是那种天赋流，仅仅是通过努力提升上去的人，唱歌突然变得很厉害了，按照正常人的想法，第一也许会妒忌，或者是倾佩。但是这两者之后我的反应就是难过与害怕。也许这里害怕这个词用的过于夸张，但是我想说的这个词用的很准确。我一向觉得有些事情如果发生在别人的身上那就是别人的事情，跟我与我自己所处于的世界是无关的。这是我基本的理念，但是我为什么会感到害怕呢？究竟是害怕什么呢？仅仅是害怕别人做的更好觉得自己会被嘲笑吗？<br>我觉得可能是我性格上的问题，我可能还是有点需要被肯定，被积极对待的心理。简单来说是需要得到更多的爱与关怀。当遇到这样的事情之后，我的第一反应是他做的更好了，我为什么做不到，那肯定是我自己太没用了，自己太没用了，那么别人一定不会注意到这么失败的自己，因为自己太没用了。而且最致命的可能就是，觉得自己无论怎么努力都无法超过他。<br>到最后虽然自己崇尚生活在自己的世界里，但是还是用别人的价值观和别人的成功与失败的来衡量自己。我觉得这是我这一个阶段需要解决的问题。归根到底，也是自己不够强大，内心世界还没有像钢铁一般。说实话，目前的我找不到解决这个很好的办法，但是可以一步一步的改变，而且这些改变也在我的身上潜移默化的进行着，比如说，更加坦然的面对自己，面对生活中的别人的优点与缺点，不再仇视比较，不再过多的去关注比较后的快乐与悲伤，虽然现在还是会有一些优越性质的高兴与难过，但是不会去主导自己心情。虽然仍然无法专注与自己的生活，但是一路走来我觉得自己成长的心路历程也是我最伟大的财富。祝自己中秋节快乐。</p>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长 </tag>
            
            <tag> 中秋节 </tag>
            
            <tag> 青春 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于军训体制的一些思考</title>
      <link href="/2017/09/15/%E5%85%B3%E4%BA%8E%E5%86%9B%E8%AE%AD%E4%BD%93%E5%88%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
      <url>/2017/09/15/%E5%85%B3%E4%BA%8E%E5%86%9B%E8%AE%AD%E4%BD%93%E5%88%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天是军训的第七天，到了军训最后的阶段了，按照大家的说法和教官们的默许，最后几天就是纯放松型的交友盛会。回顾最先开始的几天，我觉得所有对这对生活里美好的期望全部被一些存在与生理上的痛苦所摧毁。在最初开始的几天里，我现在唯一记下去的就是我们的教官连长是如何吼我们，用他所谓的阶级思想来压榨我们的自由，我不知道自己这样的说法是不是属于正确的，因为在我们国家这种部队制度，本来就是军人务必服从命令的思想支撑。在此之前我的所有思想体系，全部都是基于一点，任何人都不能阻挡住我的自由。说实话，这种思想我认真想了想，就是考虑了下产生这种思想的原因，大概率可能是青春期里的叛逆？还是独立思想及独立人格作怪？我曾经在一本书里看到的一句话，人永远不可能完全自由，也就是不可能完全跟着天性的方向行走，因为社会这个产物，本来就是各种规则相互碰撞的结果。但是在现在这种部队制度越来越变味。我所理解服从命令应该是助于管理，以便于提升完成任务的效率。而现在这种服从命令越来越多的转化成了对权利的一种狂热，也就是所谓的官大你一级压死你。越来越多的人用命令进行压迫做一些无法理解甚至是利己的事情，也就是越来越多的在部队里面的人开始崇拜权利。于是越来越多的军痞产生了。我觉得军人在任何时候首先要做的事严格要求自己，比如说一些基本的军人常识，不要总是要求别人做到，然而自己却做不到。反而违背了军人服从命令的初衷。<br>我知道并且也相信着我所遇见的军人中有很大一部分只能被称作为军痞，但是这个世界上正直的军人一定很多的。但是有这样的经历也不可能完全避免掉，在这些天里，我收获最多的是我会被磨平的急性子和自己的忍耐能力。虽然每天都在倒计时数数还剩下多少天，虽然每天都在心底里与这种在我看来毫无意义甚至是毁灭人性的虐待作斗争，但是我知道这种时候可以反抗，可以直接甩脸就走，但是自己已经成人了，成人必须具备这样的一个观点，成人的世界里必须遵守规则。不遵守规则的人直接出局。所以就会有忍耐的存在。现在真的是什么决定最后的承担者必须是自己了，对自己负责，遵守游戏规则。这次军训前面很累后面很轻松，新的生活即将开始，准备好自己的健身计划，英语和读书计划，这是你需要做的事情。最后来一句振奋人心的鸡汤。<br>未来的你一定会感谢现在拼命努力的自己。</p>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 青春 </tag>
            
            <tag> 经历 </tag>
            
            <tag> 军训 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>遗失的2016与无限可能的2017</title>
      <link href="/2017/08/01/%E9%81%97%E5%A4%B1%E7%9A%842016%E4%B8%8E%E6%97%A0%E9%99%90%E5%8F%AF%E8%83%BD%E7%9A%842017/"/>
      <url>/2017/08/01/%E9%81%97%E5%A4%B1%E7%9A%842016%E4%B8%8E%E6%97%A0%E9%99%90%E5%8F%AF%E8%83%BD%E7%9A%842017/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>与上一次写下博客的时间实在是过去了太久太久，从去年高考的意外失败，到今年高考过后不知道是应该开心还是惋惜的局面。我知道自己并不是一个强调高考一定是一件关乎生死的大事。之所以选择复读这条路呢，是觉得不甘心，因为知道自己是一个容易受环境影响的人，不甘心就此平庸下去。于是这一年就像是消失，不再关心网上的一些动态。<br>先开始是抱着苦读书的心态加入到了复读的队伍中，但是等到真正融入到那个环境中自己一个致命的毛病再一次犯了，开始轻视自己最后的目标。开始浪，开始没有高三那年这么不认真学习。虽然最后结果不差，从湖北省的66000多名跳到了24000名，但是我觉得如果当时自己不那么轻视高考的话，肯定会更好。但是人生就是人生，经历过才会刻苦铭心。<br>这一年说长也不长，说短呢，倒也是盼了数不清的日日夜夜。在复读的班级里我见过各式各样的颓废，与各式各样的惨淡，还有各式各样的对梦想的摧残与亵渎，甚至在有一些人身上完全不用跟他们谈论梦想。我觉得这就是一种提前衰老的世俗气和死气，跟他们相互交流的过程中，难免不会被其沾染分毫。由于种种原因换到外面的合租寝室与另外一个复读班级。不过还是经常用一些稀奇古怪的理由去翘课。现在想来没有指责，也没有什么引以为豪的变态想法，只剩下一种好笑的想法。不过在复读的过程中，我有一次还经历请来了警察，事情的原因是我忍受不了一些狗血与荒谬的规定，我于是就与其对着干，然后对方以我闹事为名请来了警察。就跟警察好好聊聊呗。最后得出的结论，也就是从这件事情得出来的想法，社会上是存在狗眼看人低的现象，也存在某些荒谬的规定，但是如果你没有改变这些规则的能力与筹码的时候，你最好还是忍下来，免得最后受伤害和出笑话的都是你。<br>最后6个月和7个月的时候换了寝室，跟两个自认为玩的不错的朋友合租了房子，之所以会产生矛盾就是觉得模糊了朋友与室友的关系。我觉得这一点我到大学去一定得注意。朋友是志同道合的，是可以交心的。而室友则是只是住在一起，有的时候不需要有共同的奋斗目标，只是住在一起，衣食住行上的相互照应。室友没有必要会成为好朋友。这就是以后需要注意的地方了。<br>然后就是体重问题了，这个是硬伤，本来去年去复读前体重为84公斤，好不容易瘦下来的，现在才刚刚恢复到顶尖水平。不过加油吧。这个东西是急不来的慢慢加油一定会看到成效的，正所谓，玉树则不达嘛。不过以后还是要有一个好的健身计划和健康的作息时间表。<br>要说这一年成长了么，我觉得主要是由以前理性的思维变得更加多元以及更加深入，谢谢奇葩说和狼人杀这两项事物让我看到了这个世界上还存在着诸多可能性。呵呵，年轻就有无限可能嘛<br>还有一个月就要读大学。虽然有时候觉得这个大学也选的不怎么样，毕竟可以当作是滑档下来读的一所大学，但是听到一句话，你没有到这个学校的第一名，你是没有资格指责这个学校对你是没有益处的，因为在这个学校里面你总是会有上升的空间。以前真的有一种心态，就是特别想找一个对象，好好过，好好风花雪月，曾经也堕落过，也糜乱过，有的时候想想我们这个年纪很容易把欣赏当作是喜欢，把一种羡慕的想成为当作是爱情，到最后反而使爱情的真谛隐下去了，我觉得爱情就是平等，精神上的平等，互相成长，互相加深对人生的理解，也许有的时候性和欲望会常常来干涉，但是无论如何都占据不了爱情的真谛。我年纪还小，对婚姻的理解还尚在上一辈之间，他们让我感受到最多的是生活的迫不得已，也就是无可奈何的一起过日子。会不会结婚，能不能结婚，这都不是现在应该考虑的问题，我一生都会秉持着一个理念，Follow my heart 。我现在所做的一起努力使为了让未来的我在事情的抉择方面能更加靠近本心本愿一边。当然现在还不能把大学最终朝哪个方向定下来。但是勇敢，无畏，我觉得是人生中最重要的品质。在我的视角里荒废的2016年，就给2017年的我无限的可能。在今后的生活中我觉得一句话可以成为我的路标<br>没有什么可以通向真诚，因为真诚是通向一切道路。<br>真诚面对人，面对事，面对今后可能出现的无限挫折难过，以及开心完美与胜利。未来无论如何，总之我真诚，我坦荡，我会让这无限的可能尽可能的按照我心想象的方向前进。加油。因为你叫王舒啸。</p>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长 </tag>
            
            <tag> 青春 </tag>
            
            <tag> 经历 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2015年年度总结</title>
      <link href="/2015/12/02/2015%E5%B9%B4%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2015/12/02/2015%E5%B9%B4%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今年是一个神奇的一年，做了许多以前没有想过的事情。但也碰触到了一些禁忌的事。泰戈尔也说过，人天生最强大的力量便是成长。对，就是成长。我们每一个人生来就不是完美的，我知道自己的缺点，自己的懦弱，自己在2015年所犯下的错误。但是还好，已经过去了，我也应该长大了。我也同样记得柴静说过的，只有同样经历过的人才有资格说我理解你。<br>2015年上半年经历过一场车祸，终于从小孩子的认知，强行提升到了成人阶段，虽然有诸多不愿，但是，仍在慢慢适应。高二上学期，高二下学期，高三。时间过得很快。我理解了很多以前不理解的，看到了以前看不到的。人真的只有经历过痛苦才会知道自己真正想要的是什么。有的时候欲望，贪念，真的会毁掉一个人，但是也只有承受住来自与其磨难才可以真正成人。 但是由于自己的意志力不够，总是失败，但是我也不会妥协，抗争到底，这才是我。不过说到意志力，何谓意志力呢，个人觉得是一种抗逆的能力。抗拒痛苦和诱惑的能力。不巧，曾经拥有过的品质，由于生活过于安逸，再逐渐消失。比如说自己的拖延症，说大不大，但是说小也不小。我讨厌痛苦，这就是拖延症本质的原因。包括，给自己的任务完成不了，这也是其原因造成的。没有毅力。容易在家人面前控制不住自己的情绪。新的一年，我一定会改变这些。<br>这一年里，也结识了许多人，逐渐知道社会7上的人情冷暖，以及人脉。我不想知道这些，但是现在能做的也就是默默的接受，总好比一味的抗拒。自己的性格也改了很多，一切朝好的方向进行转变。现在的我，也会学习每个人自己所遇到人的优点，从而改变自己。也许缓慢，但是方向是对的。<br>关于你自己，我知道有的时候会有一种奇异的感觉包围着你，但是请相信一切的一切都会好的。打破常规，遵循本心。只当做看阴阳造化了。<br>今后的日子，我希望自己能够坦荡做人，活出真实的自己，与自己的邪念抗争到底，完成自己的目标，过一种“没有任何借口”的生活。对自己，对别人，对一切负责。<br>最后的最后，祝自己高考圆满，不求痴心妄想，只求问心无愧。</p>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>看见与经历</title>
      <link href="/2015/08/29/%E7%9C%8B%E8%A7%81%E4%B8%8E%E7%BB%8F%E5%8E%86/"/>
      <url>/2015/08/29/%E7%9C%8B%E8%A7%81%E4%B8%8E%E7%BB%8F%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>  一直以来都是想写点什么，距离我上一次发博文也已经过去将近半年了，这半年里，也可以说这2015年里对我的改变也是挺大的。知道什么是苦，什么是乐，什么是欲望，什么是爱。今天是距离高三开学的最后一天，不知道我为什么总是这么喜欢做这样的事，直到最后一步才开始完成。我知道来自于自身里的缺陷。我懒，我没有过大的自制力，也没有太强的执行力。 我很懦弱，所以逃避。我一直坚信着一个人最可怕的并不是弱点，而是在有生之年并不去改变这些缺点。强点就是将自己的懦弱<br>     前些日子也看过一些书籍，这本书对我的启发很大，并不能说这本书给了我很大的感受，因为那都是别人的生活，别人的人生历练。但是他打开了我通向这个世界的大门。我知道生，也知道死，也知道爱，只是有的亲身经历过，有的并没有经历过。我知道主观，也知道客观。这些带给我的都只是我人生路上的一个经历。曾经的我认为要对身边的人无下限的好，也曾经认为自己已经很成熟。认为自己的消极的态度就是成熟之人必备的。错错错。真正的成熟就是要在外界的压力和内界的蜕变下找到真正的自己，所谓破而后立，当你已经立到不能再破的时候，你也就形成了自己的思想理论和自己有别于他人的鲜明个性。而往往来说这个过程却是要花费一辈子的时间。<br>     马上这个暑假也过去了，在这个暑假里，我由衷的觉得欲望和爱之间的关系，我可以做一个只有欲望的人，面对形形色色的人不动自己的生色。我目前觉得找一个与自己惺惺相惜的人那种默契才是我真正需要的。当人考虑这些东西要等到大半年之后，等我高三结束之时，也就是我人生觉醒之刻。这个夏天学会了一个人去旅行，学会了看题图，学会了处理自己与运动之间的关系。明天我将再次踏上战场，整装待发。<br>       一直相信自己，从不会失望。<br>                                                                                                                墨橹 写于 8月30日</p>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长 </tag>
            
            <tag> 经历 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【书记】活着</title>
      <link href="/2015/04/06/%E3%80%90%E4%B9%A6%E8%AE%B0%E3%80%91%E6%B4%BB%E7%9D%80/"/>
      <url>/2015/04/06/%E3%80%90%E4%B9%A6%E8%AE%B0%E3%80%91%E6%B4%BB%E7%9D%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我今天要分享的小说是活着，这本小说讲述的是一个人与命运之间的关系，他们无法接受对方，但同时也没有办法背离对方。这本书我的很多朋友都看过，他们为故事里的悲剧角色叹息，甚至有几个感性的朋友每每谈起这本书总会泪滴点点。这本书如果整个看下来我看过9遍，只是一部分一部分的看的话，我看过不止十八遍。虽然这里没有像‘书读百遍，其义自现’的体会，但还是有了自己感受。<br>首先我先声明我讲的东西并不深刻，也没有深度。你们知道什么叫作深刻么？其实一个人的存在并不深刻，但是这个人背后所浓缩的某些特点，与整个社会的客观存在某种现象的相联系，这才是深刻。我并不想去批判那个时代所呈现的劣根，因为这常常才是使人绝望的地方.<br>我现在就向大家简要介绍一下《活着》这本书的故事剧情：<br>故事里的主人公叫做福贵，是一个阔绰的少爷，他娶了一个妻子家珍，并且有一个4岁的女儿叫做凤霞。之后的悲剧也就是从这里开始的。福贵因为参与赌博被黑，卖掉了房子，输了全家三代积累下来的财富，自己怀孕的妻子家珍被老丈人无情带走。留下女儿和母亲相依为命，再过了一年多的苦生活后，家珍就带着一岁的儿子有庆回来，开始了一家人的平凡的农民生活。<br>但是就在不久之后，福贵的母亲病了，福贵去城镇里请大夫，但是被国民党军抓取做壮丁，辗转两年被解放军所救，即后也就跟这解放军回家了。此时家里，母亲已经去世，女儿凤霞在一次高烧后变成了聋哑人，听妻子说母亲临终前一遍一遍的对妻子说，福贵是不会去赌博的。<br>福贵也就在家里安顿下来，过了好几年，因为家里穷，只能卖女儿，让儿子去上学，最后女儿跑回来不忍送走，就留下来了。日子就这么一天天的过去，有一天因为县长的老婆生孩子要输血，结果儿子有庆被一个不负责任的大夫，给抽死了。后来竟然发现县长竟然是福贵当年相依为命的战友春生，不过春生之后也死于文化大革命。过了好几年，凤霞嫁了一个偏头女婿二喜，不久后死于产后大出血。两个孩子去世后，妻子家珍把外孙接到乡下来住，可没过多久就安安静静的死了。女婿二喜之后死于一场事故，死的时候外孙苦根仅仅4岁，还不知道死的概念。只留下祖孙俩人活着，但是好景不长，小苦根也意外失去了自己的生命。晚年的福贵买了一头老牛，取名为福贵。一起安享晚年。<br>我这里并不想去讲这本书里所呈现出来的现实，也不想去评价这本书里的人物形象。这本书我看了很多遍，我甚至认为他们就像是我曾经与我精神交流的朋友。因为朴素，所以真实；因为真实，所以真挚；因为真挚，所以才会深深的触动我。在这里我只是想讲由这本书里我主管里延伸出来的3个问题吗，并且用我自己的生活感悟和经验，主观描述，客观阐述，解决的这三个问题</p><ol><li>什么是活着。</li><li>为什么要活着。</li><li>怎么活着。<br>首先第一个问题：什么才是活着。众所周知，生活的三大主题，生，死，爱。这三大永恒的主题将会影响我们的一生，生死相互对立而制衡，但是爱可以超越它们。（这里的爱并不只是男女之间的情愫，也并不是人与人之间产生的情感，具体来说它是一种主观感受，比如说喜怒哀乐恨，他们都是爱的一种表现）这里就为大家拓展下爱。大家谈到爱免不到就会想到《罗密欧与朱丽叶》，《梁山伯与祝英台》这两篇都是凄美且经典的爱情故事，他们所传达出来的思想则是”我爱你，所以我要为你殉情“大家知道随后即出的电影《泰坦尼克号》为什么那么有名，仅仅谈爱情一举超过了前面两部影片呢，甚至达到近几十年无人能敌的新的高峰呢，因为其提出了一个在当时特别前卫的思想理论‘我爱你，所以我就为你活下去，连同你的那一份一起活下去。”这就是爱，一定程度里爱可以超越生死。<br>接下来便是我个人对生死的看法了，因为我有过这方面的经历所以我有这个资格拿出来来给大家分享，其实我今年17岁。在此之前对生死一点概念都是没有的，何谓生，何谓死呢，之前我的主观感觉就是教科书的生与死。直到我经历他。大家知道接触生死的第一感觉是什么吗？也许大家并不知道，仅仅只是以为是害怕，是恐惧。那么你就错了，并不是这样。接触生死的第一感觉不是恐慌，而恰恰是兴奋，我无法描述是一种怎样的兴奋，因为持续的时间特别短，大概可以类比为是一个从没有吃过糖的孩子，第一次吃糖的感觉，多少有点新鲜感在里面。之后就是一种安不下心的恐惧感，这种感觉没有经历过的人是不知道的，那是一种无法装出来的感觉。事后我也进行相关资料的查阅，好像是一个叫什么卡的理论科学家发表的一篇论文叫《生死论》里提到人在濒临死亡的那一刻，潜意识里已经把自己当作死亡，这时的恐惧将是对生活以及其他人或事物的无限眷念产生的。所以就像我的一个老师所讲的这个时候的人第一想法就是想自己最亲近的人，比如说妈妈。呵呵。我当时也是无法静下心，心里一直想如果妈妈在身边就好了，就好像这个人可以给你带来无尽的心安。之后过了一会儿后自己的心就静下来了，那种静下来的感觉叫做庆幸。感谢自己他妈的还活着。说句实话，那次的经历让我之后的一个月很不好过去，但是他对我最大的意义就是他完全打开了我对外界事物感知，就像一个美妙的气孔被揭开，然后进行气体交流的感觉。只有到了那个时候我才真正的知道到底什么是活着。就像我前面所说的爱是一切感受的源泉，所以活着就是我们在这个世界上主观上存在的感受。包括生，包括死，包括爱，包括我们生活的任何一种主观感觉，这就是活着。</li><li>我们为什么要活着<pre><code>我很反感很多专家类的人物整天批判中国人没有信仰，中国人的信仰就是“好死不如赖活着，无论发生什么活着就行了。”活着这本书也就是讲为什么活着这个问题的，福贵在书里是这么形容自己的一生：&quot;我是有时候想想伤心，有时候想想又很踏实”一个早已进去垂暮之年的老人尚且如此，全家人的葬都是这样一位老人送走的，其中的滋味是我们所没办法想象的。那联系到实际，我们为什么活着呢，其实这个问题古往今来无数人士都参与过探讨，都没有得出一个科学性的结论。他们的探讨的过程大多数都是微观细胞的存在形式，和宏观宇宙的神秘意图。由我个人的观点，并没有 微及细胞，大至宇宙，也不像这本书里的观点。活着并不是为了活着以外的事物而活着，而是为了活着本身而活着。围绕这一个比较抽象的说法，也就展开了福贵的一生。中国有一个成语叫做千钧一发。让一根头发去承受三万斤的重压，但是头发并没有断。这就是中国人的韧性。真正强大的人并不是看他征服了什么，而是看他可以承受什么。所以我的答案也就由此而产生活着就是为了坚持，坚持去爱，坚持享受所有由活着带来的一切主观感受，坚持忍受由死去带来的一切恐惧体会，这就是活着。我的观点也就是这个，也许十年后我会推翻我的理论，（我已经推翻了我小时候很多的想法理论。）但至少现在不会。</code></pre></li></ol><p>第三，我们应该怎么活。<br>这里其实就要客观的来讲一下这本书的局限性。这本书里讲的是上个世纪从解放后的土地改革、人民公社制度、大炼钢铁、三年自然灾害、文化大革命之间，讲的只是底层人民对于温饱问题矛盾，缺少的则是精神世界的建设。当然在那个年代谈精神年代就像说梦话一样。但是现在的社会水平已经高于当年很多倍了，但是现在的人民幸福度却远低当年。这又是为什么呢？唯一可以解释的原因就是，人们解决了温饱类的问题后，精神世界的匮乏甚至是溃烂，出现了极大的问题。那么怎么解决呢。物质和精神上的协调与平衡该如何做到呢？一切随心，随自己的主观感觉，随自己想要完成的事情。人为什么会不快乐，大家知道么？是由于我们个人的主观感觉被客观规律法则所牵制，导致我们并不快乐。而往往这些客观法则规律常常是没有最正确的理由的，比如说为什么评判现在一个人书读的好，就一切都好。为什么长大后赚钱的多少是评判一个人是否成功的重要依据。实现人生价值评判方式有很多，为什么单单只是这一点。那还有为什么男大当婚，女大当嫁…还有很多问题我们问不出来缘由，这些都是整个社会所给予的。那么为什么社会要这样规定呢？肯定是对整个社会的和谐稳定有益处。但同时也造成了巨大的压力给个人。按照幸福最大化原理，没有人，或者说是没有生物从本质上讲是喜欢痛苦和苦难的。然而面对这一切压力，但总是有人活的潇洒。比如庄子的物我合一，陶渊明的物我两忘，这些都是境界上的潇洒。而我们该如何做到这些呢？唯有修心。提高心理素质和承受能力，寻觅物质与精神守恒的一点。这就是我们活着该做的事情。人生的最高的境界便是淡。我没有达到这个境界，所以我没有办法为大家展开。但是按照自己的心活下去，我相信万法同一。殊途总会同归的。</p><pre><code>写与2015年4月6日。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 书籍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书评 </tag>
            
            <tag> 创作 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[海边的卡夫卡的短书评]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B5%B7%E8%BE%B9%E7%9A%84%E5%8D%A1%E5%A4%AB%E5%8D%A1%E7%9A%84%E7%9F%AD%E4%B9%A6%E8%AF%84%2F</url>
    <content type="text"><![CDATA[《海边的卡夫卡》这本书以一个悲剧戏剧为蓝本，进行双线构造，相互交织，相互迎合，从而使一个十五岁的少年的成长历程逐渐完善。虽然取自于俄狄浦斯王中杀父奸母的桥段，但是结局导向以及传达出来的意义绝不一样，前者是悲剧式的自我毁灭以及无常命运的慨叹，而后者则是彻彻底底的自我救赎式的成长。不知有多少人曾在那里流血，你本身也会流血，温暖而又鲜红的血。你的双手将会接住它们，那既是你的血，又是别人的血，而沙尘暴偃旗息鼓的时候，你恐怕还不能完全明白自己是如同从中穿过而得以逃生的。甚至它是否过去都无从判断，不过有一点是你一定是非常清楚的，从沙尘暴中逃生的不再是跨入沙尘暴的你。每一个人的成长都是自由的，但同时却也是不可预测的。村上君用一个十五岁少年的成长史告诉我们在命运的妥协与抗争之间还存在救赎和成长。但是如果仅仅写出少年的成长史的话只能算一般小说。但是村上君肯定不会这样落入俗套，于是他巧妙利用第二条故事线，一个十五岁之后丧失一切的老爷爷的奇遇，这位老爷爷拥有着诸多神奇的能力，但是就是无法思考，记不清楚发生在自己身上的一切，甚至是与整个世界脱轨。看似与第一条故事线没有任何关联，实则丝丝入扣，一个十五岁之后拥有无限可能的人生经历和一个十五岁之后一切都是空白的人生经历相对比，更加深了本文成长与救赎的主题。这本书另一个引人注目的地方也就是作者村上春树对成长中最大的敌人的定义：缺乏想象力的狭隘，苛刻，自以为是的命题，空洞的术语，被篡夺的理想，僵化的思想体系，这些才是最可怕的，但是何为正确，何为不正确，这些都是值得深思的话题，但是某种个体的判断失误，在很多情况下事后不是不可能挽回，只要有勇气主动承认错误，都是可以补救。村上春树这本书以一个全新的视角诠释我们在成长之行上必定会遇到的善与恶，以及一步步走向顽强的心路历程，不要畏惧前方有未知的风暴，因为你是世界上最顽强的是19岁的少年。]]></content>
      <tags>
        <tag>书评</tag>
        <tag>村上春树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款11：在 operator 中处理自我赋值的情况]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE11%EF%BC%9A%E5%9C%A8operator%E4%B8%AD%E5%A4%84%E7%90%86%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E7%9A%84%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[本来是可以不用担心拷贝过程中发生自我赋值的情况，但是就是为了防止用户，或者对象自身的这种情况，所以需要完成避免自赋值的情况 比如两个指针对象进行自赋值的时候，为了防止多次删除，需要检查一下自赋值的情况。 同时不仅要考虑的是自我赋值的安全性，仍然需要考虑的是异常的安全，也就是前者是需要判断如果前者的地址等于后者的地址话 就直接返回不作为，并且先删除原本的，再赋值新的，而后者则是先构造一个对象赋值给另外一个，然后先赋值，再删除。 就类似于这样，这样既能保证自赋值的情况，但是又能保证异常安全，不会在new对象的时候发生错误。 还要记住的是一般在移动赋值运算符的时候也应该注意一下自赋值的情况，不过上面的异常安全很少涉及到，因为上面的相比于前者更费点时间。 或者是直接使用自定义的 swap 功能，这样的话对于自赋值的情况以及异常安全的情况来比，更加省事和高效。]]></content>
      <categories>
        <category>effective C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法]]></title>
    <url>%2F2018%2F12%2F01%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[贪心算法定义贪心算法的本质目的也就在于对于一个问题来看，我可以用最简单的办法算出局部的解集，并且按照这个最简单的办法同样可以算出该问题的最终解决办法，即贪心算法。 三个经典的贪心算法问题 事件的序列问题： 遇到这样的题目，首先就是要想着能不能找到最长的子序列的前提，到底是按节目的开始时间进行排序，还是按照节目的结束时间进行排序。下面就是核心代码12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 100+5;struct Show&#123; int beg; int en;&#125;show[maxn];int main()&#123; int n; while (cin&gt;&gt;n&amp;&amp;n!=0)&#123; for (int i=0;i!=n;i++)&#123; cin&gt;&gt;show[i].beg&gt;&gt;show[i].en; &#125; stable_sort(show,show+n, [](const Show &amp;a, const Show &amp;b)&#123;return a.en&lt;b.en;&#125;); int cnt=1; for (int i=1,j=0;i&lt;n;i++)&#123; if (show[i].beg&gt;=show[j].en)&#123; cnt++; j=i; &#125; &#125; cout&lt;&lt;cnt&lt;&lt;endl; &#125;&#125; 此处的关键就是从第一个开始把结束时间最早的进行一个相对位置的排序，然后把第一个结束的与后面开始的时间进行挨个挨个的比较，最终得出的结果就是在这里。 区间覆盖问题下面就是这道题目的核心代码：123456789int greedy(vector&lt;int&gt; x,int k)&#123; int i,sum = 1,n=x.size(); sort(x.begin(),x.end()); int temp = x[0]; //区间的起始位置 for(i=1;i &lt; n; ++i) if(x[i] - temp &gt; k) &#123;sum++,temp=x[i]&#125;; return sum;&#125; 题目这里就是分别计数，用一个最简单的思维做出一整道题目的思路。 区间相交问题：其实就是跟第一道题目类似 算连续的序列 并且把总长度减去这些连续的序列之后得到的是剩余的区间，即得到题目答案。 ==以后若还有关于贪心类型的题目可以继续往上面加== 一下就是贪心的习题]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树相关题目]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[复原二叉树 题解此道题目就是要注意先序排序与中序排序，一个是根左右，一个是左根右，先序排序的第一个为根，利用递推关系输出每一个根（由于其的递推出口并没有等于号，意思就是说这里同样输出叶子节点） 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;string pre;string in;void post(int root,int start,int end)&#123; //递归打印这棵树的后序，递归出口为 start &gt; end //注意这里不带等于号的原因就是要把叶子节点一样给输出来 if(start&gt;end) return; int i=start;//i为 root所代表的值在中序中的下标 while(i&lt;end&amp;&amp;in[i]!=pre[root]) i++; int cnt=i-start;//左子树结点个数 //由于是先序排序，顺序永远都是根左右， post(root+1,start,i-1); //左节点 因为是后序排序，先把左节点先弄出顺序，在左节点内部在来后序排序，直到两边左边节点大于右边节点 post(root+1+cnt,i+1,end); cout&lt;&lt;pre[root];&#125;int main()&#123; while(cin&gt;&gt;pre&gt;&gt;in)&#123; int len=pre.length(); post(0,0,len-1); cout&lt;&lt;endl; &#125; return 0;&#125; 关于树的一个简单DFS运用 题解 简单的dfs运用 可以模拟树的组成，但是特别耗时间，只用用相应的搜索方法来做才容易一点，这道题有必要再做一遍。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;const int maxn = 1e5+5;//此处实际上是充分利用了vector的特性//如果此处是二维数组的话，那么一定会浪费许多没必要的空间开支//所以用一个vector的数组，每个vector存储其对应的祖先//而一共有题目给出数量的vectorvector&lt;int&gt;people[maxn];char sex[maxn*2];int ans;int top;int que[maxn];//这里e的值只是用来判断到底是该植入值还是该判断值//换算到这个题目中的意思就是前面一个人不需要看起祖先只需要输入其祖先就行了//后面一个人则需要做的是根据已有的对方祖先进行判断void dfs(int x,int s,int e)&#123; if (s&gt;=5) return ; if (e==0)&#123; for (int i=0;i!=top;i++)&#123; if (x==que[i])&#123; ans=1; return; &#125; &#125; &#125; else que[top++]=x; for (int i=0;i!=people[x].size();i++) dfs(people[x][i],s+1,e); return;&#125;//上面的递归搜索可以用来因为是从底层向上面进行搜索//由于孩子祖先有两个所以上面搜索方式每一个孩子的祖先作为单独的节点再次进行搜索，直到递推出口为止int main()&#123; int n; cin&gt;&gt;n; char ch; int x,fa,ma; for (int i=0;i!=n;i++)&#123; cin&gt;&gt;x; getchar(); cin&gt;&gt;sex[x]; cin&gt;&gt;fa&gt;&gt;ma; if (fa!=-1) people[x].push_back(fa); if (ma!=-1) people[x].push_back(ma); sex[fa]='M'; sex[ma]='F'; &#125; int k; cin&gt;&gt;k; for (int i=0;i!=k;i++)&#123; cin&gt;&gt;fa&gt;&gt;ma; ans=0; if (sex[fa]==sex[ma]) cout&lt;&lt;"Never Mind"&lt;&lt;endl; else&#123; top=0; dfs(fa,0,1); dfs(ma,0,0); if (ans) cout&lt;&lt;"No"&lt;&lt;endl; else cout&lt;&lt;"Yes"&lt;&lt;endl; &#125; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL的简单总结]]></title>
    <url>%2F2018%2F12%2F01%2FSTL%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[补一个加快C++输入输出速度的方法： 花上一天的时间来总结 C++ primer 里面的算法以及容器这一章，多余的用法可以上网去查找当做是相应的扩展。 字符串 string与字符数组 构造string的方法 操作string的方法 上面的成员函数有的说要返回，同时，有的也存在不返回值。 搜索string的方法 以上就是find函数的一些用法，在泛型算法一章，还会继续涉及到。题目返回的是下标 补充一下关于string中的比较函数一般在string中可以直接用运算符进行比较 int与string之间的转化 getline()的两种写法注意在cin&gt;&gt;t;必须要一个getchar()来吞掉其前面的回车符号。之后才能用getline()。 顺序容器 容器种类 vector&lt;vector&lt;int&gt; &gt;来表示二维数组。 容器基础操作补充一个assign的用法：允许从一个不同但相容的类型里面去赋值，或者从容器的一个子序列赋值。 还有第二个版本：接受一个整型值和一个元素值，用指定数目且具有相同给定元素替换容器中原有的元素： 再补充一个resize的用法： 需要记住有一些类型声明可以直接用auto。 初始化有两种一种直接初始化和拷贝初始化。 顺序容器添加元素上面已经列出了各种形式的插入。插入是在迭代器指向的元素之前插入。插入想要插入的元素前面，比如说push_back是插入到了尾后迭代器的前面。而返回的是新添加的第一个元素的迭代器，同样也可也==不返回==。 这里要注意的是push_front会改变整个容器的迭代器指向，而push_back不会。 访问元素 链表，单向链表，栈，队列都不支持随机访问，也就不支持下标访问了。 删除元素 删除的是迭代器指向的元素，返回的是删除元素的后迭代器也就是被删除的元素下一个元素的前面的迭代器，同样也可以不返回。 这里需要注意的就是删除一个元素之后，必定会改变原容器中迭代器的指向，所以务必小心（除了pop_back） 改变容器大小的操作 特殊的forward_list（单向链表） 由于迭代器的添加删除操作都涉及到了首前和尾后，所以对于单向链表来说这里添加了一个首前迭代器before_begin而对于单向链表的插入而言 是在元素的后面进行插入，删除也是一样，指向都是迭代器指向元素之后的元素。 关联容器 **关联容器里面的pair 关联容器的操作 关联容器的添加操作 一般都是直接用下标操作添加map里面的操作。at操作只能判断存不存在 关联容器的删除操作 关联容器的访问操作 上面关于排序的操作不适用于无序的关联容器。 当允许关键词重复的multimap中查找元素时，一般使用find函数与count函数同时进行。 算法大部分函数算法都放在&lt;algorithm&gt;的头文件里面了。还有一些数值算法是放在了&lt;numeric&gt;的头文件里面。 只读算法 accumulate 求和算法，接受三个参数，前面两个参数是累加范围，第三个是和的初值。equal 判断两个序列里面是否所有的值都相同。后面网上查找 有的再补充。find算法binary_search()二分查找函数find_end()最后一次出现算法find_first_of()第一次出现的算法find_if ()第三个参数就为自定义函数搜索lower_bound()第一个不小于的元素upper_bound()第一个大于的元素count（）算法 计算出现次数count_if（）函数自定义计数 写容器的算法 fill 填充算法 类似于memset函数前者在于可以赋值赋任何值，而后者理论上只能赋值0或者1或者0x3f3f3f3f。fill_n也是三个参数，第一个是开始点，第二个是赋值数目，第三个为赋值初始化。copy 拷贝算法，接收三个迭代器，前面两个表示输入范围，第三个为拷贝目标序列的起点。replace 替换算法，将目标序列里面的某些值更改成某些值，接受四个参数，前面两个是目标序列的范围，第三个是要搜索的值，第四个是要将搜索到的第三个的值更改后的值。remove 去除掉函数里面包括的参数的元素。remove_if 自定义。remove_copy 拷贝结果。swap（）交换两个对象的值。swap_range()交换两个序列的值。 重排容器的算法 其排序的算法中，定义的排序方式就在于自定义函数传入算法中。有三种自定义函数： 普通bool型自定义函数，比较排列顺序。 lambda 匿名小函数。 bind 函数 绑定谓词。灵活的应用自定义函数。 unique 将容器中所有重复的值全部排列到后面去，接受目标序列的迭代器范围，返回指向第一个重复元素的迭代器。sort 排序 本质上运用的是快速排序。stable_sort 本质上运动的是归并排序。stable_partition 前面进行排序后，把自定义排列的分割开来。reverse 倒排函数。reverse_copy 倒排函数。rotate 接受三个参数，前面两个是要往后面排的范围。 迭代器 插入迭代器back_inserter 类似于push_back的迭代器，创建并且使用front_inserter 创建并且使用一个push_front的迭代器inserter 创建一个普通插入的迭代器 流迭代器istream_iterator 输入迭代器 ostream_iterator 输出迭代器 反向迭代器reverse_iterator 移动迭代器后面复习到在总结 移动、拷贝、右值引用。]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>数据结构</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道STL的题解题目，需要以后花时间理解题目意思]]></title>
    <url>%2F2018%2F12%2F01%2F%E4%B8%80%E9%81%93STL%E7%9A%84%E9%A2%98%E8%A7%A3%E9%A2%98%E7%9B%AE%EF%BC%8C%E9%9C%80%E8%A6%81%E4%BB%A5%E5%90%8E%E8%8A%B1%E6%97%B6%E9%97%B4%E7%90%86%E8%A7%A3%E9%A2%98%E7%9B%AE%E6%84%8F%E6%80%9D%2F</url>
    <content type="text"><![CDATA[代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;//#include&lt;function&gt;#define ll long longusing namespace std;const int fort = 1314;ll a[6];//这道题目就换一种思考方式，让基数分贝加上加数，这样一来，就会简化很多步骤int main()&#123; int t; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;a[0]&gt;&gt;a[1]&gt;&gt;a[2]; a[3] = 5; a[4] = 2; a[5] = 0; sort(a, a + 6, [](const ll &amp;a,const ll &amp;b)&#123;return a&gt;b;&#125;); priority_queue&lt;ll, vector&lt;ll&gt;, greater&lt;ll&gt; &gt; pq; set&lt;ll&gt;s; set&lt;ll&gt;ans; pq.push(1); s.insert(1); for(int i = 0;;i++)&#123; ll x = pq.top(); pq.pop(); if(i)&#123; for(int k = 3;k &lt; 6;k++)&#123; ans.insert(x - a[k]); if(ans.size()==fort) break; &#125; if(ans.size()==fort)&#123; /*int ttt = 1; for(set&lt;ll&gt;::iterator it = ans.begin();it!=ans.end();it++) cout&lt;&lt;ttt++&lt;&lt;' '&lt;&lt;*it&lt;&lt;endl;*/ auto it = ans.rbegin(); cout&lt;&lt;*it&lt;&lt;endl; break; &#125; &#125; for(int j = 0;j&lt;3;j++)&#123; ll x2=x*a[j]; if(!s.count(x2))&#123; s.insert(x2); pq.push(x2); &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道有趣的题目——逆波兰计算器]]></title>
    <url>%2F2018%2F12%2F01%2F%E4%B8%80%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A2%98%E7%9B%AE%E2%80%94%E2%80%94%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[题解首先这道题毫无疑问是要用到stringstream流的。分别依次读取字符串，并且将其导入到char型的代码中去。比如说a+b可以变成ab+，这里最好运用到栈的知识，来控制出栈与进栈。==注意以下几个地方== 注意输入cin&gt;&gt;t以后，需要用getchar()来清空上一个步骤留下来的回车符号 注意此处需要严格进行判断栈内是否为空。 这里是将乘除求模的运算放在最右边，这样就可以有优先级存在了 括号会提前进行一步运算，然后消除掉左括号，或者左边的所有运算式，进行一个结算。 map这里存在的意义就在于 为判断进行提供条件。 此道题目涉及字符串，栈，模拟的相应算法，需要有空的时候可以多看看。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;sstream&gt;#include&lt;map&gt;using namespace std;stack&lt;char&gt;ope;stack&lt;int&gt;num;string str;map&lt;char,int&gt;m;void init()&#123; m['+']=m['-']=1; m['*']=m['/']=m['%']=m['(']=m[')']=2; while(!num.empty()) num.pop(); while(!ope.empty()) ope.pop();&#125;//此处为基本的运算规模。void op1(int &amp;a,int &amp;b,const char &amp;c)&#123; if (c =='+') a += b; else if (c == '-') a=b-a; else if (c == '*') a*=b; else if (c == '/') a=b/a; else if (c == '%') a=b%a;&#125;//此处就是控制出栈的运算，一般就是括号内部的计算了。算出每一个括号内部的运算式。void op2()&#123; char ch = ope.top(); while (ch != '('&amp;&amp;!ope.empty())&#123; ope.pop(); int a = num.top(); num.pop(); int b = num.top(); num.pop(); op1(a,b,ch); num.push(a); if (!ope.empty()) ch = ope.top(); &#125;//这个下面要注意的判断条件中一定要加上判断是否为空。 if (!ope.empty()&amp;&amp;ope.top() =='(') ope.pop();&#125;int main()&#123; int t; cin&gt;&gt;t; getchar(); while (t--)&#123; getline(cin,str); stringstream s(str); init(); char tmp; while (s&gt;&gt;tmp)&#123; if(tmp&gt;='0'&amp;&amp;tmp&lt;='9')&#123; int x = 0; do&#123; if (m[tmp]) break; x *= 10; x += tmp - '0';//此处是将char转换成int &#125;while(s&gt;&gt;tmp); num.push(x); &#125; //注意这个地方的高明之处就在于碰见‘）’的返回，以及判断有没有‘（’， 比如连加的情况就把加减乘除的优先运算级给表示出来了。 //最后相当于将运算优先级高的全部放到了右边，然后有括号的就先解决括号， 及时左括号被提前弄没了也不要紧，存在有右括号就行，然后乘除永远放在加减的左边。 if (tmp==')') op2(); else if (m[tmp]==1)&#123; if (!ope.empty()&amp;&amp;ope.top()!='(') op2(); ope.push(tmp); &#125; else if (m[tmp]) ope.push(tmp); &#125; int ans = num.top(); num.pop(); while (!num.empty()&amp;&amp;!ope.empty())&#123; op1(ans,num.top(),ope.top()); ope.pop(); num.pop(); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道计算机几何算法相关题目]]></title>
    <url>%2F2018%2F12%2F01%2F%E4%B8%80%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%87%A0%E4%BD%95%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目： 代码如下：1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;using namespace std;double v,s,b;const double pi = acos(-1.0);int main()&#123; while(cin&gt;&gt;v&gt;&gt;s&gt;&gt;b)&#123; if (s&lt;b)&#123; cout&lt;&lt;-1&lt;&lt;endl; continue; &#125; double x = (v * v) / 9.8; if ( x &lt; s ) &#123; cout&lt;&lt;"move "&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;s-x&lt;&lt;endl; &#125; else &#123; double b = (s * 9.8) / (v * v); //注意反函数的转换。 double a = asin(b) * 90 / pi; //这里有一个进一的操作，因为此题不太会去四舍五入。 int a_ = a; if (a-a_ &gt;= 0.5) a_++; cout&lt;&lt;"a "&lt;&lt;a_&lt;&lt;endl; &#125; &#125; return 0;&#125; 关于这道题目的相关要点 反函数相关要点。注意 反函数最后输出的是 一个弧度值，根据相应数学的算法而言记住 ==弧度值=角度*pi/180== 关于输出中进1的相关操作。按照第几位，先换算成相应的整形数，最后再强转成int型 最后在判断是否大于0.5来考虑时候来加一。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分法思想]]></title>
    <url>%2F2018%2F12%2F01%2F%E4%BA%8C%E5%88%86%E6%B3%95%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[二分查找实现在单调有序的集合中查找元素，每次江集合分为左右两个部分，并且通过判断集合在哪个部分从而调整集合的上下界，重复知道找到目标元素为止。 举一个简单的例子，我要在1到100里面查找62，先拿62根这个其最中间的一个数进行比较。然后在一步一步的缩小集合的上下界，最后再来一步一步往里面缩 下面是C++STL里面二分查找的函数： binary_search 返回bool值,是否存在lower_bound 返回可插入的最小位置的迭代器 即返回第一个符合条件的元素位置upper_bound 返回可插入的最大位置的迭代器 即返回最后一个符合条件的元素位置 在二分查找里面最典型的题目就是二分逼近求方程式的根了。 代码如下123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;iomanip&gt;using namespace std;const double pre =1e-4;double x,y;double f(double x)&#123; return 8*pow(x,4)+7*pow(x,3)+2*pow(x,2)+3*x+6-y;&#125;int main()&#123; int t; cin&gt;&gt;t; while (t--)&#123; cin&gt;&gt;y; double x1=0,x2=100;//先把上下界在这里确定好 double mid=(x1+x2)/2; if (f(x1)*f(x2)&gt;0) cout&lt;&lt;"No solution!"&lt;&lt;endl; else &#123; while (x2-x1&gt;=pre)&#123;//这里必须写的是上下界线是多少， 不能写的是用于判断mid的条件。 if (f(x1)*f(mid)&lt;0)&#123; x2=mid; mid=(x1+x2)/2; &#125; else &#123; x1=mid; mid=(x1+x2)/2; &#125; &#125; cout&lt;&lt;fixed&lt;&lt;setprecision(4)&lt;&lt;mid&lt;&lt;endl; &#125; &#125;&#125; 上面就是我第二次出错的地方，判断二分循环逼近的的条件不应该看mid的取值，而是应该看得是区间上界减去区间下界的范围从而来限定。 此处关于三分法的求解：当需要求某凸性或凹形函数的极值，通过函数本身表达式并不容易求解时，就可以用三分法不断逼近求解。 三分法——求解凸性函数的极值问题http://hi.baidu.com/vfxupdpaipbcpuq/item/81b21d1910ea729c99ce33db 经典例题：侵略的奶牛： 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 100005;int a[maxn],n,c;//此过程就是在判断奶牛之间的间隔为这个值合不合适bool cc(int d)&#123; int t=a[0],cnt=1; for (int i=1;i!=n;i++)&#123; if (a[i]-t&gt;=d)&#123; cnt++; t=a[i]; if (cnt&gt;=c) return true; &#125; &#125; return false;&#125;//此过程就是在收录每一个值，然后再分别进行判断int solve()&#123; int x=0,y=a[n-1]-a[0]; while (x&lt;=y)&#123; int mid=(x+y)/2; if (cc(mid)) x=mid+1; else y=mid-1; &#125; return x-1;&#125;//不过这种最大值最小值的题目需要多花时间想想。int main()&#123; while (cin&gt;&gt;n&gt;&gt;c)&#123; for (int i=0;i!=n;i++) cin&gt;&gt;a[i]; sort(a,a+n); cout&lt;&lt;solve()&lt;&lt;endl; &#125;&#125; ==下面则是其他地方关于二分的题目==基础版 POJ 3122 Pie 二分枚举区间是实数POJ 1064 Cable master 二分枚举区间是实数,注意精度POJ 3258 River Hopscotch 最大化最小值POJ 3273 Monthly Expense 最小化最大值LIGHTOJ 1076 Get the Containers 最小化最大值，。和上一个差不多LIGHTOJ 1307 Counting Triangles 进阶版 POJ 3579 二分搜索+二分查找POJ 3685 二分搜索+二分查找ZOJ 3278 也是两个二分嵌套LIGHTOJ 1048和LightOJ 1076一样，不过要输出一组解LIGHTOJ 1383 二分加贪心（区间）ZOJ 3665 某年区域赛题。，二分枚举ZOJ 3726 去年区域赛题，二分查找codeforces 382B 有意思的题codeforces 391D2 难，。。，，、 ==下面就是关于三分的题目== poj3301hdu4454hdu3714hdu2438]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于STL里面函数简单的应用]]></title>
    <url>%2F2018%2F12%2F01%2F%E5%85%B3%E4%BA%8ESTL%E9%87%8C%E9%9D%A2%E5%87%BD%E6%95%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[代码如下：1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;int main()&#123; int n,t; cin&gt;&gt;n; set&lt;int&gt;s; s.insert(0); for (int i =0;i!=n;i++)&#123; cin&gt;&gt;t; //这道题目的主要做法是记住几个upper_bound 的STL函数 if(t &lt; *s.rbegin()) &#123; s.erase(*(s.upper_bound(t))); &#125; s.insert(t); &#125; cout &lt;&lt; s.size() - 1; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于组合数学，两道思维题目，这里贴两道题目]]></title>
    <url>%2F2018%2F12%2F01%2F%E5%85%B3%E4%BA%8E%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%8C%E4%B8%A4%E9%81%93%E6%80%9D%E7%BB%B4%E9%A2%98%E7%9B%AE%EF%BC%8C%E8%BF%99%E9%87%8C%E8%B4%B4%E4%B8%A4%E9%81%93%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[第一道 简单的排列组合： 题解如下： 题目大致可以理解为4堆牌a,b,c,d，每次从一堆牌里拿出牌顶的一张牌，问共有多少种拿法。其实我们可以一堆一堆的分析，假设只有一堆a时只有1种拿法，那两堆a,b时我们可以认为是从a个牌中插入b张牌，用数学表达式就是==C(b,a+b)==;那么三堆的话我们可以把前两堆看成一堆，那么表达式就是==C(c,a+b+c)==，这是我们需要与前两堆的组成方法相乘，就是==C(b,a+b)C(c,a+b+c)==。4堆的话就是==C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)==。所以答案就是==C(a,a)C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)==。此外，有一公式==C(a,b)=C(a,b-1)+C(a-1,b-1)==，所以我们用数组来代替C(m,n)操作 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 501;const long long mod = 1000000007;long long a[4],sum[4]=&#123;0&#125;;//此处用到记忆化搜索，动态规划。long long dp[maxn*4][maxn*4];void init()&#123; dp[0][0]=0; for (int i=1;i!=4*maxn;i++)&#123; dp[i][0]=1; //根据表格来看的确是每一行的第一个是1 for (int j=1;j&lt;i;j++)&#123; //这个地方就是状态转移方程 //C(a,b)=C(a,b-1)+C(a-1,b-1)根据公式来做的 dp[i][j]=dp[i-1][j]+dp[i-1][j-1]; //dp[i][j]=dp[i][j]%mod; &#125; dp[i][i]=1; &#125;&#125;int main()&#123; int t; cin&gt;&gt;t; while (t--)&#123; init();//这个地方就开始初始化表格了。 long long ans =1; for (int i = 0; i&lt;4;i++)&#123; if (!i) sum[i]=0; else sum[i]=sum[i-1]; cin&gt;&gt;a[i]; sum[i] += a[i]; if (a[i] &gt; sum[i]-a[i]) a[i]=sum[i]-a[i]; &#125; for (int i = 1 ; i != 4; i++)&#123; ans *= dp[sum[i]][a[i]]; //ans %=mod; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 第二题 第一题的变式： 题解如上，与上面一题有区别的地方就在于要有一个取模的操作 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 501;const long long mod = 1000000007;long long a[4],sum[4]=&#123;0&#125;;//此处用到记忆化搜索，动态规划。long long dp[maxn*4][maxn*4];void init()&#123; dp[0][0]=0; for (int i=1;i!=4*maxn;i++)&#123; dp[i][0]=1; //根据表格来看的确是每一行的第一个是1 for (int j=1;j&lt;i;j++)&#123; //这个地方就是状态转移方程 //C(a,b)=C(a,b-1)+C(a-1,b-1)根据公式来做的 dp[i][j]=dp[i-1][j]+dp[i-1][j-1]; dp[i][j]=dp[i][j]%mod; &#125; dp[i][i]=1; &#125;&#125;int main()&#123; int t; cin&gt;&gt;t; while (t--)&#123; init();//这个地方就开始初始化表格了。 long long ans =1; for (int i = 0; i&lt;4;i++)&#123; if (!i) sum[i]=0; else sum[i]=sum[i-1]; cin&gt;&gt;a[i]; sum[i] += a[i]; if (a[i] &gt; sum[i]-a[i]) a[i]=sum[i]-a[i]; &#125; for (int i = 1 ; i != 4; i++)&#123; ans *= dp[sum[i]][a[i]]; ans %=mod; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; ==以后学到后面再花时间来深究==]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构相应总结]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%BA%94%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[栈 栈的概念此处只需要记住栈的思想最重要的就是先进后出思想，也就是最先进去的最后出来。 两种方法表示这种栈的实现 第一种则是 直接用c语言实现，采用一个一维数组来存储栈，用两个指针一个指向栈顶，另一个指向栈底。用top=bottom作为栈空的标记或者说是栈遍历完毕的标记。 第二种就是直接用C++里面STL模板首先先定义一个stack&lt;int&gt; s 然后以下就是其的操作。 注意其不能使用push_back只能使用push 1234s.pop() 删除栈顶元素，也就是出栈的作，把刚刚进来的元素出栈,不返回元素值。s.push() 创建一个新元素压入栈顶，可以通过拷贝，移动，甚至是构造而来。s.top() 返回栈顶的元素，也就是刚刚进来的元素。s.bottom() 返回栈底的元素，也就是最后一个元素 队列适配器队列这里分为两种一种是普通队列，还有一种是特殊排列好的优先队列，但是这二者的区别就在于，虽然都符合先进先出的思想，但是前者是不加任何排序的先进先出，而后者就是让代码编辑者自己定义一种排序方式，然后通过这种排序方式，再来出队操作。 与上面一样，先定义一个queue&lt;int&gt; q与priority_queue&lt;int&gt; q。 1234567q.pop() 按照先进先出的思想，删除首元素或者优先级最高的元素q.front() 返回首元素。q.back() 返回尾元素。以上两个是只适用于队列。q.top() 返回优先队列中优先级最高的元素。q.push()q.emplace() 加入元素到队尾，或者优先队列中一个恰当的位置，要么构造，要么拷贝。 这里需要提一下==优先队列的构造方法==以及==优先队列的特殊排序==应该怎么构造 123456789下面两种优先队列的定义是等价的priority_queue&lt;int&gt; q;priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;;//后面有一个空格默认都是从小到大排序接受三个参数，第一个参数为数据类型，第二个参数为承载容器的类型，第三个就是自定义的比较函数了。可以使lamda匿名函数，也可以是function头文件里面的函数模板。 链表特点：自定义，不连续的。同时链表也是后面相应树形结构的基础实际上就是把每一个不连续的内存空间连在一起，可以认为的控制进程这个需要自己改天把链表的遍历，删除，增加自己再写一遍，因为不是什么新东西，所以这里就不多说了 动态数组这里就是vector 存在的意义了 vector里面重要的概念 容量，长度。 树与二叉树一般的树 以上就是一般树的形态。下面则是关于树的基本用语。关于上面重要的概念就是结点和结点的度了。 二叉树二叉树的定义: 二叉树有五种基本形态： 二叉树的性质:上面所写到的==至多==都是由于将其当成了满二叉树来进行计算的。 满二叉树与完全二叉树前者全部都有子节点，后者基于深度为k的基础上，编号从1到n的结点一一对应。完全二叉树是满二叉树的一部分，而满二叉树是完全二叉树的特例。 #####二叉树的存储结构： 数组存储： 二叉链式存储（原理类似链表）：将链表内部的*next，变成了指向两边的子节点的指针。 三叉链式存储：比二叉链式结构多了一个回指向父节点的指针。 遍历二叉树的方法 先序遍历（根-&gt;左-&gt;右）： 代码: 12345678void PreOrderTraverse(BiTree *T)&#123; if(T != NULL)&#123; printf("%c", T-&gt;data); PreOrderTraverse(T-&gt;lchild); PreOrderTraverse(T-&gt;rchild); &#125;&#125; 图示： 最终结果就是==ABDGHCEIF==。 中序遍历（左-&gt;根-&gt;右)： 若二叉树为空，则空操作返回，否则从根节点开始（注意不是先访问根节点），中序遍历根节点的左子树，然后是访问根节点，最后中序遍历右子树。 代码： 12345678void InOrderTraverse(BiTree T)&#123; if(T != NULL)&#123; PreOrderTraverse(T-&gt;lchild); printf("%c", T-&gt;data); PreOrderTraverse(T-&gt;rchild); &#125;&#125; 最终结果为==GDHBAEICF==。 后序遍历（左-&gt;右-&gt;根） 若二叉树为空，则空操作返回，否则从根节点开始（注意不是先访问根节点），中序遍历根节点的左子树，然后是访问根节点，最后中序遍历右子树。 代码： 12345678void PostOrderTraverse(BiTree T)&#123; if(T != NULL)&#123; PreOrderTraverse(T-&gt;lchild); PreOrderTraverse(T-&gt;rchild); printf("%c", T-&gt;data); &#125;&#125; 最终结果为==GHDBIEFCA==。 关于二叉树的建立代码：代码我等下自己写出来。 图图的定义 图结构：是研究数据元素之间的多对多的关系。在这种结构中，任意两个元素之间可能存在关系。即结点之间的关系可以是任意的，图中任意元素之间都可能相关。 图的专业术语： 图-生成树 邻接矩阵的表示方法（数组）不带权值的表示方法 一般就是用二维数组来表示每一个结点之间的关系 关于图的遍历就最好用一个bool 类型的同二维数组 然后通过这个来标记哪些是否已经被遍历过得。]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论基础第一节]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E8%8A%82%2F</url>
    <content type="text"><![CDATA[初等数论是用初等方法研究的数论，它的研究方法本质上说，就是利用整数环的整除性质，主要包括整除理论、同余理论、连分数理论。 整除问题引申到同余问题 同余的性质 可以换算成以下式子：a=c(modb) 这里c为余数，而b为除数 同余的性质 自反性 a=a mod m 对称性 a=b mod m 等价于 b=a mod m 传递性 a=b mod m 与 b=c mod m 等价于 a=c mod m 线性合成 a=b mod m 与 c= mod m 等价于 a±c=b±d mod m 与 ac= bd mod m 消去公因子 ac=bc mod m &amp;&amp; gcd(c,m)=1 等价于 a=b mod m 素数筛 朴素筛 一般就是循环2~√n次 埃拉托斯特尼筛 循环次数 欧拉筛 相应代码如下：12 最大公约数以及最小公倍数 最大公约数 函数_gcd(a,b)而多个数的最大公约数 就是 _gcd(a,b,c)=_gcd(gcd(a,b),c) 最小公倍数_lcm(a,b)=ab/_gcd(a,b) 扩展欧几里得 关于求解线性同余方程 关于求逆元 关于快速幂 费马小定理 另外 欧拉函数 欧拉函数定义 欧拉函数性质 求值公式 上述公式 可以用来： 求逆元 欧拉降幂公式 数论函数 中国剩余定理 解法]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款01：视 C++ 为一个语言联邦]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE01%EF%BC%9A%E8%A7%86%20C%2B%2B%20%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6%2F</url>
    <content type="text"><![CDATA[现在发展的C++已经是一个多重泛型编程语言。 一个同时支持过程形式、支持面向对象形式、函数形式、泛型形式、元编程形式的语言，这些能力和弹性使 C++成为了一个无可匹敌的工具。对待其的方式最简单的方法是将其看做是一个由相关语言组成的一个联邦而不是某个次语言。 C 说到底 C++ 仍然是 C 的一个延伸，面对过程的编程思想仍然在某些时候很受用，而某些时刻 C++ 的解法只不过就是比 C 高级了一点点，但是当你以 C++的内 C 成分的工作的时候，高效编程则映照出了 C 语言的局限，没有模板，没有异常，没有重载。 Object-Oriented C++ 这部分也就是 C++ 中面对对象编程思想的直接体现，简单来说就是 C with class 比如 类，封装，继承，多态，虚函数的动态绑定。 Template C++ 这是 C++中的泛型编程部分，template 的相关考虑与设计已经弥漫了整个 C++ 而这种编程思想的强大，直接带来了全新的名字 模板元编程，后面得花上大部分时间去专研这个。 STL 基本上包括 容器，迭代器，算法以及相应的函数对象，一般竞赛可能会直接用到里面的相关容器以及相关算法，熟练使用 STL 也是一名 C++ 程序员应该必备的素质。]]></content>
      <categories>
        <category>effective C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款02：尽量以const,enum,inline 替换掉#define]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE02%EF%BC%9A%E5%B0%BD%E9%87%8F%E4%BB%A5const%2Cenum%2Cinline%20%E6%9B%BF%E6%8D%A2%E6%8E%89%23define%2F</url>
    <content type="text"><![CDATA[这个条款其实也就相当于宁可编译器替换预处理器比较好 1. 对于单纯常量而言，使用 const 对象或者是 enums 比 #define 更加省时间 时间上更为节省 作为一个语言常量而不是名称记号，由于在函数体中分配了内存，追寻起来消耗的时间比在函数中使用名称记号所花的时间更少，因为有实处更容易寻找，不像名称记号，可能有的时候并没有进入到记号表中。 还有一些其他的只能使用 const 情况 定义常量指针和类的专属常量]]></content>
      <categories>
        <category>effective C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款03：尽可能使用 const]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE03%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8%20const%2F</url>
    <content type="text"><![CDATA[首先使用 const 可以防止后期莫名其妙的进行改变原有的意思，相当于一个约束语义，另外编译器不论什么时候都会强制施行这项约束。 const 在 C++ 11 中有底层和顶层之分，前者是作用于指针本身，指针不再改变指向对象，而顶层 const 则是指针所指向的对象则不能发生改变。 const 最具威力的用法实在面对函数声明时的用法，在一个函数的声明式里，const 可以和函数的返回值，各自的参数以及函数自身产生关联。 将引用参数设置成 const 好处是在后面写代码的过程中如果把==写成=，可以立马甄别出来。 const 成员函数存在的两个理由，一个使 class 的接口一目了然，因为知道了哪些可以被改动对象而哪些不可以被改动对象，第二则是基于代码编写的高效性而言，操作 const 对象成为可能，因为可以通过 const 成员函数返回 const 对象。 存在一种特殊情况，重载[ ]运算符的时候，如果成员函数是 const 那么其的返回值也必须是 const&amp;类型的。 如果对于const 成员函数，想要改变该对象的内部成员的话，但是又不想全部改变的话，可以在类中的数据成员定义中加上 mutable，来保证可以改变该函数，其存在的意义就在于保证了其他数据成员不能被 const 成员函数改变，但是该数据成员却可以。 7.当 const 和 non-const 成员函数有实质等价的实现时，令 non-const 版本调用 const 版本可避免代码重复。 这一点还不是特别了解，需要看到后面之后花点时间来看看这一点的内容。]]></content>
      <categories>
        <category>effective C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款04：确定对象被使用前已先被初始化]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE04%EF%BC%9A%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[在 C 语言中对象的初始化可能会变得异常容易，但是在 C++中某些语境下进行对象可能不会存在自动的初始化过程，也许会在使用 C part of C++ 会自动有一个初始化过程，但是在其他部分下面的 C++就不能保证初始化过程了。 特别是在类的过程中，初始化的过程一般直接交给构造函数，初始化的过程并不等同于赋值，所以在写类的构造函数的时候，尽量不要在函数体里面写赋值给私有成员的语句，可以直接在列表上面直接写初始化的。 对于拥有多个构造函数，且每个构造函数具有自己的成员初值列，如果这些类存在许多成员变量或者基类的话，多种成员初始列表就会导致不受欢迎的重复，那么这个时候可以遗漏一些“赋值跟初始化过程差不读的成员变量”，改用他们的赋值操作，并且把这些操作放置在 private 中。 C++有着十分固定的成员初始化过程，基类的初始化会早于派生类，而类的成员变量总是以其声明的次序被初始化。 关于类的静态成员的初始化 一般在类内部进行声明，然后再类的外部进行定义，赋值，其的声明周期一般是从程序开始到程序结束。 构造函数初始化的次序非常重要，举个例子就是初始化的时候必须要为数组指定大小，所以指定大小的变量必须具有先值 对于不同人在不同时间下不同的源码文件建立起来，其的初始化相对次序并没有明确定义，所以解决办法就是将一个对象搬到自己的专属函数里面去，然后声明成静态成员，并且返回一个引用即可，后面用户直接调用这些函数，就可以无视初始化的次序问题了。具体可以看书里面P32面的相关代码。 最后总结一句为了免除“跨编译单元之初始化次序”问题，一般用 local static 对象替换 non-local static 对象。]]></content>
      <categories>
        <category>effective C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款05：了解 C++默默编写并调用了哪些函数]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE05%EF%BC%9A%E4%BA%86%E8%A7%A3%20C%2B%2B%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[几乎每一个 class 都会用一个或多个构造函数，一个析构函数，一个拷贝重载运算符，有些是系统自动生成的合成版本，有些是需要自定义的版本，所以这一条款的目的是为了探寻哪些是需要自己去写，哪一些是需要系统自身合成的。 千万不要写完构造函数或者拷贝构造函数或者是析构函数之后不去定义，那么会造成问题，而且此类问题会造成很多方面上的无法适应问题。 另外这里额外需要注意的是 C++11上增加的移动语义，只有在拥有了拷贝构造函数和拷贝赋值运算符之后，编译器才会自动生成移动构造函数，和移动赋值运算符。 最后这个条款需要注意的就是编译器自动生成的函数具有普遍性，所以就不具有特异性，一些特殊的操作在合成版本上面可能会出现大问题。]]></content>
      <categories>
        <category>effective C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款06：若不想使用编译器自动生成的函数，就应该明确拒绝]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE06%EF%BC%9A%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E5%BA%94%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D%2F</url>
    <content type="text"><![CDATA[有的时候鉴于某些情况，比如智能指针中 unique_str 和 io 库对象无法发生拷贝和赋值，是因为明确在类的内部进行了拒绝操作，所以无法拷贝与赋值，这一个条款就来讲解有哪些方法可以用来拒绝。 把自己不想要的函数，但是系统默认又会生成的函数放到私有成员中，这种方法很简便，但是有一个缺点就是在类的内部定义中仍然是可以使用拷贝与赋值功能的。 继承一个基类，使用 private 继承方法，然后将这个基类的函数放入私有成员中，这样就可以保证万无一失的方法，但是缺点就是太复杂，还需要定一个基类。 C++11 提出的新办法将函数声明出来，不仅不去定义，而且直接声明成 delete。这样更便捷。]]></content>
      <categories>
        <category>effective C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款08：别让异常逃离析构函数]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE08%EF%BC%9A%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[其实这一项条款没有领悟的很深刻，可以理解成不要再析构函数里面写捕获异常之类的代码。因为某些时候，如果在析构函数里面抓获异常导致程序终止的话，那么就可能造成对象不能完全被销毁 析构函数绝对不要吐出异常，如果一个被析构函数调用的函数可能抛出异常的话，析构函数应该做的应该是捕捉任何异常，然后吞下他们（不传播）或者结束程序。 如果对象需要对摸个操作函数运行期间抛出的异常做出反应，那么 class 应该提供一个普通函数（不应该在析构函数里面）执行该任务。但是该析构函数里面仍然要进行双保险的析构过程，可以在类的内部定义里面加上一个 bool 变量来判断到底有没有运行析构行为，相当于一般写程序的一个 flag。]]></content>
      <categories>
        <category>effective C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款07：为多态基类声明 virtual 析构函数]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE07%EF%BC%9A%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8E%20virtual%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在进行基类与派生类之间动态绑定的时候，如果发生对象销毁调用的析构函数不是虚函数的话，那么就会造成析构销毁部分的现象。 C++明确指出，当 derived class 对象经由一个 base class指针被删除，而该 base class 带着一个不是虚函数的析构函数的话，其结果往往都是自定义的，就像上述的说法而言，往往是对象的 derived 成分没有被销毁，而且消除这个问题最简单的办法是在基类的析构函数上面加上虚函数的声明。 不要随便继承标准库里面的东西，因为里面大部分东西都不存在虚函数的析构函数，这样一来，如果使用动态绑定的话，那么在销毁对象的过程中就没有办法全部销毁了。 而且不一定是基类的析构函数设置成虚函数，只要类里面有一个函数是虚函数的话，那么就需要将析构函数定义成虚函数。 类的用途不是作为多态的用途的话，那么请不要将析构函数声明成虚函数，因为那样没有作用。 对于一个纯虚函数而言，这个类就是一个抽象类，但是由于存在一个析构函数，所以一般要为这个纯虚函数提供定义，其的运作方式是最深层派生的那个类的析构函数最先被调用，然后就是每一个基类的析构函数被调用，所以编译器会在派生类的析构函数中定一个对基类纯虚析构函数的调用动作，因此，一般都得进行调用。]]></content>
      <categories>
        <category>effective C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款09：绝不在构造和析构的过程中调用 virtual 函数]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE09%EF%BC%9A%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8%20virtual%20%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[绝对不要在构造函数和析构函数期间调用虚函数，因为这样调用的结果不会带来预想的结果。 基类构造函数的时候，虚函数是不会下降到派生类中，原因就是在基类开始构造函数的时候，该类的类型是基类，而不是派生类，简单来说，如果想在构造函数的过程中，直接使用基类的虚函数来折射到派生类，从而帮助派生类完成构造的话，那么这种办法一定行不通。 相同的道理同上，在基类析构函数发生的过程中，同样将其他的派生类视作未定义。 如果将构造函数或者析构函数调用的函数设立成纯虚函数的话，那么当纯虚函数被调用的时候，大多数执行系统会直接终止程序，唯一避免的此问题的做法就是确定构造和析构期间没有调用虚函数。 唯一的替代方案是不设置虚函数，比如在构造一个派生类对象的时候，需要直接调用基类函数的构造函数，然后再完成派生类的构造，而此时最好是将派生类里面一个作用于构造函数的一个成员函数定义成静态函数，这样的话就能在程序刚开始就存在该函数了。 由第四点换句话说，你无法使用虚函数直接从基函数向下调用，但是在基类函数中可以由派生类将信息传递到基类从而进行有效调用。]]></content>
      <categories>
        <category>effective C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款10：令 operator= 返回一个 自身的返回]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE10%EF%BC%9A%E4%BB%A4%20operator%3D%20%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%20%E8%87%AA%E8%BA%AB%E7%9A%84%E8%BF%94%E5%9B%9E%2F</url>
    <content type="text"><![CDATA[一般重载赋值运算符号的时候一般都会返回一个自身的引用，这样可以更方面操作自身，如果仅仅只是返回一个拷贝的对象的话，那么将会在连续使用运算符的时候发生错误，而且在一些较大的类型的话，可能速度会慢些，所以一般返回自身的引用。]]></content>
      <categories>
        <category>effective C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于模拟与搜索的相应简单题目]]></title>
    <url>%2F2018%2F12%2F01%2F%E5%85%B3%E4%BA%8E%E6%A8%A1%E6%8B%9F%E4%B8%8E%E6%90%9C%E7%B4%A2%E7%9A%84%E7%9B%B8%E5%BA%94%E7%AE%80%E5%8D%95%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; string w,v; int x,y,m; char ch; while(cin&gt;&gt;w&gt;&gt;v)&#123; string s; int flag=0; reverse(w.begin(),w.end()); reverse(v.begin(),v.end()); if (w.size()&gt;v.size())&#123; m=w.size()-v.size(); for (int i=0;i!=v.size();i++)&#123; x=w[i]-'0'; y=v[i]-'0'; x+=y; if (flag)&#123; flag=0; x++; &#125; if (x&gt;=10)&#123; flag=1; x=x-10; &#125; ch=x+'0'; s.push_back(ch); &#125; int i=v.size(); while (flag==1&amp;&amp;i&lt;=m)&#123; flag=0; x=w[i]-'0'; x++; if (x&gt;=10)&#123; flag=1; x=x-10; &#125; ch=x+'0'; s.push_back(ch); i++; &#125; if (flag&amp;&amp;i==w.size())&#123; s.push_back('1'); &#125; &#125; else &#123; m=v.size()-w.size(); for (int i=0;i!=w.size();i++)&#123; x=w[i]-'0'; y=v[i]-'0'; x+=y; if (flag)&#123; flag=0; x++; &#125; if (x&gt;=10)&#123; flag=1; x=x-10; &#125; ch=x+'0'; s.push_back(ch); &#125; int i=w.size(); while (flag&amp;&amp;i&lt;=m)&#123; flag=0; x=w[i]-'0'; x++; if (x&gt;=10)&#123; flag=1; x=x-10; &#125; ch=x+'0'; s.push_back(ch); i++; &#125; if (flag&amp;&amp;i==v.size())&#123; s.push_back('1'); &#125; &#125; reverse(s.begin(),s.end()); cout&lt;&lt;s&lt;&lt;endl; &#125;&#125; 题解：其实这道题目属于一道相应简单的题目，就是要注意相应string与char之间的区别就行了。另外 int转换char是加上‘0’char转换int是减去‘0’。 一道简单的dfs的题目 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int maxn = 105;char h[maxn][maxn];int n,m,cnt=0;void dfs(int i,int j)&#123; if (i&lt;0||i&gt;=n||h[i][j]!='W') return ; if (j&lt;0||j&gt;=m||h[i][j]!='W') return ; if (h[i][j]=='W')&#123; h[i][j]='.'; dfs(i-1,j); dfs(i-1,j-1); dfs(i+1,j); dfs(i+1,j+1); dfs(i,j-1); dfs(i-1,j+1); dfs(i,j+1); dfs(i+1,j-1); &#125;&#125;int main()&#123; int ans=0; while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;(n!=0&amp;&amp;m!=0))&#123; for (int i=0;i!=n;i++) for (int j=0;j!=m;j++)&#123; cin&gt;&gt;h[i][j]; &#125; for (int i=0;i!=n;i++)&#123; for (int j=0;j!=m;j++)&#123; if (h[i][j]=='W')&#123; dfs(i,j); ans++; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; ans=0; &#125; return 0;&#125; 题解简单的dfs搜索出每一种情况，然后让其返回就行了。 一道经典的BFS的题目题目 代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;stdio.h&gt;#include&lt;queue&gt;using namespace std;int fxy[4][2]=&#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;//朝着四个方向char dis[101][101];int kp[101][101];//以下的node就作为每一次前进的节点struct node&#123; int x,y,cnt; node(int a=0,int b=0,int c=0)&#123; x=a; y=b; cnt=c; &#125;&#125;;int main()&#123; int m,n,k,g,k1,g1; while(~scanf("%d %d",&amp;m,&amp;n)) &#123; for(int i=0;i&lt;m;i++) &#123; scanf("%s",dis[i]); &#125; // 用队列整合的思想来完成 queue&lt;struct node&gt;q; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++)&#123; kp[i][j]=-1; &#125; // 两种初始化过程，并且找到起点与终点的所在位置 for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++)&#123; if(dis[i][j]=='S')&#123; k=i; g=j; &#125; if(dis[i][j]=='E')&#123; k1=i; g1=j; &#125; &#125; // 将起点存进去 node a(k,g,0); q.push(a); // 下面就是为bfs的相应搜索 while(!q.empty())&#123; struct node now=q.front(); q.pop(); kp[now.x][now.y]=now.cnt; // 将起点走了多少步数以及起点的坐标点存入到题目中去 for(int i=0;i&lt;4;i++)&#123; node next; next.x=now.x+fxy[i][0]; next.y=now.y+fxy[i][1]; // 判断走的下一步有没有出界，或者使下一步走的不会碰到路障 if(next.x&gt;=0&amp;&amp;next.x&lt;m&amp;&amp;next.y&gt;=0&amp;&amp;next.y&lt;n&amp;&amp;dis[next.x][next.y]!='#'&amp;&amp;kp[next.x][next.y]==-1)&#123; node empt(next.x,next.y,now.cnt+1); q.push(empt); &#125; &#125; &#125; if(kp[k1][g1]==-1) printf("Trapped!\n"); else printf("Escaped in %d minute(s).\n",kp[k1][g1]); &#125; return 0;&#125; 记住上面相应的队列思想。 一道DFS与BFS的综合题==需要多花时间来温习一遍== 题目 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;int n,m,k,cnt = 0;int x_begin,x_end,y_begin,y_end;const int maxn = 1005;int dis[maxn][maxn];char ch[maxn][maxn];class Position&#123;public: int x; int y; int distance; public: Position() = default; Position(int a, int b, int c):x(a),y(b),distance(c)&#123;&#125;; Position move(int i);&#125;;Position Position::move(int i)&#123; Position post = *this; if (i == 0) post.x = this -&gt; x + 1; else if (i == 1) post.x = this -&gt; x - 1; else if (i == 2) post.y = this -&gt; y + 1; else if (i == 3) post.y = this -&gt; y - 1; return post;&#125;void bfs()&#123; queue&lt;Position&gt;q_dis; Position p_begin (x_begin,y_begin,0); q_dis.push(p_begin); while(!q_dis.empty())&#123; Position now = q_dis.front(); q_dis.pop(); dis[now.x][now.y]=now.distance; for(int i = 0; i != 4; i++)&#123; Position next; next = now.move(i); if (next.x &gt;= 0 &amp;&amp; next.x &lt; n &amp;&amp; next.y &gt;= 0 &amp;&amp; next.y &lt; m &amp;&amp; dis[next.x][next.y] == -1 &amp;&amp; ch[next.x][next.y] != '#')&#123; Position empt (next.x,next.y,now.distance + 1); q_dis.push(empt); &#125; &#125; &#125;&#125;void dfs(int x,int y)&#123; if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m) return ; if (ch[x][y]=='L') &#123; cnt++; return; &#125; if (dis[x][y] == -1) return; // 前面已经有dis可以表示每一步走的距离，所以只需要一步一步来看，这样的做法便可以完全规避障碍物，单单从路径上面考虑。 if (dis[x][y]==dis[x+1][y]+1) dfs(x+1,y); if (dis[x][y]==dis[x-1][y]+1) dfs(x-1,y); if (dis[x][y]==dis[x][y+1]+1) dfs(x,y+1); if (dis[x][y]==dis[x][y-1]+1) dfs(x,y-1);&#125;int main()&#123; int T,Case = 0; cin&gt;&gt;T; while(T--)&#123; Case++; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; bool f_begin = false,f_end = false; for (int i = 0; i != n; i++)&#123; for (int j = 0; j != m; j++)&#123; cin &gt;&gt; ch[i][j]; dis[i][j] = -1; &#125; &#125; for (int i = 0; i != n; i++)&#123; for (int j = 0; j != m; j++)&#123; if (f_end &amp;&amp; f_begin) break; if (ch[i][j] == 'L')&#123; x_begin = i; y_begin = j; f_begin = true; &#125; if (ch[i][j] == 'C')&#123; x_end = i; y_end = j; f_end = true; &#125; &#125; &#125; bfs(); if (dis[x_end][y_end] == -1 ||dis[x_end][y_end] &gt; k ) cout &lt;&lt; "Case #"&lt;&lt;Case&lt;&lt;": "&lt;&lt;-1&lt;&lt;endl; else&#123; dfs(x_end,y_end); cout&lt;&lt;"Case #"&lt;&lt;Case&lt;&lt;": "&lt;&lt;dis[x_end][y_end]&lt;&lt;" "&lt;&lt;cnt&lt;&lt;endl; cnt = 0; &#125; &#125; return 0;&#125; 这里注明一下关于==默认实参==的知识点，因为在这个地方可以直接对类的构造函数赋值一个默认实参，可以避免输入默认构造函数了。 下面则是一道DFS的题目，这道题目看上去可以用bfs来做 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int maxn = 100;int road[maxn][maxn];int dp[maxn][maxn];int n, m;int dfs (int i,int j)&#123; if (dp[i][j] != -1) return dp[i][j]; int Max = 0; if (i-1&gt;=0 &amp;&amp; road[i][j]&gt;road[i-1][j]&amp;&amp;Max&lt;dfs(i-1,j)) Max = dfs(i-1,j); if(i+1&lt;n &amp;&amp; road[i][j]&gt;road[i+1][j]&amp;&amp;Max&lt;dfs(i+1,j)) Max=dfs(i+1,j); if(j-1&gt;=0 &amp;&amp; road[i][j]&gt;road[i][j-1]&amp;&amp;Max&lt;dfs(i,j-1)) Max=dfs(i,j-1); if(j+1&lt;m &amp;&amp; road[i][j]&gt;road[i][j+1]&amp;&amp;Max&lt;dfs(i,j+1)) Max=dfs(i,j+1); return dp[i][j]=Max+1;&#125;int main()&#123; while (cin &gt;&gt; n &gt;&gt; m) &#123; for (int i = 0; i != n; i++) &#123; for (int j = 0; j != m; j++) &#123; cin &gt;&gt; road[i][j]; dp[i][j] = -1; &#125; &#125; int MAX = -1; for (int i = 0; i != n; i++) &#123; for (int j = 0; j != m; j++) &#123; MAX = max (dfs(i,j),MAX); &#125; &#125; cout &lt;&lt; MAX &lt;&lt; endl; &#125; return 0;&#125; 题解 此题其实最重要的就在于这个题目不同于其他题目，这个题目找的是最长路径，还不是最短路径，一般来说，BFS找的是最短路径，DFS找的是最短路径的条数。而这里就是利用dfs的返回值（每走一步的最大值，意思就是从各个角度上）记录在dp中，将每一个位置都走到不能走为止，然后存储在dp中，最后找最大值的DP即可。不过自己可以试试遍历的其他方法。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>模拟与搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款12：复制对象时勿忘其每一个成分]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE12%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%8B%BF%E5%BF%98%E5%85%B6%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%88%90%E5%88%86%2F</url>
    <content type="text"><![CDATA[这个条款而言，是无论类发生什么样的内部变化，都必须重写类的管理行为。下面直接分为两个方面进行诠释： 类的内部增加或者减少数据成员，如果未重新编写构造函数的话，那么编译器也不会提醒，这样就会造成不太被需要的局部拷贝。 一旦发生继承，如果还是按照以前的方法仅仅是对函数内部的所有数据成员进行拷贝的是不对的，因为派生类不仅仅是包含着派生类的部分，还仍然包含着基类的部分，所以需要调用基类的拷贝行为，如下图： 另外拷贝构造函数定义内部是不能直接调用赋值运算符，反之亦然，前者就相当于对一个尚未构造好的对象进行赋值，而后者就相当于对一个已经构造对象再进行重新构造。所以千万不要这么做。 如果发现两个拷贝行为有类似的代码时，应该把这个相同的代码放到一个函数中区，然后由两个拷贝行为共同调用。]]></content>
      <categories>
        <category>effective C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款13：以对象管理资源]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE13%EF%BC%9A%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[系统资源的管理规则就是，一旦使用完毕，那么就一定要归还给系统，免得造成内存泄漏的问题，而 C++中需要自己去管理内存，那么为了防止在对象销毁以及内存释放之间发生异常，以及某些其他原因，一种新的基于对象的资源管理办法就应运而生。 使用智能指针， C++11之后智能指针分为三种一种是 share_ptr 指针 智能型的应用计数，共享底层数据。weak_ptr 依附于 share_ptr 作为一种核查类指针存在，最后就是 unique_ptr 指针，仅仅只是为了对象的析构函数自动销毁，上述两种主要的智能指针可以定义自己的删除器（析构函数） 获得资源后立刻放到管理对象中，其所代表的观念就是 “资源取得的时机，就是直接初始化的时机”。 需要注意的就是智能指针默认的删除器是不能删除固定的连续内存空间，意思就是说，需要自定义的删除器才能完成 delete[]。]]></content>
      <categories>
        <category>effective C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款14：在资源管理类中小心拷贝行为]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE14%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83%E6%8B%B7%E8%B4%9D%E8%A1%8C%E4%B8%BA%2F</url>
    <content type="text"><![CDATA[一般在自定义类中会遇到多种多样的拷贝行为，所以一般会采取下面的一些策略 禁止复制 向前面条款06一样，有多种办法，一般对于那些逻辑上拷贝不合理的函数。 对底层数据的共享控制 那么此处这就需要使用智能指针 share_ptr，或者自定义引用计数。并且拥有自定义的删除器，因为某些类的删除操作并不一定是释放内存、销毁对象。 转移底部资源的拥有权 移动操作，C++11 右值引用的移动过程。 复制分为浅层复制以及深层复制 前者是复制其的指针或者引用，达到共享资源的目的，这个时候使用 share_ptr 来进行控制，后者赋值的是全部内存，最好是用 unique_ptr 来保管，但是复制操作得把每一个对象所指向的对象进行拷贝之后，放进 unique_ptr 中进行管理。]]></content>
      <categories>
        <category>effective C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款15：在资源管理类中提供对原始资源的访问]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE15%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[一般使用了智能指针之后就不会在建议使用内置指针，以免发生错乱，但是就是有一些类需要在使用智能指针的过程中需要返回内置指针来完成某些函数的参数传递过程，但是需要注意的一点就是 在使用内置指针的过程中 千万不需要 delete，直接让智能指针进行删除操作。 另外除了返回内置指针这种方式来进行对原始资源的访问，还有一种方法就是重载隐式转换运算符，来完成类到资源的转换，但是这样做会加大错误的可能性，因为某些不可控的隐式类型发生转换。 上述的第一种办法属于显示转换，直接使用 get 获得资源，而下面的那种是隐式转换类型，前者比较安全，后者比较方便。]]></content>
      <categories>
        <category>effective C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款16：成对使用new和delete时需要采取相同的形式]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE16%EF%BC%9A%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8new%E5%92%8Cdelete%E6%97%B6%E9%9C%80%E8%A6%81%E9%87%87%E5%8F%96%E7%9B%B8%E5%90%8C%E7%9A%84%E5%BD%A2%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[其实我根本不知道这个为什么会成为一个单独的条款鉴于此，所以就简单的讲两句话： new 一个数组，那么一定要 delete 一个数组 智能指针默认没有 delete 数组，所以需要自定义删除器。]]></content>
      <categories>
        <category>effective C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款17：以独立语句将new过得对象放入智能指针中]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE17%EF%BC%9A%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86-new-%E8%BF%87%E5%BE%97%E5%AF%B9%E8%B1%A1%E6%94%BE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[编译器的编译次序是说不定的，就想下图的 上述的三个次序一旦顺序不对就会发生错误，所以一个最好避免的办法就是想如图所示： 先将对象存储在智能指针中（先完成智能指针的构造），在完成对智能指针的调用。 上述举的例子说明的问题是一定要把对象存入智能指针的过程独立成一个语句]]></content>
      <categories>
        <category>effective C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款18：让接口容易被正确使用，不易被误用]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE18%EF%BC%9A%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%AE%B9%E6%98%93%E8%A2%AB%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8D%E6%98%93%E8%A2%AB%E8%AF%AF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[注意类的隐式转换，并且智能指针与内置指针的区别，以及以对象管理的思想来管理资源。 好的接口很容易被正确使用，不容易被误用，应该在接口里面努力达成这些性质。 促进正确使用的办法 包括接口的一致性，与其内置类型的行为一致。 阻止误用的办法包括建立新类型，限制类型上面的操作，以及束缚对象值，以及消除客户的资源管理责任 智能指针支持定制删除器，这样可以防范动态链接程序库的问题]]></content>
      <categories>
        <category>effective C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款19：设计 class 犹如设计 type]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE19%EF%BC%9A%E8%AE%BE%E8%AE%A1%20class%20%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1%20type%2F</url>
    <content type="text"><![CDATA[一般设计一个优秀的类，实际上也就是设计一个优秀的类型，而往往需要满足下面这些疑问。 新 type 对象应该如何创建和销毁 关系到类的构造函数与析构函数如何建立 对象的初始化和对象的赋值之间的差别 主要是为了区分构造函数与赋值运算符之间的区别 该类参数传递中有传值也有传引用 传引用与传值之间的区别，以及如何实现，以及究竟何时会去调用这一类的函数。 新 type 的和法制 构造这个类的时候一些合法值，要不要对应自己的私有数据成员，或者是类型转换，通常其都会影响构造函数、赋值操作，以及 setter 函数，甚至还会影响到函数抛出的异常。 是否需要配合某一个继承体系 需要记住的是继承体系的构成一定要满足的是 is - a 的条件，另外虚函数与非虚函数之间的影响，并且还要考虑的时候 是否应该把自己的析构函数也设计成虚函数。 是否需要类型转换 类型转换一般会分为显式转换和隐式转换，实现方式一般有直接在其中一个函数内些类型转换的重载运算符函数，和没有声明 explicit 的单一参数的构造函数。 重载的操作符以及其他相应的函数，是否合理 这里看重载的函数是否符合逻辑条件，不仅仅是代码之间的严禁性质，还需要考虑的就是生活层面的实用性。 哪些成员应该封装？ 这里就设计到哪些成员应该设置成私有，而哪一些函数应该设置成公有函数，并且一些不想编译器生成的函数应该定义成删除。 类型的未声明接口 它对效率、异常安全性以及资源运用提供什么样保证，以及为类的实现代码应该提供什么的约束条件。 是否应该定义成模板 这里就看类的一般性究竟有多大，是否具有普遍价值。 考虑是否会继承与其他的类 有的时候考虑过后，也许这个类就不需要凭空创造出，仅仅只是需要从其他类上面派生出来即可。]]></content>
      <categories>
        <category>effective C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款20：宁以传 const 引用也不要传值]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE20%EF%BC%9A%E5%AE%81%E4%BB%A5%E4%BC%A0%20const%20%E5%BC%95%E7%94%A8%E4%B9%9F%E4%B8%8D%E8%A6%81%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[这个传值行为是继承与 C 语言的，基本上传引用更加方便，且付出的代价更小，不过需要注意下面了两点。 传引用有的时候会碰到切割问题，比如传参的时候，本来应该传入一个基类对象，但是实际上传入了一个派生类对象，这个时候就会把派生类基类的部分切割出去，其他部分就直接丢了 以上规则不适合某些特殊规则，比如内置类型以及 STL 的迭代器，对它们而言 ，传值往往是最恰当的。]]></content>
      <categories>
        <category>effective C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款21：必须返回对象的时候，不要妄想返回其的引用]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE21%EF%BC%9A%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%B8%8D%E8%A6%81%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6%E7%9A%84%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[该条款一般适用于某些特殊情况下必须返回值的情况 关于这个条款只需要注意一点，绝不要返回 pointer 或 reference 或者返回引用指向一个全局变量，或者返回指针引用指向一个静态成员，但是同时又需要多个这样的静态成员。在条款4中已经提供了一份设计实例。]]></content>
      <categories>
        <category>effective C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款22：将成员变量声明为 private]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE22%EF%BC%9A%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BA%20private%2F</url>
    <content type="text"><![CDATA[这里就是要记住封装的好处 切记要将成员变量声明为 private 。这样可以减少改动成员之后的破坏性，可细微划分访问控制、允诺约束条件获得保证，并且提供 class 作者以充分实现弹性。 protected 并不比 public 更具有封装性]]></content>
      <categories>
        <category>effective C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款24：若所有参数需要类型转换的时候，请设置非成员函数]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE24%EF%BC%9A%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E8%AF%B7%E8%AE%BE%E7%BD%AE%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[该条款就是需要注意一点 如果需要为某个函数的所有参数，包括this 指针所指的隐喻参数，进行类型转换的时候，那么这个函数就必须是非成员函数]]></content>
      <categories>
        <category>effective C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款23：宁以非成员友元函数代替成员函数]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE23%EF%BC%9A%E5%AE%81%E4%BB%A5%E9%9D%9E%E6%88%90%E5%91%98%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E4%BB%A3%E6%9B%BF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[同样还是为了封装 宁可拿非成员非友元函数来代替成员函数，这样做可以增加封装性，和包裹弹性，以及机能扩充性。]]></content>
      <categories>
        <category>effective C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款25：考虑写出一个不抛异常的swap函数]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE25%EF%BC%9A%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[所谓 swap 两对象值，意思就是将两个对象的值彼此赋予对方，缺省的情况下 swap 的动作可以由标准库程序提供的 swap来完成。 其中有一个最主要的方法就是，以指针指向一个对象，内含真正的数据“ 即”pimpl 手法”所以一般对于一个对象而言，直接交换里面的指针对象即可。就如同以下的写法： 以上就是该对象的特化版本。这同时也是一个模板类的偏特化的例子。 如果想特化一个函数模板的话，通常的做法就是添加一个重载版本。 但是这种特化存在问题： 我们可以全特化 std 内的模板，但是不可以添加新的模板到 std 里面去，因为 std 的内容完全由 C++标准委员会决定的。 有的时候不能直接访问私有成员，因为封装层面的相关权限缺失。 解决的办法很简单，声明一个非成员版本的 swap 函数，然后让他调用其的成员函数，而不是将那个不是成员函数的 swap 声明为 std：：中的特化版本或者是重载版本。下面就是相关步骤： 提供一个 public swap 成员函数，让它高效地置换你的类型的两个对象（注意这个地方时高效的置换），但是这个函数不应该抛出异常。 在你的类或者模板所在的命名空间内，提供一个非成员函数的 swap，并且另其调用 swap 成员函数。 如果你正在编写一个 class 而不是一个模板类的时候，为你的类特化std：：swap。并令其调用你的 swap 成员函数。 最后，在调用奇函数的时候，请确定包含一个 using 生命是，以便于让 std：：swap 在你的函数内曝光可见，直接赤裸裸的调用 swap。]]></content>
      <categories>
        <category>effective C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款27：尽量少做转型动作]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE27%EF%BC%9A%E5%B0%BD%E9%87%8F%E5%B0%91%E5%81%9A%E8%BD%AC%E5%9E%8B%E5%8A%A8%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[C++ 规则的设计目标之一就是，保证“类型错误” 绝不可能发生，但是在 C++的某些特殊的情形下面不得不去使用转型这一特性，而 C 语言的转型语句则类似于以下： 然而 C++提供四种新式的类型转换 注意 在真正进行类型转换的时候，我们不能仅仅认为编译器到最后仅仅只是更改一个文件名字，编译器改变的底层的编码，比如 int 转型到 double 之间底层描述是不一样的。 另外 C++中的一个特性使得多重继承的时候，一个对象含有多个地址。 所以需要注意的是以下几点，如果可以的话，尽量避免转型，特别是在注重代码中避免dynamic_cast. 如果有设计需要转型动作的话，去试试无需转型的替代设计。 如果转型是必要的，那么试着将其隐藏在某个函数背后。客户随后可以调用该函数，而不需要讲转型放进他们自己的代码中。 宁可使用 C++新式的转型，也不要使用旧式的转型，前者很容易识别出来，而且也有着不叫分们别类的职掌。]]></content>
      <categories>
        <category>effective C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款25：考虑写出一个不抛异常的 swap 函数]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE26%EF%BC%9A%E5%B0%BD%E9%87%8F%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E5%87%BA%E7%8E%B0%E7%9A%84%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[其实该条款总结下来就是再讲一个东西，而这个东西分成两点： 如果类的赋值成本低于一组构造和析构成本，那么将对象的定义定义到循环体外部去，尤其是在循环次数很多的情况下。否则就是将定义循环体内部中去。 尽可能延后变量定义式出现的时间，最好达到需要什么才去定义什么，这样做可以增加程序的清晰度并改善程序效率。另外最好在程序定义的时候就直接构造（初始化）。]]></content>
      <categories>
        <category>effective C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM集训相关知识]]></title>
    <url>%2F2018%2F12%2F01%2FACM%E9%9B%86%E8%AE%AD%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[基本的数据结构 扩充顺序表 （我的理解就是连续的顺序容器）存储方法就是在内存中开辟一段连续的空间。 而数据元素的位置确认： 常见的线性表运算： 此处一般都是用数组来实现，其的插入运算和删除运算都是基于连续内存空间上面所实现的。 单链表定义：链表的存储方式： 双向链表 循环链表简单来说就是首尾相连接的单向链表。 以上有时间再来进行详细的全面总结。 栈 如果用C语言来表示栈的话，得以数组作为基础，秉持先进后出的思想就行了。可以用int值作为下标值作为当时存储的栈的位置。也可以用两个指针来指示当前下标值。可以借用栈的思想来做题目。 队列 队列的基本逻辑运算： 这里也是运用两个int型的值当做是变量，分别指向头指针以及尾指针，然后执行添加减少的操作。一般到最后全部用做到下标上面。 而循环队列也是建立两个指针，但是不同的是其是将首尾进行连接之后，也就是说，其直接将每次得到的新结果对队列的总长度进行一个求余数（求mod）。 下学期上课的时候可以用C语言代码实现以下。 循环队列其实可以干和循环链表一样的事情。比如一道例题： 代码如下：1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt; #include&lt;queue&gt;#include&lt;string&gt; #include&lt;stdio.h&gt; using namespace std; int main()&#123; int n; while(cin&gt;&gt;n)&#123; queue&lt;string&gt; a; for(int i=0;i&lt;n;i++)&#123; string name; cin&gt;&gt;name; a.push(name); &#125; int w,s; scanf(&quot;%d,%d&quot;,&amp;w,&amp;s); for(int i=0;i&lt;w-1;i++)&#123; string temp = a.front(); a.pop(); a.push(temp); &#125; while(a.size())&#123; for(int i=0;i&lt;s-1;i++)&#123; string temp = a.front(); a.pop() a.push(temp); &#125; cout&lt;&lt;a.front()&lt;&lt;endl; a.pop(); &#125; &#125; &#125; 串串的定义： 此处则可以理解成是字符串。 二叉树树的定义： 二叉树的性质： 排序简单的冒泡排序]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年生日重庆之旅]]></title>
    <url>%2F2018%2F11%2F30%2F2018%E5%B9%B4%E7%94%9F%E6%97%A5%E9%87%8D%E5%BA%86%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[说句实话 自己也不知道应该写些什么东西，转眼之间似乎已经21岁了，知道自己内心不甘心的地方，但是唯一不太知道的是如何去改善这些不甘心的地方。问问自己的内心，其实自己一直想要的就是别人的关注。我觉得我个人的心路成长分成了几个阶段。 第一个阶段就是拼命的展现自我，追求其他人的认可与关爱。 如果在这个阶段里面获取了足够的认可，也许就会一直在这个阶段里面不断，要求满足，然后被满足的过程中进行沉沦。我个人的想法就是 ，如果没有进入到下一个阶段，那么永远得不到成长。 第二个阶段就是知道了这个世界上不会轻易的给自己满足的，知道了原来自己是会被拒绝的。 这个时期如果没有处理好的话，那么特别容易走向一个极端，走向一个“佛系”的一个极端，假意成为一个无欲无求的人，这个时期的我们就会厌恶一切“争宠”的行为，反而还会将那些争取优秀的人看作是特别低级的人类，从而厌恶一切优秀，但同时自己会在暗中做出很多自认为独一无二的事情，来彰显自己与别人不一样的地方。 第三个阶段往往是在经历了很长阶段的第二阶段，经历过打击，重新并且深刻的认知到这个世界并不是围绕着自己转动，一个人真的没办法获取周围每个人的关注。 也许甚至自己没办法获取周围一个朋友的全部的关注，其实换位思考一下，自己也没有全身心的投入自己去关注别人，其实到最后仍然是一个自己都达不到的标准去要求别人，那肯定是得不到自己想要的。 其实自己就在上面所说的第二阶段中无力翻腾着。虽然自己没有去蔑视努力，知道自己一切改变都是努力的结果，这是好的，但是从进入大学的一年多来，自己觉得自己很累，每天过得也很充实，也有一个固定的目标，但是自己却好像从来不能得到满足。 其实最近发生的一切不安，一切困惑，问问自己，其实全部来源于自我认知的偏差。真的以为自己是无所不能的超人，认为所有事情，只要自己认真去做，那么就一定可以实现，但是却忘记了一个很重要的前提，人的精力是有限的，真的没有办法做到面面俱到。 从最先开始的选择程序员这条路，到后面编程语言的选择，然后又到了工具，开发环境，以及编程之路方向上面的选择，我最近做出了很多很多的选择。很高兴自己做出了很多的选择，但是同样又很悲伤自己做出的选择。 比如：每天24个小时，全部花费给了学习编程，等花费回来之后就会心酸为什么自己没有留下来时间给健身，为什么自己没有留下来时间给自己阅读的时间。 比如：选择了程序员，又再次开始羡慕设计师，剪辑师，其他文学方面的职业，并且在认知到如果自己选择了其他方面的专业，那么自己一定会羡慕现在的这个专业。 比如：选择了考研，那么一定会因为羡慕赚钱的能力而摇摆不定，选择了工作，那么久一定会因为自己学历低而感到不满足。 我知道人类是一个贪婪且不会满足的动物，但是感觉自己个性中的犹豫不决更加深了这种不容易满足的天性。 其实我也认真想过，结合自身情况，为什么对于自己而言会出现这样的情况，我觉得剖析自己的内心而来，分为两个层面的原因。 外因 每个人的人生只有一次，对于个人而言，发生的一切，其实都是一个全新的体验，所以不知道该怎么做，产生迷茫的情绪是一件很正常的事情，另外对于自己而言，周围也没有陪伴自己成长的长者，没有人可以体会到自己生命中每一个抉择背后所要承担的东西。再加上本着想把一切做好的目的，这个时候就会产生即使做出选择也会产生后悔的不确定感。 内因 我觉得归根到内心的话，还是有 对自己不够自信这个心态存在的，还记得上次在经开一中一个科技展览会的时候，被一个学妹说不自信的时候，当时震惊的同时，其实更多的还是认可，我的确对自己不是特别的自信。不做选择的时候，怀疑自己是不是做不了选择了，当自己做出选择之后，又在怀疑自己是不是做出了一个错误的选择，我觉得这都是自己内心中需要克服的地方。 上面综合起来带来了 焦虑。 焦虑，一遍一遍的怀疑自己，一遍一遍的苛刻完美的标准，一遍一遍夸大其他人的成就而贬低自己的成就。以至于没有动力，没有耐心，没有毅力，以至于最后任欲望侵袭，堕落。 其实自己的初心是好的，但是为什么在初心之后的前行道路上会有如此大的阻碍呢，我觉得就是急功近利的心态，心急吃不了热豆腐，这句话适用于人生道路上面的每一寸。 不要因为走的太远，而忘记为什么出发 本来只是一个生日的小总结，不知不觉就说了这么多，本来只是想写写在重庆遇到了什么人，遇到了什么样的事情，但是还是抵御不住欲望的诱惑，主要还是焦虑，急功近利的心态毁了自己，自己在重庆得到的最大的收获便是在热闹的外界环境下，保持一份静谧，就像火锅配料上面的耗油，虽然起不到任何好吃的作用，但是却能在自己最辣的时候，给自己一点静谧。 这次的重庆之旅，有遗憾，有可惜，有没有完成的心愿，也有没有尽兴的地方，但是越长大越发现，我们总是希望人生中没有遗憾，可是到后来才发现，人生的遗憾才是人生中最有魅力的地方，因为有遗憾，才会有所向往。所有完美的东西最致命的弱点就是没有遗憾，从而也就没有了向往。 现在是凌晨的一点钟，自己还坐在火车上面颠簸，但是自己却有点享受这个时候的氛围，过道里时不时有人走过，有人上车，有人下车，旁边呼呼打鼾声音，还有时不时飘来的香烟味，提醒我 原来一直以来追求的生活就在周围。 希望自己回去以后可以好好的安排自己的人生，不要焦虑，不要急功近利，健身计划，英语六级，编程之路，成长之路，太过于追求结果就会导致失去自己想要的结果。 生活里最妙的永远不是按部就班，规划好的结果，而是转角里不经意的惊喜 祝自己21岁生日快乐。]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>个人经历</tag>
        <tag>旅行</tag>
        <tag>重庆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017~2018.5.1个人小结]]></title>
    <url>%2F2018%2F05%2F01%2F2017-2018-5-1%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[其实心知肚明自己的拖延症是非常强大的，总是在有意无意的拖延着，本来最先开始的预计是每一年都会写一个年终总结，然后2017年的年终总结直到现在才开始下笔，每次都有理由是最近的自己很忙很累，没有办法静下心来认真的写一写自己的总结，同时也秉持着“下一次一定有时间，其实后面的时间还多些呢？”然后就是这一些想法使自己拖延习惯变得越来越严重。也就有了今天”排除万难“在五一假期的第一天，在大家都出去郊游的情况下选择自己在宿舍里面好好整理。 从当初上大学一直到现在，说实话自己还是有点自命清高，也就是不太喜欢现在的环境，不过这种心态发展到现在，已经剔除了这种心态里面不太好的一面。这种想超脱环境的心态，我不知道该不该评价其的好与不好，但是我只知道的是，如果要超脱到现在原有的环境的话，得比周围的人付出200%的努力。 但是鉴于自己的表现，真的达到了200%的表现吗？我不知道，因为不知道自己努力的方向在哪，什么都想学，什么都想出人头地，但是却又什么都做不好，其实我现在越来越觉得人生最难的就是再控制好广度的同时钻研好深度。我觉得这才是难以控制的。落实到我现在的生活里面来看。上个学期的事情不去谈论过多，毕竟上个学期是来到学校的第一个学期，什么都很新鲜，由于好奇心的相互探索，自己找到了很多有趣的朋友，并且接触到了辩论，然后上个学期在保持学习进度的同时，在辩论上面进行了发展。上个学期就大学第一个学期而言，就算有太多的目标没有完成，但是这也都是可以值得原谅的。 现在我就要说的是大学的第二个学期，大道理每个人都懂，每个人都不是特别喜欢对自己说教的人，尤其是那个对你说教的人还是你的同级的时候，就更不容易接受，特别是自己做了一件事情，渴求肯定的时候，这个时候别人的”善意性质的批评“我觉得一定是听不下去的，但是对于自己而言，也许别人不会来说自己这一方面的事情，但是自己心里一定还是要有一些自知自明的，我知道对于自己这半个学期而来，很不满意，分几个块来说，由于自己每一方面都想要顾到，然后到最后自己每一方面都没有顾到。健身，辩论，编程，绩点学习奖学金，志愿者，旅游，自媒体写作，个人感觉这每一块都没有做好，因为每一件事情都想做好，但是每一件事都需要大量的时间基础很沉淀，于是我觉得目前最好的解决办法就是进行时间上面的优先级排序，把现阶段最重要的事情拿出来排到前面，自己想做，但是又不是必须做的事情放到后面。于是我就做了一下这张思维导图。 我目前的想法是想把计算机专业层面的学习放在第一位然后就是英语方面的学习，然后就是大学课程上面的学习。然后就是之后的兴趣发展。但是发展到现在，讲真的自己还是有点松懈了，没有以前的那股劲，但是就是羡慕那些有本事，有能力的人。之前的生活就是每天编点程序，学计算机方面的东西，然后也就是因为这些导致了翘课，导致了松懈，导致了现在会在宿舍里面发呆也不去教室上课，这些统统是导致的。我觉得这仍旧是自己开始松懈的标志，但是更是由于这些，我的生活也变得不太规律，之前一个星期每天估计一两点睡觉，而且早上不会再像以前一样去教室自习。我觉得我也不会像以前一样暗示自己这都不是个事，因为天然默认未来一切都是好的。然后就莫名其妙的给自己发一大段一大段的鸡汤 。这次的总结 我不想给自己讲大道理，因为全部都懂，我只想批评自己，只想反省。自己做的不对的地方就应该去改正。 未来还有一块是关于辩论队是去是留的问题，由于时间以及自己按照排序想做的事情冲突，不得不退了校队，并且极力减少自己再院队里面的比赛，但是自己还是比较喜欢这方面。但是没有办法，因为只要打乱了那个优先级排名的话，那么自己所有的事情都会乱。并且我喜欢自己做事情能够专一，最近发现自己在专一度上面没有很用功，后面可能会考虑尝试一下番茄时间。总之对于辩论队的诸多事宜，我最终决定还是仅仅是当作一个爱好，为自己的本命学科让路。 下一个问题是关于坚持，本来我觉得在这个层面是不存在的问题的，但是最近感觉的自己的自制力越来越差，其实毅力也就像肌肉，你只有多练练，才能使毅力这块肌肉越来越硬。所以以后跑步健身都要勤快点，去锻炼毅力这块肌肉。 最后是关于人际交往，有室友层面的，也有朋友层面的，交往一定要懂得度，这个度的把握，不仅要体现在自己身上，还要体现在别人身上。对于某些自以为是，只会偏激并且片面评价别人的人，我觉得还是把他们当作大神供起来吧。 贱人自有贱人收，我没办法弄他们，因为我不是贱人。 最后的最后希望从这个五一假期开始就带来改变，记住自己的优先级安排表，同时也记住坚持和努力，永远与自己的懒惰和松懈战斗下去。 总之对于现在而言​​，从5月1日到接下来放假的时间里，需要完成的目标有： 1、计算机编程语言C++的相关补充（尽量来看，还有暑假可以用来看）。 2、英语四级必须得过，接下来时间把英语听力弄好，每天尽力完成一套英语卷子。 3、体育锻炼 运动，马上夏天了，如果不想显示出自己的肥肉的话，得好好努力了。 ​4、保证接下来不挂科。允许不再以拿奖学金为主要目的。 5​、闲暇时间都看点自己感兴趣的书籍，不要再刷电视剧了。（这一点尽量控制）]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015年年度总结]]></title>
    <url>%2F2015%2F12%2F02%2F2015%E5%B9%B4%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今年是一个神奇的一年，做了许多以前没有想过的事情。但也碰触到了一些禁忌的事。泰戈尔也说过，人天生最强大的力量便是成长。对，就是成长。我们每一个人生来就不是完美的，我知道自己的缺点，自己的懦弱，自己在2015年所犯下的错误。但是还好，已经过去了，我也应该长大了。我也同样记得柴静说过的，只有同样经历过的人才有资格说我理解你。2015年上半年经历过一场车祸，终于从小孩子的认知，强行提升到了成人阶段，虽然有诸多不愿，但是，仍在慢慢适应。高二上学期，高二下学期，高三。时间过得很快。我理解了很多以前不理解的，看到了以前看不到的。人真的只有经历过痛苦才会知道自己真正想要的是什么。有的时候欲望，贪念，真的会毁掉一个人，但是也只有承受住来自与其磨难才可以真正成人。 但是由于自己的意志力不够，总是失败，但是我也不会妥协，抗争到底，这才是我。不过说到意志力，何谓意志力呢，个人觉得是一种抗逆的能力。抗拒痛苦和诱惑的能力。不巧，曾经拥有过的品质，由于生活过于安逸，再逐渐消失。比如说自己的拖延症，说大不大，但是说小也不小。我讨厌痛苦，这就是拖延症本质的原因。包括，给自己的任务完成不了，这也是其原因造成的。没有毅力。容易在家人面前控制不住自己的情绪。新的一年，我一定会改变这些。这一年里，也结识了许多人，逐渐知道社会7上的人情冷暖，以及人脉。我不想知道这些，但是现在能做的也就是默默的接受，总好比一味的抗拒。自己的性格也改了很多，一切朝好的方向进行转变。现在的我，也会学习每个人自己所遇到人的优点，从而改变自己。也许缓慢，但是方向是对的。关于你自己，我知道有的时候会有一种奇异的感觉包围着你，但是请相信一切的一切都会好的。打破常规，遵循本心。只当做看阴阳造化了。今后的日子，我希望自己能够坦荡做人，活出真实的自己，与自己的邪念抗争到底，完成自己的目标，过一种“没有任何借口”的生活。对自己，对别人，对一切负责。最后的最后，祝自己高考圆满，不求痴心妄想，只求问心无愧。]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看见与经历]]></title>
    <url>%2F2015%2F08%2F29%2F%E7%9C%8B%E8%A7%81%E4%B8%8E%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[一直以来都是想写点什么，距离我上一次发博文也已经过去将近半年了，这半年里，也可以说这2015年里对我的改变也是挺大的。知道什么是苦，什么是乐，什么是欲望，什么是爱。今天是距离高三开学的最后一天，不知道我为什么总是这么喜欢做这样的事，直到最后一步才开始完成。我知道来自于自身里的缺陷。我懒，我没有过大的自制力，也没有太强的执行力。 我很懦弱，所以逃避。我一直坚信着一个人最可怕的并不是弱点，而是在有生之年并不去改变这些缺点。强点就是将自己的懦弱 前些日子也看过一些书籍，这本书对我的启发很大，并不能说这本书给了我很大的感受，因为那都是别人的生活，别人的人生历练。但是他打开了我通向这个世界的大门。我知道生，也知道死，也知道爱，只是有的亲身经历过，有的并没有经历过。我知道主观，也知道客观。这些带给我的都只是我人生路上的一个经历。曾经的我认为要对身边的人无下限的好，也曾经认为自己已经很成熟。认为自己的消极的态度就是成熟之人必备的。错错错。真正的成熟就是要在外界的压力和内界的蜕变下找到真正的自己，所谓破而后立，当你已经立到不能再破的时候，你也就形成了自己的思想理论和自己有别于他人的鲜明个性。而往往来说这个过程却是要花费一辈子的时间。 马上这个暑假也过去了，在这个暑假里，我由衷的觉得欲望和爱之间的关系，我可以做一个只有欲望的人，面对形形色色的人不动自己的生色。我目前觉得找一个与自己惺惺相惜的人那种默契才是我真正需要的。当人考虑这些东西要等到大半年之后，等我高三结束之时，也就是我人生觉醒之刻。这个夏天学会了一个人去旅行，学会了看题图，学会了处理自己与运动之间的关系。明天我将再次踏上战场，整装待发。 一直相信自己，从不会失望。 墨橹 写于 8月30日]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>经历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【书记】活着]]></title>
    <url>%2F2015%2F04%2F06%2F%E3%80%90%E4%B9%A6%E8%AE%B0%E3%80%91%E6%B4%BB%E7%9D%80%2F</url>
    <content type="text"><![CDATA[我今天要分享的小说是《活着》，这本小说讲述的是一个人与命运之间的关系，他们无法接受对方，但同时也没有办法背离对方。这本书我的很多朋友都看过，他们为故事里的悲剧角色叹息，甚至有几个感性的朋友每每谈起这本书总会泪滴点点。这本书如果整个看下来我看过9遍，只是一部分一部分的看的话，我看过不止十八遍。虽然这里没有像‘书读百遍，其义自现’的体会，但还是有了自己感受。首先我先声明我讲的东西并不深刻，也没有深度。你们知道什么叫作深刻么？其实一个人的存在并不深刻，但是这个人背后所浓缩的某些特点，与整个社会的客观存在某种现象的相联系，这才是深刻。我并不想去批判那个时代所呈现的劣根，因为这常常才是使人绝望的地方我现在就向大家简要介绍一下《活着》这本书的故事剧情：故事里的主人公叫做福贵，是一个阔绰的少爷，他娶了一个妻子家珍，并且有一个4岁的女儿叫做凤霞。之后的悲剧也就是从这里开始的。福贵因为参与赌博被黑，卖掉了房子，输了全家三代积累下来的财富，自己怀孕的妻子家珍被老丈人无情带走。留下女儿和母亲相依为命，再过了一年多的苦生活后，家珍就带着一岁的儿子有庆回来，开始了一家人的平凡的农民生活。但是就在不久之后，福贵的母亲病了，福贵去城镇里请大夫，但是被国民党军抓取做壮丁，辗转两年被解放军所救，即后也就跟这解放军回家了。此时家里，母亲已经去世，女儿凤霞在一次高烧后变成了聋哑人，听妻子说母亲临终前一遍一遍的对妻子说，福贵是不会去赌博的。福贵也就在家里安顿下来，过了好几年，因为家里穷，只能卖女儿，让儿子去上学，最后女儿跑回来不忍送走，就留下来了。日子就这么一天天的过去，有一天因为县长的老婆生孩子要输血，结果儿子有庆被一个不负责任的大夫，给抽死了。后来竟然发现县长竟然是福贵当年相依为命的战友春生，不过春生之后也死于文化大革命。过了好几年，凤霞嫁了一个偏头女婿二喜，不久后死于产后大出血。两个孩子去世后，妻子家珍把外孙接到乡下来住，可没过多久就安安静静的死了。女婿二喜之后死于一场事故，死的时候外孙苦根仅仅4岁，还不知道死的概念。只留下祖孙俩人活着，但是好景不长，小苦根也意外失去了自己的生命。晚年的福贵买了一头老牛，取名为福贵。一起安享晚年。我这里并不想去讲这本书里所呈现出来的现实，也不想去评价这本书里的人物形象。这本书我看了很多遍，我甚至认为他们就像是我曾经与我精神交流的朋友。因为朴素，所以真实；因为真实，所以真挚；因为真挚，所以才会深深的触动我。在这里我只是想讲由这本书里我主管里延伸出来的3个问题吗，并且用我自己的生活感悟和经验，主观描述，客观阐述，解决的这三个问题 什么是活着。 为什么要活着。 怎么活着。首先第一个问题：什么才是活着。众所周知，生活的三大主题，生，死，爱。这三大永恒的主题将会影响我们的一生，生死相互对立而制衡，但是爱可以超越它们。（这里的爱并不只是男女之间的情愫，也并不是人与人之间产生的情感，具体来说它是一种主观感受，比如说喜怒哀乐恨，他们都是爱的一种表现）这里就为大家拓展下爱。大家谈到爱免不到就会想到《罗密欧与朱丽叶》，《梁山伯与祝英台》这两篇都是凄美且经典的爱情故事，他们所传达出来的思想则是”我爱你，所以我要为你殉情“大家知道随后即出的电影《泰坦尼克号》为什么那么有名，仅仅谈爱情一举超过了前面两部影片呢，甚至达到近几十年无人能敌的新的高峰呢，因为其提出了一个在当时特别前卫的思想理论‘我爱你，所以我就为你活下去，连同你的那一份一起活下去。”这就是爱，一定程度里爱可以超越生死。接下来便是我个人对生死的看法了，因为我有过这方面的经历所以我有这个资格拿出来来给大家分享，其实我今年17岁。在此之前对生死一点概念都是没有的，何谓生，何谓死呢，之前我的主观感觉就是教科书的生与死。直到我经历他。大家知道接触生死的第一感觉是什么吗？也许大家并不知道，仅仅只是以为是害怕，是恐惧。那么你就错了，并不是这样。接触生死的第一感觉不是恐慌，而恰恰是兴奋，我无法描述是一种怎样的兴奋，因为持续的时间特别短，大概可以类比为是一个从没有吃过糖的孩子，第一次吃糖的感觉，多少有点新鲜感在里面。之后就是一种安不下心的恐惧感，这种感觉没有经历过的人是不知道的，那是一种无法装出来的感觉。事后我也进行相关资料的查阅，好像是一个叫什么卡的理论科学家发表的一篇论文叫《生死论》里提到人在濒临死亡的那一刻，潜意识里已经把自己当作死亡，这时的恐惧将是对生活以及其他人或事物的无限眷念产生的。所以就像我的一个老师所讲的这个时候的人第一想法就是想自己最亲近的人，比如说妈妈。呵呵。我当时也是无法静下心，心里一直想如果妈妈在身边就好了，就好像这个人可以给你带来无尽的心安。之后过了一会儿后自己的心就静下来了，那种静下来的感觉叫做庆幸。感谢自己他妈的还活着。说句实话，那次的经历让我之后的一个月很不好过去，但是他对我最大的意义就是他完全打开了我对外界事物感知，就像一个美妙的气孔被揭开，然后进行气体交流的感觉。只有到了那个时候我才真正的知道到底什么是活着。就像我前面所说的爱是一切感受的源泉，所以活着就是我们在这个世界上主观上存在的感受。包括生，包括死，包括爱，包括我们生活的任何一种主观感觉，这就是活着。 我们为什么要活着 我很反感很多专家类的人物整天批判中国人没有信仰，中国人的信仰就是“好死不如赖活着，无论发生什么活着就行了。”活着这本书也就是讲为什么活着这个问题的，福贵在书里是这么形容自己的一生：&quot;我是有时候想想伤心，有时候想想又很踏实”一个早已进去垂暮之年的老人尚且如此，全家人的葬都是这样一位老人送走的，其中的滋味是我们所没办法想象的。那联系到实际，我们为什么活着呢，其实这个问题古往今来无数人士都参与过探讨，都没有得出一个科学性的结论。他们的探讨的过程大多数都是微观细胞的存在形式，和宏观宇宙的神秘意图。由我个人的观点，并没有 微及细胞，大至宇宙，也不像这本书里的观点。活着并不是为了活着以外的事物而活着，而是为了活着本身而活着。围绕这一个比较抽象的说法，也就展开了福贵的一生。中国有一个成语叫做千钧一发。让一根头发去承受三万斤的重压，但是头发并没有断。这就是中国人的韧性。真正强大的人并不是看他征服了什么，而是看他可以承受什么。所以我的答案也就由此而产生活着就是为了坚持，坚持去爱，坚持享受所有由活着带来的一切主观感受，坚持忍受由死去带来的一切恐惧体会，这就是活着。我的观点也就是这个，也许十年后我会推翻我的理论，（我已经推翻了我小时候很多的想法理论。）但至少现在不会。 第三，我们应该怎么活。 这里其实就要客观的来讲一下这本书的局限性。这本书里讲的是上个世纪从解放后的土地改革、人民公社制度、大炼钢铁、三年自然灾害、文化大革命之间，讲的只是底层人民对于温饱问题矛盾，缺少的则是精神世界的建设。当然在那个年代谈精神年代就像说梦话一样。但是现在的社会水平已经高于当年很多倍了，但是现在的人民幸福度却远低当年。这又是为什么呢？唯一可以解释的原因就是，人们解决了温饱类的问题后，精神世界的匮乏甚至是溃烂，出现了极大的问题。那么怎么解决呢。物质和精神上的协调与平衡该如何做到呢？一切随心，随自己的主观感觉，随自己想要完成的事情。人为什么会不快乐，大家知道么？是由于我们个人的主观感觉被客观规律法则所牵制，导致我们并不快乐。而往往这些客观法则规律常常是没有最正确的理由的，比如说为什么评判现在一个人书读的好，就一切都好。为什么长大后赚钱的多少是评判一个人是否成功的重要依据。实现人生价值评判方式有很多，为什么单单只是这一点。那还有为什么男大当婚，女大当嫁…还有很多问题我们问不出来缘由，这些都是整个社会所给予的。那么为什么社会要这样规定呢？肯定是对整个社会的和谐稳定有益处。但同时也造成了巨大的压力给个人。按照幸福最大化原理，没有人，或者说是没有生物从本质上讲是喜欢痛苦和苦难的。然而面对这一切压力，但总是有人活的潇洒。比如庄子的物我合一，陶渊明的物我两忘，这些都是境界上的潇洒。而我们该如何做到这些呢？唯有修心。提高心理素质和承受能力，寻觅物质与精神守恒的一点。这就是我们活着该做的事情。人生的最高的境界便是淡。我没有达到这个境界，所以我没有办法为大家展开。但是按照自己的心活下去，我相信万法同一。殊途总会同归的。 写与2015年4月6日。]]></content>
      <categories>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>书评</tag>
        <tag>创作</tag>
      </tags>
  </entry>
</search>

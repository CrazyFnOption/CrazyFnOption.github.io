<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PAT甲级题目总结及解析]]></title>
    <url>%2F2019%2F08%2F30%2FPAT%E7%94%B2%E7%BA%A7%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%E5%8F%8A%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[7.27线性dp与区间dp题目解析]]></title>
    <url>%2F2019%2F07%2F27%2F7-27%E7%BA%BF%E6%80%A7dp%E4%B8%8E%E5%8C%BA%E9%97%B4dp%2F</url>
    <content type="text"><![CDATA[A.导弹袭击代码如下：123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;int main()&#123; //freopen("test1.in", "r", stdin); //freopen("test1.out", "w", stdout); int T; while (~scanf("%d", &amp;T)) &#123; int dp[T + 5]; int data[T + 5]; data[0] = 0; int num = 0; for (int i = 1; i &lt;= T; i++) &#123; cin &gt;&gt; data[i]; dp[i] = 1; &#125; for (int i = 2; i &lt;= T; i++) &#123; for (int j = i - 1; j &gt;= 1; j--) &#123; if (data[i] &gt; data[j]) &#123; dp[i] = max(dp[i], dp[j] + 1); &#125; num = max(num, dp[i]); &#125; &#125; cout &lt;&lt; num &lt;&lt; endl; &#125; return 0;&#125; B.Common Subsequence代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;string s1, s2, tmp;int main()&#123; //freopen("test1.in", "r", stdin); //freopen("test1.out", "w", stdout); while (cin &gt;&gt; s1 &gt;&gt; s2) &#123; if (s1.size() &lt; s2.size()) &#123; tmp = s1; s1 = s2; s2 = tmp; &#125; int dp[s1.size() + 10][s1.size() + 10]; memset(dp, 0, sizeof dp); int Max = 0; for (int i = 0; i &lt; s2.size(); i++) &#123; int k = i + 1; for (int j = 0; j &lt; s1.size(); j++) &#123; int l = j + 1; if (s1[j] == s2[i]) &#123; dp[k][l] = dp[k - 1][l - 1] + 1; &#125; else dp[k][l] = max(dp[k - 1][l], dp[k][l - 1]); Max = max(Max, dp[k][l]); &#125; &#125; cout &lt;&lt; dp[s2.size()][s1.size()] &lt;&lt; endl; &#125; return 0;&#125; C.滑雪代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;map&gt;#define INF 0x3f3f3f3f#define N 110using namespace std;int dis[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;int len[N][N], a[N][N];int m, n;int dp(int x, int y)&#123; int tx, ty, k, s, ms; ms = 0; if (len[x][y] != 0) //递归出口； return len[x][y]; for (k = 0; k &lt;= 3; k++) &#123; tx = dis[k][0] + x; ty = dis[k][1] + y; if (tx &lt; 0 || ty &lt; 0 || tx &gt; m - 1 || ty &gt; n - 1) continue; if (a[tx][ty] &lt; a[x][y]) &#123; s = dp(tx, ty); ms = max(ms, s); &#125; &#125; len[x][y] = ms + 1; return len[x][y];&#125;int main()&#123; //freopen("test1.in", "r", stdin); //freopen("test1.out", "w", stdout); int i, j, Max; while (~scanf("%d%d", &amp;m, &amp;n)) &#123; memset(a, 0, sizeof(a)); memset(len, 0, sizeof(len)); for (i = 0; i &lt; m; i++) for (j = 0; j &lt; n; j++) scanf("%d", &amp;a[i][j]); Max = -1; for (i = 0; i &lt; m; i++) for (j = 0; j &lt; n; j++) Max = max(Max, dp(i, j)); printf("%d\n", Max); &#125; return 0;&#125; D.小红红益智游戏代码如下： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int INF = -0x3f3f3f3f; //定义一个无穷大的值const int maxn = 205;int dp[maxn][maxn];int sum[maxn][maxn], n, x;int main()&#123; sum[0][0] = 0; //初始化 while (scanf("%d", &amp;n) != EOF) &#123; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;x); sum[i][i] = x; fill(dp[i], dp[i] + maxn, INF); //初始化 dp[i][i] = 0; &#125; //区间dp for (int len = 2; len &lt;= n; len++) //枚举区间长度 &#123; for (int i = 1; (i + len - 1) &lt;= n; i++) //枚举区间起点 &#123; int j = i + len - 1; for (int k = i; k &lt; j; k++) //枚举中断点 &#123; sum[i][j] = sum[i][k] + sum[k + 1][j]; dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j] + sum[i][j]); &#125; &#125; &#125; printf("%d\n", dp[1][n]); &#125; return 0;&#125; E.最大括号匹配数代码如下： 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 105;int dp[maxn][maxn];string V;int main()&#123; while (cin &gt;&gt; V, V[0] != '0') &#123; int n = V.size(); for (int i = 0; i &lt;= n; i++) &#123; memset(dp[i], 0, sizeof(dp[i])); &#125; for (int len = 2; len &lt;= n; len++) &#123; for (int i = 0; i + len - 1 &lt; n; i++) &#123; int j = i + len - 1; if (V[i] == '(' &amp;&amp; V[j] == ')' || V[i] == '[' &amp;&amp; V[j] == ']') &#123; if (i + 1 &gt; j - 1) dp[i][j] = 2; else dp[i][j] = dp[i + 1][j - 1] + 2; &#125; for (int k = i; k &lt; j; k++) &#123; dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j]); &#125; &#125; &#125; cout &lt;&lt; dp[0][n - 1] &lt;&lt; endl; V.clear(); &#125; return 0;&#125; F.红红跳格子代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 1005;int dp[maxn];int num[maxn];//总结一下这类的线性DP。//这里dp数组保存的是每一个点为止这个位置上的递增子序列之和//然后这个地方的每一个确定的值再与之前的去比较，最后加上相应的值即可。int main()&#123; //freopen("test1.in", "r", stdin); //freopen("test1.out", "w", stdout); int T; while (cin &gt;&gt; T &amp;&amp; T) &#123; for (int i = 1; i &lt;= T; i++) &#123; cin &gt;&gt; num[i]; &#125; memset(dp, 0, sizeof dp); dp[1] = num[1]; for (int i = 2; i &lt;= T; i++) &#123; dp[i] = num[i]; for (int j = i - 1; j &gt;= 1; j--) &#123; if (num[i] &gt; num[j]) &#123; dp[i] = max(dp[i], dp[j] + num[i]); &#125; &#125; &#125; int Max = 0; for (int i = 1; i &lt;= T; i++) &#123; Max = max(Max, dp[i]); &#125; cout &lt;&lt; Max &lt;&lt; endl; &#125; return 0;&#125; G.请客的红红代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* 这道题就是被前面的思想所影响，其实这道题不像前面前面几个状态一定会影响到后面的状态， 仅仅只是一个一维的线性dp，考虑到前面的这些情况，他是另外的两个dp方程组进行放与不放的操作 所以不会涉及到多个循环反复到前面之前的状态去寻找， 只需要在一次遍历的过程中去实现究竟是一次还是两次的操作。 跟着每一个状态往下面找出每一个位置的局部最优解 最后得到结果。*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 2005;int dp[maxn];int s[maxn];int d[maxn];int main()&#123; //freopen("test1.in", "r", stdin); //freopen("test1.out", "w", stdout); int T; cin &gt;&gt; T; while (T--) &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; s[i]; dp[i] = s[i]; &#125; d[0] = 0; d[1] = 0; for (int i = 2; i &lt;= n; i++) &#123; cin &gt;&gt; d[i]; &#125; dp[0] = 0; dp[1] = s[1]; for (int i = 2; i &lt;= n; i++) &#123; dp[i] = min(dp[i - 1] + s[i], dp[i - 2] + d[i]); &#125; int h = dp[n] / 3600 + 8; int m = dp[n] / 60 % 60; int s = dp[n] % 60; if (h &lt;= 12) printf("%02d:%02d:%02d am\n", h, m, s); else printf("%02d:%02d:%02d pm\n", h, m, s); &#125; return 0;&#125; H.红红与糖果代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100005;int n;int dp[maxn][11];int date[maxn][11];int _time, pie;int main()&#123; //freopen("test1.in", "r", stdin); //freopen("test1.out", "w", stdout); while (scanf("%d", &amp;n) &amp;&amp; n != 0) &#123; memset(date, 0, sizeof date); memset(dp, 0, sizeof dp); int maxTime = 0; for (int i = 0; i &lt; n; i++) &#123; scanf("%d %d", &amp;pie, &amp;_time); date[_time][pie]++; maxTime = max(maxTime, _time); &#125; //第一秒的运行时间，里面所有的运行情况 dp[1][4] = date[1][4]; dp[1][5] = date[1][5]; dp[1][6] = date[1][6]; //这里其实是由第二次运转的时间来看，因为第一秒的时间我已经全部标记下来了。 for (int i = 2; i &lt;= maxTime; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; dp[i][j] = dp[i - 1][j]; //不过需要注意的是 这些全部都是前几秒的动作，上一秒更新的状态，到下一秒后执行的状态 //下面这个地方就是很奇幻的地方了，一共三个状态，取出来还是不取出来，就是这三种状态 //左边一个位置取，还是右边一个位置取，还是原本的位置去出来。 if (j &gt; 0) dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]); if (j &lt; 10) dp[i][j] = max(dp[i][j], dp[i - 1][j + 1]); dp[i][j] += date[i][j]; &#125; &#125; int Max = 0; for (int i = 0; i &lt; 11; i++) &#123; Max = max(Max, dp[maxTime][i]); &#125; cout &lt;&lt; Max &lt;&lt; endl; &#125; return 0;&#125; I.老左的矩阵代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* 这个地方就直接就是答案的思路了，由一种倒叙的方法往前面推，将对角线存储的数， 就是当前能存储到的最大的矩阵。 状态转移方程就是 dp[i][j] 由 dp[i - k][j]与 dp[i][j - k] 是否相等然后再来存储 不过这里有一个技巧就是 每一个仅仅只是存储这个数组能够承受的最大值、 自己想的办法没有考虑到状态的迁移，也就是没有考虑到状态与状态之间的联系，这里就展现出来了。 将每一个值存储到dp[i - 1][j + 1] 上，然后再一次对其进行验证。 */#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int n;const int maxn = 1005;char ch[maxn][maxn];int dp[maxn][maxn];int main()&#123; //freopen("test2.in", "r", stdin); //freopen("test2.out", "w", stdout); while (cin &gt;&gt; n &amp;&amp; n) &#123; getchar(); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; ch[i][j]; dp[i][j] = 1; &#125; getchar(); &#125; int Max = 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = n; j &gt;= 1; j--) &#123; if (i == 1 || j == n) continue; int tmp = dp[i - 1][j + 1]; for (int k = 1; k &lt;= tmp; k++) &#123; if (ch[i - k][j] == ch[i][j + k]) dp[i][j]++; else break; &#125; Max = max(Max, dp[i][j]); &#125; &#125; printf("%d\n", Max); &#125; return 0;&#125; J.阿春取数字代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* 这道题目就是典型的区间DP的题目了，对一个区间里面的值进行动态规划的求解，就像下面的状态转移方程 dp[i][j] = max(dp[i + 1][j] + num[i] *(n + i - j), dp[i][j - 1] + num[j] * (n + i - j)); 这道题唯一特别难想到的是，这道题目是一道逆序求解的问题， 意思就是从后面的状态往前面推，这当时的我就完全没有想到了。*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;using namespace std;int n;const int maxn = 2005;int dp[maxn][maxn];int num[maxn];int main()&#123; //freopen("test3.in", "r", stdin); //freopen("test3.out", "w", stdout); while (~scanf("%d", &amp;n)) &#123; memset(dp, 0, sizeof dp); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;num[i]); dp[i][i] = num[i]; &#125; for (int i = n; i &gt;= 1; i--) &#123; for (int j = i; j &lt;= n; j++) &#123; //这里乘以 n + i - j 其实一开始的变形就是 n - (j - i + 1) + 1 dp[i][j] = max(dp[i + 1][j] + num[i] * (n + i - j), dp[i][j - 1] + num[j] * (n + i - j)); &#125; &#125; printf("%d\n", dp[1][n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>习题解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7.26_记忆化搜索和背包习题解析]]></title>
    <url>%2F2019%2F07%2F26%2F7-26-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E5%92%8C%E8%83%8C%E5%8C%85%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[A.小辉辉玩积木代码如下：1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;cmath&gt;using namespace std;long long a[60] = &#123;1, 2&#125;;long long f(int n) &#123; if (a[n]) return a[n]; return a[n] = f(n - 2) + f(n - 1);&#125;int main()&#123; std::ios::sync_with_stdio(false); cin.tie(0); int N; while (cin &gt;&gt; N) &#123; cout &lt;&lt; f(N - 1) &lt;&lt; endl; &#125; return 0; return 0;&#125; 这道题就仅仅只是用到了一个递归和记忆化搜索，属于基础简单的题目。 B.入侵和反击代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; std::ios::sync_with_stdio(false); cin.tie(0); int T; cin &gt;&gt; T; while (T--) &#123; int n; cin &gt;&gt; n; int dp[n + 5]; int num[n + 5]; for (int i = 0; i &lt; n;i ++) &#123; cin &gt;&gt; num[i]; &#125; //memset(dp,1,sizeof dp); //fill (num,num+n,1); dp[0] = 1; for (int i = 1;i &lt; n; i++) &#123; dp[i] = 1; //这个地方的状态转移方程，需要去细想比较一下。 for (int j = 0; j &lt; i; j++) &#123; if (num[i] &lt;= num[j]) &#123; dp[i] = max(dp[i],dp[j] + 1); &#125; &#125; &#125; int Max = -1; for (int i = 0; i &lt; n; i++) &#123; Max = max(Max,dp[i]); &#125; cout &lt;&lt; n - Max &lt;&lt; endl; // 9 17 8 19 3 // 1 1 2 1 3 &#125; return 0;&#125; C.红红数钞票代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* 其实这道题也算是一道特别简单的题目，还是动态规划里面最基础的问题，但是总是容易去弄混。 记得自己当时的问题就在于 这里每一次相加的和，如何保证后面加了负数之后，再次加上一个正数不被影响呢， 下面的注释里面有写， 因为题目中限制了，如果这道题有多个答案，比如说 前面与后面相加为零，但是后面的那个正数正好作为最后的正确答案的话 比如 1 2 -3 8 10 -1 1 2 -3 正好相加为0 但是题目中要求的 序列 1 2 -3 8 作为最后的结果序列。 自己当时也在这一块上面纠结。*/#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; std::ios::sync_with_stdio(false); int m; cin &gt;&gt; m; int num[m + 5]; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; num[i]; &#125; int left = 0; int tmpleft = 0; int right = m - 1; int tmp = 0; int Max = -1; for (int i = 0; i &lt; m; i ++) &#123; tmp += num[i]; if (tmp &lt; 0) &#123; tmp = 0; tmpleft = i + 1; &#125; else if (tmp &gt; Max) &#123; Max = tmp; right = i; left = tmpleft; &#125; &#125; if (Max &gt;= 0) cout &lt;&lt; Max &lt;&lt; " " &lt;&lt; num[left] &lt;&lt; " " &lt;&lt; num[right] &lt;&lt; endl; else cout &lt;&lt; 0 &lt;&lt; " " &lt;&lt; num[0] &lt;&lt; " " &lt;&lt; num[m - 1] &lt;&lt; endl; return 0;&#125; D.Charm Bracelet代码如下：12345678910111213141516171819202122232425262728293031323334/* 第一道题属于一个简单的01背包模板题目，这里不多说 可以直接套模板。*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int n,m;int dp[13000];int w[3500],v[3500];int main()&#123; while (cin &gt;&gt; n &gt;&gt; m) &#123; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; w[i] &gt;&gt; v[i]; &#125; memset(dp,0,sizeof dp); for (int i = 1; i &lt;= n; i++) &#123; for (int j = m; j &gt;= w[i]; j--) &#123; dp[j] = max(dp[j],dp[j - w[i]] + v[i]); &#125; &#125; cout &lt;&lt; dp[m] &lt;&lt; endl; &#125; return 0;&#125; E.红红绝地求生代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* 一段简单的模板题目，不过需要弄清楚的 一维数组与二维数组在这里相应的区别，往往这里会产生很大的区别， 比如第二个循环的开始条件，因为这里是由子问题的堆积，然后一点一点向上升最终得到的问题，所以这李最好控制背包的放与不放的问题、 就比如我在这道题目的第二个问题中出现的错误，就是将j=0这个条件直接掠过去了，其实这里是不对的。*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1010;long long weight[maxn],value[maxn],dp[maxn][maxn];long v,w;int main()&#123; int T; cin &gt;&gt; T; while(T--) &#123; cin &gt;&gt; w &gt;&gt; v; value[0] = 0; weight[0] = 0; for (int i = 1; i &lt;= w; i++) &#123; cin &gt;&gt; value[i]; &#125; for (int i = 1; i &lt;= w; i++) &#123; cin &gt;&gt; weight[i]; &#125; memset(dp, 0, sizeof dp); for (int i = 1; i &lt;= w; i++) &#123; for (int j = 0; j &lt;= v; j++) &#123; if (j &gt;= weight[i]) &#123; dp[i][j] = max(dp[i - 1][j],dp[i - 1][j - weight[i]] + value[i]); &#125; else dp[i][j] = dp[i - 1][j]; &#125; &#125; cout &lt;&lt; dp[w][v] &lt;&lt; endl; &#125; return 0;&#125; F.一卡通代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041/* 一维滚动数组的做法，由于是01背包，所以直接套模板*/#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n; int d[1010]; int dp[1010]; while (cin &gt;&gt; n &amp;&amp; n) &#123; memset(d, 0, sizeof(d)); memset(dp, 0, sizeof(dp)); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; d[i]; &#125; int p; cin &gt;&gt; p; sort(d + 1, d + n + 1); if (p &lt; 5) &#123; cout &lt;&lt; p &lt;&lt; endl; &#125; else &#123; for (int i = 1; i &lt; n; i++) &#123; for (int j = p - 5; j &gt;= d[i]; j--) &#123; dp[j] = max(dp[j], dp[j - d[i]] + d[i]); &#125; &#125; cout &lt;&lt; p - dp[p - 5] - d[n] &lt;&lt; endl; &#125; &#125; return 0;&#125; 第二种方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* 二维数组直接套模板*//* 这道题神奇的地方就在于 其的重量限制于价值重合在了一起，所以对于这道题而言就是只能重合的去写状态转移方程了 另外需要注意的是最后输出结果的办法，是将最后一个物品交给剩下的最大的钱去购买，这样能彻底用光最后的钱财*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int n,m;const int maxn = 1010;int num[maxn],dp[maxn][maxn];int main()&#123; while (cin &gt;&gt; n &amp;&amp; n) &#123; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; num[i]; &#125; cin &gt;&gt; m; sort(num + 1, num + 1 + n); if (m &lt; 5) &#123; cout &lt;&lt; m &lt;&lt; endl; continue; &#125; memset(dp,0,sizeof dp); //这里与上面一维滚动数组不太一样的是，一维滚动数组是不能有对物品限制的操作。 //意思就是 我二维数组可以算出n-1个数，然后算出最后一个数给出的钱数dp[i - 1][j] //而一维数组由于只有一个参数就是体积容量的参数dp[i] //所以下面多算了一个，最后再通过计算出n-1个物品的体积，再减去相应的钱数，得到最终答案。 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= m - 5; j++) &#123; if (j &gt;= num[i]) &#123; dp[i][j] = max(dp[i - 1][j],dp[i - 1][j - num[i]] + num[i]); &#125; else dp[i][j] = dp[i - 1][j]; &#125; &#125; cout &lt;&lt; m - dp[n - 1][m - 5] - num[n] &lt;&lt; endl; &#125; return 0;&#125; G.红红减肥记代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* 这道题使用二维数组就一直就会超时 具体的我也不太清楚，但是 没有办法 只能使用一维滚动数组，进行了相应的空间优化 不过这里需要补充几个知识点 第一 关于二维数组的完全背包状态转移方程 dp[i][j] = max (dp[i - 1][j],dp[i - 1][j - k * c[i]] + k * v[i]); 由上面这个式子就可以得出，状态转移方程 于是 一种空间优化的写法 是直接写成 max(dp[i - 1][j]，dp[i][j - w[i]] + v[i]) 第二 如果换成滚动数组的话 记住 第二个循环的两个顺序，如果是倒叙的话 则就是要保证每一个物品只会取一次，但是如果是正序的话，那么就不需要保证上面所说的顺序了。 而这里官方的解释 就在这里 ： 让 v 递减是为了保证第i次循环中的状态F[i;v]是由状态F[i-1;v-Ci]递推而来。 换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第 i 件物品”这件策 略时，依据的是一个绝无已经选入第 i 件物品的子结果F[i-1;v-Ci]。而现在完全背 包的特点恰是每种物品可选无限件，所以在考虑“加选一件第 i 种物品”这种策略时， 却正需要一个可能已选入第 i 种物品的子结果F[i;v-Ci]，所以就可以并且必须采用v 递增的顺序循环。这就是这个简单的程序为何成立的道理。*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include&lt;cstdio&gt;using namespace std;int n, a, b, m;const int maxn = 110;int happiness[maxn], kaluli[maxn];int dp[110000];int main()&#123; while (~scanf("%d",&amp;n)) &#123; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d %d",&amp;happiness[i],&amp;kaluli[i]); &#125; scanf("%d",&amp;m); memset(dp,0,sizeof dp); for (int i = 1; i &lt;= n; i++) &#123; for (int j = kaluli[i]; j &lt;= m; j++) &#123; dp[j] = max(dp[j],dp[j - kaluli[i]] + happiness[i]); &#125; &#125; printf("%d\n",dp[m]); &#125; return 0;&#125; H.Piggy-Bank代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* 这道题是一个完全背包的裸题，对于这道题而言更加神奇的地方就在于其实求最小值而不是求最大值 所以在最先开始初始化的时候不应该去初始化为0，而应该初始化为无穷大 而千万不要忘记了再初始化的时候一定要对第一个状态进行一个单独赋值是等于0，还是等于无穷大，这个等到时候再看。*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt; using namespace std;int _beg,_end;const int maxn = 505;int v[maxn],w[maxn];int dp[10010];int main()&#123; int T; cin &gt;&gt; T; while (T--) &#123; scanf("%d %d",&amp;_beg,&amp;_end); int bottle = _end - _beg; int n; scanf("%d",&amp;n); for (int i = 1; i &lt;= n; i++)&#123; scanf("%d %d",&amp;v[i],&amp;w[i]); &#125; memset(dp,0x3f3f3f3f,sizeof dp); dp[0] = 0; for (int i = 1; i &lt;= n;i ++) &#123; for (int j = w[i]; j &lt;= bottle; j++) &#123; dp[j] = min(dp[j],dp[j - w[i]] + v[i]); &#125; &#125; if (dp[bottle] != 0x3f3f3f3f) cout &lt;&lt; "The minimum amount of money in the piggy-bank is " &lt;&lt; dp[bottle] &lt;&lt; "." &lt;&lt; endl; else cout &lt;&lt; "This is impossible." &lt;&lt; endl; &#125; return 0;&#125; I.美元的困惑代码如下： 12345678910111213141516171819202122232425import java.util.Scanner;import java.math.BigInteger;public class Main &#123; public static void main(String[] args) &#123; int n,k; Scanner in = new Scanner(System.in); while (in.hasNext()) &#123; BigInteger[] dp = new BigInteger[1005]; n = in.nextInt(); k = in.nextInt(); dp[0] = new BigInteger("1"); for (int i = 1; i &lt;= n; i++) &#123; dp[i] = new BigInteger("0"); &#125; for (int i = 1; i &lt;= k; i++) &#123; for (int j = i; j &lt;= n; j++) &#123; dp[j] = dp[j].add(dp[j - i]); &#125; &#125; System.out.println(dp[n]); &#125; &#125;&#125; J.Coins123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/* 这道题神奇的地方就是将多重背包的裸题进行了改变， 主要就是每一次增加的价值会发生改变，这才是最关键的地方。 这里的价值就不再是个数，而是进行一个打表，通过这个打表来判断这个重量是否能够达到。*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int n;int bag;bool dp[100040];int value[105],number[105];int cnt = 0;void zeroonepack(int weight, int value)&#123; for (int j = bag; j &gt;= weight; j--) &#123; if (!dp[j] &amp;&amp; dp[j - weight])&#123; dp[j] = true; cnt ++; &#125; &#125;&#125;//完全背包void completepack(int weight, int value)&#123; for (int j = weight; j &lt;= bag; j++) &#123; if (!dp[j] &amp;&amp; dp[j - weight]) &#123; dp[j] = true; cnt ++; &#125; &#125;&#125;//多重背包void multilpack(int weight, int number, int value)&#123; //第一种情况就是 如果这件物品所有的重量是小于背包的重量的话 //那么对于背包而言 这个物品是可以取无限大。 if (bag &lt;= number * weight) &#123; completepack(weight, value); return; &#125; //而超过的这个范围的就只能使用01背包 然后使用二进制的方法 //将每一类型的背包进行一个分组 //后面再依次分别使用多重背包。 int k = 1; while (k &lt; number) &#123; zeroonepack(k * weight, k * value); number = number - k; k = k * 2; &#125; zeroonepack(number * weight, number * value);&#125;int main()&#123; while (cin &gt;&gt; n &gt;&gt; bag &amp;&amp; n &amp;&amp; bag) &#123; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; value[i]; &#125; for (int i = 1; i &lt;= n;i ++) &#123; cin &gt;&gt; number[i]; &#125; cnt = 0; memset(dp,0,sizeof dp); dp[0] = 1; for (int i = 1; i &lt;= n ;i ++) &#123; multilpack(value[i],number[i],value[i]); &#125; cout &lt;&lt; cnt &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>习题解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA 1013 两种方法解决点与路径的关系]]></title>
    <url>%2F2019%2F07%2F24%2FPTA-1013-%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%E7%82%B9%E4%B8%8E%E8%B7%AF%E5%BE%84%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[这道题很有趣，这里直接贴出题目。 这道题纯粹就是给出一系列边与点的关系，然后再去掉一个点，看看剩余需要多少个点才能连接成一个完整的图。 第一种方法并查集123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/* 这道题最先开始真的是不知道何从入手，因为本身对于图论的相关知识并不是特别在行 这道题的两种方法，第一就是并查集，第二就是利用dfs遍历完所有需要遍历的点。*/#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cmath&gt;using namespace std;int N,M,K;const int maxn = 1005;int fa[maxn];//再次错在了这种地方，范围小了，这里题目虽然并没有给出相应的范围//但是按照每一条边之间的链接来看，这里需要加大其的范围。pair&lt;int,int&gt; pp[maxn * maxn];void init() &#123; for (int i = 0; i &lt;= N; i++) &#123; fa[i] = i; &#125;&#125;int find(int x) &#123; if (fa[x] != x) fa[x] = find(fa[x]); return fa[x];&#125;void merge(int x,int y) &#123; int fx = find(x); int fy = find(y); if (fx != fy) &#123; fa[fx] = fy; &#125;&#125;int main()&#123; std::ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; N &gt;&gt; M &gt;&gt; K; int a,b; for (int i = 0; i &lt; M; i++) &#123; cin &gt;&gt; a &gt;&gt; b; pp[i].first = a; pp[i].second = b; &#125; int tmp; for (int i = 0; i &lt; K; i++) &#123; cin &gt;&gt; tmp; init(); for (int j = 0; j &lt; M; j++) &#123; if (pp[j].first != tmp &amp;&amp; pp[j].second != tmp) &#123; merge(pp[j].first,pp[j].second); &#125; &#125; int cnt = 0; for (int i = 1; i &lt;= N; i++) &#123; if (fa[i] == i) cnt++; &#125; if (N == 1) cout &lt;&lt; 0 &lt;&lt; endl; else if (N == 2) cout &lt;&lt; 0 &lt;&lt; endl; else cout &lt;&lt; cnt - 2 &lt;&lt; endl; &#125; return 0;&#125; 第二种方法 通过dfs深搜后进行标记1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 1008;int N,M,K;bool dis[maxn][maxn];bool vis[maxn];void dfs(int x) &#123; vis[x] = true; for (int i = 1; i &lt;= N; i++) &#123; if (vis[i] == false &amp;&amp; dis[x][i] == true) &#123; dfs(i); &#125; &#125;&#125;int main()&#123; std::ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; N &gt;&gt; M &gt;&gt; K; int a,b; memset(dis,false,sizeof dis); for (int i = 0; i &lt; M; i++) &#123; cin &gt;&gt; a &gt;&gt; b; dis[a][b] = dis[b][a] = true; &#125; int tmp; for (int i = 0; i &lt; K; i++) &#123; memset(vis,false,sizeof vis); cin &gt;&gt; tmp; vis[tmp] = true; int cnt = 0; for (int i = 1; i &lt;= N; i++) &#123; if (vis[i] == false) &#123; dfs(i); cnt++; &#125; &#125; cout &lt;&lt; cnt - 1 &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA 1010 二分的基本应用]]></title>
    <url>%2F2019%2F07%2F14%2FPTA-1010-%E4%BA%8C%E5%88%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[这道题目是一个边界的二分问题，可以按照顺序进行求解，但是后面有问题会出错，然后更加坑爹的是，最前面的前置条件需要弄清楚 直接贴出代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cmath&gt;using namespace std;long long to_num(const string &amp;b,long long radix) &#123; long long res = 0; int lenb = b.size() - 1; for (int i = 0; i &lt; b.size();i++) &#123; if (b[i] &gt;= '0' &amp;&amp; b[i] &lt;='9') &#123; res += (b[i] - '0') * pow(radix,lenb--); &#125; else &#123; res += (b[i] - 'a' + 10) * pow(radix,lenb--); &#125; if (res &lt; 0) return -1; &#125; return res;&#125;int main()&#123; std::ios::sync_with_stdio(false); string a,b; int tag; long long radix; cin &gt;&gt; a &gt;&gt; b &gt;&gt; tag &gt;&gt; radix; if (a == b) &#123; cout &lt;&lt; radix &lt;&lt; endl; return 0; &#125; if (tag == 2) &#123; swap(a,b); &#125; long long tmp = 0; int len = a.size() - 1; for (int i = 0; i &lt; a.size(); i++) &#123; if (a[i] &gt;= '0' &amp;&amp; a[i] &lt;='9') &#123; tmp += (a[i] - '0') * pow(radix,len--); &#125; else &#123; tmp += (a[i] - 'a' + 10) * pow(radix,len--); &#125; &#125; int Max = -1; int mm; for (int i = 0; i &lt; b.size(); i++) &#123; if (b[i] &gt;= '0' &amp;&amp; b[i] &lt;='9') &#123; mm = b[i] - '0'; &#125; else &#123; mm = b[i] - 'a' + 10; &#125; Max = max(Max,mm); &#125; int lenb = b.size() - 1; bool flag = false; //就是这里关于边界的问题，真的要把我搞死了 // 这里的第一个样例就是 就应该是他的值小于其的边界，正好就是 Max 等于2的时候。 //将两个边界值给弄清楚。 long long low = Max + 1; long long high = max(tmp,low); long long mid = -1; while (low &lt;= high) &#123; mid = (low + high) &gt;&gt; 1; long long tp = to_num(b,mid); if (tp == -1 || tp &gt; tmp) &#123; high = mid - 1; &#125; else if (tp &lt; tmp) low = mid + 1; else if (tp == tmp) &#123; flag = true; break; &#125; &#125; /* 这里其实是一个顺序查找的过程，但是由于循环次数太多，所以必须进行二分优化。 for (ans = Max; ans &lt;= tmp; ans++) &#123; res = 0; for (int i = 0; i &lt; b.size();i++) &#123; if (b[i] &gt;= '0' &amp;&amp; b[i] &lt;='9') &#123; res += (b[i] - '0') * pow(ans,lenb--); &#125; else &#123; res += (b[i] - 'a' + 10) * pow(ans,lenb--); &#125; &#125; if (tmp == res) &#123; flag = true; break; &#125; &#125;*/ if (flag == true &amp;&amp; mid &gt;= 1) cout &lt;&lt; mid &lt;&lt; endl; else cout &lt;&lt; "Impossible" &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA 1007 最大序列和问题]]></title>
    <url>%2F2019%2F07%2F13%2FPTA-1007-%E6%9C%80%E5%A4%A7%E5%BA%8F%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这道题是一道简单的动态规划，可能是太久没有做这方面的题目了，总是对这一部分忘记，其实最终结果就是一个贪心解决问题。 贴出代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/* 其实这道题也算是一道特别简单的题目，还是动态规划里面最基础的问题，但是总是容易去弄混。 记得自己当时的问题就在于 这里每一次相加的和，如何保证后面加了负数之后，再次加上一个正数不被影响呢， 下面的注释里面有写， 因为题目中限制了，如果这道题有多个答案，比如说 前面与后面相加为零，但是后面的那个正数正好作为最后的正确答案的话 比如 1 2 -3 8 1 2 -3 正好相加为0 但是题目中要求的 序列 1 2 -3 8 作为最后的结果序列。 自己当时也在这一块上面纠结。*/#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; std::ios::sync_with_stdio(false); int m; cin &gt;&gt; m; int num[m + 5]; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; num[i]; &#125; int left = 0; int tmpleft = 0; int right = m - 1; int tmp = 0; int Max = -1; for (int i = 0; i &lt; m; i ++) &#123; tmp += num[i]; //In case that the maximum subsequence is not unique, //output the one with the smallest indices i and j (as shown by the sample case). if (tmp &lt; 0) &#123; tmp = 0; tmpleft = i + 1; &#125; else if (tmp &gt; Max) &#123; Max = tmp; right = i; left = tmpleft; &#125; &#125; //If all the K numbers are negative, then its maximum sum is defined to be 0, //and you are supposed to output the first and the last numbers of the whole sequence. if (Max &gt;= 0) cout &lt;&lt; Max &lt;&lt; " " &lt;&lt; num[left] &lt;&lt; " " &lt;&lt; num[right] &lt;&lt; endl; else cout &lt;&lt; 0 &lt;&lt; " " &lt;&lt; num[0] &lt;&lt; " " &lt;&lt; num[m - 1] &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA 1004 简单的dfs]]></title>
    <url>%2F2019%2F06%2F27%2FPTA-1004-%E7%AE%80%E5%8D%95%E7%9A%84dfs%2F</url>
    <content type="text"><![CDATA[这里直接贴出题目： 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;cmath&gt;using namespace std;int n,m;vector&lt;int&gt; kids[105];int maxlever = 0;int nums[105];void dfs(int root,int depth) &#123; if (kids[root].size() == 0) &#123; maxlever = max(depth,maxlever); nums[depth]++; return; &#125; for (int i = 0; i &lt; kids[root].size() ; i++) &#123; dfs(kids[root][i],depth + 1); &#125;&#125;int main()&#123; std::ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; int fa,num; int tmp; memset(nums,0,sizeof nums); for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; fa &gt;&gt; num; for (int i = 0 ; i &lt; num; i ++) &#123; cin &gt;&gt; tmp; kids[fa].push_back(tmp); &#125; &#125; dfs(1,0); cout &lt;&lt; nums[0] ; for (int i = 1; i &lt;= maxlever; i++ ) &#123; cout &lt;&lt; " " &lt;&lt; nums[i]; &#125; cout &lt;&lt; endl; return 0;&#125; 我可能是太久没有写代码了，上面这样一道水题，我先开始就被完完全全的弄糊涂了，这道题就是一个简单的dfs，首先先把数之间的对应关系一点一点的打通，然后再根据后面dfs的递归可以得出来，就是一个简单的根据根节点一点一点的往后面递归搜索，然后达到终点之后，记得把这一个层的叶子结点数加一，这里注意两点，可以发现 在cin的处理里面，可以直接将00，01，02，直接变成相应的0，1，2；]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA 1003 Dijkstra ---- 关于Dijkstra单源最短路的相应总结]]></title>
    <url>%2F2019%2F06%2F25%2FPTA-1003-Dijkstra-%E5%85%B3%E4%BA%8EDijkstra%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%9A%84%E7%9B%B8%E5%BA%94%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[首先 这里先贴出题目 解题代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 505;const int inf = 0x3f3f3f3f;int n,m,_beg,_end;int people[maxn];bool vis[maxn];int _map[maxn][maxn];int dis[maxn];int paths[maxn];int Maxvalue[maxn];void Dijkstra(int beg) &#123; memset(dis,inf,sizeof dis); memset(vis,false,sizeof vis); dis[beg] = 0; paths[beg] = 1; Maxvalue[beg] = people[beg]; for (int i = 0; i &lt; n; i++) &#123; int Min = 0x3f3f3f, index = -1; for (int j = 0; j &lt; n; j++) &#123; if (!vis[j] &amp;&amp; dis[j] &lt; Min) &#123; Min = dis[j]; index = j; &#125; &#125; if (index == -1) break; vis[index] = true; for (int j = 0; j &lt; n; j++) &#123; if (!vis[j] &amp;&amp; _map[index][j] != inf) &#123; if (dis[index] + _map[index][j] &lt; dis[j]) &#123; dis[j] = dis[index] + _map[index][j]; paths[j] = paths[index]; Maxvalue[j] = Maxvalue[index] + people[j]; &#125; else if (dis[index] + _map[index][j] == dis[j]) &#123; paths[j] += paths[index]; Maxvalue[j] = max(Maxvalue[j],Maxvalue[index] + people[j]); &#125; &#125; &#125; &#125;&#125;int main()&#123; std::ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; _beg &gt;&gt; _end; for (int i = 0 ; i &lt; n; i++) &#123; cin &gt;&gt; people[i]; &#125; int x,y,val; memset(_map,inf,sizeof _map); for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; val; _map[x][y] = val; _map[y][x] = val; &#125; Dijkstra(_beg); cout &lt;&lt; paths[_end] &lt;&lt; " " &lt;&lt; Maxvalue[_end] &lt;&lt; endl; return 0;&#125; 这里明显就是关于Dijkstra的裸题，变化的地方就是加了一两个内置数组，作为状态的变化，类似于动态规划，到后面就可以解题解出来了。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论总结]]></title>
    <url>%2F2019%2F05%2F06%2F%E6%95%B0%E8%AE%BA%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[数论总结来自西北工业大学的讲义以及题目的总结 素数运算实验范例这里将的就是与素数相关的筛法，这里介绍两种筛法。 素数的线性筛法埃式筛法12345678910111213141516//最普通的埃式筛法memset(check, 0, sizeof(check));int tot = 0;for (int i = 2; i &lt;= n; ++i)&#123; if (!check[i]) &#123; prime[tot++] = i; &#125; // 下面其实用乘法和用加法都是一样的，而这里就是乘法的原因就在于，减少了循环次数 // 唯一没有被优化的地方就在于 每一个数字被重复标记了很多次，而后面的欧拉筛就会限制标记次数为一次 for (int j = i * i; j &lt;= n; j *= i) &#123; check[j] = 1; &#125;&#125; 欧拉筛法 12345678910111213141516171819202122232425262728293031//进阶版的线性筛法//质数数组int prime[MAXN];//判断每一个数 数组int check[MAXL];int tot = 0;memset(check, 0, sizeof(check));for (int i = 2; i &lt; MAXL; ++i)&#123; if (!check[i]) &#123; prime[tot++] = i; &#125; for (int j = 0; j &lt; tot; ++j) &#123; //大致意思就在于 将每一个数的与质数数组里面的数进行相乘，最后得到的结果存在check中去 //需要注意的就是 一旦当前的数能被整除的时候 就立马退出，这样代表每一个数字都会被自己的最小质因数给整除出来。 if (i * prime[j] &gt; MAXL) &#123; break; &#125; check[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; break; &#125; &#125;&#125; 然后下面就由上面两种线性筛法引申出来下面两个结论 每一个大于4的偶数可以写成两个奇素数的和。(poj 2262) 每一个大于8的数字可以分为4个素数的和。(uva 10168) 大素数的实验范例一般这里还存在一些超过给出的素数表的范围，或者是打表到那个地方一定会反超之类的题目，这里都使用一种类似于区间筛法的办法去解决问题。 比如 uva 10871: 打出 2 到 根号n范围的表，然后超过这个范围的数，对于这个数里面的数全部去除以前面打表产生的素数表，看能不能除尽，来判断这个大整数是否是素数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122/* 这道题 其实利用了素数表之后，就是一个一次遍历的过程了 不过我没有想到的是， 这道题其实已经提前将每一个sum给记录下来了，就相当于一个打表的方式。 另外这道题第二个爆点就在于 当超出了表范围内的大数怎么办，这里就可以用分两种，第一种是在这种情况的直接看表， 另外一种就是用 这个数去mod 表内的每一个质数，这样可以加快时间。*/#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 10011;bool u[maxn];int su[maxn];int num = 0;void prepare()&#123; int i, j; memset(u, true, sizeof(u)); for (i = 2; i &lt; maxn; ++i) &#123; if (u[i]) &#123; su[++num] = i; &#125; for (j = 1; j &lt;= num; ++j) &#123; if (i * su[j] &gt; maxn) &#123; break; &#125; u[i * su[j]] = false; if (i % su[j] == 0) &#123; break; &#125; &#125; &#125;&#125;bool pri(int x)&#123; if (x &lt;= 10010) &#123; return u[x]; &#125; int i; for (i = 1; i &lt;= num; ++i) &#123; if (x % su[i] == 0) &#123; return false; break; &#125; &#125; return true;&#125;int main()&#123; prepare(); int t; scanf("%d", &amp;t); while (t--) &#123; int n; scanf("%d", &amp;n); int i, j; int s[n + 1]; s[0] = 0; for (i = 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;s[i]); s[i] += s[i - 1]; &#125; bool ok = false; for (i = 2; i &lt;= n; ++i) &#123; for (j = 1; j + i - 1 &lt;= n; ++j) &#123; int k = s[i + j - 1] - s[j - 1]; if (pri(k)) &#123; ok = true; printf("Shortest primed subsequence is length %d:", i); for (k = 1; k &lt;= i; ++k) &#123; printf(" %d", s[j + k - 1] - s[j + k - 2]); &#125; printf("\n"); break; &#125; &#125; if (ok) &#123; break; &#125; &#125; if (!ok) &#123; printf("This sequence is anti-primed.\n"); &#125; &#125; return 0;&#125; 求解不定方程和同余的实验范例这一个章节的东西基本上可以说是奠定了数论的基础，所以这部分的东西请务必掌握。 首先这里先贴出 gcd 和 exgcd的代码 欧几里得算法1234int gcd(int a,int b) &#123; if (b == 0) retuan a; return gcd(b,a % b);&#125; exgcd 扩展欧几里得算法12345678910111213int exgcd (int a,int b, int &amp;x,int &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; int t = exgcd(b,a % b,x,y); int d = x; x = y; y = d - (a / b) * y; return t;&#125; 欧几里得算法是用来求解最大公约数的由欧几里得公式推出 如果 a与b 互素，那么b * t + a 与 b 也一定互素。 这里贴出一道题 就是对于上面gcd公式的周期性的利用 happy poj 2773 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* 这道题目就是在于对于gcd的周期性的使用。 这道题就利用了与m互素的数对m去膜具有周期性*/#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;int s[1000005];int gcd(int a, int b)&#123; if (b == 0) &#123; return a; &#125; else &#123; return gcd(b, a % b); &#125;&#125;int main()&#123; int m, k; while (scanf("%d%d", &amp;m, &amp;k) != EOF) &#123; int i; int num = 0; for (i = 1; i &lt;= m; i++) &#123; if (gcd(m, i) == 1) &#123; s[num++] = i; &#125; &#125; //这里其实进行了两种情况：一种刚好除尽的情况， //和另外一种没有刚好除尽的情况。 if (k % num == 0) &#123; //这里减一的目的是刚刚好除尽，减去一个后面好加上一个ai; printf("%d\n", (k / num - 1) * m + s[num - 1]); &#125; else &#123; //后面的则就体现在了余数这个地方。，之所以减去1是因为num不可能算上的最后一个 printf("%d\n", k / num * m + s[k % num - 1]); &#125; &#125; return 0;&#125; 扩展欧几里得算法是用来求最大公约数和不定方程的通解 这里同样也贴出一道模板样题作为示范 The Balance poj 2142 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/* 这道题就在于其很厉害的是 解释了ecgcd的真正的用途。 这道题说难也不是很难，只是教会了一些数论题目全部的代码该如何去写。 典型的求 不定方程的做法 ax + by = d; 求解 一个 x，y 的满足条件的特解。 这里写一下求解步骤 ： 第一步 首先先得出这个方程，然后对方程两边同时除以gcd(a,b); 在步入第二步的过程中有一个判断 就是看d 对于 gcd(a,b)的比较情况，决定这个不定方程是否有解； 第二步 就是直接用未初始化的 x,y 带入exgcd求解 可以得到一个 x,y的其中一个特解 第三步 将得到的特解乘以相应的扩大的d_倍，最后按照题目规定的条件进行整改最终得出结果 其中需要注意的是 上面得到的特解，只有在ax + by 正好等于gcd(a,b)的时候 才会同时满足。*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;int gcd(int a,int b) &#123; if (b == 0) return a; return gcd(b,a % b);&#125;int exgcd(int a,int b,int &amp;x,int &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; int t = exgcd(b,a % b,x,y); int _x = x; int _y = y; x = _y; y = _x - (a/b) * _y; return t;&#125;int a,b,d;int a_,b_,d_;int x,y;//通解int q;int x1,x2,y1,y2;int main()&#123; while (scanf("%d %d %d",&amp;a,&amp;b,&amp;d) &amp;&amp; a &amp;&amp; b &amp;&amp; d) &#123; q = gcd(a,b); a_ = a / q; b_ = b / q; d_ = d / q; int k = exgcd(a_,b_,x,y); x1 = x * d_; x1 = (x1 % b_ + b_) % b_; y1 = (d - x1 * a) / b; if (y1 &lt; 0) y1 = -y1; y2 = y * d_; y2 = (y2 % a_ + a_) % a_; x2 = (d - y2 * b) / a; if (x2 &lt; 0) x2 = -x2; if (x1 + y1 &lt; x2 + y2) printf("%d %d\n",x1,y1); else printf("%d %d\n",x2,y2); &#125; return 0;&#125; 这里还是讲求解不定方程的步骤再详细的过一遍 得到不定方程ax + by = m，先判断 m 是否是gcd(a,b)的倍数，如果是说明方程有解，如果不是方程则没有解 有解之后，方程两边同时除以gcd(a,b)，然后将重新得到的a,b值带入到扩展欧几里得的方程式中得到两个通解x,y， 需要将得到的x 或者 y 值 扩大 经除后的m值，因为扩展欧几里得求的不定方程默认就是等于1的。对于这道题而言，想要求最小的正整数的通解，于是就 (x % b + b) % b, 这里就是防止C++取余带来的负数影响。 下面还有一道题 也是求出不定方程的解，但是有一点点不同。 One Person Game zoj3593 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/* 这里的与上面一道题不一样的地方就在于 后面限制条件不太相同。 前面一道题上面求出的一个特解，但是 取mod之后得到的结果， 所以用改变后的变量值，来求另外一个。 而这道题不一样的是是通过求解答案 然后 根据特解来算结构来算。*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;long long _beg,_end,a,b;const long long inf = 0x3f3f3f3f;long exgcd(long long a,long long b,long long &amp;x,long long &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; long long t = exgcd(b,a % b,x,y); int x_ = x; int y_ = y; x = y_; y = x_ - (a / b) * y_; return t;&#125;int main()&#123; int T; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; _beg &gt;&gt; _end &gt;&gt; a &gt;&gt; b; long long res = _end - _beg; long long d,x,y; d = exgcd(a,b,x,y); if (res % d != 0) &#123; cout &lt;&lt; -1 &lt;&lt; endl; continue; &#125; x *= res / d; y *= res / d; a = a / d; b = b / d; long long ans = inf * inf,tmp; long long mid = (y - x) / (a + b); for (int i = mid - 1; i &lt;= mid + 1; i++) &#123; long long x1 = x + i * b; long long y1 = y - i * a; if (x1 * y1 &gt;= 0) tmp = max(abs(x1),abs(y1)); else tmp = abs(x1 - y1); ans = min(ans,tmp); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 这道题不一样的是 他不是像前面求出通解之后求一个最小或者最大，我的理解就是 因为 其算出来的通解为 x = xo + k b,y = yo - k a ,其实将这里两个特解 直接当成0来算，因为题目要求最小，并且 a , b 的差距还不能太大，就直接求出 k的范围 然后 对其进行加1 减1的操作得出最后结果。 计算同余方程与同余方程组关于同余理论，自己的其他相关博客已经存在讲解这里就不在过多介绍了， 这里有一道经典的题，以后有时间插一下代码。 这里再次总结一下一元线性同余方程的解法。 首先首先 线性同余方程可以表示为 ax =- b(mod m) 就这样可以表示为一个不定方程式 ax = b + ym; 先求出 b % gcd(a,m) 判断其是否为0，如果不为0，那么以上的同余方程式或者不定方程式无解。如果 得到的结果为j，那么说明该方程有 j个 mod m 不同余的解 d = gcd(a,m); 当用欧几里得算法求出以上的解之后 得到其实是 ax=- d(mod m) 这一同余方程中 x 的解。所以说人话就是 当求出了那个特解之后 再去乘以之前 的 B 值 最后mod m得到最终同余方程的解。2 关于计算同余方程，其实与求解扩展欧几里得通解的效果是一样的， C_Loop poj2115 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/* 这道题其实再一次涉及到 exgcd的另外一个用法 这个用法仍然是从其中求解不定方程的作用中延伸过来的。 这道题就是一个简单的一维的线性求余过程， 对于这道题就显示一下 线性同余的过程 首先 线性同余方程可以表示为 ax =- b(mod m) 就这样可以表示为一个不定方程式 ax = b + ym; 所以第一步 先求出 b % gcd(a,m) 判断其是否为0，如果不为0，那么以上的同余方程式或者不定方程式无解。 如果 得到的结果为j，那么说明该方程有 j个 mod m 不同余的解 d = gcd(a,m); 当用欧几里得算法求出以上的解之后 得到其实是 ax` =- d(mod m) 这一同余方程中 x`的解。 所以根据判断d是否等于0 可以求出第一个解释x0 = x` * (b / d) mod m; 而其余d - 1的解就是 xi = (x0 + i *(m / d)) mod m; 所以说人话就是 当求出了那个特解之后 再去乘以之前 的 B 值 最后mod m得到最终同余方程的解。*/#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;map&gt;using namespace std;long long exgcd(long long a,long long b,long long &amp;x,long long &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; long long t = exgcd(b,a % b,x,y); long long d = x; x = y; y = d - (a / b) * y; return t;&#125;long long gcd (long long a,long long b) &#123; if (b == 0) return a; return gcd(b,a % b);&#125;long long a,b,c,k;long long x,y;int main()&#123; while (scanf("%lld %lld %lld %lld",&amp;a,&amp;b,&amp;c,&amp;k)) &#123; if (a == 0 &amp;&amp; b == 0 &amp; c == 0 &amp;&amp; k ==0) break; long long gap = b - a; k = ((long long)1 &lt;&lt; k); gap = (gap % k + k) % k; if (gap == 0) &#123; printf("0\n"); continue; &#125; long long q = exgcd(c,k,x,y); if (gap % q) &#123; printf("FOREVER\n"); continue; &#125; //前面属于判断过程，后面就是正常的ecgcd的 不定方程求解了 //所以需要做的事情就是 方程两边同时除以gcd c = c / q; gap = gap / q; k = k / q; long long xx = exgcd(c,k,x,y); x *= gap; x = (x % k + k) % k; printf("%lld\n",x); &#125; return 0;&#125; 接下来就是一道求解逆元的问题了。 定理 同余方程 ax =- 1(mod m)有解 当且仅仅当 gcd(a,m) = 时候成立，且其的所有解都同余 Modular Inverse zoj 3609 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;int exgcd(int a,int b,int &amp;x,int &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; int t = exgcd(b,a % b,x,y); int d = x; x = y; y = d - (a / b) * y; return t; &#125;int a,b,q,x,y;int main()&#123; int T; while (cin &gt;&gt; T) &#123; while (T--) &#123; cin &gt;&gt; a &gt;&gt; b; q = exgcd(a,b,x,y); //就是这里多了判断其是否为0的条件。 if (q != 1) &#123; printf("Not Exist\n"); continue; &#125; //这里就是处理0的情况 x = (x % b + b) % b; if (x == 0) cout &lt;&lt; b &lt;&lt; endl; else cout &lt;&lt; x &lt;&lt; endl; &#125; &#125; return 0;&#125; 同余方程组 （中国剩余定理）这里贴出 求解同余方程组的阶梯步骤 将题目中给出的所有同余方程组列出来，形如 a =- ai (mod ni),并且将每一个ni相乘起来 得到一个 n 。（或者是求其全部的最小公倍数） 然后通过公式 计算出 mi = n / ni，然后再通过mi 计算出mi模 n 的逆 就是通过 扩展欧几里得公式去求解每一个同余方程 mi * x =- 1 (mod ni); 然后再计算每一个 ci = mi * mi的逆。 最后通过公式 a = ((全部相加)ai * ci ) mod n… Biorhythms poj 1006 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/* 这道题目其实是严格按照中国剩余定理来计算的，最后求解的结果实际上是计算出来的三个同余的结果，同时满足多个同余方程的一个共同的结果 不过下面的步骤需要弄清楚，第一步是先求出每一个同余的 m值，然后再通过求m逆，然后将其相乘得到ci 最后乘以每一项的ci 最后求解的结果去mod上一个最终的mod n就行了*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;cmath&gt;using namespace std;int p,e,i,d;int exgcd (int a,int b, int &amp;x,int &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; int t = exgcd(b,a % b,x,y); int d = x; x = y; y = d - (a / b) * y; return t;&#125;int m1,m2,m3;int n1,n2,n3;int n = 21252;int x,x2,x3;int y,y2,y3;//处理C++ 中 % 出负数的情况int _mod(int x,int b) &#123; return (x % b + b) % b;&#125;int main()&#123; int Case = 1; while (scanf("%d %d %d %d",&amp;p,&amp;e,&amp;i,&amp;d)) &#123; if (p == -1 &amp;&amp; e == -1 &amp;&amp; i == -1 &amp;&amp; d== -1) break; m1 = n / 23; m2 = n / 28; m3 = n / 33; int q1 = exgcd(m1,23,x,y); int q2 = exgcd(m2,28,x2,y2); int q3 = exgcd(m3,33,x3,y3); x = _mod(x,23) * m1; x2 = _mod(x2,28) * m2; x3 = _mod(x3,33) * m3; int res = x * p + x2 * e + x3 * i - d; res = res % n; if (res &lt;= 0) res += n; cout &lt;&lt; "Case "&lt;&lt; Case++ &lt;&lt;": the next triple peak occurs in "&lt;&lt;res &lt;&lt;" days." &lt;&lt; endl; &#125; return 0;&#125; 特殊的同余式威尔逊定理如果 p 是素数，(p - 1)! =- -1 (mod p)成立 意思就是 如果 p是素数的情况，(p - 1)! + 1 mod p 正好可以等于0. YAPTCHA uva 4382 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;sstream&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define MOD 2018#define LL long long#define ULL unsigned long long#define Pair pair&lt;int, int&gt;#define mem(a, b) memset(a, b, sizeof(a))#define _ ios_base::sync_with_stdio(0), cin.tie(0)using namespace std;const int maxn = 3e6 + 10, INF = 0x7fffffff;int vis[maxn], ans[maxn];//这里是一种简单的筛法,相当于一个简单的埃式筛法。void init()&#123; mem(vis, 0); for (int i = 2; i &lt;= sqrt(maxn + 0.5); i++) if (!vis[i]) for (int j = i * i; j &lt; maxn; j += i) vis[j] = 1;&#125;void f()&#123; mem(ans, 0); for (int i = 1; i &lt;= 1e6; i++) &#123; int temp = 3 * i + 7; ans[i] = ans[i - 1] + (1 - vis[temp]); &#125;&#125;int main()&#123; init(); f(); int T, n; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; cout &lt;&lt; ans[n] &lt;&lt; endl; &#125; return 0;&#125; 费马小定理 如果p是素数，a是正整数，gcd(a,p) = 1,则 a的p - 1 次幂 同余 1 mod p. what day is that day zoj 37851234567891011121314151617181920212223242526272829303132/* 这道题讲述的就是费马小定理，这道题目关键点就是在，前面对于周期mod的求取，应用了费马小定理，最后得出的结论。*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int num[1000];char day[10][10] = &#123;"Saturday", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday"&#125;;int pow(int x)&#123; int ans = 1; for (int i = 1; i &lt;= x; i++) ans = (ans * x) % 7; return ans;&#125;int main()&#123; for (int i = 1; i &lt;= 300; i++) num[i] = (pow(i) + num[i - 1]) % 7; int T; scanf("%d", &amp;T); while (T--) &#123; int n; scanf("%d", &amp;n); printf("%s\n", day[num[n % 294]]); &#125; return 0;&#125; 伪素数其产生的原因就在于费马小定理的逆不成立，如果a是一个正整数，如果n是一个正合数，并且a的n次幂 同余 a (mod n) 则称n为以a为基的伪素数。 Pseudoprime numbers poj 3641 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* 这道题不断的出现runtime error 用java 的时候 这个时候我就不太清楚是为什么了。 后面还需要弄清楚一件事情就是 究竟什么时候才能够用欧拉赛的时间去打表，这里就不太清楚 有的时候用欧拉筛打表反而出现错误的答案。 */#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;cmath&gt;using namespace std;long long _mod(long long x,long long y,long long mod) &#123; long long ans = 1; while (y) &#123; if (y &amp; 1) ans = ans * x % mod; y &gt;&gt;= 1; x = x * x % mod; &#125; return ans;&#125;bool is_prime(long long x) &#123; for (int i = 2; i &lt;= sqrt(x) + 0.5; i++) &#123; if (x % i == 0) return false; &#125; return true;&#125;long long q,a;int main()&#123; while (scanf("%lld %lld",&amp;q,&amp;a) &amp;&amp; q &amp;&amp; a) &#123; if (is_prime(q)) &#123; printf("no\n"); continue; &#125; long long ans = _mod(a,q,q); if (ans == a) printf("yes\n"); else printf("no\n"); &#125; return 0;&#125; 接下来还有一道题，可以根据java的一个函数直接得出结果，但是同样也可以通过C++ 的大素数的检测方法从而得出结果。 123456789101112131415161718192021import java.util.Scanner;import java.math.BigInteger;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n; BigInteger a; while (in.hasNext()) &#123; n = in.nextInt(); int cnt = 0; for (int i = 0; i &lt; n; i++) &#123; a = in.nextBigInteger(); if (a.isProbablePrime(3)) cnt++; &#125; System.out.println(cnt); &#125; in.close(); return; &#125;&#125; C++ 前面有讲的超出区间的测定方法。 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;math.h&gt;int is_prime(int x)&#123; int tp = (int)sqrt(x * 1.0); for (int i = 2; i &lt;= tp; ++i) &#123; if (x % i == 0) &#123; return 0; &#125; &#125; return 1;&#125;int main()&#123; int n; while (~scanf("%d", &amp;n)) &#123; int ans = 0, tp; for (int i = 0; i &lt; n; ++i) &#123; scanf("%d", &amp;tp); if (tp == 2) &#123; ++ans; &#125; else if (tp &amp; 1) &#123; ans += is_prime(tp); &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125; 欧拉定理欧拉函数表示的是到n之前与n互素的且不超过n的正整数的个数。 如果 n和a是互素的正整数，则 a的 欧拉函数n 同余1 mod n]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包初级及相应题目总结]]></title>
    <url>%2F2019%2F05%2F01%2F%E8%83%8C%E5%8C%85%E5%88%9D%E7%BA%A7%E5%8F%8A%E7%9B%B8%E5%BA%94%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[背包初级讲解这里对于动态规划里面一个简单基础的问题进行总结，包括 01背包，完全背包，多重背包，混合背包… 01背包题目 有N件物品和一个容量为V 的背包。放入第i件物品耗费的费用是Ci1，得到 的价值是Wi 。求解将哪些物品装入背包可使价值总和最大。 基本思路 用子问题定义状态:即F [i, v]表示前i件物品恰放入一个容量为v的背包可 以获得的最大价值。则其状态转移方程便是:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657**对于二维dp数组的伪代码如下**F[0,0..V] ←0 fori ←1toNforv ←Ci toVF[i,v] ← max&#123;F[i − 1,v],F[i − 1,v − Ci] + Wi&#125;**优化空间的复杂度**使用滚动数组，以及进行压缩空间。伪代码如下：F [0..V ] ←0 fori ←1toNforv ←V toCiF[v] ←max&#123;F[v],F[v−Ci]+Wi&#125;**初始化的细节**&gt;我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。 有的题目要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背 包装满。一种区别这两种问法的实现方法是在初始化的时候有所不同。&gt;如果是第一种问法，要求恰好装满背包，那么在初始化时除了F [0]为0，其 它F [1..V ]均设为−∞，这样就可以保证最终得到的F [V ]是一种恰好装满背包的 最优解。&gt;如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该 将F [0..V ]全部设为0。#### 题目总结 ##### 1.Charm Bracelet (poj3624)```C++/* 第一道题属于一个简单的01背包模板题目，这里不多说 可以直接套模板。*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int n,m;int dp[13000];int w[3500],v[3500];int main()&#123; while (cin &gt;&gt; n &gt;&gt; m) &#123; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; w[i] &gt;&gt; v[i]; &#125; memset(dp,0,sizeof dp); for (int i = 1; i &lt;= n; i++) &#123; for (int j = m; j &gt;= w[i]; j--) &#123; dp[j] = max(dp[j],dp[j - w[i]] + v[i]); &#125; &#125; cout &lt;&lt; dp[m] &lt;&lt; endl; &#125; return 0;&#125; 2.Bone_Collector(hdu 2602)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* 一段简单的模板题目，不过需要弄清楚的 一维数组与二维数组在这里相应的区别，往往这里会产生很大的区别， 比如第二个循环的开始条件，因为这里是由子问题的堆积，然后一点一点向上升最终得到的问题，所以这李最好控制背包的放与不放的问题、 就比如我在这道题目的第二个问题中出现的错误，就是将j=0这个条件直接掠过去了，其实这里是不对的。*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1010;long long weight[maxn],value[maxn],dp[maxn][maxn];long v,w;int main()&#123; int T; cin &gt;&gt; T; while(T--) &#123; cin &gt;&gt; w &gt;&gt; v; value[0] = 0; weight[0] = 0; for (int i = 1; i &lt;= w; i++) &#123; cin &gt;&gt; value[i]; &#125; for (int i = 1; i &lt;= w; i++) &#123; cin &gt;&gt; weight[i]; &#125; memset(dp, 0, sizeof dp); for (int i = 1; i &lt;= w; i++) &#123; for (int j = 0; j &lt;= v; j++) &#123; if (j &gt;= weight[i]) &#123; dp[i][j] = max(dp[i - 1][j],dp[i - 1][j - weight[i]] + value[i]); &#125; else dp[i][j] = dp[i - 1][j]; &#125; &#125; cout &lt;&lt; dp[w][v] &lt;&lt; endl; &#125; return 0;&#125; 3.饭卡123456789101112131415161718192021222324252627282930313233343536373839404142/* 这道题神奇的地方就在于 其的重量限制于价值重合在了一起，所以对于这道题而言就是只能重合的去写状态转移方程了 另外需要注意的是最后输出结果的办法，是将最后一个物品交给剩下的最大的钱去购买，这样能彻底用光最后的钱财*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int n,m;const int maxn = 1010;int num[maxn],dp[maxn][maxn];int main()&#123; while (cin &gt;&gt; n &amp;&amp; n) &#123; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; num[i]; &#125; cin &gt;&gt; m; sort(num + 1, num + 1 + n); if (m &lt; 5) &#123; cout &lt;&lt; m &lt;&lt; endl; continue; &#125; memset(dp,0,sizeof dp); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= m - 5; j++) &#123; if (j &gt;= num[i]) &#123; dp[i][j] = max(dp[i - 1][j],dp[i - 1][j - num[i]] + num[i]); &#125; else dp[i][j] = dp[i - 1][j]; &#125; &#125; cout &lt;&lt; m - dp[n - 1][m - 5] - num[n] &lt;&lt; endl; &#125; return 0;&#125; 完全背包完全背包这里与01背包相类似，但是区别就在于每一个种类的背包可以取无数个 1234567一般都是将其转化为01背包的方法求解，用一个滚动数组来进行表示，不过需要注意的是，其与01背包的第二个循环不同地方完全背包的伪代码：```pydef CompletePack(F, C, W ) forv ←CtoVF[v] ←max&#123;F[v],f[v−C]+W&#125; 题目下面贴出关于完全背包的题目 1.减肥1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* 这道题使用二维数组就一直就会超时 具体的我也不太清楚，但是 没有办法 只能使用一维滚动数组，进行了相应的空间优化 不过这里需要补充几个知识点 第一 关于二维数组的完全背包状态转移方程 dp[i][j] = max (dp[i - 1][j],dp[i - 1][j - k * c[i]] + k * v[i]); 由上面这个式子就可以得出，状态转移方程 于是 一种空间优化的写法 是直接写成 max(dp[i - 1][j]，dp[i][j - w[i]] + v[i]) 第二 如果换成滚动数组的话 记住 第二个循环的两个顺序，如果是倒叙的话 则就是要保证每一个物品只会取一次，但是如果是正序的话，那么就不需要保证上面所说的顺序了。 而这里官方的解释 就在这里 ： 让 v 递减是为了保证第i次循环中的状态F[i;v]是由状态F[i-1;v-Ci]递推而来。 换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第 i 件物品”这件策 略时，依据的是一个绝无已经选入第 i 件物品的子结果F[i-1;v-Ci]。而现在完全背 包的特点恰是每种物品可选无限件，所以在考虑“加选一件第 i 种物品”这种策略时， 却正需要一个可能已选入第 i 种物品的子结果F[i;v-Ci]，所以就可以并且必须采用v 递增的顺序循环。这就是这个简单的程序为何成立的道理。*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include&lt;cstdio&gt;using namespace std;int n, a, b, m;const int maxn = 110;int happiness[maxn], kaluli[maxn];int dp[110000];int main()&#123; while (~scanf("%d",&amp;n)) &#123; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d %d",&amp;happiness[i],&amp;kaluli[i]); &#125; scanf("%d",&amp;m); memset(dp,0,sizeof dp); for (int i = 1; i &lt;= n; i++) &#123; for (int j = kaluli[i]; j &lt;= m; j++) &#123; dp[j] = max(dp[j],dp[j - kaluli[i]] + happiness[i]); &#125; &#125; printf("%d\n",dp[m]); &#125; return 0;&#125; 2.Dollar Dayz12345678910111213141516171819202122232425import java.util.Scanner;import java.math.BigInteger;public class Main &#123; public static void main(String[] args) &#123; int n,k; Scanner in = new Scanner(System.in); while (in.hasNext()) &#123; BigInteger[] dp = new BigInteger[1005]; n = in.nextInt(); k = in.nextInt(); dp[0] = new BigInteger("1"); for (int i = 1; i &lt;= n; i++) &#123; dp[i] = new BigInteger("0"); &#125; for (int i = 1; i &lt;= k; i++) &#123; for (int j = i; j &lt;= n; j++) &#123; dp[j] = dp[j].add(dp[j - i]); &#125; &#125; System.out.println(dp[n]); &#125; &#125;&#125; 3.Piggy-Bank1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* 这道题是一个完全背包的裸题，对于这道题而言更加神奇的地方就在于其实求最小值而不是求最大值 所以在最先开始初始化的时候不应该去初始化为0，而应该初始化为无穷大 而千万不要忘记了再初始化的时候一定要对第一个状态进行一个单独赋值是等于0，还是等于无穷大，这个等到时候再看。*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt; using namespace std;int _beg,_end;const int maxn = 505;int v[maxn],w[maxn];int dp[10010];int main()&#123; int T; cin &gt;&gt; T; while (T--) &#123; scanf("%d %d",&amp;_beg,&amp;_end); int bottle = _end - _beg; int n; scanf("%d",&amp;n); for (int i = 1; i &lt;= n; i++)&#123; scanf("%d %d",&amp;v[i],&amp;w[i]); &#125; memset(dp,0x3f3f3f3f,sizeof dp); dp[0] = 0; for (int i = 1; i &lt;= n;i ++) &#123; for (int j = w[i]; j &lt;= bottle; j++) &#123; dp[j] = min(dp[j],dp[j - w[i]] + v[i]); &#125; &#125; if (dp[bottle] != 0x3f3f3f3f) cout &lt;&lt; "The minimum amount of money in the piggy-bank is " &lt;&lt; dp[bottle] &lt;&lt; "." &lt;&lt; endl; else cout &lt;&lt; "This is impossible." &lt;&lt; endl; &#125; return 0;&#125; 多重背包多重背包与完全背包最大的不同就是在于，完全背包其的每一个背包取值可以取无数个（相对于背包容量而言）而多重背包的意思就是相对于背包容量而言 取不满，在取不满的同时还能够再加入其的背包，故，这里就为多重背包 模板代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;const int maxn = 100005;//三个属性值 一个重量 数量 以及价值int weight[maxn],number[maxn],value[maxn];//状态存储int dp[maxn &lt;&lt; 4];//背包的容量int bag; int n;//01背包 void zeroonepack(int weight,int value) &#123; for (int j = bag; j &gt;= weight; j--) &#123; dp[j] = max(dp[j],dp[j - weight] + value); &#125;&#125;//完全背包void completepack(int weight,int value) &#123; for (int j = weight; j &lt;= bag; j++) &#123; dp[j] = max(dp[j],dp[j - weight] + value); &#125;&#125;//多重背包void multilpack(int weight,int number,int value) &#123; //第一种情况就是 如果这件物品所有的重量是小于背包的重量的话 //那么对于背包而言 这个物品是可以取无限大。 if (bag &lt;= number * weight) &#123; completepack(weight,value); return; &#125; //而超过的这个范围的就只能使用01背包 然后使用二进制的方法 //将每一类型的背包进行一个分组 //后面再依次分别使用多重背包。 int k = 1; while (k &lt;= number) &#123; zeroonepack(k * weight,k * value); number = number - k; k = k * 2; &#125; zeroonepack(number * weight, number * value);&#125;int main()&#123; cin &gt;&gt; bag &gt;&gt; n; for (int i = 1; i &lt;= n ;i ++) &#123; cin &gt;&gt; weight[i] &gt;&gt; number[i] &gt;&gt; value[i]; &#125; for (int i = 1; i &lt;= n ;i ++) &#123; multilpack(weight[i],number[i],value[i]); &#125; cout &lt;&lt; dp[bag] &lt;&lt; endl; return 0;&#125; 相应题目总结1. Space Elevator1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* 一道多重背包的裸题目，这道题虽然并没有去套用多重背包的裸模板，但是这道题神奇的地方就在于其对于 背包的数量进行了再一次的循环，然后再来看看有没有符合的特点。 然后其的状态转移方程也是特别的有意思： dp[k] |= dp[k - node[i].h] 不过这个 |= 到后面去官网查询一下最后的结果的意思.*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Node &#123; int h,a,c; bool operator &lt; (const Node &amp;n) const &#123; return a &lt; n.a; &#125;&#125;node[450];int dp[40050];int main()&#123; int K; while (cin &gt;&gt; K) &#123; for (int i = 1; i &lt;= K; i++) &#123; cin &gt;&gt; node[i].h &gt;&gt; node[i].a &gt;&gt; node[i].c; &#125; memset(dp,0,sizeof dp); dp[0] = 1; sort(node + 1, node + 1 + K); for (int i = 1; i &lt;= K ;i ++) &#123; for (int j = 1; j &lt;= node[i].c; j++) &#123; for (int k = node[i].a; k &gt;= node[i].h; k-- )&#123; dp[k] |= dp[k - node[i].h]; &#125; &#125; &#125; int cnt = 0; for (int i = node[K].a; i &gt;= 0; i--) &#123; if (dp[i]) &#123; cnt = i; break; &#125; &#125; cout &lt;&lt; cnt &lt;&lt; endl; &#125; return 0;&#125; 2. Coins123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/* 这道题神奇的地方就是将多重背包的裸题进行了改变， 主要就是每一次增加的价值会发生改变，这才是最关键的地方。 这里的价值就不再是个数，而是进行一个打表，通过这个打表来判断这个重量是否能够达到。*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int n;int bag;bool dp[100040];int value[105],number[105];int cnt = 0;void zeroonepack(int weight, int value)&#123; for (int j = bag; j &gt;= weight; j--) &#123; if (!dp[j] &amp;&amp; dp[j - weight])&#123; dp[j] = true; cnt ++; &#125; &#125;&#125;//完全背包void completepack(int weight, int value)&#123; for (int j = weight; j &lt;= bag; j++) &#123; if (!dp[j] &amp;&amp; dp[j - weight]) &#123; dp[j] = true; cnt ++; &#125; &#125;&#125;//多重背包void multilpack(int weight, int number, int value)&#123; //第一种情况就是 如果这件物品所有的重量是小于背包的重量的话 //那么对于背包而言 这个物品是可以取无限大。 if (bag &lt;= number * weight) &#123; completepack(weight, value); return; &#125; //而超过的这个范围的就只能使用01背包 然后使用二进制的方法 //将每一类型的背包进行一个分组 //后面再依次分别使用多重背包。 int k = 1; while (k &lt; number) &#123; zeroonepack(k * weight, k * value); number = number - k; k = k * 2; &#125; zeroonepack(number * weight, number * value);&#125;int main()&#123; while (cin &gt;&gt; n &gt;&gt; bag &amp;&amp; n &amp;&amp; bag) &#123; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; value[i]; &#125; for (int i = 1; i &lt;= n;i ++) &#123; cin &gt;&gt; number[i]; &#125; cnt = 0; memset(dp,0,sizeof dp); dp[0] = 1; for (int i = 1; i &lt;= n ;i ++) &#123; multilpack(value[i],number[i],value[i]); &#125; cout &lt;&lt; cnt &lt;&lt; endl; &#125; return 0;&#125; 混合背包将01背包 完全背包 多重背包的三种背包 进行一个混合最简单的解决方法就是将其分开进行来算 举个例子 就是 一道题可能有多个背包，通过这多个背包来进行判断题目中所要求解的值。 题目1.Fewest coins1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/* 这道题目神奇的地方 是两个背包的问题 的总和，其实也算作是一个简单的题目，但是 这道题唯一复杂的地方就在于对于背包问题的理解 意思就是如何将一个看上去不是背包的问题转换成一个背包问题 首先的思路就是来判断是一个什么类型的背包 映射到这道题上面可以发现 前面付钱的过程是一个多重背包 后面付钱的过程是一个完全背包 不过深入理解了塞入 状态方程 第一次在价值那个地方出现了错误。 最终的价值不应该是相比总是的钱数，而应该是最小能够达到的背包数。*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;const int maxn = 30005;int dp[maxn],back[maxn];int value[105],number[105];int bag;int n,k;void zeroonepack(int weight,int value)&#123; for (int j = bag ; j &gt;= weight; j--) &#123; dp[j] = min(dp[j],dp[j - weight] + value); &#125;&#125;void completepack(int weight,int value) &#123; for (int j = weight; j &lt;= bag; j++) &#123; dp[j] = min(dp[j],dp[j - weight] + value); &#125;&#125;void mutipack(int weight,int value,int number) &#123; if (number * weight &gt;= bag) &#123; completepack(weight,value); return; &#125; int k = 1; while (k &lt; number) &#123; zeroonepack(k * weight,k * value); number = number - k; k *= 2; &#125; zeroonepack(number * weight , number * value);&#125;int main()&#123; while (cin &gt;&gt; n &gt;&gt; k) &#123; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; value[i] ; &#125; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; number[i]; &#125; memset(dp,0x3f3f3f3f,sizeof dp); memset(back,0x3f3f3f3f,sizeof back); dp[0] = 0; back[0] = 0; bag = k + 20000; for (int i = 1; i &lt;= n; i++) &#123; for (int j = value[i]; j &lt;= bag; j++) &#123; back[j] = min(back[j],back[j - value[i]] + 1); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; mutipack(value[i],1,number[i]); &#125; int ans = 0x3f3f3f3f; for (int i = k; i &lt;= bag; i++) &#123; ans = min(ans,back[i - k] + dp[i]); &#125; if (ans == 0x3f3f3f3f) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
        <tag>背包九讲</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[effective java item 6]]></title>
    <url>%2F2019%2F03%2F28%2Feffective-java-item-6%2F</url>
    <content type="text"><![CDATA[Item 6: Avoid creating unnecessary objects It is often appropriate to reuse a single object instead of creating a new function- ally equivalent object each time it is needed. Reuse can be both faster and more stylish. An object can always be reused if it is immutable 去反复的使用一个单一的对象，而不是再次创建一个新对象再需要的时候这样的做法是非常合适的。重复使用可以同时很快有符合现代规则。然后一个对象可以被总是反复使用如果其是不变的话。 下面有一个基本简单的例子 12String s = new String("bikini"); // DON'T DO THIS!String s = "bikini"; 前者是不可以采取的，因为其新建了两个对象，并且第二个新建的对象直接赋值给第一个新建的对象，而后者可取的地方就在于其直接赋值给了第一个对象，不存在创建一个新的对象。 You can often avoid creating unnecessary objects by using static factory meth- ods (Item 1) in preference to constructors on immutable classes that provide both. 你可以经常通过用静态的工厂方法禁止创建一个不必要的对象而不是使用不会改变的类或者是一个构造器。 For example, the factory method Boolean.valueOf(String) is preferable to the constructor Boolean(String), which was deprecated in Java 9. The constructor must create a new object each time it’s called, while the factory method is never required to do so and won’t in practice. 这里举个例子，工厂方法就像上面提供的相比于其的构造函数而言，不需要再每次调用的时候构建一个新的对象，而且如果反复利用的是一个不变的对象的话，你可以保证的是，找个对象永远都不会改变。 Unfortunately, it’s not always obvious when you’re creating such an object. Suppose you want to write a method to determine whether a string is a valid Roman numeral. Here’s the easiest way to do this using a regular expression 不幸的是，当你创建一个这样的对象的时候不总是那么的明显，假设你想要写一个方法去判断一个字符串是否是罗马数字，下面有一个简单的办法来进行判断：1234// Performance can be greatly improved! static boolean isRomanNumeral(String s) &#123; return s.matches("^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)" + "(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$"); &#125; While String.matches is the easiest way to check if a string matches a regular expression, it’s not suitable for repeated use in performance-critical situations. 这通常是一个最简单的方法去判断是否一个字符串去包含常规的语法操作，然而其并不适合多次使用即多次调用的场景下面。 The problem is that it internally creates a Pattern instance for the regular expression and uses it only once, after which it becomes eligible for garbage collection. Creating a Pattern instance is expensive because it requires compiling the regular expression into a finite state machine. 而这个的问题就在于其创建了一个Pattern的实例给相应的正则表达式，而且仅仅只是使用了一次，然后就直接被java垃圾回收器给回收了，而创建一个Pattern的实例的代价是非常昂贵的，因为其需要compiling这个正则表达式到相应的机器里面去。 1234567// Reusing expensive object for improved performance public class RomanNumerals &#123; private static final Pattern ROMAN = Pattern.compile( "^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)" + "(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$"); static boolean isRomanNumeral(String s) &#123; return ROMAN.matcher(s).matches(); &#125; &#125; If the class containing the improved version of the isRomanNumeral method is initialized but the method is never invoked, the field ROMAN will be initialized needlessly. It would be possible to eliminate the initialization by lazily initializing the field (Item 83) the first time the isRomanNumeral method is invoked, but this is not recommended. As is often the case with lazy initialization, it would compli- cate the implementation with no measurable performance improvement (Item 67). 还有一种优化的方案就在于，如果上面这个类永远都没有被调用的话，那么上面直接设置成静态的成员变量就会出现构造对象的浪费，意思就是如果没有被调用就会有浪费，于是有一种方法就是按照之前的单实例化类那样，在构造函数里面加上，如果被调用了，那么就会创建一个final的对象。 Another way to create unnecessary objects is autoboxing, which allows the programmer to mix primitive and boxed primitive types, boxing and unboxing automatically as needed. Autoboxing blurs but does not erase the distinction between primitive and boxed primitive types. 还存在一种方式去创建一些不必要的对象，就是自动打包行为，就是将原生的类型，自动打包成了封装类型，这样也会造成许多不需要的对象，有些对象仅仅只是使用了一次。就像下面这个例子：1234567// Hideously slow! Can you spot the object creation? private static long sum() &#123; Long sum = 0L; for (long i = 0; i &lt;= Integer.MAX_VALUE; i++) sum += i; return sum; &#125; 上面的这个例子就是在加法的时候使long的类型自动包装成一个Long类型，这样则造成了很多不必要的开销。 The present item says, “Don’t create a new object when you should reuse an existing one,”while Item 50 says, “Don’t reuse an existing object when you should create a new one.” Note that the penalty for reusing an object when defensive copying is called for is far greater than the penalty for needlessly creating a duplicate object. Failing to make defensive copies where required can lead to insidious bugs and security holes; creating objects unnecessarily merely affects style and performance. 总而言之，当你可以并且应该重复利用一个已经存在的一个对象的时候，不要重复创建一个新的对象，而第五十条提醒的是 当你需要一个新的对象的时候不要去重复引用一个存在的旧对象。记住一些保护性质copy实际上是并不可取的，这个在后面会涉及到，其实这里与C++里面的知识有点吻合，关于左值引用与右值引用的知识。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
        <tag>effective_java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[effective java item 5]]></title>
    <url>%2F2019%2F03%2F26%2Feffective-java-item-5%2F</url>
    <content type="text"><![CDATA[Item 5: Prefer dependency injection to hardwiring resources Many classes depend on one or more underlying resources. For example, a spell checker depends on a dictionary. It is not uncommon to see such classes imple- mented as static utility classes (Item 4): 有一些类依赖一些潜在的资源，就像一个字符串检查器 依靠字典，所以也就不是很特殊见到一些类被翻译成静态的工具类。 Similarly, it’s not uncommon to see them implemented as singletons (Item 3): 就像一些类直接被翻译成单一实例类。 12345678// Inappropriate use of singleton - inflexible &amp; untestable! public class SpellChecker &#123; private final Lexicon dictionary = ...; private SpellChecker(...) &#123;&#125; public static INSTANCE = new SpellChecker(...); public boolean isValid(String word) &#123; ... &#125; public List&lt;String&gt; suggestions(String typo) &#123; ... &#125; &#125; Static utility classes and singletons are inappropriate for classes whose behavior is parameterized by an underlying resource. 静态的工具类和单一实体类，会在存在多种参数替换给基础资源，（就像上面的检查器有多种版本的字典资源一样），那么这些类就会变得特别不合适。 A simple pattern that satisfies this requirement is to pass the resource into the constructor when creating a new instance. This is one form of dependency injection: the dictionary is a dependency of the spell checker and is injected into the spell checker when it is created. 只有一种办法就是在构建的时候 构建函数里面直接给予相应的构造器，这样既维护了单实例化，又解决了上面多版本的问题。 123456789// Dependency injection provides flexibility and testability public class SpellChecker &#123; private final Lexicon dictionary; public SpellChecker(Lexicon dictionary) &#123; this.dictionary = Objects.requireNonNull(dictionary); &#125; public boolean isValid(String word) &#123; ... &#125; public List&lt;String&gt; suggestions(String typo) &#123; ... &#125; &#125; In summary, do not use a singleton or static utility class to implement a class that depends on one or more underlying resources whose behavior affects that of the class, and do not have the class create these resources directly. Instead, pass the resources, or factories to create them, into the constructor (or static factory or builder). This practice, known as dependency injection, will greatly enhance the flexibility, reusability, and testability of a class. 总而言之，不要在实现一个静态工具类或者一个单实例类的时候的同时去实现一个多个资源替换的类，这样会影响其他的类，并且违背了这个类最先开始的本意，好的解决办法就是在类的构造函数里面加上该资源或者带上该工厂方法。 另外对于上面一个函数进行讲解Objects.requireNonNull;其的代码形式如下： 12345public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
        <tag>effective_java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[effective java item 4]]></title>
    <url>%2F2019%2F03%2F16%2Feffective-java-item-4%2F</url>
    <content type="text"><![CDATA[Item 4: Enforce noninstantiability with a private constructor强迫不能实例化的类，拥有一个私有的构造函数。 Occasionally you’ll want to write a class that is just a grouping of static methods and static fields. Such classes have acquired a bad reputation because some people abuse them to avoid thinking in terms of objects, but they do have valid uses. 也许有的时候，你需要写一个类，拥有一些静态的变量与函数，而当有人给这些类实例化的时候，这些类往往就具有一些不太好的口碑。因为这些类并不是当成对象，仅仅只是当成一个工具。 (As of Java 8, you can also put such methods in the interface, assuming it’s yours to modify.) Lastly, such classes can be used to group methods on a final class, since you can’t put them in a subclass 在java8的时候你可以把一些函数直接放在接口里面，而最近一些类可以帮用做是一系列的函数群，不过你不能将他们放到可以继承的子类里面去。 Such utility classes were not designed to be instantiated: an instance would be nonsensical. In the absence of explicit constructors, however, the compiler pro- vides a public, parameterless default constructor. To a user, this constructor is indistinguishable from any other. 而一些功能类型的类不是被设计成可实例化的，是因为实例化往往没有意思，而这个时候编译器会自动的提供公开且没有参数的构造函数，对于客户及其使用者而言，必须使这类构造函数隐藏起来。 Attempting to enforce noninstantiability by making a class abstract does not work. The class can be subclassed and the subclass instantiated. 然后仅仅只是强迫这些类变成抽象类是完全达不到效果的，因为这些类还会被继承，而继承其的子类往往还会被实例化。 A default construc- tor is generated only if a class contains no explicit constructors, so a class can be made noninstantiable by including a private constructor: 然后最后的结果就是只能给类安置一个私有的构造函数才能避免以上问题。 就像如下代码：12345678// Noninstantiable utility class public class UtilityClass &#123; // Suppress default constructor for noninstantiability private UtilityClass() &#123; throw new AssertionError(); &#125; ...// Remainder omitted &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>effective_java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[effective java item 3]]></title>
    <url>%2F2019%2F03%2F15%2Feffective-java-item-3%2F</url>
    <content type="text"><![CDATA[Item 3: Enforce the singleton property with a private constructor or an enum type A singleton is simply a class that is instantiated exactly once [Gamma95]. Single- tons typically represent either a stateless object such as a function (Item 24) or a system component that is intrinsically unique. 首先先解释一下 singleton 这个是表示一个类只会被实例化一次的类，一般用于一些函数类型的功能，以及某些一同的独一无二的重要组成成分。 There are two common ways to implement singletons. Both are based on keeping the constructor private and exporting a public static member to provide access to the sole instance. In one approach, the member is a final field 现在有两种办法去实现这种单实例的情况，基于保证其的构造函数私有化，和输出公开静态成员来保护唯一的实例，一般这个实例都是final的变量。 123456// Singleton with public final field public class Elvis &#123; public static final Elvis INSTANCE = new Elvis(); private Elvis() &#123; ... &#125; public void leaveTheBuilding() &#123; ... &#125; &#125; 以上的例子就是在静态加载的过程中就直接调用这个实例类的函数，外部无法直接去构造这个类，所以也就直接造成这个类只能够被访问一次。 In the second approach to implementing singletons, the public member is a static factory method 第二种方法获得这种单实例化的类，直接使用一个get类型的函数，也可以使用一种你那个懒惰标记的方法，直到调用的时候才开始实例化这个类。 One advantage of the static factory approach is that it gives you the flexibility to change your mind about whether the class is a singleton without changing its API. The factory method returns the sole instance, but it could be modified to return, say, a separate instance for each thread that invokes it. 第一个函数就是给你灵活性去改变这个类是否是单实例化，其的静态工厂方法是返回这个类的唯一实例，但是其很容易被修改，比如说为每一次调用该方法的线程返回一个唯一的实例。 A second advantage is that you can write a generic singleton factory if your application requires it (Item 30). A final advantage of using a static factory is that a method reference can be used as a supplier, for example Elvis::instance is a Supplier. Unless one of these advantages is relevant, the public field approach is preferable 第二个好事就是你可以写一个泛型类型的单实例化类，如果你的应用就此要求的话。就此的方法可以把这个单实例化当成一种提供者。 To make a singleton class that uses either of these approaches serializable (Chapter 12), it is not sufficient merely to add implements Serializable to its declaration. To maintain the singleton guarantee, declare all instance fields transient and provide a readResolve method (Item 89). Otherwise, each time a serialized instance is deserialized, a new instance will be created, leading, in the case of our example, to spurious Elvis sightings. 为了保证每一次访问到类里面的，去获得一个”只读函数“，这样就防止每一次访问到这个类的时候不会再生成一个新的类，确确实实的保证了类的单一性。 A third way to implement a singleton is to declare a single-element enum: 第三种方法实现单实例化是生成一个单个元素的枚举类 This approach is similar to the public field approach, but it is more concise, provides the serialization machinery for free, and provides an ironclad guarantee against multiple instantiation, even in the face of sophisticated serialization or reflection attacks. This approach may feel a bit unnatural, but a single-element enum type is often the best way to implement a singleton. 这种类型的方法就是类似于类的变量方法，但是这个更精细，提供的机器内存消耗几乎就是免费的，并且提供（这里后面的一句话 英文没怎么看懂 自动标红）。 这种方法可能有点不自然，但是这种方法往往是实现这种单实例化最好的方法。 Note that you can’t use this approach if your singleton must extend a superclass other than Enum (though you can declare an enum to implement interfaces). 记住如果你需要用单实例化类去继承一个类的话，那么就不能使用这种单枚举的方法了。其的样例代码如下：1234567// Enum singleton - the preferred approach public enum Elvis &#123; INSTANCE; public void leaveTheBuilding() &#123; ... &#125; &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>effective_java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[effective java item 2]]></title>
    <url>%2F2019%2F03%2F14%2Feffective-java-item-2%2F</url>
    <content type="text"><![CDATA[Item 2: Consider a builder when faced with many constructor parameters条款二 当面临许多构造参数的时候，建议考虑一下一个构造器(builder) What sort of constructors or static factories should you write for such a class? Traditionally, programmers have used the telescoping constructor pattern, in which you provide a constructor with only the required parameters, another with a single optional parameter, a third with two optional parameters, and so on, culmi- nating in a constructor with all the optional parameters. 经常会遇到构造函数中有多个参数，而这些参数，如果按照标准的方法来写的话，会特别的麻烦，于是就采用C++中的委托构造函数，利用其中一个构造函数，为其他所有的构造函数构造，相当于起到了一个构造器的作用(builder) Typically this constructor invocation will require many parameters that you don’t want to set, but you’re forced to pass a value for them anyway. In this case, we passed a value of 0 for fat. 很多时候你不想设置那么多的参数，最简单的一个办法是给这个成员直接设置0。 In short, the telescoping constructor pattern works, but it is hard to write client code when there are many parameters, and harder still to read it. The reader is left wondering what all those values mean and must carefully count parameters to find out. Long sequences of identically typed parameters can cause subtle bugs. If the client accidentally reverses two such parameters, the compiler won’t complain, but the program will misbehave at runtime (Item 51). 简而言之，这种委托构造函数虽然可行，但是客户在写代码的时候很容易写错，就算写对了，也很难读出来，并且也会出现一种情况就是当参数够多的时候，写错了参数的顺序，这样造成的错误，编译器是不会轻易报错的。所以这里就很难被找出来。 A second alternative when you’re faced with many optional parameters in a constructor is the JavaBeans pattern, in which you call a parameterless construc- tor to create the object and then call setter methods to set each required parameter and each optional parameter of interest 还有第二种办法就是 给每一个私有成员设置一个set函数，一个外围的函数直接可以作用到内部私有成员，并且直接设置其的值。 Unfortunately, the JavaBeans pattern has serious disadvantages of its own.Because construction is split across multiple calls, a JavaBean may be in an inconsistent state partway through its construction. The class does not have the option of enforcing consistency merely by checking the validity of the constructor parameters. Attempting to use an object when it’s in an inconsistent state may cause failures that are far removed from the code containing the bug and hence difficult to debug. 不幸的是，这种模式的代码写法，将构造过程与赋值过程分开，也就意味着，当构造对象并没有赋值的时候会造成错误，另外，其还会在写一个immutable类的时候花费额外的工作保证线程安全。 Luckily, there is a third alternative that combines the safety of the telescoping constructor pattern with the readability of the JavaBeans pattern. It is a form of the Builder pattern [Gamma95]. Instead of making the desired object directly, the client calls a constructor (or static factory) with all of the required parameters and gets a builder object. Then the client calls setter-like methods on the builder object to set each optional parameter of interest. Finally, the client calls a parameterless build method to generate the object, which is typically immutable. 幸运的是 这里存在第三种构造方式，结合上述两种方法的优点，并且保证了线程安全，也不会有过多的参数的麻烦。按照下述的例子，直接在内的内部构造一个静态的builder的类，用一个其他的类来构造这个类，第一解决了immutable的问题，其次也解决了参数不能特意的问题。 This client code is easy to write and, more importantly, easy to read. The Builder pattern simulates named optional parameters as found in Python and Scala. NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8) .calories(100).sodium(35).carbohydrate(27).build();Check invariants involving multiple parameters in the constructor invoked by the build method. To ensure these invariants against attack, do the checks on object fields after copying parameters from the builder (Item 50). If a check fails, throw an IllegalArgumentException (Item 72) whose detail message indicates which parameters are invalid (Item 75). 这样的做法会造成代码清晰可读，并且最重要的是，可以在构造器这个类型里面进行一个check函数进行异常检查。 The Builder pattern is well suited to class hierarchies. Use a parallel hier- archy of builders, each nested in the corresponding class. Abstract classes have abstract builders; concrete classes have concrete builders. 这种构造模式，其实特别有利于类型继承，利用相应的类内的构造器帮助进行构造。一般利用像如下形式的构造方法即可：记住这个地方时直接用过build 来返回外部的那个类。 NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8) .calories(100).sodium(35).carbohydrate(27).build(); Here are two concrete subclasses of Pizza, one of which represents a standard New-York-style pizza, the other a calzone. 后面的两种模式属于继承过程中出现的构造，注意构造的这个构造器 一定要满足如下形式。最重要的是下面继承处的处理，调用基类的构造器 super(builder);12345678910111213141516171819202122232425262728293031323334353637public class NyPizza extends Pizza &#123; public enum Size &#123; SMALL, MEDIUM, LARGE &#125; private final Size size; public static class Builder extends Pizza.Builder&lt;Builder&gt; &#123; private final Size size; public Builder(Size size) &#123; this.size = Objects.requireNonNull(size); &#125; @Override public NyPizza build() &#123; return new NyPizza(this); &#125; @Override protected Builder self() &#123; return this; &#125; &#125; private NyPizza(Builder builder) &#123; super(builder); size = builder.size; &#125; &#125; public class Calzone extends Pizza &#123; private final boolean sauceInside; public static class Builder extends Pizza.Builder&lt;Builder&gt; &#123; private boolean sauceInside = false; // Default public Builder sauceInside() &#123; sauceInside = true; return this; &#125; @Override public Calzone build() &#123; return new Calzone(this); &#125; @Override protected Builder self() &#123; return this; &#125; &#125; private Calzone(Builder builder) &#123; super(builder); sauceInside = builder.sauceInside; &#125; &#125; This technique, wherein a subclass method is declared to return a subtype of the return type declared in the super- class, is known as covariant return typing. It allows clients to use these builders without the need for casting. 这项技术返回的类都是隶属于该类的，这样做的好处可以允许客户使用这些类而不需要使用转型。 A single builder can be used repeatedly to build multiple objects. The parameters of the builder can be tweaked between invocations of the build method to vary the objects that are created. A builder can fill in some fields automatically upon object creation, such as a serial number that increases each time an object is created. 由于是静态的类，所以只需要被构造一次，却可以造成多次使用，这里就是其的好处，，而这个构造器可以在这个对象被创建之后自动赋值。，比较方便。 The Builder pattern has disadvantages as well. In order to create an object, you must first create its builder. While the cost of creating this builder is unlikely to be noticeable in practice, it could be a problem in performance-critical situations. Also, the Builder pattern is more verbose than the telescoping constructor pattern 其存在的坏处就在于，其写出来的代码非常的复杂和冗杂，对于只有一点参数的构造器而言，完全没有这样写的必要，但是对于先开始只有一点参数，但是后面则变成很多参数的工程来说第一次使用这种构造器方便以后来写。 In summary, the Builder pattern is a good choice when designing classes whose constructors or static factories would have more than a handful of parameters 总而言之，使用这种办法的方便在于大工程，且一个类的构造参数过多的情况，即解决了参数冗杂的问题，又再次解决了类不能final的问题。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>effective_java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[effective java item 1]]></title>
    <url>%2F2019%2F03%2F13%2Feffective-java-item-1%2F</url>
    <content type="text"><![CDATA[Item 1: Consider static factory methods instead of constructors前面几个条款的内容是关于创建和销毁对象。 The traditional way for a class to allow a client to obtain an instance is to provide a public constructor. There is another technique that should be a part of every programmer’s toolkit. A class can provide a public static factory method, which is simply a static method that returns an instance of the class. Here’s a simple example from Boolean (the boxed primitive class for boolean). This method translates a boolean primitive value into a Boolean object reference: 考虑直接用一个静态的方法来完成构造函数的功能，比如接受一个对象，然后通过这个对象来构造一个新的对象。 A class can provide its clients with static factory methods instead of, or in addition to, public constructors. Providing a static factory method instead of a public constructor has both advantages and disadvantages. 提供一个静态方法作为构造函数的有额外相对于提供公开构造函数的好处以及坏处。 One advantage of static factory methods is that, unlike constructors, they have names. If the parameters to a constructor do not, in and of themselves, describe the object being returned, a static factory with a well-chosen name is easier to use and the resulting client code easier to read. 第一个好处是静态的函数有独特的名字而构造函数没有名字，通过名字将构造函数的参数进行一个分类显示的更加耐用。 the constructor BigInteger(int, int, Random), which returns a BigInteger that is probably prime, would have been better expressed as a static factory method named BigInteger.probablePrime. 就像大整数类在里面就有一个构造一个趋近于自己值的质数的大整数类，然后这里直接用名字命名显得更加方便。 Because they have names, static factory methods don’t share the restriction discussed in the previous paragraph. In cases where a class seems to require multiple constructors with the same signature, replace the constructors with static factory methods and carefully chosen names to highlight their differences. 有的时候一些公开构造函数的参数类型，以及参数的顺序，代表着不同的构造函数，这样会容易弄混淆，于是这也是体现名字第二个好的地方。 A second advantage of static factory methods is that, unlike constructors, they are not required to create a new object each time they’re invoked. 第二个好处就是相比于构造函数每次在被call的时候，会构造一个新的对象，而静态方法有的时候则会节省下这一笔开销。就像之前举了一个例子，Boolean.valueOf 从来没有构造一个新的对象。 . Instance control allows a class to guarantee that it is a singleton (Item 3) or noninstantiable (Item 4). Also, it allows an immutable value class (Item 17) to make the guarantee that no two equal instances exist: a.equals(b) if and only if a == b. This is the basis of the Flyweight pattern . Enum types (Item 34) provide this guarantee. 这种实例化重复使用一个对象，得到的两个好处，第一个好处就是保证其是一个singleton,另一个好处，就是保证在调用equal函数的时候只能允许相等的条件只会有一个，那么就可以直接使用==号进行操作，从而进行性能上面的提升。 A third advantage of static factory methods is that, unlike constructors, they can return an object of any subtype of their return type. This gives you great flexibility in choosing the class of the returned object. 而其的第三点好处就体现在其的返回值可以为任意该类型的子类型对象，这样在类型的返回的时候会提供很大的灵活性。 One application of this flexibility is that an API can return objects without making their classes public. Hiding implementation classes in this fashion leads to a very compact API. 而其中的第一点应用就在于返回API接口的时候可以不需要将这个类弄成公开的，隐藏其的实现。 For example, the Java Collections Framework has forty-five utility implementations of its interfaces, providing unmodifiable collections, synchronized collections, and the like. Nearly all of these implemen- tations are exported via static factory methods in one noninstantiable class (java.util.Collections). The classes of the returned objects are all nonpublic. java在实现其的接口的时候，在接口里面采用静态的方法，导出的类往往都是没有公有化的，这样实现了 类的实现过程的隐藏。 one for each convenience implemen- tation. It is not just the bulk of the API that is reduced but the conceptual weight: the number and difficulty of the concepts that programmers must master in order to use the API. The programmer knows that the returned object has precisely the API specified by its interface, so there is no need to read additional class docu- mentation for the implementation class. Furthermore, using such a static factory method requires the client to refer to the returned object by interface rather than implementation class, which is generally good practice (Item 64). 开发者在接口的使用过程中，通过其的返回类型可以逐渐了解到其API的真实用途，这样来就不需要阅读额外的开发者文档。 As of Java 8, the restriction that interfaces cannot contain static methods was eliminated, so there is typically little reason to provide a noninstantiable compan- ion class for an interface. Many public static members that would have been at home in such a class should instead be put in the interface itself. Note, however, that it may still be necessary to put the bulk of the implementation code behind these static methods in a separate package-private class. This is because Java 8 requires all static members of an interface to be public. Java 9 allows private static methods, but static fields and static member classes are still required to be public. java8的时候就同样将 接口里面不能放静态类型的函数规定给消除了，所以这个时候就没有理由去提供一个不可实例化的类给一个接口了，而许多静态成员应该被放在这样一个接口本身里，记住，现在还是最重要的是将实现的代码放在这些静态实现方法之后。这是因为java8 所有的静态成员都必须公开，而java9 则允许私有的静态函数，其他则是公开的。 A fourth advantage of static factories is that the class of the returned object can vary from call to call as a function of the input parameters. Any sub- type of the declared return type is permissible. The class of the returned object can also vary from release to release. 第四个好处就在于返回的子类型中可以根据参数的形式来进行改变 一一对应的关系，这里举出了一个enumset的例子 （我看的不是很懂 所以这里标红，以后有时间再次来了解一下。） A fifth advantage of static factories is that the class of the returned object need not exist when the class containing the method is written. Such flexible static factory methods form the basis of service provider frameworks, like the Java Database Connectivity API (JDBC). A service provider framework is a system in which providers implement a service, and the system makes the implementations available to clients, decoupling the clients from the implementations. 第五个好处就是当类中包含的函数已经被写了，然后这返回对象不需要存在，（这一点也没有看懂，等以后拜读了中文版再来解释，手动标红） The main limitation of providing only static factory methods is that classes without public or protected constructors cannot be subclassed. For example, it is impossible to subclass any of the convenience implementation classes in the Collections Framework. Arguably this can be a blessing in disguise because it encourages programmers to use composition instead of inheritance (Item 18), and is required for immutable types (Item 17). 其实这个地方最大的一个局限的地方就在于，如果一个类没有公开或者保护的构造函数的话 那么这个类是不允许被继承的，意思就是对于被静态函数得来的类，因为不具有公开的构造函数 所以不能够被子类化。 A second shortcoming of static factory methods is that they are hard for programmers to find. They do not stand out in API documentation in the way that constructors do, so it can be difficult to figure out how to instantiate a class that provides static factory methods instead of constructors. 第二个缺点就在于可能开发者会很不容易找到这些静态方法，而且他们不会像平常构造函数一样，所以很难理解实例化一个类提供的静态函数而不是此构造函数。 不过有一些静态函数的样例 类似的模板 可以自己在书中去查找。 In summary, static factory methods and public constructors both have their uses, and it pays to understand their relative merits. Often static factories are preferable, so avoid the reflex to provide public constructors without first consid- ering static factories. 总之 两种构造函数都有相应的好处与坏处，具体样例具体分析。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>effective_java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数专题的java方法总结]]></title>
    <url>%2F2019%2F03%2F13%2F%E5%A4%A7%E6%95%B0%E4%B8%93%E9%A2%98%E7%9A%84java%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[其实这里题目类型都差不多仅仅只贴出几道题的代码，并且对这些题目所用到的函数进行一个总结。123456789101112131415161718192021222324import java.math.BigDecimal;import java.util.Scanner;import java.io.BufferedInputStream;public class E &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); while (in.hasNext()) &#123; BigDecimal r; int n; r = in.nextBigDecimal(); n = in.nextInt(); BigDecimal ans; ans = r.pow(n); ans = ans.stripTrailingZeros(); String res = ans.toPlainString(); while (res.startsWith("0")) &#123;res =res.substring(1);&#125; System.out.println(res); &#125; in.close(); &#125;&#125; stripTrailingZeros() 这个函数的意思是去除多余的0。toPlainString() 这个函数的意思是将某些科学计数法，给全部展开。startsWith(&quot;0&quot;) 这个函数的意思就是 判断字符串到底以什么函数为前提。substring(1) 这个函数的意思就是字符串进行一个有效的替换。 另外 java 里面大数的大数幂次方必须要规定一个mod对象 实现函数则为modpow() 最后再累积点 C++ 知识：12345678910A*B % C = (A%C * B%C)%C(A+B)%C = (A%C + B%C)%C如 532 mod 7 =（500%7+30%7+2%7)%7;当然还有a*b mod c=(a mod c+b mod c)mod c;如35 mod 3=((5%3)*(7%3))%3 还有一道题目 具体看代码这道题展现了 java在求余数方面的缺陷。 重要的就是这一步 v = (v * 10 + s[i] - ‘0’) % mod123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.Scanner;import java.math.BigInteger;public class H &#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); BigInteger a; String b,c; int Case = 1; while (cin.hasNext()) &#123; a = cin.nextBigInteger(); b = a.mod(new BigInteger("137")).toString(); c = a.mod(new BigInteger("73")).toString(); if (b.equals("0") &amp;&amp; c.equals("0") ) System.out.println("Case #" + Case++ + ": YES"); else System.out.println("Case #" + Case++ + ": NO"); &#125; &#125;&#125;/*关于这道题，不知道为什么用java 提交就是没有办法过，全部都是爆内存，我个人觉得可能在大数，求余数这方面，可能存在缺陷。下面提供几个 AC的 C++代码#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 10000000 + 1;const int mod = 10001;char s[maxn];int main()&#123; int kase = 0; while(scanf("%s",s) == 1)&#123; int len = strlen(s); int v = 0; for (int i = 0; i &lt; len; ++i)&#123; v = (v*10 + s[i]-48) % mod; &#125; if (v == 0)printf("Case #%d: YES\n",++kase); else printf("Case #%d: NO\n",++kase); &#125; return 0;&#125;*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四道关于BFS的情况变换题目]]></title>
    <url>%2F2019%2F03%2F13%2F%E5%9B%9B%E9%81%93%E5%85%B3%E4%BA%8EBFS%E7%9A%84%E6%83%85%E5%86%B5%E5%8F%98%E6%8D%A2%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[这个专题 同样还是总结一些BFS的题目，但是这些BFS的题目都存在一个特定的特点，也就是你真的没有办法猜到，原来这道题目最后是通过BFS的方法做的。 第一题 FliptileFliptile 这道题 个人是觉得很有必要来做一遍，这道题不太属于一个严格的bfs，但是这道题的递归解题思路很有意思。 题目大意就是两种颜色的格子，给定一个初始图，翻动最小的步数，使得全部为白色，并且最后给出翻动与不翻动的图片 这道题最好玩的是 我们需要明白一个前提，第i行的格子在竖排上只能被上面的颜色改变，意思是 最后一排的只能根据倒数第二排的位置来确定。那我们通过递归确定第一排便利下去的每一种方法，然后判断是否会进行改变，最后保证最后一排全部为白色，也就达到了全部为白色的效果。 需要注意的是，里面有一个&amp; 1的操作，这个意思就是对2求余，最终导致的结果就是可以判断该位置的格子该不该重复翻转过来。 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 17;int cpy[maxn][maxn];int map[maxn][maxn];int res[maxn][maxn];int n,m;int Min;bool judge() &#123; for (int i = 1; i &lt;= m; i ++) &#123; int tmp = cpy[n][i] + cpy[n][i - 1] + cpy[n][i + 1] + cpy[n - 1][i]; if ((map[n][i] + tmp) &amp; 1) return false; &#125; return true;&#125;void dfs(int a,int num) &#123; if (num &gt; Min) return; if (a &gt; n) &#123; if (judge() &amp;&amp; Min &gt; num) &#123; Min = num; memcpy(res,cpy,sizeof (cpy)); return ; &#125; return; &#125; int _time = 0; for (int i = 1 ; i &lt;= m; i ++) &#123; int tmp = map[a - 1][i] + cpy[a - 1][i] + cpy[a - 2][i] + cpy[a - 1][i - 1] + cpy[a - 1][i + 1]; if (tmp &amp; 1) &#123; cpy[a][i] = 1; _time ++; &#125; else cpy[a][i] = 0; &#125; dfs(a + 1, num + _time);&#125;void solve(int a,int num) &#123; if (a &gt; m) &#123; dfs(2,num); return ; &#125; cpy[1][a] = 0; solve(a + 1,num); cpy[1][a] = 1; solve(a + 1,num + 1);&#125;void get()&#123; while( cin &gt;&gt; n &gt;&gt; m) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; Min = 0x3f3f3f3f; memset(cpy,0,sizeof(cpy)); solve(1,0); if (Min == 0x3f3f3f3f) cout &lt;&lt; "IMPOSSIBLE" &lt;&lt; endl; else &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cout &lt;&lt; res[i][j] &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; &#125; &#125;&#125;int main()&#123; get(); return 0;&#125; 第二题 potspots 这道题刚开始看的第一眼完全想象不到这竟然是一个BFS的题目，因为相互之间倒水，当时是完全没有一点思路的，不过后来根据BFS层序查找的性质，可以逐渐发现，原来这个地方的一共有六种情况，然后将已经遍历过的和不符合条件的全部去除，然后将返回到原来的位置的情况直接失败，很容易就可以用BFS给弄出来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;iterator&gt;using namespace std;int A,B,C;const int maxn = 1005;bool vis[maxn][maxn];const string s[6] = &#123;"FILL(1)", "FILL(2)", "DROP(1)", "DROP(2)", "POUR(1,2)", "POUR(2,1)"&#125;;struct Node&#123; int v_a,v_b; int step; vector&lt;string&gt; vs; Node() &#123;&#125;; Node (int a,int b,int c) : v_a(a), v_b(b), step(c) &#123; &#125;&#125;;bool bfs() &#123; queue&lt;Node&gt; q; Node now(0,0,0),next; vis[0][0] = true; q.push(now); vector&lt;string&gt; * tmp; while(!q.empty()) &#123; Node now = q.front(); q.pop(); if (now.v_a == C || now.v_b == C) &#123; cout &lt;&lt; now.step &lt;&lt; endl; for (int it = 0; it != now.vs.size(); it++) &#123; cout &lt;&lt; now.vs[it] &lt;&lt; endl; &#125; return true; &#125; if (now.v_a != A) &#123; next.v_a = A; next.v_b = now.v_b; next.step = now.step + 1; if (!vis[next.v_a][next.v_b])&#123; vis[next.v_a][next.v_b] = true; next.vs = now.vs; next.vs.push_back(s[0]); q.push(next); &#125; &#125; if (now.v_b != B) &#123; next.v_b = B; next.v_a = now.v_a; next.step = now.step + 1; if (!vis[next.v_a][next.v_b]) &#123; vis[next.v_a][next.v_b] = true; next.vs = now.vs; next.vs.push_back(s[1]); q.push(next); &#125; &#125; if (now.v_a != 0)&#123; next.v_a = 0; next.v_b = now.v_b; next.step = now.step + 1; if (!vis[next.v_a][next.v_b]) &#123; vis[next.v_a][next.v_b] = true; next.vs = now.vs; next.vs.push_back(s[2]); q.push(next); &#125; &#125; if (now.v_b != 0)&#123; next.v_b = 0; next.v_a = now.v_a; next.step = now.step + 1; if (!vis[next.v_a][next.v_b]) &#123; vis[next.v_a][next.v_b] = true; next.vs = now.vs; next.vs.push_back(s[3]); q.push(next); &#125; &#125; if (now.v_a != 0 &amp;&amp; now.v_b != B) &#123; next.v_a = now.v_a - (B - now.v_b); next.v_b = now.v_a + now.v_b; if (next.v_b &gt; B) next.v_b = B; if (next.v_a &lt; 0) next.v_a = 0; next.step = now.step + 1; if (!vis[next.v_a][next.v_b]) &#123; vis[next.v_a][next.v_b] = true; next.vs = now.vs; next.vs.push_back(s[4]); q.push(next); &#125; &#125; if (now.v_a != A &amp;&amp; now.v_b != 0)&#123; next.v_b = now.v_b - (A - now.v_a); next.v_a = now.v_a + now.v_b; if (next.v_a &gt; A) next.v_a = A; if (next.v_b &lt; 0) next.v_b = 0; next.step = now.step + 1; if (!vis[next.v_a][next.v_b]) &#123; vis[next.v_a][next.v_b] = true; next.vs = now.vs; next.vs.push_back(s[5]); q.push(next); &#125; &#125; &#125; return false;&#125;int main()&#123; while(cin &gt;&gt; A &gt;&gt; B &gt;&gt; C) &#123; memset(vis,false,sizeof vis); if (!bfs()) cout &lt;&lt; "impossible" &lt;&lt; endl; &#125; return 0;&#125; 第三题 非常可乐非常可乐 这一道题，其实与上面一道题很类似的地方就在于，也是将诸多情况进行一个总结与分布，符合条件的入队列，不符合条件的直接出队列。关键就是这道题的条件设置方面与上面一题有些不同。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160import java.util.*;public class L_非常可乐 &#123; static Scanner in = new Scanner(System.in); static final int maxn = 105; // 标志数组来标记路径，三个杯子三维数组即可 static int[][][] visited = new int[maxn][maxn][maxn]; static void init() &#123; for (int i = 0; i &lt; maxn; ++i) for (int j = 0; j &lt; maxn; ++j) for (int k = 0; k &lt; maxn; ++k) visited[i][j][k] = 0; &#125; // a b c为三个容器的最大容量 static void bfs(int a, int b, int c) &#123; if (a % 2 == 1) &#123; System.out.println("NO"); return; &#125; //记住这里可以直接写queue的接口 来声明类型 并且在后面 new 的时候 以LinkedList来实现 其的接口 Queue&lt;Node&gt; que = new LinkedList&lt;Node&gt;(); // 初始 que.add(new Node(a, 0, 0, 0)); while (!que.isEmpty()) &#123; // 取队头并弹出 Node t = que.poll(); visited[t.a][t.b][t.c] = 1; // 判断是否符合条件 if (t.a == t.b &amp;&amp; t.c == 0 || t.a == t.c &amp;&amp; t.b == 0 || t.b == t.c &amp;&amp; t.a == 0) &#123; System.out.println(t.step); return; &#125; // 倒水过程，注意倒水的前提是杯子里面有水 // b -&gt; a if (t.b != 0) &#123; // 因为没有刻度， 所以每次倒水都有两种情况 // 第一种情况是把自己倒完 if (t.a + t.b &lt;= a) &#123; if (visited[t.a + t.b][0][t.c] == 0) &#123; que.add(new Node(t.a + t.b, 0, t.c, t.step + 1)); visited[t.a + t.b][0][t.c] = 1; &#125; &#125; // 第二种情况是把对方倒满 else if (t.a != a) &#123; if (visited[a][t.b - (a - t.a)][t.c] == 0) &#123; que.add(new Node(a, t.b - (a - t.a), t.c, t.step + 1)); visited[a][t.b - (a - t.a)][t.c] = 1; &#125; &#125; &#125; // c -&gt; a if (t.c != 0) &#123; if (t.a + t.c &lt;= a) &#123; if (visited[t.a + t.c][t.b][0] == 0) &#123; que.add(new Node(t.a + t.c, t.b, 0, t.step + 1)); visited[t.a + t.c][t.b][0] = 1; &#125; &#125; else if (t.a != a) &#123; if (visited[a][t.b][t.c - (a - t.a)] == 0) &#123; que.add(new Node(a, t.b, t.c - (a - t.a), t.step + 1)); visited[a][t.b][t.c - (a - t.a)] = 1; &#125; &#125; &#125; // b -&gt; c if (t.b != 0) &#123; if (t.b + t.c &lt;= c) &#123; if (visited[t.a][0][t.b + t.c] == 0) &#123; que.add(new Node(t.a, 0, t.b + t.c, t.step + 1)); visited[t.a][0][t.b + t.c] = 1; &#125; &#125; else if (t.c != c) &#123; if (visited[t.a][t.b - (c - t.c)][c] == 0) &#123; que.add(new Node(t.a, t.b - (c - t.c), c, t.step + 1)); visited[t.a][t.b - (c - t.c)][c] = 1; &#125; &#125; &#125; // c -&gt; b if (t.c != 0) &#123; if (t.c + t.b &lt;= b) &#123; if (visited[t.a][t.c + t.b][0] == 0) &#123; que.add(new Node(t.a, t.c + t.b, 0, t.step + 1)); visited[t.a][t.c + t.b][0] = 1; &#125; &#125; else if (t.b != b) &#123; if (visited[t.a][b][t.c - (b - t.b)] == 0) &#123; que.add(new Node(t.a, b, t.c - (b - t.b), t.step + 1)); visited[t.a][b][t.c - (b - t.b)] = 1; &#125; &#125; &#125; // a -&gt; b if (t.a != 0) &#123; if (t.a + t.b &lt;= b) &#123; if (visited[0][t.a + t.b][t.c] == 0) &#123; que.add(new Node(0, t.a + t.b, t.c, t.step + 1)); visited[0][t.a + t.b][t.c] = 1; &#125; &#125; else if (t.b != b) &#123; if (visited[t.a - (b - t.b)][b][t.c] == 0) &#123; que.add(new Node(t.a - (b - t.b), b, t.c, t.step + 1)); visited[t.a - (b - t.b)][b][t.c] = 1; &#125; &#125; &#125; // a -&gt; c if (t.a != 0) &#123; if (t.a + t.c &lt;= c) &#123; if (visited[0][t.b][t.a + t.c] == 0) &#123; que.add(new Node(0, t.b, t.a + t.c, t.step + 1)); visited[0][t.b][t.a + t.c] = 1; &#125; &#125; else if (t.c != c) &#123; if (visited[t.a - (c - t.c)][t.b][c] == 0) &#123; que.add(new Node(t.a - (c - t.c), t.b, c, t.step + 1)); visited[t.a - (c - t.c)][t.b][c] = 1; &#125; &#125; &#125; &#125; System.out.println("NO"); &#125; public static void main(String[] args) &#123; while (in.hasNext()) &#123; int a = in.nextInt(), b = in.nextInt(), c = in.nextInt(); if (a == 0 &amp;&amp; b == 0 &amp;&amp; c == 0) break; init(); bfs(a, b, c); &#125; &#125;&#125;class Node &#123; // a b c 代表实际拥有水的体积 int a, b, c, step; Node(int a, int b, int c, int step) &#123; this.a = a; this.b = b; this.c = c; this.step = step; &#125;&#125; 第四题 prime pathprime path 这道题 同样看题目这的没有办法观察到这是一个BFS的题目，只有看到后面才逐渐发现这道题目 其实是通过搜寻每个部位的变化，最终导致输出结果不过这里会借助到一些筛选质数的办法 比如欧拉筛 比如埃式筛 只不过后面是直接用暴力枚举这部分 我是真的没有想到，暴力枚举了四十种情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;int T;int a,b;const int maxn = 10000;int prime[maxn];bool check[maxn];bool vis[maxn];int tot = 0;struct Node &#123; int x,step; Node()&#123;&#125;; Node(int a,int c):x(a),step(c)&#123;&#125;&#125;;void get_prime() &#123; memset(check,false,sizeof(check)); for (int i = 2; i &lt; maxn ; i++) &#123; if (!check[i]) prime[tot++] = i; for (int j = 0; j &lt; tot; j++) &#123; if (i * prime[j] &gt; maxn) break; check[i * prime[j]] = true; if (i % prime[j] == 0) break; &#125; &#125;&#125;int bfs(int a,int b) &#123; memset(vis,false,sizeof vis); queue&lt;Node&gt; q; Node o1(a,0),o2,o3; q.push(o1); vis[a] = false; while(!q.empty()) &#123; o2 = q.front(); q.pop(); if (o2.x == b) return o2.step; int num[4]; num[0] = o2.x / 1000; num[1] = o2.x / 100 % 10; num[2] = o2.x / 10 % 10; num[3] = o2.x % 10; for (int i = 0; i &lt; 4; i++) &#123; int tmp = num[i]; for (int j = 0; j &lt; 10; j++) &#123; num[i] = j; int yy = num[0] * 1000 + num[1] * 100 + num[2] *10 + num[3]; if (!vis[yy] &amp;&amp; !check[yy] &amp;&amp; yy &gt; 1000 &amp;&amp; yy &lt; 9999) &#123; vis[yy] = true; o3.x = yy; o3.step = o2.step + 1; q.push(o3); &#125; &#125; num[i] = tmp; &#125; &#125; return -1;&#125;int main()&#123; get_prime(); cin &gt;&gt; T; int ans = -1; while(T--) &#123; cin &gt;&gt; a &gt;&gt; b; ans = bfs(a,b); if (ans == -1) cout &lt;&lt; "Impossible" &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两道与fire有关的基础BFS]]></title>
    <url>%2F2019%2F03%2F13%2F%E4%B8%A4%E9%81%93%E4%B8%8Efire%E6%9C%89%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80BFS%2F</url>
    <content type="text"><![CDATA[第一道题fire game 这道题目其实就是一个简单的bfs，但是令我特别困惑的是，我不知道怎么去取每一个火苗向四周扩散的时间，然后最后才知道，原来是直接计算那个最长的路线就行了，这道题目的意思就是根据每一个点的遍历，去寻找最长的那一个点，将每个点放进去，然后找距离这个点最长的距离就是其扩散的最终时间，然后到最后依次枚举两个点，按照各自两个点之间的最快的时间来决定最终的时间。 其实这道题不难，一道bfs的模拟题目，只不过就是后面决策的那个地方不太好下。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;#define inf 0x3f3f3f3fint n,m;const int maxn = 15;char map[maxn][maxn];int vis[maxn][maxn];struct point&#123; int x,y,pos; point ()&#123;&#125; point (int a,int b,int c) : x(a),y(b),pos(c) &#123;&#125; point move(int i) &#123; point tmp(x,y,pos); switch (i)&#123; case 0:&#123; tmp.x = x + 1; break; &#125; case 1: &#123; tmp.x = x - 1; break; &#125; case 2: &#123; tmp.y = y + 1; break; &#125; case 3: &#123; tmp.y = y - 1; break; &#125; &#125; tmp.pos++; return tmp; &#125;&#125;;int bfs(point a,point b) &#123; queue&lt;point&gt; q; point now,next; q.push(a); q.push(b); memset(vis,inf,sizeof vis); vis[a.x][a.y] = 0; vis[b.x][b.y] = 0; while (!q.empty()) &#123; now = q.front(); q.pop(); for (int i = 0; i &lt; 4; i++) &#123; next = now.move(i); if (next.x &gt;= 0 &amp;&amp; next.x &lt; n &amp;&amp; next.y &gt;= 0 &amp;&amp; next.y &lt; m &amp;&amp; map[next.x][next.y] == '#' &amp;&amp; vis[next.x][next.y] == inf) &#123; vis[next.x][next.y] = next.pos; q.push(next); &#125; &#125; &#125; int res = 0; for (int i = 0 ;i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (map[i][j] == '#') //这里就是找在层序遍历中距离res最大的每一个点，即最后的时间。 res = max(res,vis[i][j]); &#125; &#125; return res;&#125;int main()&#123; int T; cin &gt;&gt; T; int Case = 1; while (T--) &#123; cin &gt;&gt; n &gt;&gt; m; int cnt = 0; getchar(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j ++) &#123; cin &gt;&gt; map[i][j]; if (map[i][j] == '#') &#123; cnt ++; &#125; &#125; getchar(); &#125; if (cnt &lt;= 2) &#123; cout &lt;&lt; "Case " &lt;&lt; Case++ &lt;&lt; ": " &lt;&lt; 0 &lt;&lt; endl; continue; &#125; int res = inf; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (map[i][j] == '#') &#123; for (int l = 0; l &lt; n; l++) &#123; for (int k = 0; k &lt; m; k++) &#123; if (l &lt;= i &amp;&amp; k &lt;= j) continue; if (map[l][k] == '#')&#123; point p1(i,j,0); point p2(l,k,0); //这里就是找每一个距离最远的点中最小的那个值。 int ans = bfs(p1,p2); res = min(ans,res); &#125; &#125; &#125; &#125; &#125; &#125; if (cnt == inf) cout &lt;&lt; "Case " &lt;&lt; Case++ &lt;&lt; ": " &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; "Case " &lt;&lt; Case++ &lt;&lt; ": " &lt;&lt; cnt &lt;&lt; endl; &#125;&#125; 第二道题Fire! 其实吧，这道题刚出来的时候，我在想，因为两个BFS嘛，会不会用到并发编程,(原谅我的天真烂漫)，后面是直接用两个BFS分开放，用一个二维数组来记录火蔓延的时间，然后再用一个BFS来记录其的走向位置，。 本质上，还是属于一个bfs的模板题目。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;#define inf 0x3f3f3f3fstruct point &#123; int x,y,step; point() &#123;&#125; point (int a,int b,int c) : x(a),y(b), step(c) &#123;&#125; point move(int i) &#123; point tmp(x, y, step); switch (i) &#123; case 0: &#123; tmp.x = x + 1; break; &#125; case 1: &#123; tmp.x = x - 1; break; &#125; case 2: &#123; tmp.y = y + 1; break; &#125; case 3: &#123; tmp.y = y - 1; break; &#125; &#125; tmp.step++; return tmp; &#125;&#125;;const int maxn = 1010;int m,n;char map[maxn][maxn];bool vis[maxn][maxn];int _time[maxn][maxn];queue&lt;point&gt; q_fire;queue&lt;point&gt; q_joe;void bfs_fire() &#123; point now, next; while (!q_fire.empty()) &#123; now = q_fire.front(); q_fire.pop(); for (int i = 0; i &lt; 4 ; i++) &#123; next = now.move(i); if (next.x &gt;= 0 &amp;&amp; next.y &gt;= 0 &amp;&amp; next.x &lt; m &amp;&amp; next.y &lt; n &amp;&amp; _time[next.x][next.y] &gt; next.step &amp;&amp; (map[next.x][next.y] == '.' || map[next.x][next.y] == 'J')) &#123; q_fire.push(next); _time[next.x][next.y] = next.step; &#125; &#125; &#125;&#125;bool is_ok(int x,int y) &#123; return (x == 0 || y == 0 || x == m - 1 || y == n - 1);&#125;int bfs_joe() &#123; point now,next; while (!q_joe.empty()) &#123; now = q_joe.front(); q_joe.pop(); if (is_ok(now.x,now.y)) return now.step + 1; for (int i = 0; i &lt; 4; i ++) &#123; next = now.move(i); if (next.x &gt;= 0 &amp;&amp; next.y &gt;= 0 &amp;&amp; next.x &lt; m &amp;&amp; next.y &lt; n &amp;&amp; !vis[next.x][next.y] &amp;&amp; map[next.x][next.y] == '.' &amp;&amp; next.step &lt; _time[next.x][next.y])&#123; q_joe.push(next); vis[next.x][next.y] = true; &#125; &#125; &#125; return 0;&#125;void clear()&#123; memset(vis, false, sizeof(vis)); while (!q_fire.empty()) q_fire.pop(); while (!q_joe.empty()) q_joe.pop();&#125;int main()&#123; int T; cin &gt;&gt; T; while (T--) &#123; clear(); cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; map[i][j]; _time[i][j] = inf; if (map[i][j] == 'J') &#123; q_joe.push(point (i,j,0)); vis[i][j] = true; &#125; else if (map[i][j] == 'F') &#123; q_fire.push(point(i,j,0)); &#125; &#125; getchar(); &#125; bfs_fire(); int t = bfs_joe(); if (t) cout &lt;&lt; t &lt;&lt; endl; else cout &lt;&lt; "IMPOSSIBLE" &lt;&lt; endl; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[质数筛选问题]]></title>
    <url>%2F2019%2F03%2F05%2F%E8%B4%A8%E6%95%B0%E7%AD%9B%E9%80%89%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[关于质数的筛选问题，就像最先开始学习C语言一样，最先开始都是从1遍历到本身。 后来的优化版本就体现在遍历到本身的 根号下的倍数关系。但是 后来则发现有太多的重复循环次数，这里反而显得不是特别好，所以就出来一种新的筛选方法。 12345678910111213141516//最普通的埃式筛法memset(check, 0, sizeof(check));int tot = 0;for (int i = 2; i &lt;= n; ++i)&#123; if (!check[i]) &#123; prime[tot++] = i; &#125; // 下面其实用乘法和用加法都是一样的，而这里就是乘法的原因就在于，减少了循环次数 // 唯一没有被优化的地方就在于 每一个数字被重复标记了很多次，而后面的欧拉筛就会限制标记次数为一次 for (int j = i * i; j &lt;= n; j *= i) &#123; check[j] = 1; &#125;&#125; 鉴于上面所说的在进行一次优化，则优化体现在了减少重复次数 123456789101112131415161718192021222324252627282930//进阶版的线性筛法//质数数组int prime[MAXN];//判断每一个数 数组int check[MAXL];int tot = 0;memset(check, 0, sizeof(check));for (int i = 2; i &lt; MAXL; ++i)&#123; if (!check[i]) &#123; prime[tot++] = i; &#125; for (int j = 0; j &lt; tot; ++j) &#123; //大致意思就在于 将每一个数的与质数数组里面的数进行相乘，最后得到的结果存在check中去 //需要注意的就是 一旦当前的数能被整除的时候 就立马退出，这样代表每一个数字都会被自己的最小质因数给整除出来。 if (i * prime[j] &gt; MAXL) &#123; break; &#125; check[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; break; &#125; &#125;&#125; 接下来就是区间筛]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>质数筛选</tag>
        <tag>欧拉筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分享几道简单搜索题目]]></title>
    <url>%2F2019%2F03%2F05%2F%E5%88%86%E4%BA%AB%E5%87%A0%E9%81%93%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[不多做分析，其基本上都是一些 dfs 与 bfs上面的简单题目 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/************************************************************************* &gt; File Name: 棋盘问题.cpp &gt; Author: wangshuxiao &gt; Mail: wsx1128@outlook.com &gt; Created Time: Sun 3 Mar 15:05:54 2019 ************************************************************************/#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;int n,k;char board [10][10];int total;bool booked[10];int cnt;void dfs(int cur) &#123; if (cnt == k) &#123; total ++; return; &#125; if (cur &gt;= n) return ; for (int j = 0; j &lt; n; j ++) &#123; if (booked[j] == false &amp;&amp; board[cur][j] == '#') &#123; booked[j] = true; cnt ++; dfs(cur + 1); booked[j] = false; cnt --; &#125; &#125; //这种情况是防范 没有在首置位 有满足符合条件的数据 dfs(cur + 1);&#125;int main()&#123; while (cin &gt;&gt; n &gt;&gt; k) &#123; if (n == -1 &amp;&amp; k == -1) break; for (int i = 0; i &lt; n; i ++) &#123; booked[i] = false; for (int j = 0; j &lt; n; j ++) &#123; cin &gt;&gt; board[i][j]; &#125; &#125; total = 0,cnt = 0; dfs(0); cout &lt;&lt; total &lt;&lt; endl; &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/************************************************************************* &gt; File Name: DungeonMaster.cpp &gt; Author: wangshuxiao &gt; Mail: wsx1128@outlook.com &gt; Created Time: Sun 3 Mar 16:10:18 2019 ************************************************************************/#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;const int maxn = 35;int L,C,R;char map[maxn][maxn][maxn];int dis[maxn][maxn][maxn];struct position &#123; int x,y,z; int pos; position () = default; position(int x,int y,int z,int pos) : this.x(x), this.y(y),this.z(z),this.pos(pos) &#123;&#125;; position move (int i);&#125;;position position::move(int i)&#123; position tmp = *this; switch (i) &#123; case 1: tmp.x = x + 1; break; case 2: tmp.x = x - 1; break; case 3: tmp.y = y + 1; break; case 4: tmp.y = y - 1; break; case 5: tmp.z = z + 1; break; case 6: tmp.z = z - 1; break; &#125; return tmp;&#125;void bfs (int i,int j,int k) &#123; position beg (i,j,k,0); queue&lt;position&gt; q; q.push(beg); while (!q.empty()) &#123; position now = q.front(); q.pop(); dis[now.x][now.y][now.z] = now.pos; for (int i = 0; i &lt; 7; i++) &#123; position next = now.move(i); if (next.x &gt;= 0 &amp;&amp; next.x &lt; L &amp;&amp; next.y &gt;= 0 &amp;&amp; next.y &lt; R &amp;&amp; next.z &gt;= 0 &amp;&amp; next.z &lt; C &amp;&amp; dis[next.x][next.y][next.z] == -1 &amp;&amp; map[next.x][next.y][next.z] != '#') &#123; position empt (next.x,next.y,next.z,now.pos + 1); q.push(empt); &#125; &#125; &#125;&#125;int main()&#123; while (cin &gt;&gt; L &gt;&gt; R &gt;&gt; C) &#123; if (L == 0 &amp;&amp; R == 0 &amp;&amp; C == 0) &#123; break; int x1,y1,z1; int x2,y2,z2; for (int i = 0; i != L; i++) &#123; for (int j = 0; j != R; j++) &#123; for (int k = 0; k != C; k++) &#123; cin &gt;&gt; map[i][j][k]; dis[i][j][k] = -1; if (map[i][j][k] == 'S') &#123; x1 = i; y1 = j; z1 = k; &#125; if (map[i][j][k] == 'E') &#123; x2 = i; y2 = j; z2 = k; &#125; &#125; &#125; &#125; bfs(x1, y1, z1); if (dis[x2][y2][z2] == -1) cout &lt;&lt; "Trapped!" &lt;&lt; endl; else &#123; cout &lt;&lt; "Escaped in " &lt;&lt; dis[x2][y2][z2] &lt;&lt; " minute(s)." &lt;&lt; endl; &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;int m,n;const int maxn = 105;char map [maxn][maxn];int cnt;void dfs(int i,int j) &#123; if (i &lt; 0 &amp;&amp; i &gt;= m) return; if (j &lt; 0 &amp;&amp; j &gt;= n) return; if (map[i][j] == '@') &#123; map[i][j] = '.'; dfs(i-1,j); dfs(i+1,j); dfs(i,j-1); dfs(i,j+1); dfs(i-1,j-1); dfs(i-1,j+1); dfs(i+1,j-1); dfs(i+1,j+1); &#125;&#125;int main() &#123; while (cin &gt;&gt; m &amp;&amp; m != 0 &amp;&amp; cin &gt;&gt; n) &#123; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) cin &gt;&gt; map[i][j]; &#125; for (int i = 0; i &lt; m; i ++) &#123; for (int j = 0; j &lt; n ; j++) &#123; if (map[i][j] == '@')&#123; dfs(i,j); cnt++; &#125; &#125; &#125; cout &lt;&lt; cnt &lt;&lt; endl; cnt = 0; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stdio.h&gt;#include &lt;cstring&gt;using namespace std;int n, m;char map[201][201];int dis_Y[201][201];int dis_M[201][201];struct point&#123; int x, y, pos; point()&#123;&#125;; point(int a, int b, int c) : x(a), y(b), pos(c) &#123;&#125;&#125;;int _move[4][2] = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;void bfs(queue&lt;point&gt; *q, int x, int y, bool flag)&#123; point beg(x, y, 0); q-&gt;push(beg); point now, next; while (!q-&gt;empty()) &#123; now = q-&gt;front(); q-&gt;pop(); for (int i = 0; i &lt; 4; i++) &#123; next.x = now.x + _move[i][0]; next.y = now.y + _move[i][1]; if ( next.x &lt; n &amp;&amp; next.x &gt;= 0 &amp;&amp; next.y &lt; m &amp;&amp; next.y &gt;= 0 &amp;&amp; map[next.x][next.y] != '#') &#123; if (flag) &#123; if (dis_Y[next.x][next.y] == -1) &#123; next.pos = now.pos + 1; q -&gt; push(next); dis_Y[now.x][now.y] = now.pos + 1; &#125; &#125; else &#123; if (dis_M[next.x][next.y] == -1) &#123; next.pos = now.pos + 1; q -&gt; push(next); dis_M[now.x][now.y] = now.pos + 1; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; int yi_x, yi_y; int m_x, m_y; while (~scanf("%d %d", &amp;n, &amp;m)) &#123; pair&lt;int,int&gt; p; getchar(); vector&lt;pair&lt;int,int&gt; &gt;v; queue&lt;point&gt; qm; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; scanf("%c", &amp;map[i][j]); dis_M[i][j] = -1; dis_Y[i][j] = -1; if (map[i][j] == 'Y') &#123; yi_x = i; yi_y = j; &#125; else if (map[i][j] == 'M') &#123; m_x = i; m_y = j; &#125; else if (map[i][j] == '@') &#123; v.push_back(make_pair(i,j)); &#125; &#125; getchar(); &#125; dis_Y[yi_x][yi_y] = 0; dis_M[m_x][m_y] = 0; bfs(&amp;qm, yi_x, yi_y, true); bfs(&amp;qm, m_x, m_y, false); int Min = 9999999; int tmp = 0; for (auto it = v.begin(); it != v.end(); it++) &#123; tmp = dis_M[it-&gt;first][it-&gt;second] + dis_Y[it-&gt;first][it-&gt;second]; if (Min &gt; tmp) Min = tmp; &#125; printf("%d\n", Min * 11); &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;#include &lt;stack&gt;#include&lt;utility&gt;using namespace std;const int maxn = 6;int map [maxn][maxn];struct point&#123; int x , y , pos; pair&lt;int ,int &gt; p; point()&#123;&#125;; point(int a,int b,int c) : x(a),y(b),pos(c) &#123;&#125; point move(int i) &#123; point tmp = *this; switch (i) &#123; case 0: &#123; tmp.x += 1; break; &#125; case 1: &#123; tmp.x -= 1; break; &#125; case 2: &#123; tmp.y += 1; break; &#125; case 3: &#123; tmp.y -= 1; break; &#125; &#125; return tmp; &#125;&#125;;int main()&#123; point m[maxn][maxn]; for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0 ; j &lt; 5; j++) &#123; cin &gt;&gt; map[i][j]; m[i][j].x = i; m[i][j].y = j; m[i][j].pos = -1; &#125; &#125; queue&lt;point&gt;q; point beg(0,0,0); q.push(beg); while (!q.empty()) &#123; point now = q.front(); q.pop(); //m[now.x][now.y].pos = now.pos; for (int i = 0; i &lt; 4; i++) &#123; point next = now.move(i); if (next.x &lt; 5 &amp;&amp; next.x &gt;= 0 &amp;&amp; next.y &lt; 5 &amp;&amp; next.y &gt;= 0 &amp;&amp; map[next.x][next.y] != 1 &amp;&amp; m[next.x][next.y].pos == -1) &#123; m[next.x][next.y].pos = now.pos+1; m[next.x][next.y].p = make_pair(now.x,now.y); q.push(m[next.x][next.y]); &#125; &#125; &#125; stack&lt;pair&lt;int ,int&gt; &gt; s; s.push(make_pair(4,4)); pair&lt;int,int&gt;x = m[4][4].p; int y = m[4][4].pos; while (y --) &#123; s.push(x); x = m[x.first][x.second].p; &#125; while (!s.empty()) &#123; x = s.top(); s.pop(); cout &lt;&lt; "(" &lt;&lt; x.first &lt;&lt; ", " &lt;&lt; x.second &lt;&lt; ")" &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>bfs</tag>
        <tag>dfs</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8_pazzle]]></title>
    <url>%2F2019%2F02%2F26%2F8-pazzle%2F</url>
    <content type="text"><![CDATA[此为第四周普林斯顿算法课大作业，基本思路是基于优先队列的A*算法。所谓A*算法，就是启发式算法，人工智能基础，就是将每一步周围的一步之类的情况全部存储起来，然后放进优先队列里面进行比较，然后依次出队，算出最终的结果相当于一个小博弈。 首先，先看题目。 直接贴出代码 Board.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148package Programming_Assignment_4;import edu.princeton.cs.algs4.StdRandom;import java.util.ArrayList;public class Board &#123; private int [][] blocks; private final int dimension; public Board(int[][] blocks) &#123; if (blocks == null) throw new NullPointerException("Null blocks"); dimension = blocks.length; this.blocks = new int[dimension][dimension]; for (int i = 0; i &lt; dimension; i++) &#123; this.blocks[i] = blocks[i].clone(); &#125; &#125; public int dimension() &#123; return dimension; &#125; public int hamming() &#123; int cnt = 0; for (int i = 0; i &lt; dimension; i++) &#123; for (int j = 0; j &lt; dimension; j++) &#123; if (blocks[i][j] == 0) continue; if (blocks[i][j] != i * dimension + j + 1) cnt ++; &#125; &#125; return cnt; &#125; public int manhattan() &#123; int cnt = 0; for (int i = 0; i &lt; dimension; i++) &#123; for (int j = 0; j &lt; dimension; j++) &#123; if (blocks[i][j] == 0) continue; if (blocks[i][j] != i * dimension + j + 1) &#123; int val = blocks[i][j]; int row = (val - 1) / dimension; int col = (val - 1) % dimension; int dif = Math.abs(row - i) + Math.abs(col - j); cnt += dif; &#125; &#125; &#125; return cnt; &#125; public boolean isGoal() &#123; return hamming() == 0; &#125; private void swap (int i1,int r1,int i2,int r2) &#123; int tmp = blocks[i1][r1]; blocks[i1][r1] = blocks[i2][r2]; blocks[i2][r2] = tmp; &#125; public Board twin() &#123; Board twinBoard = new Board(blocks); int row = 0,col = 0; if (blocks[row][col] == 0) col++; for (int i = 0; i &lt; dimension; i++) &#123; for (int j = 0; j &lt; dimension; j++) &#123; if (blocks[i][j] != 0 &amp;&amp; blocks[i][j] != blocks[row][col]) &#123; twinBoard.swap(i,j,row,col); return twinBoard; &#125; &#125; &#125; return twinBoard; &#125; public boolean equals(Object y) &#123; if (y == null) return false; if (y.getClass().isInstance(this)) &#123; Board tmp = (Board) y; if (tmp.dimension != this.dimension) return false; for (int i = 0; i &lt; dimension; i++) &#123; for (int j = 0; j &lt; dimension; j++) &#123; if (tmp.blocks[i][j] != this.blocks[i][j]) return false; &#125; &#125; return true; &#125; return false; &#125; public Iterable&lt;Board&gt; neighbors() &#123; ArrayList&lt;Board&gt; neighbors = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; dimension; i++) &#123; for (int j = 0; j &lt; dimension; j++) &#123; if (blocks[i][j] == 0) &#123; if (i &gt; 0) &#123; Board tmpUp = new Board(blocks); tmpUp.swap(i,j,i - 1,j); neighbors.add(tmpUp); &#125; if (i &lt; dimension - 1) &#123; Board tmpDown = new Board(blocks); tmpDown.swap(i,j,i + 1,j); neighbors.add(tmpDown); &#125; if (j &gt; 0) &#123; Board tmpLeft = new Board(blocks); tmpLeft.swap(i,j,i,j - 1); neighbors.add(tmpLeft); &#125; if (j &lt; dimension - 1) &#123; Board tmpRight = new Board(blocks); tmpRight.swap(i,j,i,j + 1); neighbors.add(tmpRight); &#125; break; &#125; &#125; &#125; return neighbors; &#125; public String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append(dimension + "\n"); for (int row = 0; row &lt; dimension; row++) &#123; for (int col = 0; col &lt; dimension; col++) &#123; sb.append(String.format("%2d ", blocks[row][col])); &#125; sb.append("\n"); &#125; return sb.toString(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package Programming_Assignment_4;import edu.princeton.cs.algs4.In;import edu.princeton.cs.algs4.MinPQ;import edu.princeton.cs.algs4.Stack;import edu.princeton.cs.algs4.StdOut;public class Solver &#123; private BoardNode current; private BoardNode twinCurrent; private class BoardNode implements Comparable&lt;BoardNode&gt; &#123; private Board item; private int priority; private int move; private BoardNode preBoard; public BoardNode (Board item,BoardNode preBoard) &#123; this.item = item; this.preBoard = preBoard; if (preBoard == null) this.move = 0; else this.move = preBoard.move + 1; this.priority = this.move + item.manhattan(); &#125; public int compareTo(BoardNode b) &#123; return Integer.compare(this.priority,b.priority); &#125; &#125; private void putNeighbors (BoardNode current,MinPQ&lt;BoardNode&gt;pq) &#123; Iterable&lt;Board&gt; neighbors = current.item.neighbors(); for (Board it : neighbors) &#123; if (current.preBoard == null || !it.equals(current.preBoard.item)) &#123; pq.insert(new BoardNode(it,current)); &#125; &#125; &#125; public Solver(Board initial) &#123; if (initial == null) &#123; throw new IllegalArgumentException("Constructor argument Board is null!"); &#125; current = new BoardNode(initial,null); twinCurrent = new BoardNode(initial.twin(),null); MinPQ&lt;BoardNode&gt; pq = new MinPQ&lt;BoardNode&gt;(); MinPQ&lt;BoardNode&gt; twinpq = new MinPQ&lt;BoardNode&gt;(); pq.insert(current); twinpq.insert(twinCurrent); while (true) &#123; current = pq.delMin(); if (current.item.isGoal()) break; putNeighbors(current,pq); twinCurrent = twinpq.delMin(); if (twinCurrent.item.isGoal()) break; putNeighbors(twinCurrent,twinpq); &#125; &#125; public boolean isSolvable() &#123; return current.item.isGoal(); &#125; public int moves() &#123; if (current.item.isGoal()) return current.move; return -1; &#125; public Iterable&lt;Board&gt; solution() &#123; if (isSolvable()) &#123; Stack&lt;Board&gt; stack = new Stack&lt;&gt;(); BoardNode node = current; while (node != null) &#123; stack.push(node.item); node = node.preBoard; &#125; return stack; &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
        <tag>普林斯顿算法课</tag>
        <tag>A*算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于java的碰撞物理引擎]]></title>
    <url>%2F2019%2F02%2F26%2F%E5%9F%BA%E4%BA%8Ejava%E7%9A%84%E7%A2%B0%E6%92%9E%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[首先，贴出效果图，基于java的物理引擎。 完成这个效果需要考虑几件事情。 第一步显示定义出每一个颗粒，具体的形状，颜色，位置，速度…具体API如下： 其实这里最关键的是上面的预测碰撞时间的算法，应用了大学物理的相关知识。将三种碰撞的预测时间算出来，另外并依次赋予三种碰撞的效果。然后将其放入一个可比较的事件中，通过遍历每一个球与其他球预测碰撞情况，放入优先队列中再依次处理。 第一种 两球相撞1234567891011121314151617181920212223242526272829303132333435363738//时间//注意下面几个地方的剪枝public double timeToHitBall (Ball that) &#123; if (this == that) return INFINITY; double dx = that.pos_x - this.pos_x; double dy = that.pos_y - this.pos_y; double dvx = that.vec_x - this.vec_x; double dvy = that.vec_y - this.vec_y; double dvdr = dx * dvx + dy * dvy; if (dvdr &gt; 0) return INFINITY; double dvdv = dvx * dvx + dvy * dvy; if (dvdv == 0) return INFINITY; double drdr = dx * dx + dy * dy; double sigma = this.radius + that.radius; double d = (dvdr * dvdr) - dvdv * (drdr - sigma * sigma); if (d &lt; 0) return INFINITY; return -(dvdr + Math.sqrt(d)) / dvdv; &#125;//碰撞后的效果public void bounceOff (Ball that) &#123; double dx = that.pos_x - this.pos_x; double dy = that.pos_y - this.pos_y; double dvx = that.vec_x - this.vec_x; double dvy = that.vec_y - this.vec_y; double dvdr = dx * dvx + dy * dvy; double dist = this.radius + that.radius; double J = 2 * this.mass * that.mass * dvdr / ((this.mass + that.mass) * dist); double Jx = J * dx / dist; double Jy = J * dy / dist; this.vec_x += Jx / this.mass; this.vec_y += Jy / this.mass; that.vec_x -= Jx / that.mass; that.vec_y -= Jy / that.mass; this.cnt ++; that.cnt ++; &#125; 第二种与墙体发生碰撞12345678910111213141516171819202122232425//碰撞垂直墙的时间public double timeToHitVerticalWall() &#123; if (vec_x &gt; 0) return (border - pos_x - radius) / vec_x; else if (vec_x &lt; 0) return (radius - pos_x) / vec_x; else return INFINITY;&#125;//碰撞水平墙的时间public double timeToHitHorizontalWall() &#123; if (vec_y &gt; 0) return (border - pos_y - radius) / vec_y; else if (vec_y &lt; 0) return (radius - pos_y) / vec_y; return INFINITY;&#125;//碰撞效果public void bounceOffVerticalWall () &#123; this.cnt ++; this.vec_x = - this.vec_x;&#125;public void bounceoffHorizontalWall () &#123; this.cnt ++; this.vec_y = - this.vec_y;&#125; 以下便是第一个球体类型的完整代码Ball.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121import edu.princeton.cs.algs4.StdDraw;import edu.princeton.cs.algs4.StdRandom;import java.awt.*;public class Ball &#123; //球的横纵坐标 private double pos_x; private double pos_y; //球的横纵方向上面的速度 private double vec_x; private double vec_y; //球的半径 private final double radius; //球的质量 private final double mass; //边界长度 private final double border; //球的颜色 private final Color color; //碰撞次数 private int cnt = 0; //限定一个最大值 private static final double INFINITY = Double.POSITIVE_INFINITY; public Ball () &#123; pos_x = StdRandom.uniform(0.0, 1.0); pos_y = StdRandom.uniform(0.0, 1.0); vec_x = StdRandom.uniform(-0.005, 0.005); vec_y = StdRandom.uniform(-0.005, 0.005); radius = 0.01; mass = 0.5; border = 1; color = Color.BLACK; &#125; public Ball (double px,double py,double vx,double vy,double radius,double mass,double border,Color color) &#123; this.pos_x = px; this.pos_y = py; this.vec_x = vx; this.vec_y = vy; this.radius = radius; this.mass = mass; this.border = border; this.color = color; &#125; public void draw() &#123; StdDraw.filledCircle(pos_x,pos_y,radius); StdDraw.setPenColor(color); &#125; public void move (double dt) &#123; pos_x = pos_x + vec_x * dt; pos_y = pos_y + vec_y * dt; &#125; public double timeToHitBall (Ball that) &#123; if (this == that) return INFINITY; double dx = that.pos_x - this.pos_x; double dy = that.pos_y - this.pos_y; double dvx = that.vec_x - this.vec_x; double dvy = that.vec_y - this.vec_y; double dvdr = dx * dvx + dy * dvy; if (dvdr &gt; 0) return INFINITY; double dvdv = dvx * dvx + dvy * dvy; if (dvdv == 0) return INFINITY; double drdr = dx * dx + dy * dy; double sigma = this.radius + that.radius; double d = (dvdr * dvdr) - dvdv * (drdr - sigma * sigma); if (d &lt; 0) return INFINITY; return -(dvdr + Math.sqrt(d)) / dvdv; &#125; public double timeToHitVerticalWall() &#123; if (vec_x &gt; 0) return (border - pos_x - radius) / vec_x; else if (vec_x &lt; 0) return (radius - pos_x) / vec_x; else return INFINITY; &#125; public double timeToHitHorizontalWall() &#123; if (vec_y &gt; 0) return (border - pos_y - radius) / vec_y; else if (vec_y &lt; 0) return (radius - pos_y) / vec_y; return INFINITY; &#125; public void bounceOff (Ball that) &#123; double dx = that.pos_x - this.pos_x; double dy = that.pos_y - this.pos_y; double dvx = that.vec_x - this.vec_x; double dvy = that.vec_y - this.vec_y; double dvdr = dx * dvx + dy * dvy; double dist = this.radius + that.radius; double J = 2 * this.mass * that.mass * dvdr / ((this.mass + that.mass) * dist); double Jx = J * dx / dist; double Jy = J * dy / dist; this.vec_x += Jx / this.mass; this.vec_y += Jy / this.mass; that.vec_x -= Jx / that.mass; that.vec_y -= Jy / that.mass; this.cnt ++; that.cnt ++; &#125; public int count() &#123; return cnt; &#125; public void bounceOffVerticalWall () &#123; this.cnt ++; this.vec_x = - this.vec_x; &#125; public void bounceoffHorizontalWall () &#123; this.cnt ++; this.vec_y = - this.vec_y; &#125;&#125; 其次，我们需要对以上球体类进行一个包装，将其赋予可比较的特性。因为从宏观上来看，我们需要比较的是每一个球体的碰撞情况，所以，用一个事件包含其诸多特性 12345678910111213141516171819202122232425262728private static class Collison_Event implements Comparable&lt;Collison_Event&gt;&#123; private final Ball a,b; private final double time; private final int countA,countB; public Collison_Event (Ball a,Ball b,double time) &#123; this.time = time; this.a = a; this.b = b; if (a != null) countA = a.count(); else countA = -1; if (b != null) countB = b.count(); else countB = -1; &#125; public int compareTo(Collison_Event that) &#123; return Double.compare(this.time,that.time); &#125; public boolean isValid () &#123; if (this.time == Double.POSITIVE_INFINITY) return false; else &#123; if (a != null &amp;&amp; a.count() != countA) return false; if (b != null &amp;&amp; b.count() != countB) return false; return true; &#125; &#125; &#125; 最后就是整个包含类，就称为一个系统思路就是预测碰撞的时间，放入优先队列中，另外，需要注意的核心的一点就是，其采用了时间限制，大于某个时间的球体碰撞即不放进队列中，避免开销。还有，不要忘记重绘的条件，在这里加入一个HZ变量控制帧数。 以下是第二个类的全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121import edu.princeton.cs.algs4.MinPQ;import edu.princeton.cs.algs4.StdDraw;import java.awt.Color;public class CollisionSystem &#123; protected MinPQ&lt;Collison_Event&gt; pq; //相当于一个总控时间的一个参数，后面所有关于时间的参数都需要加上一个这个 protected double t = 0.0; protected Ball[] balls; //这里就相当于一个控制每一帧数的频率控制 private static final double HZ = 0.5; public CollisionSystem(Ball[] balls) &#123; this.balls = balls.clone(); &#125; //这里新加上的一个参数 limit 是控制一些完全没必要的事件 //意思就是剔除那些需要太长时间才会相撞的球体 protected void pridict (Ball b,double limit) &#123; if (b == null) return; for (int i = 0;i &lt; balls.length;i++)&#123; double dt = b.timeToHitBall(balls[i]); if (t + dt &lt;= limit) pq.insert(new Collison_Event(b,balls[i],dt + t)); &#125; double dxt = b.timeToHitHorizontalWall() + t; double dyt = b.timeToHitVerticalWall() + t; if (dxt &lt;= limit) pq.insert(new Collison_Event(b,null,dxt)); if (dyt &lt;= limit) pq.insert(new Collison_Event(null,b,dyt)); &#125; protected void redrew(double limit) &#123; StdDraw.clear(); for (int i = 0;i &lt; balls.length;i++) &#123; balls[i].draw(); &#125; StdDraw.show(); StdDraw.pause(20); if (t &lt; limit) &#123; pq.insert(new Collison_Event(null,null,t + 1.0 / HZ)); &#125; &#125; protected void simulate (double limit) &#123; pq = new MinPQ&lt;Collison_Event&gt;(); for (int i = 0; i &lt; balls.length; i++) &#123; pridict(balls[i],limit); &#125; pq.insert(new Collison_Event(null,null,0)); while (!pq.isEmpty()) &#123; Collison_Event event = pq.delMin(); if (!event.isValid()) continue; //将其他的点全部移动 for (int i = 0; i &lt; balls.length; i++) &#123; balls[i].move(event.time - t); &#125; t = event.time; if (event.a != null &amp;&amp; event.b != null) event.a.bounceOff(event.b); else if (event.a == null &amp;&amp; event.b != null) event.b.bounceOffVerticalWall(); else if (event.a != null &amp;&amp; event.b == null) event.a.bounceoffHorizontalWall(); else if (event.a == null &amp;&amp; event.b == null) redrew(limit); pridict(event.a,limit); pridict(event.b,limit); &#125; &#125; private static class Collison_Event implements Comparable&lt;Collison_Event&gt;&#123; private final Ball a,b; private final double time; private final int countA,countB; public Collison_Event (Ball a,Ball b,double time) &#123; this.time = time; this.a = a; this.b = b; if (a != null) countA = a.count(); else countA = -1; if (b != null) countB = b.count(); else countB = -1; &#125; public int compareTo(Collison_Event that) &#123; return Double.compare(this.time,that.time); &#125; public boolean isValid () &#123; if (this.time == Double.POSITIVE_INFINITY) return false; else &#123; if (a != null &amp;&amp; a.count() != countA) return false; if (b != null &amp;&amp; b.count() != countB) return false; return true; &#125; &#125; &#125; public static void main(String [] args)&#123; StdDraw.setCanvasSize(600,600); //这个是清楚缓冲 帮助改善运动的 StdDraw.enableDoubleBuffering(); Ball[] balls = new Ball[100]; for (int i = 0;i &lt; 100; i++) &#123; balls[i] = new Ball(); &#125; CollisionSystem system = new CollisionSystem(balls); system.simulate(100000); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
        <tag>物理引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普林斯顿算法课第四周小作业]]></title>
    <url>%2F2019%2F02%2F24%2F%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%B0%8F%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[第四周的小作业主要围绕优先队列以及基于优先队列的Taxicabnumber。先贴出关于优先队列的代码MaxPQ.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149package Interview_Question_Week4.PQ;import edu.princeton.cs.algs4.StdIn;import edu.princeton.cs.algs4.StdOut;import java.util.Comparator;import java.util.Iterator;import java.util.NoSuchElementException;public class MaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt; implements Iterable&lt;Key&gt; &#123; protected Key[] key; protected int len; private Comparator&lt;Key&gt; comparator; public MaxPQ(int init)&#123; key = (Key[]) new Object[1 + init]; len = 0 + init; &#125; public MaxPQ (int init , Comparator&lt;Key&gt; rule)&#123; comparator = rule; key = (Key[]) new Object[1 + init]; len = 0 + init; &#125; private boolean less(int i,int j)&#123; if (comparator == null)&#123; return key[i].compareTo(key[j]) &lt; 0; &#125; return comparator.compare(key[i],key[j]) &lt; 0; &#125; protected void change(int i,int j) &#123; Key temp = key[i]; key[i] = key[j]; key[j] = temp; &#125; protected void sink(int k)&#123; while (k * 2 &lt;= len) &#123; int j = k * 2; if (j &lt; len &amp;&amp; less(j,j+1)) j++; if (!less(k,j)) break; change(k,j); k = j; &#125; &#125; protected void up(int k)&#123; while (k &gt; 1 &amp;&amp; less(k / 2,k)) &#123; change(k, k / 2); k = k / 2; &#125; &#125; private void resize(int n) &#123; Key[] temp = (Key[]) new Object[n]; for (int i = 1; i &lt;= len;i++) &#123; temp[i] = key[i]; &#125; key = temp; &#125; public boolean isEmpty()&#123; return len == 0; &#125; public Key get(int n) &#123; return key[n]; &#125; public int size() &#123; return len; &#125; public void insert(Key item) &#123; if (item == null) throw new IllegalArgumentException("wrong"); if (len + 1 == key.length) resize(2 * key.length); key[++len] = item; up(len); assert isMaxHeap(1); &#125; // 这里是帮助后面完成一个assert判断而存在的 private boolean isMaxHeap(int k) &#123; if (k &gt; len) return true; int left = 2*k; int right = 2*k + 1; if (left &lt;= len &amp;&amp; less(k, left)) return false; if (right &lt;= len &amp;&amp; less(k, right)) return false; return isMaxHeap(left) &amp;&amp; isMaxHeap(right); &#125; public Key delMax() &#123; if (isEmpty()) throw new NoSuchElementException(); Key item = key[1]; key[1] = null; change(1,len--); sink(1); if (len + 1 &lt;= key.length / 4 &amp;&amp; len &gt; 0 ) resize(key.length / 2); assert isMaxHeap(1); return item; &#125; public Iterator&lt;Key&gt; iterator ()&#123; return new heapIterator(); &#125; private class heapIterator implements Iterator&lt;Key&gt;&#123; private MaxPQ&lt;Key&gt; copy; public heapIterator() &#123; if (comparator == null) &#123; copy = new MaxPQ&lt;Key&gt;(len); &#125; else copy = new MaxPQ&lt;Key&gt;(len,comparator); for (int i = 0;i &lt; len;i++)&#123; copy.insert(key[i]); &#125; &#125; public boolean hasNext() &#123; if (!isEmpty()) return true; return false; &#125; public Key next() &#123; if (!hasNext()) throw new NoSuchElementException(); return copy.delMax(); &#125; @Override public void remove() &#123; throw new UnsupportedOperationException(); &#125; &#125; public static void main(String[] args) &#123; edu.princeton.cs.algs4.MaxPQ&lt;String&gt; pq = new edu.princeton.cs.algs4.MaxPQ&lt;String&gt;(); while (!StdIn.isEmpty()) &#123; String item = StdIn.readString(); if (!item.equals("-")) pq.insert(item); else if (!pq.isEmpty()) StdOut.print(pq.delMax() + " "); &#125; StdOut.println("(" + pq.size() + " left on pq)"); &#125;&#125; 随机优先队列 RandomPQ.java 12345678910111213141516171819202122232425262728package Interview_Question_Week4;import Interview_Question_Week4.PQ.MaxPQ;import edu.princeton.cs.algs4.StdRandom;public class RandomPQ&lt;Key extends Comparable&lt;Key&gt;&gt; extends MaxPQ &#123; private int len; public RandomPQ (int n) &#123; super(n); this.len = super.len; &#125; public Comparable&lt;Key&gt; sample() &#123; int n = StdRandom.uniform(len + 1); return super.get(n); &#125; public Comparable&lt;Key&gt; randomRemove () &#123; int n = StdRandom.uniform(len + 1); Comparable&lt;Key&gt; item = key[n]; change(n,len--); key[len + 1] = null; sink(n); return item; &#125;&#125; 优先队列的一些应用PriorityQueue.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class PriorityQueue &#123; private MaxPQ&lt;Integer&gt; left; private MinPQ&lt;Integer&gt; right; public PriorityQueue() &#123; left = new MaxPQ&lt;Integer&gt;(); right = new MinPQ&lt;Integer&gt;(); &#125; public double findMedian() &#123; int L = left.size(); int R = right.size(); if (L == R) return (left.max() + right.min()) / 2; else if (L &gt; R) return left.max(); else return right.min(); &#125; public void insert(int key) &#123; double median = findMedian(); int L = left.size(); int R = right.size(); if (key &lt;= median) &#123; left.insert(key); if (L - R &gt; 1) &#123; right.insert(left.delMax()); &#125; &#125; else &#123; right.insert(key); if (R - L &gt; 1) &#123; left.insert(right.delMin()); &#125; &#125; &#125; public void removeMedian() &#123; int L = left.size(); int R = right.size(); if (L &gt; R) &#123; left.delMax(); &#125; else &#123; right.delMin(); &#125; &#125;&#125; 有四个数 a,b,c,d 满足 a^3 + b^3 = c^3 +d^3，然后再给一个数 n，求出 n之内所有满足上述等式的四个数 思路此处就是运用优先队列，将没两个数的立方和加起来，然后再以立方和的大小来进行排序，作为最后排序的标准，最后进行比较，可做优化。 代码如下： Taxicab 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package Interview_Question_Week4;import edu.princeton.cs.algs4.MinPQ;import edu.princeton.cs.algs4.StdOut;public class Taxicab implements Comparable&lt;Taxicab&gt; &#123; private final int a; private final int b; private final int cube; public Taxicab(int x,int y) &#123; this.a = x; this.b = y; this.cube = x * x * x + y * y * y; &#125; @Override public int compareTo(Taxicab a) &#123; if (this.cube &lt; a.cube) return -1; if (this.cube &gt; a.cube) return 1; if (this.a &lt; a.a) return -1; if (this.a &gt; a.a) return 1; return 0; &#125; @Override public String toString() &#123; return "number: " + cube + " (" + a + ", " + b + ")"; &#125; public void findTaxicabNumber(int N) &#123; MinPQ&lt;Taxicab&gt; candidate = new MinPQ&lt;Taxicab&gt;(); for (int i = 1;i &lt;= N;i++) &#123; candidate.insert(new Taxicab(i,i)); &#125; int cnt = 1; Taxicab pre = new Taxicab(0,0); while (!candidate.isEmpty()) &#123; Taxicab curr = candidate.delMin(); if (curr == pre) &#123; cnt ++; if (cnt == 2) &#123; StdOut.print(pre.cube + "=" + pre); &#125; StdOut.print(" = " + curr); &#125; else &#123; if (cnt &gt; 1) StdOut.println(); cnt = 1; &#125; pre = curr; if (curr.a &lt; N) candidate.insert(new Taxicab(curr.a,curr.b + 1)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
        <tag>普林斯顿算法课</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CollinearPoint]]></title>
    <url>%2F2019%2F02%2F24%2FCollinearPoint%2F</url>
    <content type="text"><![CDATA[CollinearPoint—–普林斯顿第三周大作业第三周的大作业 有点意思，基于排序的一次简单优化，先看题目。 一步一步来，根据题目首先写出一个点的类，这个类要包含比较，并且，要包含求出两个类之间斜率的方法。Point.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package Programming_Assignment_3;import edu.princeton.cs.algs4.StdDraw;import edu.princeton.cs.algs4.StdRandom;import java.util.Arrays;import java.util.Comparator;public class Point implements Comparable&lt;Point&gt; &#123; private final int x; private final int y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; public void draw() &#123; StdDraw.point(x,y); &#125; public void drawTo(Point that) &#123; StdDraw.line(x,y,that.x,that.y); &#125; public String toString() &#123; return "(" + x + ", " + y + ")"; &#125; public int compareTo(Point that) &#123; if (y &gt; that.y) return 1; else if (y &lt; that.y) return -1; else if (x &gt; that.x) return 1; else if (x &lt; that.x) return -1; else return 0; &#125; public double slopeTo(Point that) &#123; if (x == that.x) &#123; if (y == that.y) return Double.NEGATIVE_INFINITY; else return Double.POSITIVE_INFINITY; &#125; if (y == that.y) return 0 / 1.0; return (y - that.y) * 1.0 / (x - that.x); &#125; private class SlopeOrder implements Comparator&lt;Point&gt;&#123; public int compare(Point p, Point q) &#123; if (slopeTo(p) &lt; slopeTo(q)) return -1; if (slopeTo(p) &gt; slopeTo(q)) return +1; return 0; &#125; &#125; public Comparator&lt;Point&gt; slopeOrder() &#123; return new SlopeOrder(); &#125; public static void main(String[] args) &#123; int x0 = Integer.parseInt(args[0]); int y0 = Integer.parseInt(args[1]); int n = Integer.parseInt(args[2]); StdDraw.setCanvasSize(800, 800); StdDraw.setXscale(0, 50); StdDraw.setYscale(0, 50); StdDraw.setPenRadius(0.005); StdDraw.enableDoubleBuffering(); Point[] points = new Point[n]; for (int i = 0; i &lt; n; i++) &#123; int x = StdRandom.uniform(50); int y = StdRandom.uniform(50); points[i] = new Point(x, y); points[i].draw(); &#125; // draw p = (x0, x1) in red Point p = new Point(x0, y0); StdDraw.setPenColor(StdDraw.RED); StdDraw.setPenRadius(0.02); p.draw(); // draw line segments from p to each point, one at a time, in polar order StdDraw.setPenRadius(); StdDraw.setPenColor(StdDraw.BLUE); Arrays.sort(points, p.slopeOrder()); for (int i = 0; i &lt; n; i++) &#123; p.drawTo(points[i]); StdDraw.show(); StdDraw.pause(100); &#125; &#125;&#125; 接下来就是直线的类，这两个类都比较简单，这里就直接贴出代码LineSegment.java123456789101112131415161718192021222324package Programming_Assignment_3;public class LineSegment &#123; private final Point a; private final Point b; public LineSegment(Point p, Point q) &#123; if (p == null || q == null) throw new java.lang.IllegalArgumentException(); a = p; b = q; &#125; public void draw() &#123; a.drawTo(b); &#125; public String toString() &#123; return a + " -&gt; " + b; &#125; public int hasCode() &#123; throw new UnsupportedOperationException(); &#125;&#125; 最后就是问题的求解方法。问题 需要知道平面上的点，有哪些点是在一条直线上的，第一种方法，暴力法，直接用四种循环写出答案。 BruteCollinearPoints.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package Programming_Assignment_3;import java.util.ArrayList;import java.util.Arrays;public class BruteCollinearPoints &#123; private Point[] copies; private ArrayList&lt;LineSegment&gt; lineSegments = new ArrayList&lt;LineSegment&gt;(); // finds all line segments containing 4 points public BruteCollinearPoints(final Point[] points) &#123; if (points == null) throw new java.lang.IllegalArgumentException(); copies = new Point[points.length]; for (int i = 0; i &lt; points.length; i++) &#123; copies[i] = points[i]; &#125; // sort by y-coordinate // the endpoints are the first and last points Arrays.sort(copies); // after sort then can check if duplicate for (int i = 0; i &lt; copies.length - 1; i++) if (copies[i].compareTo(copies[i+1]) == 0) throw new java.lang.IllegalArgumentException(); for (int ip = 0; ip &lt; copies.length-3; ip++) &#123; for (int iq = ip + 1; iq &lt; copies.length-2; iq++) &#123; double slopeP2Q = copies[ip].slopeTo(copies[iq]); for (int ir = iq + 1; ir &lt; copies.length-1; ir++) &#123; double slopeQ2R = copies[iq].slopeTo(copies[ir]); if (slopeP2Q != slopeQ2R) continue; for (int is = ir + 1; is &lt; copies.length; is++) &#123; double slopeR2S = copies[ir].slopeTo(copies[is]); // if 3 of 4's slopes are equal then 4 points are colllinear if (slopeP2Q == slopeR2S) lineSegments.add(new LineSegment(copies[ip], copies[is])); &#125; &#125; &#125; &#125; &#125; // the number of line segments public int numberOfSegments() &#123; return lineSegments.size(); &#125; // the line segments public LineSegment[] segments() &#123; LineSegment[] result = new LineSegment[lineSegments.size()]; for (int i = 0; i &lt; lineSegments.size(); i++) &#123; result[i] = lineSegments.get(i); &#125; return result; &#125; 优化的方法就是基于排序，将每一个点都与已经排好序的点集进行比较，按照一定的顺序进行比较可以省略很多。FastCollinearPoints.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package Programming_Assignment_3;import java.util.ArrayList;import java.util.Arrays;public class FastCollinearPoints &#123; private Point[] copies; private ArrayList&lt;LineSegment&gt; lineSegments = new ArrayList&lt;LineSegment&gt;(); // finds all line segments containing 4 or more points public FastCollinearPoints(Point[] points) &#123; if (points == null) throw new java.lang.IllegalArgumentException(); copies = new Point[points.length]; for (int i = 0; i &lt; points.length; i++) &#123; copies[i] = points[i]; &#125; // sort by y-coordinate // the endpoints are the first and last points Arrays.sort(copies); // after sort then can check if duplicate for (int i = 0; i &lt; copies.length - 1; i++) if (copies[i].compareTo(copies[i+1]) == 0) throw new java.lang.IllegalArgumentException(); for (int i = 0; i &lt; copies.length - 1; i++) &#123; Point origin = copies[i]; // Think of p as the origin. double[] slopes = new double[copies.length - 1 - i]; Point[] others = new Point[copies.length - 1 - i]; for (int j = 0; j &lt; copies.length - 1 - i; j++) others[j] = copies[j + 1 + i]; // For each other point q, determine the slope it makes with p for (int j = 0; j &lt; others.length; j++) slopes[j] = origin.slopeTo(others[j]); // Sort the points according to the slopes they makes with p Arrays.sort(others, origin.slopeOrder()); Arrays.sort(slopes); // Check if any 3 (or more) adjacent points in the // sorted order have equal slopes with respect to p // If so, these points, together with p, are collinear for (int cnt_same = 0, j = 0; j &lt; slopes.length - 1; j++) &#123; if (slopes[j] == slopes[j+1]) &#123; cnt_same++; &#125; if (cnt_same &gt;= 2) &#123; lineSegments.add(new LineSegment(origin, others[j + 1])); break; &#125; &#125; &#125; &#125; // the number of line segments public int numberOfSegments() &#123; return lineSegments.size(); &#125; // the line segments public LineSegment[] segments() &#123; LineSegment[] result = new LineSegment[lineSegments.size()]; for (int i = 0; i &lt; lineSegments.size(); i++) &#123; result[i] = lineSegments.get(i); &#125; return result; &#125;&#125; 总结由于暴力做法运算了很多原本不需要的循环，相当于是做了很多重复功，所以不招收待见，而基于优化的版本进行了优化，所以在实际应用中是可取的。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
        <tag>普林斯顿算法课</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普林斯顿算法课第三周小作业]]></title>
    <url>%2F2019%2F02%2F24%2F%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E4%B8%89%E5%91%A8%E5%B0%8F%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[第三周主要讲的是归并排序和快速排序，这里在C++里面已经总结过，直接贴出代码。CountInversions 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package Interview_Question_Week3;import java.util.Arrays;public class CountInversions &#123; private Comparable[] aux; private int inversion = 0; private boolean less (Comparable a,Comparable b)&#123; return a.compareTo(b) &lt; 0; &#125; public int get_num(Comparable[] a) &#123; aux = new Comparable[a.length]; sort(a,0,a.length - 1); return inversion; &#125; public void sort(Comparable[] a,int lo,int high)&#123; if (lo &gt;= high) return; int mid = (lo + high) / 2; sort(a,lo,mid); sort(a,mid+1,high); merge(a,lo,mid,high); &#125; public void merge(Comparable[] a,int lo,int mid,int high)&#123; int i = lo; int j = mid + 1; for (int k = lo; k &lt;= high;k++)&#123; aux[k] = a[k]; &#125; for (int k = lo;k &lt;= high;k++)&#123; if (i &gt; mid) a[k] = aux[j++]; else if (j &gt; high) a[k] = aux[i++]; else if (less (aux[i],aux[j]))&#123; // 这一步的目的就在于逆序对的个数，前面有多少个大于自己个数，就有多少个逆序对 inversion += mid + 1 - i; a[k] = aux[i++]; &#125; else a[k] = aux[j++]; &#125; &#125; public static void main(String [] args)&#123; Integer []a = &#123;1,5,3,7,2,8,6,4&#125;; System.out.println(new CountInversions().get_num(a)); System.out.println(Arrays.toString(a)); &#125;&#125; LinkedMergedArrays123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package Interview_Question_Week3;import java.util.Arrays;import java.util.Iterator;import java.util.ListIterator;public class LinkedMergedArrays &lt;T extends Comparable&lt;T&gt;&gt; implements Iterable&lt;T&gt;&#123; private Node first = null; private Node last = null; private int n = 0; private class Node &#123; Node next; T item; &#125; private boolean less (Comparable a,Comparable b) &#123; return a.compareTo(b) &lt; 0; &#125; public Iterator&lt;T&gt; iterator() &#123; return new ListIterator(); &#125; private class ListIterator implements Iterator&lt;T&gt;&#123; private Node current = first; public boolean hasNext() &#123; return current != null; &#125; public T next() &#123; // TODO Auto-generated method stub T t = current.item; current = current.next; return t; &#125; &#125; public void add(T t)&#123; Node node = new Node(); node.item = t; node.next = null; if(first == null &amp;&amp; last == null)&#123; first = node; last = node; &#125;else if(first != null &amp;&amp; first == last)&#123; first.next = node; last = node; &#125;else&#123; last.next = node; last = node; &#125; n++; &#125; public String toString()&#123; Iterator&lt;T&gt; iter = iterator(); String ret = iter.next().toString(); while(iter.hasNext())&#123; ret += ", "+ iter.next().toString() ; &#125; return ret; &#125; //以下代码是第一种方式的归并 还有第二种形式的归并 明天可以写一下。 public void mergeSort()&#123; first = sort(first); &#125; private Node sort(Node head)&#123; if(head == null || head.next == null) return head; Node slow = head; Node fast = head; //取中间节点 while(fast.next != null &amp;&amp; fast.next.next != null)&#123; slow = slow.next; fast = fast.next.next; &#125; Node left = head; Node right = slow.next; slow.next = null; //将左右链表分开 left = sort(left); right = sort(right); return merge(left,right); &#125; private Node merge(Node left, Node right)&#123; //System.out.println("left="+left.element+",right="+right.element); Node aux = new Node(); //需要耗费logn的额外空间 Node l= left; Node r = right; Node current = aux; while(l != null &amp;&amp; r!=null)&#123; if(less(r.item,l.item)) &#123; current.next = r; current = current.next; r = r.next; &#125; else &#123; current.next = l; current = current.next; l= l.next; &#125; &#125; if(l!=null) current.next = l; // 如果左侧没遍历完，将其连接至current后 else if(r != null) current.next = r; //如果右侧没遍历完，将其连接至current后 return aux.next; //返回归并好的链表 &#125;&#125; MergeSortedSubArray 12345678910111213141516171819202122232425262728package Interview_Question_Week3;import edu.princeton.cs.algs4.StdRandom;import java.util.Arrays;public class MergeSortedSubArray &#123; private static boolean less (Comparable a,Comparable b)&#123; return a.compareTo(b) &lt; 0; &#125; public static void merge(Comparable[] array)&#123; int n = array.length / 2; Comparable[] aux = new Comparable[n]; for (int i = 0;i &lt; n;i++)&#123; aux[i] = array[i]; &#125; System.out.println(Arrays.toString(aux)); int l = 0; int r = n; for(int k = 0; k&lt;2*n;k++)&#123; if(l &gt;= n) break;//辅助元素数组全部用完，array右侧不需要挪动位置了 else if(r&gt;=2*n) array[k]=aux[l++];//array原右侧元素全部放置合适位置，后面只需把辅助数组的元素挪到array右侧 else if(less(array[r],aux[l])) array[k] = array[r++]; else array[k] = aux[l++]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
        <tag>普林斯顿算法课</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普林斯顿第二周小作业]]></title>
    <url>%2F2019%2F02%2F24%2F%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%B0%8F%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[第二周是关于队列与栈的相关实现，由于C++里面早就涉及到了，这里并不多说，直接贴代码Elementary_Sorts123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package Interview_Question_Week2.Elementary_Sorts;import edu.princeton.cs.algs4.StdRandom;enum Ball &#123; Red, Blue, White;&#125;public class Backets&#123; private Ball backets[]; private Ball color(int i)&#123; return backets[i]; &#125; private void swap (int i , int j)&#123; Ball tmp = backets[i]; backets[i] = backets[j]; backets[j] = tmp; &#125; public Backets(int n) &#123; backets = new Ball[n]; for (Ball i : backets)&#123; int x = StdRandom.uniform(3); switch (x)&#123; case 0: &#123;i = Ball.Blue;break;&#125; case 1: &#123; i = Ball.Red;break;&#125; case 2: &#123;i = Ball.White;break;&#125; &#125; &#125; &#125; public void sort() &#123; int low = 0; int cur = 0; int high = backets.length - 1; while (cur &lt;= high)&#123; switch (color(cur))&#123; case Red: &#123; if (cur != low) &#123; swap(cur, low); &#125; cur++; low++; break; &#125; case White: &#123; cur++; break; &#125; case Blue: &#123; swap (high,cur); high--; break; &#125; &#125; &#125; &#125; public static void main(String [] args)&#123; &#125;&#125;package Interview_Question_Week2.Elementary_Sorts;import java.awt.Point;import java.util.Arrays;import java.util.HashSet;import java.util.Random;import java.util.Set;public class Intersection_of_two_sets &#123; private Set&lt;Point&gt; same; private int sameTimes; public Intersection_of_two_sets(Point[]a , Point[]b,int times)&#123; same = new HashSet&lt;Point&gt;(); for (int i = 0;i &lt; times;i++)&#123; same.add(a[i]); same.add(b[i]); &#125; sameTimes = times * 2 - same.size(); &#125; public int get()&#123; return sameTimes; &#125; public static void main(String [] args)&#123; int n = 10; Random ra = new Random(); Point[] a = new Point[10]; Point[] b = new Point[10]; for (int i = 0;i &lt; n;i++)&#123; a[i] = new Point(); b[i] = new Point(); a[i].setLocation(ra.nextInt(10)+1,ra.nextInt(10)+1); b[i].setLocation(ra.nextInt(10)+1,ra.nextInt(10)+1); &#125; Intersection_of_two_sets i = new Intersection_of_two_sets(a,b,n); System.out.println(Arrays.toString(a)); System.out.println(Arrays.toString(b)); System.out.println(i.same); System.out.println(i.get()); &#125;&#125; MaxArrayStack1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package Interview_Question_Week2;import java.util.*;public class MaxArrayStack &#123; private int Max; private int sz; private int []a; public MaxArrayStack()&#123; Max = -999999999; a = new int [1]; sz = 0; &#125; public void resize(int capacity)&#123; int[] tmp = new int [capacity]; for (int i = 0;i != sz;i++)&#123; tmp[i] = a[i]; &#125; a = tmp; &#125; private void check()&#123; if (sz == a.length) resize(a.length * 2); &#125; public void push(int item)&#123; if (item &gt; Max) Max = item; check(); a[sz++] = item; &#125; public int pop()&#123; return a[--sz]; &#125; public int getMax()&#123; return Max; &#125; public String toString()&#123; return Arrays.toString(a); &#125; public static void main(String [] args)&#123; MaxArrayStack mStack = new MaxArrayStack(); mStack.push(4); mStack.push(5); mStack.push(6); mStack.push(2); mStack.push(1); mStack.push(10); mStack.push(7); mStack.push(7); System.out.println(mStack); System.out.println(mStack.getMax()); &#125;&#125; MaxLinkedStack123456789101112131415161718192021222324252627282930313233343536373839404142package Interview_Question_Week2;import java.util.*;class MaxLinkedStack &#123; private int N; private Node first; private Node max; private class Node &#123; private double item; private Node next; &#125; public MaxLinkedStack() &#123; N = 0; first = null; max = null; &#125; public double getMax() &#123; return max.item; &#125; public void push(double item) &#123; Node oldfirst = first; first = new Node(); first.item = item; first.next = oldfirst; N++; if (item &gt;= getMax()) &#123; Node oldmax = max; max = new Node(); max.next = oldmax; &#125; &#125; public double pop() &#123; double tmp = first.item; first = first.next; N--; if (tmp == getMax()) &#123; max = max.next; &#125; return tmp; &#125;&#125; StackQueue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package Interview_Question_Week2;import java.util.*;public class StackQueue&lt;Item&gt; &#123; private Stack&lt;Item&gt; input = new Stack &lt;Item&gt;(); private Stack&lt;Item&gt; output = new Stack &lt;Item&gt;(); public int size ()&#123; return input.size() + output.size(); &#125; public StackQueue() &#123; &#125; public boolean isEmpty() &#123; return size() == 0; &#125; public void enqueue(Item item) &#123; if (item == null) throw new IllegalArgumentException("wrong enquene"); input.push(item); &#125; public Item dequeue() &#123; if (isEmpty())&#123; throw new IndexOutOfBoundsException("out of range"); &#125; if (output.isEmpty())&#123; while (!input.isEmpty())&#123; output.push(input.pop()); &#125; &#125; return output.pop(); &#125; public static void main(String [] args)&#123; StackQueue&lt;Integer&gt; squeue = new StackQueue&lt;Integer&gt;(); int i = 0; int N = 100; System.out.println("Size: " + squeue.size()); squeue.enqueue(i); while (i &lt;= N) &#123; if (i % 3 == 0) &#123; System.out.println("Dequeue: " + squeue.dequeue()); &#125; else &#123; squeue.enqueue(i); System.out.println("Enqueue: " + i); &#125; ++i; &#125; System.out.println("Size: " + squeue.size()); while (!squeue.isEmpty()) &#123; System.out.println("Dequeue: " + squeue.dequeue()); &#125; System.out.println("Size: " + squeue.size()); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
        <tag>普林斯顿算法课</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Permutation]]></title>
    <url>%2F2019%2F02%2F24%2FPermutation%2F</url>
    <content type="text"><![CDATA[Permutation——普林斯顿算法大作业第二次总的来说第二次算法大作业比较简单，实现以下双端队列，以及随机出队的队列。鉴于这个难度系数，我这里直接写了两种，基于数组与基于链表两种方式，首先先看题目。 由于比较简单 这里不多说 直接开始贴代码。 Deque123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131package Programming_Assignment_2;import java.util.Iterator;import java.util.NoSuchElementException;public class Deque&lt;Item&gt; implements Iterable&lt;Item&gt; &#123; private Node first,last; private int size; private class Node &#123; Item item; Node next; Node previous; Node (Item i)&#123; item = i; next = null; previous = null; &#125; &#125; public Deque() &#123; first = last = null; size = 0; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public int size() &#123; return size; &#125; public void addFirst(Item item) &#123; if (item == null)&#123; throw new IllegalArgumentException(); &#125; Node oldFirst = first; first = new Node(item); first.previous = null; if (isEmpty())&#123; last = first; first.next = null; &#125; else &#123; first.next = oldFirst; oldFirst.previous = first; &#125; size++; &#125; public void addLast(Item item) &#123; if (item == null)&#123; throw new IllegalArgumentException(); &#125; Node tmp = new Node(item); tmp.next = null; if (isEmpty())&#123; first = tmp; last = tmp; last.previous = null; &#125; else &#123; last.next = tmp; tmp.previous = last; last = tmp; &#125; size++; &#125; public Item removeFirst() &#123; if (isEmpty())&#123; throw new NoSuchElementException(); &#125; Item cnt = first.item; first = first.next; size--; if (isEmpty()) &#123; last = first =null; &#125; else &#123; first.previous = null; &#125; return cnt; &#125; public Item removeLast() &#123; if (isEmpty())&#123; throw new NoSuchElementException(); &#125; Item cnt = last.item; last = last.previous; size--; if (isEmpty())&#123; first = last = null; &#125; else &#123; last.next = null; &#125; return cnt; &#125; public Iterator&lt;Item&gt; iterator() &#123; return new DequeIterator(first); &#125; private class DequeIterator implements Iterator&lt;Item&gt;&#123; private Node current; public DequeIterator(Node first) &#123; current = first; &#125; public boolean hasNext()&#123; return current != null; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public Item next()&#123; if (!hasNext())&#123; throw new NoSuchElementException(); &#125; Item cnt = current.item; current = current.next; return cnt; &#125; &#125;&#125; RandomizedQueue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package Programming_Assignment_2;import java.util.Iterator;import java.util.NoSuchElementException;import java.lang.UnsupportedOperationException;import edu.princeton.cs.algs4.StdRandom;//原本最初的打算是直接用链表进行实现的，//但是后来才发现性能要求迭代器的next的方法必须是常数时间，//而用链表实现不了，所以改用数组实现。public class RandomizedQueue&lt;Item&gt; implements Iterable&lt;Item&gt; &#123; private Item[] array; private int size; public RandomizedQueue()&#123; size = 0; array = (Item[]) new Object[1]; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public int size() &#123; return size; &#125; private void check() &#123; if (size &gt;= array.length)&#123; resize(array.length * 2); &#125; else if (size &lt; array.length / 4)&#123; resize(array.length / 2); &#125; &#125; private void resize(int n) &#123; Item[] tmp = (Item[]) new Object[n]; for (int i = 0;i &lt; size;i++)&#123; tmp[i] = array[i]; &#125; array = tmp; &#125; public void enqueue(Item item) &#123; if (item == null) throw new IllegalArgumentException("wrong input"); check(); array[size++] = item; &#125; public Item dequeue() &#123; if (isEmpty()) throw new NoSuchElementException(); int random = StdRandom.uniform(size); Item cnt =array[random]; array[random] = array[size - 1]; array[--size] = null; check(); return cnt; &#125; public Item sample() &#123; if (isEmpty()) throw new NoSuchElementException(); return array[StdRandom.uniform(size)]; &#125; public Iterator&lt;Item&gt; iterator() &#123; return new RandomIterator(); &#125; private class RandomIterator implements Iterator&lt;Item&gt; &#123; private int rank; private Item[] iarray; public RandomIterator() &#123; rank = size; iarray = (Item[]) new Object[rank]; for (int i = 0;i &lt; rank;i++)&#123; iarray[i] = array[i]; &#125; &#125; public boolean hasNext() &#123; return rank &gt; 0; &#125; public void remove()&#123; throw new UnsupportedOperationException(); &#125; public Item next ()&#123; if (!hasNext()) throw new NoSuchElementException(); int random = StdRandom.uniform(rank); rank--; Item item = iarray[random]; iarray[random] = iarray[rank]; //这里需要注意的是 与上面直接在原数组上面操作的区别就在于不能直接令后面等于null //如 iarray[rank] = null 这样造成的后果是多用几次迭代器使用不了了。 iarray[rank] = null; return item; &#125; &#125;&#125; Permutation 123456789101112131415161718package Programming_Assignment_2;import edu.princeton.cs.algs4.StdIn;public class Permutation &#123; public static void main(String[] args) &#123; RandomizedQueue&lt;String&gt; rq = new RandomizedQueue&lt;String&gt;(); int k = Integer.parseInt(args[0]); while (!StdIn.isEmpty()) &#123; rq.enqueue(StdIn.readString()); // System.out.println(StdIn.readString()); &#125; while (k &gt; 0) &#123; System.out.println(rq.dequeue()); k--; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
        <tag>普林斯顿算法课</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Percolation]]></title>
    <url>%2F2019%2F02%2F08%2FPercolation%2F</url>
    <content type="text"><![CDATA[Programming Assignment 1: Percolation第一次提交这样的全英文大作业，先开始完全看不懂题目，然后在网上看懂题目之后，于是写代码的时候也是混乱的，完全不知道该怎么用，看了别人提交的写了之后，自己也提交了几次，都是60分70分左右，到最后才发现数组的溢出，以及java输入输出的一些问题。 接下来看题目首先先看英文版的题目 看懂的大神可以不用看下面的中文版的题目了： 通过蒙特卡洛模拟方法来估计渗流阈值。 Percolation. 给一个有随机分布的绝缘和金属材料的组成的复合系统。例如我们想知道哪些部分必须是金属材料才能让这个复合系统是一个电导体。或者在一个多孔的地形，在表面有水或者油，在什么情况下水或者油能够从最表面渗透到最底层。科学家把这种过程的模型叫做Percolation。 The model. 在Assignment中，用一个NxN的格子表示percolation系统，每一个格子是打开或者关闭，打开是白色关闭是黑色。如果一个格子是full，首先他必须是打开额，然后表示从最顶上通过相连(4方向)的打开的格子可以渗透到这个位置。当一个系统是percolates，表示能从最顶层渗透到最底层，也就是说，最底层存在打开的格子是full。 The Problem. 研究人员对一下的问题感兴趣，如果每一个格子是独立的，并且被打开的概率为p，那么系统percolates的概率是多少？p=0，percolates概率为0，p=100，percolates的概率为100。下图是20x20和100x100格子的概率p的分布： 当N足够大时, 有一个阈值P, 使得当p &lt; p时候，任意的NN网格，几乎不能被渗透, 并且当p &gt; p, 基本能够被渗透。p没有准确的数值解。任务是写一个计算估计p的算法。 题目给出了两个样版分别作为题目开始写的两个类： 1234567public class Percolation &#123; public Percolation(int N) // create N-by-N grid, with all sites blocked public void open(int i, int j) // open site (row i, column j) if it is not already public boolean isOpen(int i, int j) // is site (row i, column j) open? public boolean isFull(int i, int j) // is site (row i, column j) full? public boolean percolates() // does the system percolate?&#125; 123456789public class PercolationStats &#123; public PercolationStats(int n, int trials) // perform trials independent experiments on an n-by-n grid public double mean() // sample mean of percolation threshold public double stddev() // sample standard deviation of percolation threshold public double confidenceLo() // low endpoint of 95% confidence interval public double confidenceHi() // high endpoint of 95% confidence interval public static void main(String[] args) // test client (described below)&#125; 第一部分建立起一个数学模型来模拟这个系统class Percolation123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import edu.princeton.cs.algs4.WeightedQuickUnionUF;public class Percolation &#123; //建立两个并查集 来控制 backwash 的虚拟节点所产生的问题 private WeightedQuickUnionUF uf; private WeightedQuickUnionUF backwash; //打开的数目 private int num; //这里用一维数组来表示整张图 private boolean[] percolation; //总数目 private int len; public Percolation(int n) &#123; if (n &lt; 1) throw new IllegalArgumentException("Illeagal Argument"); len = n; percolation = new boolean[n * n + 2]; uf = new WeightedQuickUnionUF(n * n + 2); backwash = new WeightedQuickUnionUF(n * n + 1); num = 0; for (int i = 1;i &lt; n * n + 1; i++)&#123; percolation[i] = false; &#125; percolation[0] = percolation[n * n + 1] = true; &#125; private void check(int i,int j)&#123; if (i &lt; 1 || i &gt; len || j &lt; 1 || j &gt; len) throw new IllegalArgumentException("out of the range"); &#125; private int get_position(int i,int j) &#123; return (i - 1) * len + j; &#125; public void open(int row, int col) &#123; check(row,col); if (isOpen(row,col)) return; int index = get_position(row,col); percolation[index] = true; num++; //处理虚拟节点与实际中的点的关系 //并且同时处理一下前后左右点之间的关系 if (row == 1)&#123; uf.union(0,index); backwash.union(0,index); &#125; else if (isOpen(index - len))&#123; uf.union(index,index - len); backwash.union(index,index - len); &#125; if (row == len) uf.union(len * len + 1,index); else if (isOpen(index + len))&#123; uf.union(index,index + len); backwash.union(index,index + len); &#125; if (col != 1 &amp;&amp; isOpen(index - 1))&#123; uf.union(index,index - 1); backwash.union(index,index - 1); &#125; if (col != len &amp;&amp; isOpen(index + 1))&#123; uf.union(index,index + 1); backwash.union(index,index + 1); &#125; &#125; private boolean isOpen(int x)&#123; return percolation[x]; &#125; public boolean isOpen(int row, int col)&#123; check(row,col); return isOpen(get_position(row,col)); &#125; public boolean isFull(int row, int col)&#123; check(row,col); int index = get_position(row,col); if (backwash.connected(index,0)) return true; return false; &#125; public int numberOfOpenSites()&#123; return num; &#125; public boolean percolates()&#123; return uf.connected(0,len * len + 1); &#125;&#125; 关于以上这个类 其实最初思考之处，完全就是借鉴并查集的思想，使用一个数组来存储当前的模块有没有被打开，然后根据这个模块进行改变，然后再使用并查集将第一个与当前位置相连接，前后左右都打开就相当于链接了，然后根据遍历就可以找出是否会遍历到最后一个位置去了。 上面所说的办法有些麻烦，有一种方法所产生的两个问题，也就是上面所使用的方法使用虚拟节点，相当于预设一个起点和一个终点，最后只需要判断起点与终点是否是并查集相连接的即可 并查集的使用方法，可以直接写一个类也可以使用自带好的类型。 会产生终点处的backwash问题，意思就是终点位置可能会与许多没有连接到起点的支点相连接，所以采用的解决办法就是使用两个并查集。 第二部分就是 解决数据的位置估计percolation的阈值，初始化时候格子都是关闭的，随机寻找一个关闭的位置打开，直到系统可以渗透为止，打开的格子比上总格子数就是阈值。 运用一下这些公式： 这个问题仅仅就是数学处理的问题，以及控制格式上面的输入输出。 class PercolationStats12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import edu.princeton.cs.algs4.StdIn;import edu.princeton.cs.algs4.StdOut;import edu.princeton.cs.algs4.StdRandom;import edu.princeton.cs.algs4.StdStats;import edu.princeton.cs.algs4.Stopwatch;public class PercolationStats &#123; private double[] results; // estimated threshold for each trial private double avg; private double std; public PercolationStats(int n, int trials)&#123; if(n &lt;= 0 || trials &lt;= 0) throw new IllegalArgumentException(); results = new double[trials]; for(int i = 0; i &lt; trials; i++)&#123; int step = 0; Percolation pr = new Percolation(n); while(!pr.percolates())&#123; int row = StdRandom.uniform(n) + 1; int col = StdRandom.uniform(n) + 1; if(!pr.isOpen(row, col))&#123; pr.open(row, col); step++; &#125; &#125; results[i] = (double)step / (n * n); &#125; this.avg = StdStats.mean(results); this.std = StdStats.stddev(results); &#125; public static void main(String[] args)&#123; StdOut.printf("%-25s\n", "Please input 2 integers"); int N = StdIn.readInt(); int T = StdIn.readInt(); Stopwatch wt = new Stopwatch(); PercolationStats ps = new PercolationStats(N, T); // elapsed CPU time in seconds double elapsed = wt.elapsedTime(); StdOut.printf("%-25s= %.15f\n", "elapsed CPU time", elapsed); StdOut.printf("%-25s= %.7f\n", "mean", ps.mean()); StdOut.printf("%-25s= %.17f\n", "stddev", ps.stddev()); StdOut.printf("%-25s= [%.15f, %.15f]\n", "%95 confidence interval", ps.confidenceLo(), ps.confidenceHi()); &#125; public double mean()&#123; return this.avg; &#125; public double stddev()&#123; return this.std; &#125; public double confidenceLo()&#123; return mean() - 1.96 * stddev() / Math.sqrt(results.length); &#125; public double confidenceHi()&#123; return mean() + 1.96 * stddev() / Math.sqrt(results.length); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>普林斯顿算法课</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普林斯顿算法课之并查集]]></title>
    <url>%2F2019%2F02%2F08%2F%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B9%8B%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[普林斯顿算法之并查集个人理解 并查集就是运用在联通路径中，需要压缩路径，从而快速判断接下里的几个位置是否相连. 根据以上的需求可以写出简单类似于并查集的操作 建立数学模型，用一维甚至是多维数组来表示两个位置是否相连，相连则用相同数字来进行表示，然后经过遍历来筛查。 以上这种办法简单粗暴会花费很多无用功，所以这才产生了并查集的前身 简单来说就是根据叠加效应，如若两者相连，就将前者作为后者的值，然后依次累积，就会产生类似树形结构的根节点，也就是下面将会提到的root函数1234567private int root(int i)&#123; while (i != point[i]) &#123; i = point[i]; &#125; return i; &#125; 以上代码在二者没有相连接的时候，每一个人的根节点都是自己，当使用union操作的时候，就是将前者接到后者上面即后者就变成前者的节点，而这里就进行循环，知道找到根节点（根节点的祖先是自己） 接下来就是union操作1234567public void union(int a,int b)&#123; int roota = root(a); int rootb = root(b); if (roota == rootb) return ; point[rootb] = roota; cnt--; &#125; 找到两个所给点的祖先，并且把他们的祖先做一个连接行为，这样就完成了并查集的核心，而往往最多的变式就产生在这其中，一般涉及到祖先的赋值情况，后面优化的时候再说。 最后一个就是connected的函数，主要用来判断是否两个点是否连接，直接判断他们两个的祖先点是否相等即可。123public boolean connected(int a,int b)&#123; return root(a)==root(b); &#125; 优化优化主要分为两个方面路径压缩和路径树平衡。 路径压缩12345678private int root(int i)&#123; while (i != point[i]) &#123; point[i] = point[point[i]]; i = point[i]; &#125; return i; &#125; 此处与上面相比仅仅只是多了一行代码，但是却可以让代码提高速度5倍以上，这里就是将本来要一个一个叠加的节点，变成了多支叠加，这样树的深度少了很多，所带来的结果就是效率的提高。 路径树平衡1234567891011121314151617public void union(int a,int b)&#123; int roota = root(a); int rootb = root(b); if (roota == rootb) return ; if (sz[roota] &lt; sz[rootb])&#123; //下面的意思就是让 roota 接到 rootb 上面 point[roota] = rootb; sz[rootb] += sz[roota]; &#125; else &#123; point[rootb] = roota; //下面这个意思就是继续接头接上去 sz[roota] += sz[rootb]; if (Max[rootb] &gt; Max[roota]) Max[roota] = Max[rootb]; &#125; cnt--; &#125; 这里所带来的改变就是 使用了一个sz数组来记录每一个点在这个位置的深度，从而在每一次union操作的时候，都会有一个判断，就是树层次小的往树层次大的节点上面接，这样一来，同样减少了树的开销，加快效率。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>普林斯顿算法课</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中this和super的用法总结]]></title>
    <url>%2F2019%2F01%2F21%2FJava%E4%B8%ADthis%E5%92%8Csuper%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[thisthis是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。 this的用法在java中大体可以分为3种： 1. 类似于C++里面对于自身普通的引用，这种情况就不在多讲了2. 形参与成员名字重名，用this来区分1234567891011121314151617class Person &#123; private int age = 10; public Person()&#123; System.out.println("初始化年龄："+age);&#125; public int GetAge(int age)&#123; this.age = age; return this.age; &#125;&#125; public class test1 &#123; public static void main(String[] args) &#123; Person Harry = new Person(); System.out.println("Harry's age is "+Harry.GetAge(12)); &#125;&#125; 运行结果：初始化年龄：10Harry’s age is 12 可以看到，这里age是GetAge成员方法的形参，this.age是Person类的成员变量。 3. 引用构造函数这个就放在下面与super一起讲。 supersuper可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。 1. 类似于C++的普通对父类对象的引用。（这里也不在多说）2. 子类中的成员变量或方法与父类中的成员变量或方法同名（可以用该办法区分）123456789101112131415161718192021class Country &#123; String name; void value() &#123; name = "China"; &#125;&#125;class City extends Country &#123; String name; void value() &#123; name = "Shanghai"; super.value(); //调用父类的方法 System.out.println(name); System.out.println(super.name); &#125; public static void main(String[] args) &#123; City c=new City(); c.value(); &#125;&#125; 运行结果:ShanghaiChina 可以看到，这里既调用了父类的方法，也调用了父类的变量。若不调用父类方法value()，只调用父类变量name的话，则父类name值为默认值null。 3.引用构造函数super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。 1234567891011121314151617181920212223242526272829303132333435363738class Person &#123; public static void prt(String s) &#123; System.out.println(s); &#125; Person() &#123; prt("父类·无参数构造方法： "+"A Person."); &#125;//构造方法(1) Person(String name) &#123; prt("父类·含一个参数的构造方法： "+"A person's name is " + name); &#125;//构造方法(2) &#125; public class Chinese extends Person &#123; Chinese() &#123; super(); // 调用父类构造方法（1） prt("子类·调用父类”无参数构造方法“： "+"A chinese coder."); &#125; Chinese(String name) &#123; super(name);// 调用父类具有相同形参的构造方法（2） prt("子类·调用父类”含一个参数的构造方法“： "+"his name is " + name); &#125; Chinese(String name, int age) &#123; this(name);// 调用具有相同形参的构造方法（3） prt("子类：调用子类具有相同形参的构造方法：his age is " + age); &#125; public static void main(String[] args) &#123; Chinese cn = new Chinese(); cn = new Chinese("codersai"); cn = new Chinese("codersai", 18); &#125; &#125;``` 运行结果:父类·无参数构造方法： A Person.子类·调用父类”无参数构造方法“： A chinese coder.父类·含一个参数的构造方法： A person’s name is codersai子类·调用父类”含一个参数的构造方法“： his name is codersai父类·含一个参数的构造方法： A person’s name is codersai子类·调用父类”含一个参数的构造方法“： his name is codersai子类：调用子类具有相同形参的构造方法：his age is 18 从本例可以看到，可以用super和this分别调用父类的构造方法和本类中其他形式的构造方法。 例子中Chinese类第三种构造方法调用的是本类中第二种构造方法，而第二种构造方法是调用父类的，因此也要先调用父类的构造方法，再调用本类中第二种，最后是重写第三种构造方法。 super和this的异同： super（参数）：调用基类中的某一个构造函数（应该为构造函数中的第一条语句） this（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句） super: 它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参） this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名） 调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。 super()和this()类似,区别是，super()从子类中调用父类的构造方法，this()在同一类内调用其它方法。 super()和this()均需放在构造方法内第一行。 尽管可以用this调用一个构造器，但却不能调用两个。 this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。 this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。 从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之排序总结]]></title>
    <url>%2F2018%2F12%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[数据结构的排序总结首先先展示一张图，来说明每一个排序之间的复杂度和稳定性 冒泡排序这种排序往往属于最基本的排序了，比较稳定，而且代码也比较简单，这里不做多讲，直接贴代码 123456789101112131415void maopao(int *p)&#123; for (int i=0;i!=maxn;i++) &#123; for (int j=i+1;j!=maxn;j++) &#123; if (*(p+i)&gt;*(p+j))&#123; int temp = *(p+i); *(p+i) = *(p+j); *(p+j) = temp; &#125; &#125; &#125; print(p);&#125; 快速排序 进阶版的冒泡排序，即对冒泡排序进行算法优化过得结果 快速排序的基本思想就是，通过找到一个中间值(枢纽值)，然后比枢纽值小的放到枢纽值的左边，比枢纽值大的放在枢纽值的右边，然后通过枢纽值来进行划分，一次往下面划分，利用递归或者是非递归的栈来实现，最终实现相应的排序。 算法步骤 首先找到一个枢纽,一般找最中间的一个值，或者找最左边的一个值，或者最右边的值，但是这样就会有缺陷，在某些特殊情况下会会存在很多不必要的开销。 如果最后这个值刚好是整段序列最大或者最小的值，那么这次划分就是没意义的。 所以当序列是正序或者逆序时，每次选到的枢轴都是没有起到划分的作用。快排的效率会极速退化。所以可以每次在选枢轴时，在序列的第一，中间，最后三个值里面选一个中间值出来作为枢轴，保证每次划分接近均等。 所以采用的是三值取中法： 12345678910111213141516int get_mid(int *a,int left,int right)&#123; int mid = (left + right) / 2; if (a[left] &lt;= a[right]) &#123; if (a[mid] &lt; a[left]) return left; else if (a[mid] &gt; a[right]) return right; else return mid; &#125; else &#123; if (a[mid] &lt; a[right]) return right; else if (a[mid] &gt; a[left]) return left; else return mid; &#125;&#125; 当取到中间的枢纽值之后，接下来需要完成的是将枢纽值放到最右边，并且一次进行比较排序，将比枢纽值小的放在左边，比枢纽值大的放在右边。最后返回最终枢纽值所在的位置，按照此位置进行划分子区，从而完成一次快速排序，然后再到每一个子区进行重复上述过程。 以下介绍两种方法，而这两种方法代码类似，而两者唯一的区别也就在于对于key的处理了，一个是直接将key当做是引用，而另一个则是直接拷贝。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//左右指针交换的办法int part_sort1(int *a,int left,int right)&#123; int mid = get_mid(a,left,right); swap(a[mid],a[right]); int &amp;key = a[right]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; a[left] &lt;= key) ++left; while (left &lt; right &amp;&amp; a[right] &gt;= key) --right; //交换左右两个的值，分别根据key值进行一个有效的划分 swap (a[left],a[right]); &#125; //由于这里的key是一个引用，直接附在了枢纽值上面，无论怎么移动，都可以在这个地方直接进行交换 swap(a[right],key); //然而这里需要注意就是，无论这里是写right还是left，到最后right与left一定会相同的，因为每一次划分最后到不能划分之后，左右指针就会进行一个重叠。 return right;&#125;//挖坑填补法int part_sort2(int *a,int left,int right)&#123; int mid = get_mid(a,left,right); swap (a[mid],a[right]); //这里实际上就是直接将枢纽值进行拷贝给temp上面 int key = a[right]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; a[left] &lt;= key) ++left; a[right] = a[left]; //每一步骤就进行占位 while (left &lt; right &amp;&amp; a[right] &gt;= key) --right; //相当于此处进行一个有效的位置互换 a[left] = a[right]; &#125; a[right] = key; //然后这里right指向的元素就应该是多余且本应该存放枢纽值的位置 return right;&#125; 当每一步结束之后，可以利用递归，也可以使用非递归的栈来实现对每一步的分区进行快排的操作。 123456789void quick_sort(int *a,int left,int right)&#123; if (left &lt; right) &#123; int index = part_sort1(a,left,right); quick_sort(a,left,index-1); quick_sort(a,index+1,right); &#125;&#125; 选择排序简单选择排序是最简单直观的一种算法，基本思想为每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，直到所有元素排完为止，简单选择排序是不稳定排序。 算法思想：每一趟确定最小元素的时候会通过不断地比较交换来使得首位置为当前最小，交换是个比较耗时的操作。通过设置一个变量min，每一次比较仅存储较小元素的数组下标，当轮循环结束之后，那这个变量存储的就是当前最小元素的下标，此时再执行交换操作即可。（这里不做过多阐述） 12345678910111213141516171819void xuanze(int *p)&#123; for (int i=0;i!=maxn;i++) &#123; int Min = i; for (int j = i+1; j!=maxn ;j++) &#123; if (*(p+Min) &gt; *(p+j)) Min = j; &#125; if (Min != i) &#123; int temp = *(p + Min); *(p + Min) = * (p + i); *(p + i) = temp; &#125; &#125; print(p);&#125; 堆排序堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，（可以理解成特殊的选择排序，相当于完全二叉树型的选择排序）它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。 首先简单了解下堆结构。 堆堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图： 堆排序的思想：首先先将给出的序列进行一个调整，调整成一个大顶堆或者一个小顶堆，调整之后，再把栈顶的元素与最后一个元素进行交换，交换完成之后在进行调整，最后完成堆排序。 堆排序步骤: 构造大顶堆或者小顶堆，通过调整的方式 最初模样 从最后一个非叶子节点开始，从左到右，从上到下进行调整 找到根节点，左孩子，右孩子，中的最大的一个，使其放在根节点的位置。 继续向上面调整，一步一步的更替到下面 代码如下：123456789101112131415161718void adjust(int *a,int root,int len)&#123; int temp = a[root]; //堆排序这里如果是数组是从0开始计数的话 这里必须加上一个1 //但是如果是从0开始计数的话，那么这里就这样写 int child = 2 * root; while (child &lt; len) &#123; if (child + 1 &lt; len &amp;&amp; a[child] &lt; a[child + 1]) child ++; if (temp &gt;= a[child]) break; a[root] = a[child]; root = child; child = 2 * child; &#125; a[root] = temp;&#125; 将栈顶元素与最后一个元素进行交换，使末尾元素最大，然后再来慢慢调整。 以下的四张图就是交换元素，并且每交换一次都会调整元素一次 代码如下12345678910111213void heap_sort(int *a)&#123; //注意这里必须从后面开始往前面递归的意思就在于便于改变上面之后可以有效的推至下面，相当于一个小型递归 for (int i = maxn / 2;i &gt;= 0;i--) adjust(a,i,maxn); for (int i = maxn - 1;i &gt; 0;i--)&#123; swap (a[0],a[i]); //这里需不需要减1 是根据上面的adjust里面对于上限值的处理 如果是大于等于就需要减去1 如果仅仅只是小于，那么就不需要减去1 adjust(a,0,i); &#125; print (a);&#125; 插入排序算法思想： 从后面往前面递进，将每一个树直接插入到前面已经排好序的序列里面去。(后面再详细阐明) 123456789101112131415161718void charu(int *p)&#123; for (int i=1;i!=maxn;i++) &#123; int temp = *(p+i); int j = i; while (j&gt;0 &amp;&amp; temp &lt; *(p+j-1) ) &#123; *(p+j) = *(p+j-1); j--; &#125; if (i != j) &#123; *(p+j) = temp; &#125; &#125; print(p);&#125; 希尔排序 其实希尔排序也就是基于插入排序的优化版本，而插入排序则可以看做是增值为1的希尔排序 算法思想希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止 可以观看下面图示： 算法步骤：首先找出每一个gap值（增值），然后根据增值进行相除，找到每一个间隔位置的元素，来比较大小然后排序，而gap值所造成的间隔会越来越小，直到最后增值为一，成为最后的插入排序。 一般gap值为2，即用2去整除，但是有的算法表示同样也可以用到3 代码如下：12345678910111213141516171819202122void xier(int *a)&#123; for (int gap = maxn/2;gap&gt;0;gap=gap/2) &#123; //从后面往前面进行递增，获取gap的值，然后依次除以2. for (int i=gap;i&lt;maxn;i++) &#123; //下面就类似于插入排序了，只不过增值要从1变成gap。 int temp = a[i]; int j = i; //这个地方需要注意的是对于插入排序 最后一个值是需要到j&gt;=1，而这里要到gap，注意清楚范围。 while (j&gt;gap-1 &amp;&amp; temp &lt; *(a+j-gap)) &#123; *(a+j) = *(a+j-gap); j -= gap; &#125; //上一步每一个都伦换过后，将最初这里的值换到相应的位置上面 *(a+j) = temp; &#125; &#125; print(a);&#125; 归并排序 归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略（分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。 算法思想:其实有点像完全二叉树的结构，但是又有很大的不同,主要就是借助另外一个同样长的数组来存储合并之后的结果，合并的时候可以使用递归或者使用栈来决定合并部位。然后合并的过程中分成无数个小部分，然后一一往新的数组上面添加，最后拷贝到原来的数组上面。 算法步骤： 决定合并部位，这里贴出两个，一个是直接利用递归，另一个是利用循环，用1，2，4，8…乘数扩大进行操作。 递归版本： 12345678910void gui_sort(int *a,int left,int right,int *temp)&#123; if (left &lt; right) &#123; int mid = (left + right) / 2; gui_sort(a,left,mid,temp); gui_sort(a,mid+1,right,temp); merge(a,left,mid,right,temp); &#125;&#125; 非递归版本： 12345678910111213141516171819202122void fei_gui_sort(int *a,int *temp)&#123; int size=1,low,mid,high; while(size&lt;=maxn-1) &#123; low=0; //这个步骤就相当于上面递归内部进行的步骤了，从1到2到4到8到16，依次进行。 //但是这种非递归的版本可以带来节省很多由栈带来的递归开销。 while(low+size&lt;=maxn-1) &#123; mid=low+size-1; high=mid+size; if(high&gt;maxn-1) high=maxn-1; merge(a,low,mid,high,temp); low=high+1; &#125; //这里乘以2。 size*=2; &#125;&#125; 然后就是合并操作了，设置几个指针节点，然后依次比较大小，把小的那个先放入排序中。 12345678910111213141516171819202122232425void merge(int *a,int left,int mid,int right,int *temp)&#123; int i =left; int j = mid +1; int t = 0; //左边与右边开始进行比较 while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; if (a[i] &lt; a[j]) temp[t++] = a[i++]; else temp[t++] = a[j++]; &#125; //左边剩下的 while (i &lt;= mid) temp[t++] = a[i++]; //右边剩下的 while (j &lt;= right) temp[t++] = a[j++]; t = 0; //拷贝到原数组中去 while (left &lt;= right) a[left++] = temp[t++];&#125; 全部代码(可直接运行)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330/************************************************************************* &gt; File Name: 排序代码.cpp &gt; Author: wangshuxiao &gt; Mail: wsx1128@outlook.com &gt; Created Time: Mon 17 Dec 11:23:48 2018 ************************************************************************/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;const int maxn = 20;//这里使用STL算法中的shuffle来使最初的排序全部随机void print(int *p)&#123; for (int i = 0; i != 20; i++) &#123; cout &lt;&lt; *p++ &lt;&lt;" "; &#125; cout &lt;&lt; endl &lt;&lt; endl;&#125;void random(int *p)&#123; random_shuffle(p,p+maxn); print(p);&#125;void maopao(int *p)&#123; for (int i=0;i!=maxn;i++) &#123; for (int j=i+1;j!=maxn;j++) &#123; if (*(p+i)&gt;*(p+j))&#123; int temp = *(p+i); *(p+i) = *(p+j); *(p+j) = temp; &#125; &#125; &#125; print(p);&#125;void xuanze(int *p)&#123; for (int i=0;i!=maxn;i++) &#123; int Min = i; for (int j = i+1; j!=maxn ;j++) &#123; if (*(p+Min) &gt; *(p+j)) Min = j; &#125; if (Min != i) &#123; int temp = *(p + Min); *(p + Min) = * (p + i); *(p + i) = temp; &#125; &#125; print(p);&#125;void charu(int *p)&#123; for (int i=1;i!=maxn;i++) &#123; int temp = *(p+i); int j = i; while (j&gt;0 &amp;&amp; temp &lt; *(p+j-1) ) &#123; *(p+j) = *(p+j-1); j--; &#125; if (i != j) &#123; *(p+j) = temp; &#125; &#125; print(p);&#125;void xier(int *a)&#123; for (int gap = maxn/2;gap&gt;0;gap=gap/2) &#123; for (int i=gap;i&lt;maxn;i++) &#123; int temp = a[i]; int j = i; while (j&gt;gap-1 &amp;&amp; temp &lt; *(a+j-gap)) &#123; *(a+j) = *(a+j-gap); j -= gap; &#125; *(a+j) = temp; &#125; &#125; print(a);&#125;void merge(int *a,int left,int mid,int right,int *temp)&#123; int i =left; int j = mid +1; int t = 0; while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; if (a[i] &lt; a[j]) temp[t++] = a[i++]; else temp[t++] = a[j++]; &#125; while (i &lt;= mid) temp[t++] = a[i++]; while (j &lt;= right) temp[t++] = a[j++]; t = 0; while (left &lt;= right) a[left++] = temp[t++];&#125;void gui_sort(int *a,int left,int right,int *temp)&#123; if (left &lt; right) &#123; int mid = (left + right) / 2; gui_sort(a,left,mid,temp); gui_sort(a,mid+1,right,temp); merge(a,left,mid,right,temp); &#125;&#125;void guibing(int *a)&#123; int *temp = new int [maxn]; gui_sort(a,0,maxn-1,temp); print(a); delete [] temp; return ;&#125;void fei_gui_sort(int *a,int *temp)&#123; int size=1,low,mid,high; while(size&lt;=maxn-1) &#123; low=0; while(low+size&lt;=maxn-1) &#123; mid=low+size-1; high=mid+size; if(high&gt;maxn-1) high=maxn-1; merge(a,low,mid,high,temp); low=high+1; &#125; size*=2; &#125;&#125;void fei_guibing(int *a)&#123; int *temp = new int [maxn]; fei_gui_sort(a,temp); print(a); if (temp != NULL) delete [] temp;&#125;int get_mid(int *a,int left,int right)&#123; int mid = (left + right) / 2; if (a[left] &lt;= a[right]) &#123; if (a[mid] &lt; a[left]) return left; else if (a[mid] &gt; a[right]) return right; else return mid; &#125; else &#123; if (a[mid] &lt; a[right]) return right; else if (a[mid] &gt; a[left]) return left; else return mid; &#125;&#125;//左右指针交换的办法int part_sort1(int *a,int left,int right)&#123; int mid = get_mid(a,left,right); swap(a[mid],a[right]); int &amp;key = a[right]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; a[left] &lt;= key) ++left; while (left &lt; right &amp;&amp; a[right] &gt;= key) --right; swap (a[left],a[right]); &#125; swap(a[right],key); return right;&#125;//挖坑填补法int part_sort2(int *a,int left,int right)&#123; int mid = get_mid(a,left,right); swap (a[mid],a[right]); int key = a[right]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; a[left] &lt;= key) ++left; a[right] = a[left]; while (left &lt; right &amp;&amp; a[right] &gt;= key) --right; a[left] = a[right]; &#125; a[right] = key; return right;&#125;void quick_sort(int *a,int left,int right)&#123; if (left &lt; right) &#123; int index = part_sort1(a,left,right); quick_sort(a,left,index-1); quick_sort(a,index+1,right); &#125;&#125;void kuaisu(int *a)&#123; quick_sort(a,0,maxn-1); print(a);&#125;void adjust(int *a,int root,int len)&#123; int temp = a[root]; int child = 2 * root + 1; while (child &lt; len) &#123; if (child + 1 &lt; len &amp;&amp; a[child] &lt; a[child + 1]) child ++; if (temp &gt;= a[child]) break; a[root] = a[child]; root = child; child = 2 * child; &#125; a[root] = temp;&#125;void heap_sort(int *a)&#123; for (int i = maxn / 2;i &gt;= 0;i--) adjust(a,i,maxn); for (int i = maxn - 1;i &gt; 0;i--)&#123; swap (a[0],a[i]); adjust(a,0,i); &#125; print (a);&#125;int main()&#123; int a[20] = &#123;1,2,3,4,5,6,7,8,9,10,11, 12,13,14,15,16,17,18,19,20&#125;; cout &lt;&lt; "最初的顺序为" &lt;&lt; endl; print(a); //以上为初始化过后，并且进行打乱顺序的排列顺序 //冒泡排序 cout &lt;&lt; "冒泡排序" &lt;&lt; endl; random(a); maopao(a); //选择排序 cout &lt;&lt; "选择排序" &lt;&lt; endl; random(a); xuanze(a); //插入排序 cout &lt;&lt; "插入排序" &lt;&lt; endl; random(a); charu(a); //希尔排序 cout &lt;&lt; "希尔排序" &lt;&lt; endl; random(a); xier(a); //归并排序 cout &lt;&lt; "递归版本归并排序" &lt;&lt; endl; random(a); guibing(a); cout &lt;&lt; "非递归版本的归并排序" &lt;&lt; endl; random (a); fei_guibing(a); //快速排序 cout &lt;&lt; "快速排序" &lt;&lt; endl; random(a); kuaisu(a); //堆排序 cout &lt;&lt; "堆排序" &lt;&lt; endl; random(a); heap_sort(a); return 0;&#125; 文中图片转载自多个博客，这里不贴出来源了，如若侵权，即刻删除，谢谢。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树总结]]></title>
    <url>%2F2018%2F12%2F04%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天花时间整理一下二叉树的一切内容下面的部分包括： 二叉树的创建 二叉树的遍历 二叉树的层序遍历 二叉树的深度遍历 二叉树递归先序遍历 二叉树递归中序遍历 二叉树递归后序遍历 二叉树非递归先序遍历 二叉树非递归中序遍历 二叉树非递归后序遍历 线索树 下面直接贴代码（在代码内部进行注释）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273/************************************************************************* &gt; File Name: tree.cpp &gt; Author: wangshuxiao &gt; Mail: wsx1128@outlook.com &gt; Created Time: 二 11/20 18:51:16 2018 ************************************************************************/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;memory&gt;#include &lt;string&gt;using namespace std;class Node&#123;public: Node():left(0),right(0)&#123;&#125;; Node(char e): value(e)&#123;left = 0;right = 0;&#125;;public: char value; Node* left; Node* right;&#125;;class Bi_tree&#123;public: Bi_tree()=default; ~Bi_tree() &#123; clear(); &#125;//由于建树与析构都要使用到递归，所以对于类而言，必须使用另外一个函数来进行递归，才不会影响私有成员 void bulid (); Node* _bulid (Node *); bool isEmpty () const &#123; return root == 0; &#125;; void breath_order() void preorder(Node *t); void inorder(Node *t); void postorder(Node *t); void iter_preorder(); void iter_inorder(); void iter_postorder(); Node * get_root() &#123;return root;&#125;private: void clear(); void clear(Node *); void print(Node *p); Node *root; &#125;;void Bi_tree::clear()&#123; clear(root); root = 0;&#125;void Bi_tree::clear(Node *n)&#123; if (n) &#123; if (n-&gt;left) clear(n-&gt;left); if (n-&gt;right) clear(n-&gt;right); delete n; &#125;&#125;void Bi_tree::print(Node *p)&#123; cout &lt;&lt; p-&gt;value &lt;&lt; " ";&#125;void Bi_tree::bulid()&#123; root = _bulid(root);&#125;//另外这里还是需要注意到的是，由于类的逻辑与C语言的不太相同，所以再循环的时候不能直接返回为空，所以必须要返回一个`Node*`，这样才可以把之前的给联系在一起。//或者还有一种办法是，使用指针的引用，这样也就是所谓的二级指针，才能造成效果。Node * Bi_tree::_bulid(Node *t)&#123; //creat the tree by preorder char ch; cin &gt;&gt; ch; if (ch =='#') t = nullptr ; else&#123; t = new Node; t-&gt;value = ch; t-&gt;left = _bulid(t-&gt;left); t-&gt;right = _bulid(t-&gt;right); &#125; return t;&#125;// 层序遍历void Bi_tree::breath_order()&#123; queue&lt;Node*&gt; q_tree; Node *t = root; if ( t != 0 ) &#123; q_tree.push(t); while (!q_tree.empty()) &#123; t = q_tree.front(); q_tree.pop(); print(t); if (t-&gt;left != 0) q_tree.push(t-&gt;left); if (t-&gt;right != 0) q_tree.push(t-&gt;right); &#125; &#125;&#125;//递归 先序遍历void Bi_tree::preorder(Node *t)&#123; if (t) &#123; print(t); preorder(t-&gt;left); preorder(t-&gt;right); &#125; return ;&#125;//递归 中序遍历void Bi_tree::inorder(Node *t)&#123; if (t) &#123; inorder(t-&gt;left); print(t); inorder(t-&gt;right); &#125; return ;&#125;//递归 后序遍历void Bi_tree::postorder(Node *t)&#123; if (t) &#123; postorder(t-&gt;left); postorder(t-&gt;right); print(t); &#125; return ;&#125;//非递归 先序遍历 使用栈void Bi_tree::iter_preorder()&#123; stack&lt;Node*&gt; s_tree; Node *t = root; if (t != 0) &#123; s_tree.push(t); while (!s_tree.empty()) &#123; t = s_tree.top(); s_tree.pop(); print(t); if (t-&gt;right != 0) &#123; s_tree.push(t-&gt;right); &#125; if (t-&gt;left != 0) &#123; s_tree.push(t-&gt;left); &#125; &#125; &#125; return ;&#125;//非递归 中序遍历 使用栈void Bi_tree::iter_postorder()&#123; stack&lt;Node*&gt; s_tree; Node *p = root , *q = root; while (p != 0) &#123; for ( ;p-&gt;left != 0;p = p-&gt;left) s_tree.push(p); while (p-&gt;right == 0 || p-&gt;right == q) &#123; print(p); q = p; if (s_tree.empty()) return ; p = s_tree.top(); s_tree.pop(); &#125; s_tree.push(p); p = p-&gt;right; &#125;&#125;// 非递归 后序遍历 使用栈void Bi_tree::iter_inorder()&#123; stack &lt;Node*&gt; s_tree; Node *p = root; while (p != 0) &#123; while (p != 0) &#123; if (p-&gt;right) s_tree.push(p-&gt;right); s_tree.push(p); p = p-&gt;left; &#125; p = s_tree.top(); s_tree.pop(); while (!s_tree.empty() &amp;&amp; p-&gt;right == 0) &#123; print (p); p = s_tree.top(); s_tree.pop(); &#125; print(p); if (!s_tree.empty()) &#123; p = s_tree.top(); s_tree.pop(); &#125; else p = 0; &#125; return ;&#125;int main()&#123; Bi_tree b; b.bulid(); if (b.isEmpty()) cout &lt;&lt; "空的" &lt;&lt; endl; cout &lt;&lt; "下面是递归形式的遍历方式"&lt;&lt;endl; cout &lt;&lt; "递归形式先序遍历" &lt;&lt; endl; b.preorder(b.get_root()); cout &lt;&lt;endl; cout &lt;&lt; "递归形式后续遍历" &lt;&lt;endl; b.postorder(b.get_root()); cout &lt;&lt; endl; cout &lt;&lt; " 非递归形式的中序遍历"&lt;&lt; endl; b.iter_inorder(); cout &lt;&lt; endl; cout &lt;&lt; " 非递归形式的后序遍历"&lt;&lt; endl; b.iter_postorder(); cout &lt;&lt; endl; return 0;&#125; 线索树线索二叉树原理通过考察各种二叉链表，不管儿叉树的形态如何，空链域的个数总是多过非空链域的个数。准确的说，n各结点的二叉链表共有2n个链域，非空链域为n-1个，但其中的空链域却有n+1个。因此，提出了一种方法，利用原来的空链域存放指针，指向树中其他结点。这种指针称为线索。 记ptr指向二叉链表中的一个结点，以下是建立线索的规则： 如果ptr-&gt;lchild为空，则存放指向中序遍历序列中该结点的前驱结点。这个结点称为ptr的中序前驱； 如果ptr-&gt;rchild为空，则存放指向中序遍历序列中该结点的后继结点。这个结点称为ptr的中序后继； 显然，在决定lchild是指向左孩子还是前驱，rchild是指向右孩子还是后继，需要一个区分标志的。因此，我们在每个结点再增设两个标志域ltag和rtag，注意ltag和rtag只是区分0或1数字的布尔型变量，其占用内存空间要小于像lchild和rchild的指针变量。 其中： ltag为0时指向该结点的左孩子，为1时指向该结点的前驱； rtag为0时指向该结点的右孩子，为1时指向该结点的后继； 因此对于上图的二叉链表图可以修改为下图的养子。 线索二叉树的代码实现对接下来的例子中，线索二叉树的中序遍历。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[海边的卡夫卡的短书评]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B5%B7%E8%BE%B9%E7%9A%84%E5%8D%A1%E5%A4%AB%E5%8D%A1%E7%9A%84%E7%9F%AD%E4%B9%A6%E8%AF%84%2F</url>
    <content type="text"><![CDATA[《海边的卡夫卡》这本书以一个悲剧戏剧为蓝本，进行双线构造，相互交织，相互迎合，从而使一个十五岁的少年的成长历程逐渐完善。虽然取自于俄狄浦斯王中杀父奸母的桥段，但是结局导向以及传达出来的意义绝不一样，前者是悲剧式的自我毁灭以及无常命运的慨叹，而后者则是彻彻底底的自我救赎式的成长。不知有多少人曾在那里流血，你本身也会流血，温暖而又鲜红的血。你的双手将会接住它们，那既是你的血，又是别人的血，而沙尘暴偃旗息鼓的时候，你恐怕还不能完全明白自己是如同从中穿过而得以逃生的。甚至它是否过去都无从判断，不过有一点是你一定是非常清楚的，从沙尘暴中逃生的不再是跨入沙尘暴的你。每一个人的成长都是自由的，但同时却也是不可预测的。村上君用一个十五岁少年的成长史告诉我们在命运的妥协与抗争之间还存在救赎和成长。但是如果仅仅写出少年的成长史的话只能算一般小说。但是村上君肯定不会这样落入俗套，于是他巧妙利用第二条故事线，一个十五岁之后丧失一切的老爷爷的奇遇，这位老爷爷拥有着诸多神奇的能力，但是就是无法思考，记不清楚发生在自己身上的一切，甚至是与整个世界脱轨。看似与第一条故事线没有任何关联，实则丝丝入扣，一个十五岁之后拥有无限可能的人生经历和一个十五岁之后一切都是空白的人生经历相对比，更加深了本文成长与救赎的主题。这本书另一个引人注目的地方也就是作者村上春树对成长中最大的敌人的定义：缺乏想象力的狭隘，苛刻，自以为是的命题，空洞的术语，被篡夺的理想，僵化的思想体系，这些才是最可怕的，但是何为正确，何为不正确，这些都是值得深思的话题，但是某种个体的判断失误，在很多情况下事后不是不可能挽回，只要有勇气主动承认错误，都是可以补救。村上春树这本书以一个全新的视角诠释我们在成长之行上必定会遇到的善与恶，以及一步步走向顽强的心路历程，不要畏惧前方有未知的风暴，因为你是世界上最顽强的是19岁的少年。]]></content>
      <tags>
        <tag>书评</tag>
        <tag>村上春树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款09：绝不在构造和析构的过程中调用 virtual 函数]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE09%EF%BC%9A%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8%20virtual%20%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[绝对不要在构造函数和析构函数期间调用虚函数，因为这样调用的结果不会带来预想的结果。 基类构造函数的时候，虚函数是不会下降到派生类中，原因就是在基类开始构造函数的时候，该类的类型是基类，而不是派生类，简单来说，如果想在构造函数的过程中，直接使用基类的虚函数来折射到派生类，从而帮助派生类完成构造的话，那么这种办法一定行不通。 相同的道理同上，在基类析构函数发生的过程中，同样将其他的派生类视作未定义。 如果将构造函数或者析构函数调用的函数设立成纯虚函数的话，那么当纯虚函数被调用的时候，大多数执行系统会直接终止程序，唯一避免的此问题的做法就是确定构造和析构期间没有调用虚函数。 唯一的替代方案是不设置虚函数，比如在构造一个派生类对象的时候，需要直接调用基类函数的构造函数，然后再完成派生类的构造，而此时最好是将派生类里面一个作用于构造函数的一个成员函数定义成静态函数，这样的话就能在程序刚开始就存在该函数了。 由第四点换句话说，你无法使用虚函数直接从基函数向下调用，但是在基类函数中可以由派生类将信息传递到基类从而进行有效调用。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于STL里面函数简单的应用]]></title>
    <url>%2F2018%2F12%2F01%2F%E5%85%B3%E4%BA%8ESTL%E9%87%8C%E9%9D%A2%E5%87%BD%E6%95%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[代码如下：1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;int main()&#123; int n,t; cin&gt;&gt;n; set&lt;int&gt;s; s.insert(0); for (int i =0;i!=n;i++)&#123; cin&gt;&gt;t; //这道题目的主要做法是记住几个upper_bound 的STL函数 if(t &lt; *s.rbegin()) &#123; s.erase(*(s.upper_bound(t))); &#125; s.insert(t); &#125; cout &lt;&lt; s.size() - 1; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构相应总结]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%BA%94%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[栈 栈的概念此处只需要记住栈的思想最重要的就是先进后出思想，也就是最先进去的最后出来。 两种方法表示这种栈的实现 第一种则是 直接用c语言实现，采用一个一维数组来存储栈，用两个指针一个指向栈顶，另一个指向栈底。用top=bottom作为栈空的标记或者说是栈遍历完毕的标记。 第二种就是直接用C++里面STL模板首先先定义一个stack&lt;int&gt; s 然后以下就是其的操作。 注意其不能使用push_back只能使用push 1234s.pop() 删除栈顶元素，也就是出栈的作，把刚刚进来的元素出栈,不返回元素值。s.push() 创建一个新元素压入栈顶，可以通过拷贝，移动，甚至是构造而来。s.top() 返回栈顶的元素，也就是刚刚进来的元素。s.bottom() 返回栈底的元素，也就是最后一个元素 队列适配器队列这里分为两种一种是普通队列，还有一种是特殊排列好的优先队列，但是这二者的区别就在于，虽然都符合先进先出的思想，但是前者是不加任何排序的先进先出，而后者就是让代码编辑者自己定义一种排序方式，然后通过这种排序方式，再来出队操作。 与上面一样，先定义一个queue&lt;int&gt; q与priority_queue&lt;int&gt; q。 1234567q.pop() 按照先进先出的思想，删除首元素或者优先级最高的元素q.front() 返回首元素。q.back() 返回尾元素。以上两个是只适用于队列。q.top() 返回优先队列中优先级最高的元素。q.push()q.emplace() 加入元素到队尾，或者优先队列中一个恰当的位置，要么构造，要么拷贝。 这里需要提一下==优先队列的构造方法==以及==优先队列的特殊排序==应该怎么构造 123456789下面两种优先队列的定义是等价的priority_queue&lt;int&gt; q;priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;;//后面有一个空格默认都是从小到大排序接受三个参数，第一个参数为数据类型，第二个参数为承载容器的类型，第三个就是自定义的比较函数了。可以使lamda匿名函数，也可以是function头文件里面的函数模板。 链表特点：自定义，不连续的。同时链表也是后面相应树形结构的基础实际上就是把每一个不连续的内存空间连在一起，可以认为的控制进程这个需要自己改天把链表的遍历，删除，增加自己再写一遍，因为不是什么新东西，所以这里就不多说了 动态数组这里就是vector 存在的意义了 vector里面重要的概念 容量，长度。 树与二叉树一般的树 以上就是一般树的形态。下面则是关于树的基本用语。关于上面重要的概念就是结点和结点的度了。 二叉树二叉树的定义: 二叉树有五种基本形态： 二叉树的性质:上面所写到的==至多==都是由于将其当成了满二叉树来进行计算的。 满二叉树与完全二叉树前者全部都有子节点，后者基于深度为k的基础上，编号从1到n的结点一一对应。完全二叉树是满二叉树的一部分，而满二叉树是完全二叉树的特例。 #####二叉树的存储结构： 数组存储： 二叉链式存储（原理类似链表）：将链表内部的*next，变成了指向两边的子节点的指针。 三叉链式存储：比二叉链式结构多了一个回指向父节点的指针。 遍历二叉树的方法 先序遍历（根-&gt;左-&gt;右）： 代码: 12345678void PreOrderTraverse(BiTree *T)&#123; if(T != NULL)&#123; printf("%c", T-&gt;data); PreOrderTraverse(T-&gt;lchild); PreOrderTraverse(T-&gt;rchild); &#125;&#125; 图示： 最终结果就是==ABDGHCEIF==。 中序遍历（左-&gt;根-&gt;右)： 若二叉树为空，则空操作返回，否则从根节点开始（注意不是先访问根节点），中序遍历根节点的左子树，然后是访问根节点，最后中序遍历右子树。 代码： 12345678void InOrderTraverse(BiTree T)&#123; if(T != NULL)&#123; PreOrderTraverse(T-&gt;lchild); printf("%c", T-&gt;data); PreOrderTraverse(T-&gt;rchild); &#125;&#125; 最终结果为==GDHBAEICF==。 后序遍历（左-&gt;右-&gt;根） 若二叉树为空，则空操作返回，否则从根节点开始（注意不是先访问根节点），中序遍历根节点的左子树，然后是访问根节点，最后中序遍历右子树。 代码： 12345678void PostOrderTraverse(BiTree T)&#123; if(T != NULL)&#123; PreOrderTraverse(T-&gt;lchild); PreOrderTraverse(T-&gt;rchild); printf("%c", T-&gt;data); &#125;&#125; 最终结果为==GHDBIEFCA==。 关于二叉树的建立代码：代码我等下自己写出来。 图图的定义 图结构：是研究数据元素之间的多对多的关系。在这种结构中，任意两个元素之间可能存在关系。即结点之间的关系可以是任意的，图中任意元素之间都可能相关。 图的专业术语： 图-生成树 邻接矩阵的表示方法（数组）不带权值的表示方法 一般就是用二维数组来表示每一个结点之间的关系 关于图的遍历就最好用一个bool 类型的同二维数组 然后通过这个来标记哪些是否已经被遍历过得。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分法思想]]></title>
    <url>%2F2018%2F12%2F01%2F%E4%BA%8C%E5%88%86%E6%B3%95%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[二分查找实现在单调有序的集合中查找元素，每次江集合分为左右两个部分，并且通过判断集合在哪个部分从而调整集合的上下界，重复知道找到目标元素为止。 举一个简单的例子，我要在1到100里面查找62，先拿62根这个其最中间的一个数进行比较。然后在一步一步的缩小集合的上下界，最后再来一步一步往里面缩 下面是C++STL里面二分查找的函数： binary_search 返回bool值,是否存在lower_bound 返回可插入的最小位置的迭代器 即返回第一个符合条件的元素位置upper_bound 返回可插入的最大位置的迭代器 即返回最后一个符合条件的元素位置 在二分查找里面最典型的题目就是二分逼近求方程式的根了。 代码如下123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;iomanip&gt;using namespace std;const double pre =1e-4;double x,y;double f(double x)&#123; return 8*pow(x,4)+7*pow(x,3)+2*pow(x,2)+3*x+6-y;&#125;int main()&#123; int t; cin&gt;&gt;t; while (t--)&#123; cin&gt;&gt;y; double x1=0,x2=100;//先把上下界在这里确定好 double mid=(x1+x2)/2; if (f(x1)*f(x2)&gt;0) cout&lt;&lt;"No solution!"&lt;&lt;endl; else &#123; while (x2-x1&gt;=pre)&#123;//这里必须写的是上下界线是多少， 不能写的是用于判断mid的条件。 if (f(x1)*f(mid)&lt;0)&#123; x2=mid; mid=(x1+x2)/2; &#125; else &#123; x1=mid; mid=(x1+x2)/2; &#125; &#125; cout&lt;&lt;fixed&lt;&lt;setprecision(4)&lt;&lt;mid&lt;&lt;endl; &#125; &#125;&#125; 上面就是我第二次出错的地方，判断二分循环逼近的的条件不应该看mid的取值，而是应该看得是区间上界减去区间下界的范围从而来限定。 此处关于三分法的求解：当需要求某凸性或凹形函数的极值，通过函数本身表达式并不容易求解时，就可以用三分法不断逼近求解。 三分法——求解凸性函数的极值问题http://hi.baidu.com/vfxupdpaipbcpuq/item/81b21d1910ea729c99ce33db 经典例题：侵略的奶牛： 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 100005;int a[maxn],n,c;//此过程就是在判断奶牛之间的间隔为这个值合不合适bool cc(int d)&#123; int t=a[0],cnt=1; for (int i=1;i!=n;i++)&#123; if (a[i]-t&gt;=d)&#123; cnt++; t=a[i]; if (cnt&gt;=c) return true; &#125; &#125; return false;&#125;//此过程就是在收录每一个值，然后再分别进行判断int solve()&#123; int x=0,y=a[n-1]-a[0]; while (x&lt;=y)&#123; int mid=(x+y)/2; if (cc(mid)) x=mid+1; else y=mid-1; &#125; return x-1;&#125;//不过这种最大值最小值的题目需要多花时间想想。int main()&#123; while (cin&gt;&gt;n&gt;&gt;c)&#123; for (int i=0;i!=n;i++) cin&gt;&gt;a[i]; sort(a,a+n); cout&lt;&lt;solve()&lt;&lt;endl; &#125;&#125; ==下面则是其他地方关于二分的题目==基础版 POJ 3122 Pie 二分枚举区间是实数POJ 1064 Cable master 二分枚举区间是实数,注意精度POJ 3258 River Hopscotch 最大化最小值POJ 3273 Monthly Expense 最小化最大值LIGHTOJ 1076 Get the Containers 最小化最大值，。和上一个差不多LIGHTOJ 1307 Counting Triangles 进阶版 POJ 3579 二分搜索+二分查找POJ 3685 二分搜索+二分查找ZOJ 3278 也是两个二分嵌套LIGHTOJ 1048和LightOJ 1076一样，不过要输出一组解LIGHTOJ 1383 二分加贪心（区间）ZOJ 3665 某年区域赛题。，二分枚举ZOJ 3726 去年区域赛题，二分查找codeforces 382B 有意思的题codeforces 391D2 难，。。，，、 ==下面就是关于三分的题目== poj3301hdu4454hdu3714hdu2438]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道计算机几何算法相关题目]]></title>
    <url>%2F2018%2F12%2F01%2F%E4%B8%80%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%87%A0%E4%BD%95%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目： 代码如下：1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;using namespace std;double v,s,b;const double pi = acos(-1.0);int main()&#123; while(cin&gt;&gt;v&gt;&gt;s&gt;&gt;b)&#123; if (s&lt;b)&#123; cout&lt;&lt;-1&lt;&lt;endl; continue; &#125; double x = (v * v) / 9.8; if ( x &lt; s ) &#123; cout&lt;&lt;"move "&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;s-x&lt;&lt;endl; &#125; else &#123; double b = (s * 9.8) / (v * v); //注意反函数的转换。 double a = asin(b) * 90 / pi; //这里有一个进一的操作，因为此题不太会去四舍五入。 int a_ = a; if (a-a_ &gt;= 0.5) a_++; cout&lt;&lt;"a "&lt;&lt;a_&lt;&lt;endl; &#125; &#125; return 0;&#125; 关于这道题目的相关要点 反函数相关要点。注意 反函数最后输出的是 一个弧度值，根据相应数学的算法而言记住 ==弧度值=角度*pi/180== 关于输出中进1的相关操作。按照第几位，先换算成相应的整形数，最后再强转成int型 最后在判断是否大于0.5来考虑时候来加一。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款27：尽量少做转型动作]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE27%EF%BC%9A%E5%B0%BD%E9%87%8F%E5%B0%91%E5%81%9A%E8%BD%AC%E5%9E%8B%E5%8A%A8%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[C++ 规则的设计目标之一就是，保证“类型错误” 绝不可能发生，但是在 C++的某些特殊的情形下面不得不去使用转型这一特性，而 C 语言的转型语句则类似于以下： 然而 C++提供四种新式的类型转换 注意 在真正进行类型转换的时候，我们不能仅仅认为编译器到最后仅仅只是更改一个文件名字，编译器改变的底层的编码，比如 int 转型到 double 之间底层描述是不一样的。 另外 C++中的一个特性使得多重继承的时候，一个对象含有多个地址。 所以需要注意的是以下几点，如果可以的话，尽量避免转型，特别是在注重代码中避免dynamic_cast. 如果有设计需要转型动作的话，去试试无需转型的替代设计。 如果转型是必要的，那么试着将其隐藏在某个函数背后。客户随后可以调用该函数，而不需要讲转型放进他们自己的代码中。 宁可使用 C++新式的转型，也不要使用旧式的转型，前者很容易识别出来，而且也有着不叫分们别类的职掌。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于组合数学，两道思维题目，这里贴两道题目]]></title>
    <url>%2F2018%2F12%2F01%2F%E5%85%B3%E4%BA%8E%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%8C%E4%B8%A4%E9%81%93%E6%80%9D%E7%BB%B4%E9%A2%98%E7%9B%AE%EF%BC%8C%E8%BF%99%E9%87%8C%E8%B4%B4%E4%B8%A4%E9%81%93%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[第一道 简单的排列组合： 题解如下： 题目大致可以理解为4堆牌a,b,c,d，每次从一堆牌里拿出牌顶的一张牌，问共有多少种拿法。其实我们可以一堆一堆的分析，假设只有一堆a时只有1种拿法，那两堆a,b时我们可以认为是从a个牌中插入b张牌，用数学表达式就是==C(b,a+b)==;那么三堆的话我们可以把前两堆看成一堆，那么表达式就是==C(c,a+b+c)==，这是我们需要与前两堆的组成方法相乘，就是==C(b,a+b)C(c,a+b+c)==。4堆的话就是==C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)==。所以答案就是==C(a,a)C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)==。此外，有一公式==C(a,b)=C(a,b-1)+C(a-1,b-1)==，所以我们用数组来代替C(m,n)操作 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 501;const long long mod = 1000000007;long long a[4],sum[4]=&#123;0&#125;;//此处用到记忆化搜索，动态规划。long long dp[maxn*4][maxn*4];void init()&#123; dp[0][0]=0; for (int i=1;i!=4*maxn;i++)&#123; dp[i][0]=1; //根据表格来看的确是每一行的第一个是1 for (int j=1;j&lt;i;j++)&#123; //这个地方就是状态转移方程 //C(a,b)=C(a,b-1)+C(a-1,b-1)根据公式来做的 dp[i][j]=dp[i-1][j]+dp[i-1][j-1]; //dp[i][j]=dp[i][j]%mod; &#125; dp[i][i]=1; &#125;&#125;int main()&#123; int t; cin&gt;&gt;t; while (t--)&#123; init();//这个地方就开始初始化表格了。 long long ans =1; for (int i = 0; i&lt;4;i++)&#123; if (!i) sum[i]=0; else sum[i]=sum[i-1]; cin&gt;&gt;a[i]; sum[i] += a[i]; if (a[i] &gt; sum[i]-a[i]) a[i]=sum[i]-a[i]; &#125; for (int i = 1 ; i != 4; i++)&#123; ans *= dp[sum[i]][a[i]]; //ans %=mod; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 第二题 第一题的变式： 题解如上，与上面一题有区别的地方就在于要有一个取模的操作 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 501;const long long mod = 1000000007;long long a[4],sum[4]=&#123;0&#125;;//此处用到记忆化搜索，动态规划。long long dp[maxn*4][maxn*4];void init()&#123; dp[0][0]=0; for (int i=1;i!=4*maxn;i++)&#123; dp[i][0]=1; //根据表格来看的确是每一行的第一个是1 for (int j=1;j&lt;i;j++)&#123; //这个地方就是状态转移方程 //C(a,b)=C(a,b-1)+C(a-1,b-1)根据公式来做的 dp[i][j]=dp[i-1][j]+dp[i-1][j-1]; dp[i][j]=dp[i][j]%mod; &#125; dp[i][i]=1; &#125;&#125;int main()&#123; int t; cin&gt;&gt;t; while (t--)&#123; init();//这个地方就开始初始化表格了。 long long ans =1; for (int i = 0; i&lt;4;i++)&#123; if (!i) sum[i]=0; else sum[i]=sum[i-1]; cin&gt;&gt;a[i]; sum[i] += a[i]; if (a[i] &gt; sum[i]-a[i]) a[i]=sum[i]-a[i]; &#125; for (int i = 1 ; i != 4; i++)&#123; ans *= dp[sum[i]][a[i]]; ans %=mod; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; ==以后学到后面再花时间来深究==]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论基础第一节]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E8%8A%82%2F</url>
    <content type="text"><![CDATA[初等数论是用初等方法研究的数论，它的研究方法本质上说，就是利用整数环的整除性质，主要包括整除理论、同余理论、连分数理论。 整除问题引申到同余问题 同余的性质 可以换算成以下式子：a=c(modb) 这里c为余数，而b为除数 同余的性质 自反性 a=a mod m 对称性 a=b mod m 等价于 b=a mod m 传递性 a=b mod m 与 b=c mod m 等价于 a=c mod m 线性合成 a=b mod m 与 c= mod m 等价于 a±c=b±d mod m 与 ac= bd mod m 消去公因子 ac=bc mod m &amp;&amp; gcd(c,m)=1 等价于 a=b mod m 素数筛 朴素筛 一般就是循环2~√n次 埃拉托斯特尼筛 循环次数 欧拉筛 相应代码如下：12 最大公约数以及最小公倍数 最大公约数 函数_gcd(a,b)而多个数的最大公约数 就是 _gcd(a,b,c)=_gcd(gcd(a,b),c) 最小公倍数_lcm(a,b)=ab/_gcd(a,b) 扩展欧几里得 关于求解线性同余方程 关于求逆元 关于快速幂 费马小定理 另外 欧拉函数 欧拉函数定义 欧拉函数性质 求值公式 上述公式 可以用来： 求逆元 欧拉降幂公式 数论函数 中国剩余定理 解法]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道有趣的题目——逆波兰计算器]]></title>
    <url>%2F2018%2F12%2F01%2F%E4%B8%80%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A2%98%E7%9B%AE%E2%80%94%E2%80%94%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[题解首先这道题毫无疑问是要用到stringstream流的。分别依次读取字符串，并且将其导入到char型的代码中去。比如说a+b可以变成ab+，这里最好运用到栈的知识，来控制出栈与进栈。==注意以下几个地方== 注意输入cin&gt;&gt;t以后，需要用getchar()来清空上一个步骤留下来的回车符号 注意此处需要严格进行判断栈内是否为空。 这里是将乘除求模的运算放在最右边，这样就可以有优先级存在了 括号会提前进行一步运算，然后消除掉左括号，或者左边的所有运算式，进行一个结算。 map这里存在的意义就在于 为判断进行提供条件。 此道题目涉及字符串，栈，模拟的相应算法，需要有空的时候可以多看看。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;sstream&gt;#include&lt;map&gt;using namespace std;stack&lt;char&gt;ope;stack&lt;int&gt;num;string str;map&lt;char,int&gt;m;void init()&#123; m['+']=m['-']=1; m['*']=m['/']=m['%']=m['(']=m[')']=2; while(!num.empty()) num.pop(); while(!ope.empty()) ope.pop();&#125;//此处为基本的运算规模。void op1(int &amp;a,int &amp;b,const char &amp;c)&#123; if (c =='+') a += b; else if (c == '-') a=b-a; else if (c == '*') a*=b; else if (c == '/') a=b/a; else if (c == '%') a=b%a;&#125;//此处就是控制出栈的运算，一般就是括号内部的计算了。算出每一个括号内部的运算式。void op2()&#123; char ch = ope.top(); while (ch != '('&amp;&amp;!ope.empty())&#123; ope.pop(); int a = num.top(); num.pop(); int b = num.top(); num.pop(); op1(a,b,ch); num.push(a); if (!ope.empty()) ch = ope.top(); &#125;//这个下面要注意的判断条件中一定要加上判断是否为空。 if (!ope.empty()&amp;&amp;ope.top() =='(') ope.pop();&#125;int main()&#123; int t; cin&gt;&gt;t; getchar(); while (t--)&#123; getline(cin,str); stringstream s(str); init(); char tmp; while (s&gt;&gt;tmp)&#123; if(tmp&gt;='0'&amp;&amp;tmp&lt;='9')&#123; int x = 0; do&#123; if (m[tmp]) break; x *= 10; x += tmp - '0';//此处是将char转换成int &#125;while(s&gt;&gt;tmp); num.push(x); &#125; //注意这个地方的高明之处就在于碰见‘）’的返回，以及判断有没有‘（’， 比如连加的情况就把加减乘除的优先运算级给表示出来了。 //最后相当于将运算优先级高的全部放到了右边，然后有括号的就先解决括号， 及时左括号被提前弄没了也不要紧，存在有右括号就行，然后乘除永远放在加减的左边。 if (tmp==')') op2(); else if (m[tmp]==1)&#123; if (!ope.empty()&amp;&amp;ope.top()!='(') op2(); ope.push(tmp); &#125; else if (m[tmp]) ope.push(tmp); &#125; int ans = num.top(); num.pop(); while (!num.empty()&amp;&amp;!ope.empty())&#123; op1(ans,num.top(),ope.top()); ope.pop(); num.pop(); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道STL的题解题目，需要以后花时间理解题目意思]]></title>
    <url>%2F2018%2F12%2F01%2F%E4%B8%80%E9%81%93STL%E7%9A%84%E9%A2%98%E8%A7%A3%E9%A2%98%E7%9B%AE%EF%BC%8C%E9%9C%80%E8%A6%81%E4%BB%A5%E5%90%8E%E8%8A%B1%E6%97%B6%E9%97%B4%E7%90%86%E8%A7%A3%E9%A2%98%E7%9B%AE%E6%84%8F%E6%80%9D%2F</url>
    <content type="text"><![CDATA[代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;//#include&lt;function&gt;#define ll long longusing namespace std;const int fort = 1314;ll a[6];//这道题目就换一种思考方式，让基数分贝加上加数，这样一来，就会简化很多步骤int main()&#123; int t; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;a[0]&gt;&gt;a[1]&gt;&gt;a[2]; a[3] = 5; a[4] = 2; a[5] = 0; sort(a, a + 6, [](const ll &amp;a,const ll &amp;b)&#123;return a&gt;b;&#125;); priority_queue&lt;ll, vector&lt;ll&gt;, greater&lt;ll&gt; &gt; pq; set&lt;ll&gt;s; set&lt;ll&gt;ans; pq.push(1); s.insert(1); for(int i = 0;;i++)&#123; ll x = pq.top(); pq.pop(); if(i)&#123; for(int k = 3;k &lt; 6;k++)&#123; ans.insert(x - a[k]); if(ans.size()==fort) break; &#125; if(ans.size()==fort)&#123; /*int ttt = 1; for(set&lt;ll&gt;::iterator it = ans.begin();it!=ans.end();it++) cout&lt;&lt;ttt++&lt;&lt;' '&lt;&lt;*it&lt;&lt;endl;*/ auto it = ans.rbegin(); cout&lt;&lt;*it&lt;&lt;endl; break; &#125; &#125; for(int j = 0;j&lt;3;j++)&#123; ll x2=x*a[j]; if(!s.count(x2))&#123; s.insert(x2); pq.push(x2); &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法]]></title>
    <url>%2F2018%2F12%2F01%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[贪心算法定义贪心算法的本质目的也就在于对于一个问题来看，我可以用最简单的办法算出局部的解集，并且按照这个最简单的办法同样可以算出该问题的最终解决办法，即贪心算法。 三个经典的贪心算法问题 事件的序列问题： 遇到这样的题目，首先就是要想着能不能找到最长的子序列的前提，到底是按节目的开始时间进行排序，还是按照节目的结束时间进行排序。下面就是核心代码12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 100+5;struct Show&#123; int beg; int en;&#125;show[maxn];int main()&#123; int n; while (cin&gt;&gt;n&amp;&amp;n!=0)&#123; for (int i=0;i!=n;i++)&#123; cin&gt;&gt;show[i].beg&gt;&gt;show[i].en; &#125; stable_sort(show,show+n, [](const Show &amp;a, const Show &amp;b)&#123;return a.en&lt;b.en;&#125;); int cnt=1; for (int i=1,j=0;i&lt;n;i++)&#123; if (show[i].beg&gt;=show[j].en)&#123; cnt++; j=i; &#125; &#125; cout&lt;&lt;cnt&lt;&lt;endl; &#125;&#125; 此处的关键就是从第一个开始把结束时间最早的进行一个相对位置的排序，然后把第一个结束的与后面开始的时间进行挨个挨个的比较，最终得出的结果就是在这里。 区间覆盖问题下面就是这道题目的核心代码：123456789int greedy(vector&lt;int&gt; x,int k)&#123; int i,sum = 1,n=x.size(); sort(x.begin(),x.end()); int temp = x[0]; //区间的起始位置 for(i=1;i &lt; n; ++i) if(x[i] - temp &gt; k) &#123;sum++,temp=x[i]&#125;; return sum;&#125; 题目这里就是分别计数，用一个最简单的思维做出一整道题目的思路。 区间相交问题：其实就是跟第一道题目类似 算连续的序列 并且把总长度减去这些连续的序列之后得到的是剩余的区间，即得到题目答案。 ==以后若还有关于贪心类型的题目可以继续往上面加== 一下就是贪心的习题]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL的简单总结]]></title>
    <url>%2F2018%2F12%2F01%2FSTL%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[补一个加快C++输入输出速度的方法： 花上一天的时间来总结 C++ primer 里面的算法以及容器这一章，多余的用法可以上网去查找当做是相应的扩展。 字符串 string与字符数组 构造string的方法 操作string的方法 上面的成员函数有的说要返回，同时，有的也存在不返回值。 搜索string的方法 以上就是find函数的一些用法，在泛型算法一章，还会继续涉及到。题目返回的是下标 补充一下关于string中的比较函数一般在string中可以直接用运算符进行比较 int与string之间的转化 getline()的两种写法注意在cin&gt;&gt;t;必须要一个getchar()来吞掉其前面的回车符号。之后才能用getline()。 顺序容器 容器种类 vector&lt;vector&lt;int&gt; &gt;来表示二维数组。 容器基础操作补充一个assign的用法：允许从一个不同但相容的类型里面去赋值，或者从容器的一个子序列赋值。 还有第二个版本：接受一个整型值和一个元素值，用指定数目且具有相同给定元素替换容器中原有的元素： 再补充一个resize的用法： 需要记住有一些类型声明可以直接用auto。 初始化有两种一种直接初始化和拷贝初始化。 顺序容器添加元素上面已经列出了各种形式的插入。插入是在迭代器指向的元素之前插入。插入想要插入的元素前面，比如说push_back是插入到了尾后迭代器的前面。而返回的是新添加的第一个元素的迭代器，同样也可也==不返回==。 这里要注意的是push_front会改变整个容器的迭代器指向，而push_back不会。 访问元素 链表，单向链表，栈，队列都不支持随机访问，也就不支持下标访问了。 删除元素 删除的是迭代器指向的元素，返回的是删除元素的后迭代器也就是被删除的元素下一个元素的前面的迭代器，同样也可以不返回。 这里需要注意的就是删除一个元素之后，必定会改变原容器中迭代器的指向，所以务必小心（除了pop_back） 改变容器大小的操作 特殊的forward_list（单向链表） 由于迭代器的添加删除操作都涉及到了首前和尾后，所以对于单向链表来说这里添加了一个首前迭代器before_begin而对于单向链表的插入而言 是在元素的后面进行插入，删除也是一样，指向都是迭代器指向元素之后的元素。 关联容器 **关联容器里面的pair 关联容器的操作 关联容器的添加操作 一般都是直接用下标操作添加map里面的操作。at操作只能判断存不存在 关联容器的删除操作 关联容器的访问操作 上面关于排序的操作不适用于无序的关联容器。 当允许关键词重复的multimap中查找元素时，一般使用find函数与count函数同时进行。 算法大部分函数算法都放在&lt;algorithm&gt;的头文件里面了。还有一些数值算法是放在了&lt;numeric&gt;的头文件里面。 只读算法 accumulate 求和算法，接受三个参数，前面两个参数是累加范围，第三个是和的初值。equal 判断两个序列里面是否所有的值都相同。后面网上查找 有的再补充。find算法binary_search()二分查找函数find_end()最后一次出现算法find_first_of()第一次出现的算法find_if ()第三个参数就为自定义函数搜索lower_bound()第一个不小于的元素upper_bound()第一个大于的元素count（）算法 计算出现次数count_if（）函数自定义计数 写容器的算法 fill 填充算法 类似于memset函数前者在于可以赋值赋任何值，而后者理论上只能赋值0或者1或者0x3f3f3f3f。fill_n也是三个参数，第一个是开始点，第二个是赋值数目，第三个为赋值初始化。copy 拷贝算法，接收三个迭代器，前面两个表示输入范围，第三个为拷贝目标序列的起点。replace 替换算法，将目标序列里面的某些值更改成某些值，接受四个参数，前面两个是目标序列的范围，第三个是要搜索的值，第四个是要将搜索到的第三个的值更改后的值。remove 去除掉函数里面包括的参数的元素。remove_if 自定义。remove_copy 拷贝结果。swap（）交换两个对象的值。swap_range()交换两个序列的值。 重排容器的算法 其排序的算法中，定义的排序方式就在于自定义函数传入算法中。有三种自定义函数： 普通bool型自定义函数，比较排列顺序。 lambda 匿名小函数。 bind 函数 绑定谓词。灵活的应用自定义函数。 unique 将容器中所有重复的值全部排列到后面去，接受目标序列的迭代器范围，返回指向第一个重复元素的迭代器。sort 排序 本质上运用的是快速排序。stable_sort 本质上运动的是归并排序。stable_partition 前面进行排序后，把自定义排列的分割开来。reverse 倒排函数。reverse_copy 倒排函数。rotate 接受三个参数，前面两个是要往后面排的范围。 迭代器 插入迭代器back_inserter 类似于push_back的迭代器，创建并且使用front_inserter 创建并且使用一个push_front的迭代器inserter 创建一个普通插入的迭代器 流迭代器istream_iterator 输入迭代器 ostream_iterator 输出迭代器 反向迭代器reverse_iterator 移动迭代器后面复习到在总结 移动、拷贝、右值引用。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>数据结构</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树相关题目]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[复原二叉树 题解此道题目就是要注意先序排序与中序排序，一个是根左右，一个是左根右，先序排序的第一个为根，利用递推关系输出每一个根（由于其的递推出口并没有等于号，意思就是说这里同样输出叶子节点） 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;string pre;string in;void post(int root,int start,int end)&#123; //递归打印这棵树的后序，递归出口为 start &gt; end //注意这里不带等于号的原因就是要把叶子节点一样给输出来 if(start&gt;end) return; int i=start;//i为 root所代表的值在中序中的下标 while(i&lt;end&amp;&amp;in[i]!=pre[root]) i++; int cnt=i-start;//左子树结点个数 //由于是先序排序，顺序永远都是根左右， post(root+1,start,i-1); //左节点 因为是后序排序，先把左节点先弄出顺序，在左节点内部在来后序排序，直到两边左边节点大于右边节点 post(root+1+cnt,i+1,end); cout&lt;&lt;pre[root];&#125;int main()&#123; while(cin&gt;&gt;pre&gt;&gt;in)&#123; int len=pre.length(); post(0,0,len-1); cout&lt;&lt;endl; &#125; return 0;&#125; 关于树的一个简单DFS运用 题解 简单的dfs运用 可以模拟树的组成，但是特别耗时间，只用用相应的搜索方法来做才容易一点，这道题有必要再做一遍。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;const int maxn = 1e5+5;//此处实际上是充分利用了vector的特性//如果此处是二维数组的话，那么一定会浪费许多没必要的空间开支//所以用一个vector的数组，每个vector存储其对应的祖先//而一共有题目给出数量的vectorvector&lt;int&gt;people[maxn];char sex[maxn*2];int ans;int top;int que[maxn];//这里e的值只是用来判断到底是该植入值还是该判断值//换算到这个题目中的意思就是前面一个人不需要看起祖先只需要输入其祖先就行了//后面一个人则需要做的是根据已有的对方祖先进行判断void dfs(int x,int s,int e)&#123; if (s&gt;=5) return ; if (e==0)&#123; for (int i=0;i!=top;i++)&#123; if (x==que[i])&#123; ans=1; return; &#125; &#125; &#125; else que[top++]=x; for (int i=0;i!=people[x].size();i++) dfs(people[x][i],s+1,e); return;&#125;//上面的递归搜索可以用来因为是从底层向上面进行搜索//由于孩子祖先有两个所以上面搜索方式每一个孩子的祖先作为单独的节点再次进行搜索，直到递推出口为止int main()&#123; int n; cin&gt;&gt;n; char ch; int x,fa,ma; for (int i=0;i!=n;i++)&#123; cin&gt;&gt;x; getchar(); cin&gt;&gt;sex[x]; cin&gt;&gt;fa&gt;&gt;ma; if (fa!=-1) people[x].push_back(fa); if (ma!=-1) people[x].push_back(ma); sex[fa]='M'; sex[ma]='F'; &#125; int k; cin&gt;&gt;k; for (int i=0;i!=k;i++)&#123; cin&gt;&gt;fa&gt;&gt;ma; ans=0; if (sex[fa]==sex[ma]) cout&lt;&lt;"Never Mind"&lt;&lt;endl; else&#123; top=0; dfs(fa,0,1); dfs(ma,0,0); if (ans) cout&lt;&lt;"No"&lt;&lt;endl; else cout&lt;&lt;"Yes"&lt;&lt;endl; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款01：视 C++ 为一个语言联邦]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE01%EF%BC%9A%E8%A7%86%20C%2B%2B%20%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6%2F</url>
    <content type="text"><![CDATA[现在发展的C++已经是一个多重泛型编程语言。 一个同时支持过程形式、支持面向对象形式、函数形式、泛型形式、元编程形式的语言，这些能力和弹性使 C++成为了一个无可匹敌的工具。对待其的方式最简单的方法是将其看做是一个由相关语言组成的一个联邦而不是某个次语言。 C 说到底 C++ 仍然是 C 的一个延伸，面对过程的编程思想仍然在某些时候很受用，而某些时刻 C++ 的解法只不过就是比 C 高级了一点点，但是当你以 C++的内 C 成分的工作的时候，高效编程则映照出了 C 语言的局限，没有模板，没有异常，没有重载。 Object-Oriented C++ 这部分也就是 C++ 中面对对象编程思想的直接体现，简单来说就是 C with class 比如 类，封装，继承，多态，虚函数的动态绑定。 Template C++ 这是 C++中的泛型编程部分，template 的相关考虑与设计已经弥漫了整个 C++ 而这种编程思想的强大，直接带来了全新的名字 模板元编程，后面得花上大部分时间去专研这个。 STL 基本上包括 容器，迭代器，算法以及相应的函数对象，一般竞赛可能会直接用到里面的相关容器以及相关算法，熟练使用 STL 也是一名 C++ 程序员应该必备的素质。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款02：尽量以const,enum,inline 替换掉#define]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE02%EF%BC%9A%E5%B0%BD%E9%87%8F%E4%BB%A5const%2Cenum%2Cinline%20%E6%9B%BF%E6%8D%A2%E6%8E%89%23define%2F</url>
    <content type="text"><![CDATA[这个条款其实也就相当于宁可编译器替换预处理器比较好 1. 对于单纯常量而言，使用 const 对象或者是 enums 比 #define 更加省时间 时间上更为节省 作为一个语言常量而不是名称记号，由于在函数体中分配了内存，追寻起来消耗的时间比在函数中使用名称记号所花的时间更少，因为有实处更容易寻找，不像名称记号，可能有的时候并没有进入到记号表中。 还有一些其他的只能使用 const 情况 定义常量指针和类的专属常量]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款03：尽可能使用 const]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE03%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8%20const%2F</url>
    <content type="text"><![CDATA[首先使用 const 可以防止后期莫名其妙的进行改变原有的意思，相当于一个约束语义，另外编译器不论什么时候都会强制施行这项约束。 const 在 C++ 11 中有底层和顶层之分，前者是作用于指针本身，指针不再改变指向对象，而顶层 const 则是指针所指向的对象则不能发生改变。 const 最具威力的用法实在面对函数声明时的用法，在一个函数的声明式里，const 可以和函数的返回值，各自的参数以及函数自身产生关联。 将引用参数设置成 const 好处是在后面写代码的过程中如果把==写成=，可以立马甄别出来。 const 成员函数存在的两个理由，一个使 class 的接口一目了然，因为知道了哪些可以被改动对象而哪些不可以被改动对象，第二则是基于代码编写的高效性而言，操作 const 对象成为可能，因为可以通过 const 成员函数返回 const 对象。 存在一种特殊情况，重载[ ]运算符的时候，如果成员函数是 const 那么其的返回值也必须是 const&amp;类型的。 如果对于const 成员函数，想要改变该对象的内部成员的话，但是又不想全部改变的话，可以在类中的数据成员定义中加上 mutable，来保证可以改变该函数，其存在的意义就在于保证了其他数据成员不能被 const 成员函数改变，但是该数据成员却可以。 7.当 const 和 non-const 成员函数有实质等价的实现时，令 non-const 版本调用 const 版本可避免代码重复。 这一点还不是特别了解，需要看到后面之后花点时间来看看这一点的内容。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款04：确定对象被使用前已先被初始化]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE04%EF%BC%9A%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[在 C 语言中对象的初始化可能会变得异常容易，但是在 C++中某些语境下进行对象可能不会存在自动的初始化过程，也许会在使用 C part of C++ 会自动有一个初始化过程，但是在其他部分下面的 C++就不能保证初始化过程了。 特别是在类的过程中，初始化的过程一般直接交给构造函数，初始化的过程并不等同于赋值，所以在写类的构造函数的时候，尽量不要在函数体里面写赋值给私有成员的语句，可以直接在列表上面直接写初始化的。 对于拥有多个构造函数，且每个构造函数具有自己的成员初值列，如果这些类存在许多成员变量或者基类的话，多种成员初始列表就会导致不受欢迎的重复，那么这个时候可以遗漏一些“赋值跟初始化过程差不读的成员变量”，改用他们的赋值操作，并且把这些操作放置在 private 中。 C++有着十分固定的成员初始化过程，基类的初始化会早于派生类，而类的成员变量总是以其声明的次序被初始化。 关于类的静态成员的初始化 一般在类内部进行声明，然后再类的外部进行定义，赋值，其的声明周期一般是从程序开始到程序结束。 构造函数初始化的次序非常重要，举个例子就是初始化的时候必须要为数组指定大小，所以指定大小的变量必须具有先值 对于不同人在不同时间下不同的源码文件建立起来，其的初始化相对次序并没有明确定义，所以解决办法就是将一个对象搬到自己的专属函数里面去，然后声明成静态成员，并且返回一个引用即可，后面用户直接调用这些函数，就可以无视初始化的次序问题了。具体可以看书里面P32面的相关代码。 最后总结一句为了免除“跨编译单元之初始化次序”问题，一般用 local static 对象替换 non-local static 对象。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款05：了解 C++默默编写并调用了哪些函数]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE05%EF%BC%9A%E4%BA%86%E8%A7%A3%20C%2B%2B%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[几乎每一个 class 都会用一个或多个构造函数，一个析构函数，一个拷贝重载运算符，有些是系统自动生成的合成版本，有些是需要自定义的版本，所以这一条款的目的是为了探寻哪些是需要自己去写，哪一些是需要系统自身合成的。 千万不要写完构造函数或者拷贝构造函数或者是析构函数之后不去定义，那么会造成问题，而且此类问题会造成很多方面上的无法适应问题。 另外这里额外需要注意的是 C++11上增加的移动语义，只有在拥有了拷贝构造函数和拷贝赋值运算符之后，编译器才会自动生成移动构造函数，和移动赋值运算符。 最后这个条款需要注意的就是编译器自动生成的函数具有普遍性，所以就不具有特异性，一些特殊的操作在合成版本上面可能会出现大问题。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款06：若不想使用编译器自动生成的函数，就应该明确拒绝]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE06%EF%BC%9A%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E5%BA%94%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D%2F</url>
    <content type="text"><![CDATA[有的时候鉴于某些情况，比如智能指针中 unique_str 和 io 库对象无法发生拷贝和赋值，是因为明确在类的内部进行了拒绝操作，所以无法拷贝与赋值，这一个条款就来讲解有哪些方法可以用来拒绝。 把自己不想要的函数，但是系统默认又会生成的函数放到私有成员中，这种方法很简便，但是有一个缺点就是在类的内部定义中仍然是可以使用拷贝与赋值功能的。 继承一个基类，使用 private 继承方法，然后将这个基类的函数放入私有成员中，这样就可以保证万无一失的方法，但是缺点就是太复杂，还需要定一个基类。 C++11 提出的新办法将函数声明出来，不仅不去定义，而且直接声明成 delete。这样更便捷。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款07：为多态基类声明 virtual 析构函数]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE07%EF%BC%9A%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8E%20virtual%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在进行基类与派生类之间动态绑定的时候，如果发生对象销毁调用的析构函数不是虚函数的话，那么就会造成析构销毁部分的现象。 C++明确指出，当 derived class 对象经由一个 base class指针被删除，而该 base class 带着一个不是虚函数的析构函数的话，其结果往往都是自定义的，就像上述的说法而言，往往是对象的 derived 成分没有被销毁，而且消除这个问题最简单的办法是在基类的析构函数上面加上虚函数的声明。 不要随便继承标准库里面的东西，因为里面大部分东西都不存在虚函数的析构函数，这样一来，如果使用动态绑定的话，那么在销毁对象的过程中就没有办法全部销毁了。 而且不一定是基类的析构函数设置成虚函数，只要类里面有一个函数是虚函数的话，那么就需要将析构函数定义成虚函数。 类的用途不是作为多态的用途的话，那么请不要将析构函数声明成虚函数，因为那样没有作用。 对于一个纯虚函数而言，这个类就是一个抽象类，但是由于存在一个析构函数，所以一般要为这个纯虚函数提供定义，其的运作方式是最深层派生的那个类的析构函数最先被调用，然后就是每一个基类的析构函数被调用，所以编译器会在派生类的析构函数中定一个对基类纯虚析构函数的调用动作，因此，一般都得进行调用。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款08：别让异常逃离析构函数]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE08%EF%BC%9A%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[其实这一项条款没有领悟的很深刻，可以理解成不要再析构函数里面写捕获异常之类的代码。因为某些时候，如果在析构函数里面抓获异常导致程序终止的话，那么就可能造成对象不能完全被销毁 析构函数绝对不要吐出异常，如果一个被析构函数调用的函数可能抛出异常的话，析构函数应该做的应该是捕捉任何异常，然后吞下他们（不传播）或者结束程序。 如果对象需要对摸个操作函数运行期间抛出的异常做出反应，那么 class 应该提供一个普通函数（不应该在析构函数里面）执行该任务。但是该析构函数里面仍然要进行双保险的析构过程，可以在类的内部定义里面加上一个 bool 变量来判断到底有没有运行析构行为，相当于一般写程序的一个 flag。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于模拟与搜索的相应简单题目]]></title>
    <url>%2F2018%2F12%2F01%2F%E5%85%B3%E4%BA%8E%E6%A8%A1%E6%8B%9F%E4%B8%8E%E6%90%9C%E7%B4%A2%E7%9A%84%E7%9B%B8%E5%BA%94%E7%AE%80%E5%8D%95%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; string w,v; int x,y,m; char ch; while(cin&gt;&gt;w&gt;&gt;v)&#123; string s; int flag=0; reverse(w.begin(),w.end()); reverse(v.begin(),v.end()); if (w.size()&gt;v.size())&#123; m=w.size()-v.size(); for (int i=0;i!=v.size();i++)&#123; x=w[i]-'0'; y=v[i]-'0'; x+=y; if (flag)&#123; flag=0; x++; &#125; if (x&gt;=10)&#123; flag=1; x=x-10; &#125; ch=x+'0'; s.push_back(ch); &#125; int i=v.size(); while (flag==1&amp;&amp;i&lt;=m)&#123; flag=0; x=w[i]-'0'; x++; if (x&gt;=10)&#123; flag=1; x=x-10; &#125; ch=x+'0'; s.push_back(ch); i++; &#125; if (flag&amp;&amp;i==w.size())&#123; s.push_back('1'); &#125; &#125; else &#123; m=v.size()-w.size(); for (int i=0;i!=w.size();i++)&#123; x=w[i]-'0'; y=v[i]-'0'; x+=y; if (flag)&#123; flag=0; x++; &#125; if (x&gt;=10)&#123; flag=1; x=x-10; &#125; ch=x+'0'; s.push_back(ch); &#125; int i=w.size(); while (flag&amp;&amp;i&lt;=m)&#123; flag=0; x=w[i]-'0'; x++; if (x&gt;=10)&#123; flag=1; x=x-10; &#125; ch=x+'0'; s.push_back(ch); i++; &#125; if (flag&amp;&amp;i==v.size())&#123; s.push_back('1'); &#125; &#125; reverse(s.begin(),s.end()); cout&lt;&lt;s&lt;&lt;endl; &#125;&#125; 题解：其实这道题目属于一道相应简单的题目，就是要注意相应string与char之间的区别就行了。另外 int转换char是加上‘0’char转换int是减去‘0’。 一道简单的dfs的题目 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int maxn = 105;char h[maxn][maxn];int n,m,cnt=0;void dfs(int i,int j)&#123; if (i&lt;0||i&gt;=n||h[i][j]!='W') return ; if (j&lt;0||j&gt;=m||h[i][j]!='W') return ; if (h[i][j]=='W')&#123; h[i][j]='.'; dfs(i-1,j); dfs(i-1,j-1); dfs(i+1,j); dfs(i+1,j+1); dfs(i,j-1); dfs(i-1,j+1); dfs(i,j+1); dfs(i+1,j-1); &#125;&#125;int main()&#123; int ans=0; while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;(n!=0&amp;&amp;m!=0))&#123; for (int i=0;i!=n;i++) for (int j=0;j!=m;j++)&#123; cin&gt;&gt;h[i][j]; &#125; for (int i=0;i!=n;i++)&#123; for (int j=0;j!=m;j++)&#123; if (h[i][j]=='W')&#123; dfs(i,j); ans++; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; ans=0; &#125; return 0;&#125; 题解简单的dfs搜索出每一种情况，然后让其返回就行了。 一道经典的BFS的题目题目 代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;stdio.h&gt;#include&lt;queue&gt;using namespace std;int fxy[4][2]=&#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;//朝着四个方向char dis[101][101];int kp[101][101];//以下的node就作为每一次前进的节点struct node&#123; int x,y,cnt; node(int a=0,int b=0,int c=0)&#123; x=a; y=b; cnt=c; &#125;&#125;;int main()&#123; int m,n,k,g,k1,g1; while(~scanf("%d %d",&amp;m,&amp;n)) &#123; for(int i=0;i&lt;m;i++) &#123; scanf("%s",dis[i]); &#125; // 用队列整合的思想来完成 queue&lt;struct node&gt;q; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++)&#123; kp[i][j]=-1; &#125; // 两种初始化过程，并且找到起点与终点的所在位置 for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++)&#123; if(dis[i][j]=='S')&#123; k=i; g=j; &#125; if(dis[i][j]=='E')&#123; k1=i; g1=j; &#125; &#125; // 将起点存进去 node a(k,g,0); q.push(a); // 下面就是为bfs的相应搜索 while(!q.empty())&#123; struct node now=q.front(); q.pop(); kp[now.x][now.y]=now.cnt; // 将起点走了多少步数以及起点的坐标点存入到题目中去 for(int i=0;i&lt;4;i++)&#123; node next; next.x=now.x+fxy[i][0]; next.y=now.y+fxy[i][1]; // 判断走的下一步有没有出界，或者使下一步走的不会碰到路障 if(next.x&gt;=0&amp;&amp;next.x&lt;m&amp;&amp;next.y&gt;=0&amp;&amp;next.y&lt;n&amp;&amp;dis[next.x][next.y]!='#'&amp;&amp;kp[next.x][next.y]==-1)&#123; node empt(next.x,next.y,now.cnt+1); q.push(empt); &#125; &#125; &#125; if(kp[k1][g1]==-1) printf("Trapped!\n"); else printf("Escaped in %d minute(s).\n",kp[k1][g1]); &#125; return 0;&#125; 记住上面相应的队列思想。 一道DFS与BFS的综合题==需要多花时间来温习一遍== 题目 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;int n,m,k,cnt = 0;int x_begin,x_end,y_begin,y_end;const int maxn = 1005;int dis[maxn][maxn];char ch[maxn][maxn];class Position&#123;public: int x; int y; int distance; public: Position() = default; Position(int a, int b, int c):x(a),y(b),distance(c)&#123;&#125;; Position move(int i);&#125;;Position Position::move(int i)&#123; Position post = *this; if (i == 0) post.x = this -&gt; x + 1; else if (i == 1) post.x = this -&gt; x - 1; else if (i == 2) post.y = this -&gt; y + 1; else if (i == 3) post.y = this -&gt; y - 1; return post;&#125;void bfs()&#123; queue&lt;Position&gt;q_dis; Position p_begin (x_begin,y_begin,0); q_dis.push(p_begin); while(!q_dis.empty())&#123; Position now = q_dis.front(); q_dis.pop(); dis[now.x][now.y]=now.distance; for(int i = 0; i != 4; i++)&#123; Position next; next = now.move(i); if (next.x &gt;= 0 &amp;&amp; next.x &lt; n &amp;&amp; next.y &gt;= 0 &amp;&amp; next.y &lt; m &amp;&amp; dis[next.x][next.y] == -1 &amp;&amp; ch[next.x][next.y] != '#')&#123; Position empt (next.x,next.y,now.distance + 1); q_dis.push(empt); &#125; &#125; &#125;&#125;void dfs(int x,int y)&#123; if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m) return ; if (ch[x][y]=='L') &#123; cnt++; return; &#125; if (dis[x][y] == -1) return; // 前面已经有dis可以表示每一步走的距离，所以只需要一步一步来看，这样的做法便可以完全规避障碍物，单单从路径上面考虑。 if (dis[x][y]==dis[x+1][y]+1) dfs(x+1,y); if (dis[x][y]==dis[x-1][y]+1) dfs(x-1,y); if (dis[x][y]==dis[x][y+1]+1) dfs(x,y+1); if (dis[x][y]==dis[x][y-1]+1) dfs(x,y-1);&#125;int main()&#123; int T,Case = 0; cin&gt;&gt;T; while(T--)&#123; Case++; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; bool f_begin = false,f_end = false; for (int i = 0; i != n; i++)&#123; for (int j = 0; j != m; j++)&#123; cin &gt;&gt; ch[i][j]; dis[i][j] = -1; &#125; &#125; for (int i = 0; i != n; i++)&#123; for (int j = 0; j != m; j++)&#123; if (f_end &amp;&amp; f_begin) break; if (ch[i][j] == 'L')&#123; x_begin = i; y_begin = j; f_begin = true; &#125; if (ch[i][j] == 'C')&#123; x_end = i; y_end = j; f_end = true; &#125; &#125; &#125; bfs(); if (dis[x_end][y_end] == -1 ||dis[x_end][y_end] &gt; k ) cout &lt;&lt; "Case #"&lt;&lt;Case&lt;&lt;": "&lt;&lt;-1&lt;&lt;endl; else&#123; dfs(x_end,y_end); cout&lt;&lt;"Case #"&lt;&lt;Case&lt;&lt;": "&lt;&lt;dis[x_end][y_end]&lt;&lt;" "&lt;&lt;cnt&lt;&lt;endl; cnt = 0; &#125; &#125; return 0;&#125; 这里注明一下关于==默认实参==的知识点，因为在这个地方可以直接对类的构造函数赋值一个默认实参，可以避免输入默认构造函数了。 下面则是一道DFS的题目，这道题目看上去可以用bfs来做 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int maxn = 100;int road[maxn][maxn];int dp[maxn][maxn];int n, m;int dfs (int i,int j)&#123; if (dp[i][j] != -1) return dp[i][j]; int Max = 0; if (i-1&gt;=0 &amp;&amp; road[i][j]&gt;road[i-1][j]&amp;&amp;Max&lt;dfs(i-1,j)) Max = dfs(i-1,j); if(i+1&lt;n &amp;&amp; road[i][j]&gt;road[i+1][j]&amp;&amp;Max&lt;dfs(i+1,j)) Max=dfs(i+1,j); if(j-1&gt;=0 &amp;&amp; road[i][j]&gt;road[i][j-1]&amp;&amp;Max&lt;dfs(i,j-1)) Max=dfs(i,j-1); if(j+1&lt;m &amp;&amp; road[i][j]&gt;road[i][j+1]&amp;&amp;Max&lt;dfs(i,j+1)) Max=dfs(i,j+1); return dp[i][j]=Max+1;&#125;int main()&#123; while (cin &gt;&gt; n &gt;&gt; m) &#123; for (int i = 0; i != n; i++) &#123; for (int j = 0; j != m; j++) &#123; cin &gt;&gt; road[i][j]; dp[i][j] = -1; &#125; &#125; int MAX = -1; for (int i = 0; i != n; i++) &#123; for (int j = 0; j != m; j++) &#123; MAX = max (dfs(i,j),MAX); &#125; &#125; cout &lt;&lt; MAX &lt;&lt; endl; &#125; return 0;&#125; 题解 此题其实最重要的就在于这个题目不同于其他题目，这个题目找的是最长路径，还不是最短路径，一般来说，BFS找的是最短路径，DFS找的是最短路径的条数。而这里就是利用dfs的返回值（每走一步的最大值，意思就是从各个角度上）记录在dp中，将每一个位置都走到不能走为止，然后存储在dp中，最后找最大值的DP即可。不过自己可以试试遍历的其他方法。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>模拟与搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款11：在 operator 中处理自我赋值的情况]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE11%EF%BC%9A%E5%9C%A8operator%E4%B8%AD%E5%A4%84%E7%90%86%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E7%9A%84%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[本来是可以不用担心拷贝过程中发生自我赋值的情况，但是就是为了防止用户，或者对象自身的这种情况，所以需要完成避免自赋值的情况 比如两个指针对象进行自赋值的时候，为了防止多次删除，需要检查一下自赋值的情况。 同时不仅要考虑的是自我赋值的安全性，仍然需要考虑的是异常的安全，也就是前者是需要判断如果前者的地址等于后者的地址话 就直接返回不作为，并且先删除原本的，再赋值新的，而后者则是先构造一个对象赋值给另外一个，然后先赋值，再删除。 就类似于这样，这样既能保证自赋值的情况，但是又能保证异常安全，不会在new对象的时候发生错误。 还要记住的是一般在移动赋值运算符的时候也应该注意一下自赋值的情况，不过上面的异常安全很少涉及到，因为上面的相比于前者更费点时间。 或者是直接使用自定义的 swap 功能，这样的话对于自赋值的情况以及异常安全的情况来比，更加省事和高效。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款10：令 operator= 返回一个 自身的返回]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE10%EF%BC%9A%E4%BB%A4%20operator%3D%20%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%20%E8%87%AA%E8%BA%AB%E7%9A%84%E8%BF%94%E5%9B%9E%2F</url>
    <content type="text"><![CDATA[一般重载赋值运算符号的时候一般都会返回一个自身的引用，这样可以更方面操作自身，如果仅仅只是返回一个拷贝的对象的话，那么将会在连续使用运算符的时候发生错误，而且在一些较大的类型的话，可能速度会慢些，所以一般返回自身的引用。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款12：复制对象时勿忘其每一个成分]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE12%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%8B%BF%E5%BF%98%E5%85%B6%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%88%90%E5%88%86%2F</url>
    <content type="text"><![CDATA[这个条款而言，是无论类发生什么样的内部变化，都必须重写类的管理行为。下面直接分为两个方面进行诠释： 类的内部增加或者减少数据成员，如果未重新编写构造函数的话，那么编译器也不会提醒，这样就会造成不太被需要的局部拷贝。 一旦发生继承，如果还是按照以前的方法仅仅是对函数内部的所有数据成员进行拷贝的是不对的，因为派生类不仅仅是包含着派生类的部分，还仍然包含着基类的部分，所以需要调用基类的拷贝行为，如下图： 另外拷贝构造函数定义内部是不能直接调用赋值运算符，反之亦然，前者就相当于对一个尚未构造好的对象进行赋值，而后者就相当于对一个已经构造对象再进行重新构造。所以千万不要这么做。 如果发现两个拷贝行为有类似的代码时，应该把这个相同的代码放到一个函数中区，然后由两个拷贝行为共同调用。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款13：以对象管理资源]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE13%EF%BC%9A%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[系统资源的管理规则就是，一旦使用完毕，那么就一定要归还给系统，免得造成内存泄漏的问题，而 C++中需要自己去管理内存，那么为了防止在对象销毁以及内存释放之间发生异常，以及某些其他原因，一种新的基于对象的资源管理办法就应运而生。 使用智能指针， C++11之后智能指针分为三种一种是 share_ptr 指针 智能型的应用计数，共享底层数据。weak_ptr 依附于 share_ptr 作为一种核查类指针存在，最后就是 unique_ptr 指针，仅仅只是为了对象的析构函数自动销毁，上述两种主要的智能指针可以定义自己的删除器（析构函数） 获得资源后立刻放到管理对象中，其所代表的观念就是 “资源取得的时机，就是直接初始化的时机”。 需要注意的就是智能指针默认的删除器是不能删除固定的连续内存空间，意思就是说，需要自定义的删除器才能完成 delete[]。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款14：在资源管理类中小心拷贝行为]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE14%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83%E6%8B%B7%E8%B4%9D%E8%A1%8C%E4%B8%BA%2F</url>
    <content type="text"><![CDATA[一般在自定义类中会遇到多种多样的拷贝行为，所以一般会采取下面的一些策略 禁止复制 向前面条款06一样，有多种办法，一般对于那些逻辑上拷贝不合理的函数。 对底层数据的共享控制 那么此处这就需要使用智能指针 share_ptr，或者自定义引用计数。并且拥有自定义的删除器，因为某些类的删除操作并不一定是释放内存、销毁对象。 转移底部资源的拥有权 移动操作，C++11 右值引用的移动过程。 复制分为浅层复制以及深层复制 前者是复制其的指针或者引用，达到共享资源的目的，这个时候使用 share_ptr 来进行控制，后者赋值的是全部内存，最好是用 unique_ptr 来保管，但是复制操作得把每一个对象所指向的对象进行拷贝之后，放进 unique_ptr 中进行管理。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款15：在资源管理类中提供对原始资源的访问]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE15%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[一般使用了智能指针之后就不会在建议使用内置指针，以免发生错乱，但是就是有一些类需要在使用智能指针的过程中需要返回内置指针来完成某些函数的参数传递过程，但是需要注意的一点就是 在使用内置指针的过程中 千万不需要 delete，直接让智能指针进行删除操作。 另外除了返回内置指针这种方式来进行对原始资源的访问，还有一种方法就是重载隐式转换运算符，来完成类到资源的转换，但是这样做会加大错误的可能性，因为某些不可控的隐式类型发生转换。 上述的第一种办法属于显示转换，直接使用 get 获得资源，而下面的那种是隐式转换类型，前者比较安全，后者比较方便。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款17：以独立语句将new过得对象放入智能指针中]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE17%EF%BC%9A%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86-new-%E8%BF%87%E5%BE%97%E5%AF%B9%E8%B1%A1%E6%94%BE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[编译器的编译次序是说不定的，就想下图的 上述的三个次序一旦顺序不对就会发生错误，所以一个最好避免的办法就是想如图所示： 先将对象存储在智能指针中（先完成智能指针的构造），在完成对智能指针的调用。 上述举的例子说明的问题是一定要把对象存入智能指针的过程独立成一个语句]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款18：让接口容易被正确使用，不易被误用]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE18%EF%BC%9A%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%AE%B9%E6%98%93%E8%A2%AB%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8D%E6%98%93%E8%A2%AB%E8%AF%AF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[注意类的隐式转换，并且智能指针与内置指针的区别，以及以对象管理的思想来管理资源。 好的接口很容易被正确使用，不容易被误用，应该在接口里面努力达成这些性质。 促进正确使用的办法 包括接口的一致性，与其内置类型的行为一致。 阻止误用的办法包括建立新类型，限制类型上面的操作，以及束缚对象值，以及消除客户的资源管理责任 智能指针支持定制删除器，这样可以防范动态链接程序库的问题]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款19：设计 class 犹如设计 type]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE19%EF%BC%9A%E8%AE%BE%E8%AE%A1%20class%20%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1%20type%2F</url>
    <content type="text"><![CDATA[一般设计一个优秀的类，实际上也就是设计一个优秀的类型，而往往需要满足下面这些疑问。 新 type 对象应该如何创建和销毁 关系到类的构造函数与析构函数如何建立 对象的初始化和对象的赋值之间的差别 主要是为了区分构造函数与赋值运算符之间的区别 该类参数传递中有传值也有传引用 传引用与传值之间的区别，以及如何实现，以及究竟何时会去调用这一类的函数。 新 type 的和法制 构造这个类的时候一些合法值，要不要对应自己的私有数据成员，或者是类型转换，通常其都会影响构造函数、赋值操作，以及 setter 函数，甚至还会影响到函数抛出的异常。 是否需要配合某一个继承体系 需要记住的是继承体系的构成一定要满足的是 is - a 的条件，另外虚函数与非虚函数之间的影响，并且还要考虑的时候 是否应该把自己的析构函数也设计成虚函数。 是否需要类型转换 类型转换一般会分为显式转换和隐式转换，实现方式一般有直接在其中一个函数内些类型转换的重载运算符函数，和没有声明 explicit 的单一参数的构造函数。 重载的操作符以及其他相应的函数，是否合理 这里看重载的函数是否符合逻辑条件，不仅仅是代码之间的严禁性质，还需要考虑的就是生活层面的实用性。 哪些成员应该封装？ 这里就设计到哪些成员应该设置成私有，而哪一些函数应该设置成公有函数，并且一些不想编译器生成的函数应该定义成删除。 类型的未声明接口 它对效率、异常安全性以及资源运用提供什么样保证，以及为类的实现代码应该提供什么的约束条件。 是否应该定义成模板 这里就看类的一般性究竟有多大，是否具有普遍价值。 考虑是否会继承与其他的类 有的时候考虑过后，也许这个类就不需要凭空创造出，仅仅只是需要从其他类上面派生出来即可。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款20：宁以传 const 引用也不要传值]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE20%EF%BC%9A%E5%AE%81%E4%BB%A5%E4%BC%A0%20const%20%E5%BC%95%E7%94%A8%E4%B9%9F%E4%B8%8D%E8%A6%81%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[这个传值行为是继承与 C 语言的，基本上传引用更加方便，且付出的代价更小，不过需要注意下面了两点。 传引用有的时候会碰到切割问题，比如传参的时候，本来应该传入一个基类对象，但是实际上传入了一个派生类对象，这个时候就会把派生类基类的部分切割出去，其他部分就直接丢了 以上规则不适合某些特殊规则，比如内置类型以及 STL 的迭代器，对它们而言 ，传值往往是最恰当的。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款16：成对使用new和delete时需要采取相同的形式]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE16%EF%BC%9A%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8new%E5%92%8Cdelete%E6%97%B6%E9%9C%80%E8%A6%81%E9%87%87%E5%8F%96%E7%9B%B8%E5%90%8C%E7%9A%84%E5%BD%A2%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[其实我根本不知道这个为什么会成为一个单独的条款鉴于此，所以就简单的讲两句话： new 一个数组，那么一定要 delete 一个数组 智能指针默认没有 delete 数组，所以需要自定义删除器。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款22：将成员变量声明为 private]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE22%EF%BC%9A%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BA%20private%2F</url>
    <content type="text"><![CDATA[这里就是要记住封装的好处 切记要将成员变量声明为 private 。这样可以减少改动成员之后的破坏性，可细微划分访问控制、允诺约束条件获得保证，并且提供 class 作者以充分实现弹性。 protected 并不比 public 更具有封装性]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款21：必须返回对象的时候，不要妄想返回其的引用]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE21%EF%BC%9A%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%B8%8D%E8%A6%81%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6%E7%9A%84%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[该条款一般适用于某些特殊情况下必须返回值的情况 关于这个条款只需要注意一点，绝不要返回 pointer 或 reference 或者返回引用指向一个全局变量，或者返回指针引用指向一个静态成员，但是同时又需要多个这样的静态成员。在条款4中已经提供了一份设计实例。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款23：宁以非成员友元函数代替成员函数]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE23%EF%BC%9A%E5%AE%81%E4%BB%A5%E9%9D%9E%E6%88%90%E5%91%98%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E4%BB%A3%E6%9B%BF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[同样还是为了封装 宁可拿非成员非友元函数来代替成员函数，这样做可以增加封装性，和包裹弹性，以及机能扩充性。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款24：若所有参数需要类型转换的时候，请设置非成员函数]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE24%EF%BC%9A%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E8%AF%B7%E8%AE%BE%E7%BD%AE%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[该条款就是需要注意一点 如果需要为某个函数的所有参数，包括this 指针所指的隐喻参数，进行类型转换的时候，那么这个函数就必须是非成员函数]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款25：考虑写出一个不抛异常的 swap 函数]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE26%EF%BC%9A%E5%B0%BD%E9%87%8F%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E5%87%BA%E7%8E%B0%E7%9A%84%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[其实该条款总结下来就是再讲一个东西，而这个东西分成两点： 如果类的赋值成本低于一组构造和析构成本，那么将对象的定义定义到循环体外部去，尤其是在循环次数很多的情况下。否则就是将定义循环体内部中去。 尽可能延后变量定义式出现的时间，最好达到需要什么才去定义什么，这样做可以增加程序的清晰度并改善程序效率。另外最好在程序定义的时候就直接构造（初始化）。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款25：考虑写出一个不抛异常的swap函数]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE25%EF%BC%9A%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[所谓 swap 两对象值，意思就是将两个对象的值彼此赋予对方，缺省的情况下 swap 的动作可以由标准库程序提供的 swap来完成。 其中有一个最主要的方法就是，以指针指向一个对象，内含真正的数据“ 即”pimpl 手法”所以一般对于一个对象而言，直接交换里面的指针对象即可。就如同以下的写法： 以上就是该对象的特化版本。这同时也是一个模板类的偏特化的例子。 如果想特化一个函数模板的话，通常的做法就是添加一个重载版本。 但是这种特化存在问题： 我们可以全特化 std 内的模板，但是不可以添加新的模板到 std 里面去，因为 std 的内容完全由 C++标准委员会决定的。 有的时候不能直接访问私有成员，因为封装层面的相关权限缺失。 解决的办法很简单，声明一个非成员版本的 swap 函数，然后让他调用其的成员函数，而不是将那个不是成员函数的 swap 声明为 std：：中的特化版本或者是重载版本。下面就是相关步骤： 提供一个 public swap 成员函数，让它高效地置换你的类型的两个对象（注意这个地方时高效的置换），但是这个函数不应该抛出异常。 在你的类或者模板所在的命名空间内，提供一个非成员函数的 swap，并且另其调用 swap 成员函数。 如果你正在编写一个 class 而不是一个模板类的时候，为你的类特化std：：swap。并令其调用你的 swap 成员函数。 最后，在调用奇函数的时候，请确定包含一个 using 生命是，以便于让 std：：swap 在你的函数内曝光可见，直接赤裸裸的调用 swap。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM集训相关知识]]></title>
    <url>%2F2018%2F12%2F01%2FACM%E9%9B%86%E8%AE%AD%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[基本的数据结构 扩充顺序表 （我的理解就是连续的顺序容器）存储方法就是在内存中开辟一段连续的空间。 而数据元素的位置确认： 常见的线性表运算： 此处一般都是用数组来实现，其的插入运算和删除运算都是基于连续内存空间上面所实现的。 单链表定义：链表的存储方式： 双向链表 循环链表简单来说就是首尾相连接的单向链表。 以上有时间再来进行详细的全面总结。 栈 如果用C语言来表示栈的话，得以数组作为基础，秉持先进后出的思想就行了。可以用int值作为下标值作为当时存储的栈的位置。也可以用两个指针来指示当前下标值。可以借用栈的思想来做题目。 队列 队列的基本逻辑运算： 这里也是运用两个int型的值当做是变量，分别指向头指针以及尾指针，然后执行添加减少的操作。一般到最后全部用做到下标上面。 而循环队列也是建立两个指针，但是不同的是其是将首尾进行连接之后，也就是说，其直接将每次得到的新结果对队列的总长度进行一个求余数（求mod）。 下学期上课的时候可以用C语言代码实现以下。 循环队列其实可以干和循环链表一样的事情。比如一道例题： 代码如下：1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt; #include&lt;queue&gt;#include&lt;string&gt; #include&lt;stdio.h&gt; using namespace std; int main()&#123; int n; while(cin&gt;&gt;n)&#123; queue&lt;string&gt; a; for(int i=0;i&lt;n;i++)&#123; string name; cin&gt;&gt;name; a.push(name); &#125; int w,s; scanf(&quot;%d,%d&quot;,&amp;w,&amp;s); for(int i=0;i&lt;w-1;i++)&#123; string temp = a.front(); a.pop(); a.push(temp); &#125; while(a.size())&#123; for(int i=0;i&lt;s-1;i++)&#123; string temp = a.front(); a.pop() a.push(temp); &#125; cout&lt;&lt;a.front()&lt;&lt;endl; a.pop(); &#125; &#125; &#125; 串串的定义： 此处则可以理解成是字符串。 二叉树树的定义： 二叉树的性质： 排序简单的冒泡排序]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年生日重庆之旅]]></title>
    <url>%2F2018%2F11%2F30%2F2018%E5%B9%B4%E7%94%9F%E6%97%A5%E9%87%8D%E5%BA%86%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[说句实话，自己也不知道应该写些什么东西，转眼之间似乎已经21岁了，知道自己内心不甘心的地方，但是唯一不太知道的是如何去改善这些不甘心的地方。问问自己的内心，其实自己一直想要的就是别人的关注。我觉得我个人的心路成长分成了几个阶段。 第一个阶段就是拼命的展现自我，追求其他人的认可与关爱。 如果在这个阶段里面获取了足够的认可，也许就会一直在这个阶段里面不断，要求满足，然后被满足的过程中进行沉沦。我个人的想法就是，如果没有进入到下一个阶段，那么永远得不到成长。 第二个阶段就是知道了这个世界上不会轻易的给自己满足的，知道了原来自己是会被拒绝的。 这个时期如果没有处理好的话，那么特别容易走向一个极端，走向一个“佛系”的一个极端，假意成为一个无欲无求的人，这个时期的我们就会厌恶一切“争宠”的行为，反而还会将那些争取优秀的人看作是特别低级的人类，从而厌恶一切优秀，但同时自己会在暗中做出很多自认为独一无二的事情，来彰显自己与别人不一样的地方。 第三个阶段往往是在经历了很长阶段的第二阶段，经历过打击，重新并且深刻的认知到这个世界并不是围绕着自己转动，一个人真的没办法获取周围每个人的关注。 也许甚至自己没办法获取周围一个朋友的全部的关注，其实换位思考一下，自己也没有全身心的投入自己去关注别人，其实到最后自己还是以一个自己都达不到的标准全部要求别人，有点自欺欺人的感觉。 其实自己就在上面所说的第二阶段中无力翻腾着。虽然自己没有去蔑视努力，知道自己一切改变都是努力的结果，这是好的，但是从进入大学的一年多来，自己觉得自己很累，每天过得也很充实，也有一个固定的目标，但是自己却好像从来不能得到满足。 其实最近发生的一切不安，一切困惑，问问自己，其实全部来源于自我认知的偏差。真的以为自己是无所不能的超人，认为所有事情，只要自己认真去做，那么就一定可以实现，但是却忘记了一个很重要的前提，人的精力是有限的，真的没有办法做到面面俱到。 从最先开始的选择程序员这条路，到后面编程语言的选择，然后又到了工具，开发环境，以及编程之路方向上面的选择，我最近做出了很多很多的选择。很高兴自己做出了很多的选择，但是同样又很悲伤自己做出的选择。 外因 每个人的人生只有一次，对于个人而言，发生的一切，其实都是一个全新的体验，所以不知道该怎么做，产生迷茫的情绪是一件很正常的事情，另外对于自己而言，周围也没有陪伴自己成长的长者，没有人可以体会到自己生命中每一个抉择背后所要承担的东西。再加上本着想把一切做好的目的，这个时候就会产生即使做出选择也会产生后悔的不确定感。 内因 我觉得归根到内心的话，还是有对自己不够自信这个心态存在的，还记得上次在经开一中一个科技展览会的时候，被一个学妹说不自信的时候，当时震惊的同时，其实更多的还是认可，我的确对自己不是特别的自信。不做选择的时候，怀疑自己是不是做不了选择了，当自己做出选择之后，又在怀疑自己是不是做出了一个错误的选择，我觉得这都是自己内心中需要克服的地方。 上面综合起来带来了 焦虑。 焦虑，一遍一遍的怀疑自己，一遍一遍的苛刻完美的标准，一遍一遍夸大其他人的成就而贬低自己的成就。以至于没有动力，没有耐心，没有毅力，以至于最后任欲望侵袭，堕落。 其实自己的初心是好的，但是为什么在初心之后的前行道路上会有如此大的阻碍呢，我觉得就是急功近利的心态，心急吃不了热豆腐，这句话适用于人生道路上面的每一寸。 不要因为走的太远，而忘记为什么出发 本来只是一个生日的小总结，不知不觉就说了这么多，本来只是想写写在重庆遇到了什么人，遇到了什么样的事情，但是还是抵御不住欲望的诱惑，主要还是焦虑，急功近利的心态毁了自己，自己在重庆得到的最大的收获便是在热闹的外界环境下，保持一份静谧，就像火锅配料上面的耗油，虽然起不到任何好吃的作用，但是却能在自己最辣的时候，给自己一点静谧。 这次的重庆之旅，有遗憾，有可惜，有没有完成的心愿，也有没有尽兴的地方，但是越长大越发现，我们总是希望人生中没有遗憾，可是到后来才发现，人生的遗憾才是人生中最有魅力的地方，因为有遗憾，才会有所向往。所有完美的东西最致命的弱点就是没有遗憾，从而也就没有了向往。 现在是凌晨的一点钟，自己还坐在火车上面颠簸，但是自己却有点享受这个时候的氛围，过道里时不时有人走过，有人上车，有人下车，旁边呼呼打鼾声音，还有时不时飘来的香烟味，提醒我 原来一直以来追求的生活就在周围。 希望自己回去以后可以好好的安排自己的人生，不要焦虑，不要急功近利，健身计划，英语六级，编程之路，成长之路，太过于追求结果就会导致失去自己想要的结果。 生活里最妙的永远不是按部就班，规划好的结果，而是转角里不经意的惊喜 祝自己21岁生日快乐。]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>个人经历</tag>
        <tag>旅行</tag>
        <tag>重庆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017~2018.5.1个人小结]]></title>
    <url>%2F2018%2F05%2F01%2F2017-2018-5-1%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[其实心知肚明自己的拖延症是非常强大的，总是在有意无意的拖延着，本来最先开始的预计是每一年都会写一个年终总结，然后2017年的年终总结直到现在才开始下笔，每次都有理由是最近的自己很忙很累，没有办法静下心来认真的写一写自己的总结，同时也秉持着“下一次一定有时间，其实后面的时间还多些呢？”然后就是这一些想法使自己拖延习惯变得越来越严重。也就有了今天”排除万难“在五一假期的第一天，在大家都出去郊游的情况下选择自己在宿舍里面好好整理。 从当初上大学一直到现在，说实话自己还是有点自命清高，也就是不太喜欢现在的环境，不过这种心态发展到现在，已经剔除了这种心态里面不太好的一面。这种想超脱环境的心态，我不知道该不该评价其的好与不好，但是我只知道的是，如果要超脱到现在原有的环境的话，得比周围的人付出200%的努力。 但是鉴于自己的表现，真的达到了200%的表现吗？我不知道，因为不知道自己努力的方向在哪，什么都想学，什么都想出人头地，但是却又什么都做不好，其实我现在越来越觉得人生最难的就是再控制好广度的同时钻研好深度。我觉得这才是难以控制的。落实到我现在的生活里面来看。上个学期的事情不去谈论过多，毕竟上个学期是来到学校的第一个学期，什么都很新鲜，由于好奇心的相互探索，自己找到了很多有趣的朋友，并且接触到了辩论，然后上个学期在保持学习进度的同时，在辩论上面进行了发展。上个学期就大学第一个学期而言，就算有太多的目标没有完成，但是这也都是可以值得原谅的。 现在我就要说的是大学的第二个学期，大道理每个人都懂，每个人都不是特别喜欢对自己说教的人，尤其是那个对你说教的人还是你的同级的时候，就更不容易接受，特别是自己做了一件事情，渴求肯定的时候，这个时候别人的”善意性质的批评“我觉得一定是听不下去的，但是对于自己而言，也许别人不会来说自己这一方面的事情，但是自己心里一定还是要有一些自知自明的，我知道对于自己这半个学期而来，很不满意，分几个块来说，由于自己每一方面都想要顾到，然后到最后自己每一方面都没有顾到。健身，辩论，编程，绩点学习奖学金，志愿者，旅游，自媒体写作，个人感觉这每一块都没有做好，因为每一件事情都想做好，但是每一件事都需要大量的时间基础很沉淀，于是我觉得目前最好的解决办法就是进行时间上面的优先级排序，把现阶段最重要的事情拿出来排到前面，自己想做，但是又不是必须做的事情放到后面。于是我就做了一下这张思维导图。 我目前的想法是想把计算机专业层面的学习放在第一位然后就是英语方面的学习，然后就是大学课程上面的学习。然后就是之后的兴趣发展。但是发展到现在，讲真的自己还是有点松懈了，没有以前的那股劲，但是就是羡慕那些有本事，有能力的人。之前的生活就是每天编点程序，学计算机方面的东西，然后也就是因为这些导致了翘课，导致了松懈，导致了现在会在宿舍里面发呆也不去教室上课，这些统统是导致的。我觉得这仍旧是自己开始松懈的标志，但是更是由于这些，我的生活也变得不太规律，之前一个星期每天估计一两点睡觉，而且早上不会再像以前一样去教室自习。我觉得我也不会像以前一样暗示自己这都不是个事，因为天然默认未来一切都是好的。然后就莫名其妙的给自己发一大段一大段的鸡汤 。这次的总结 我不想给自己讲大道理，因为全部都懂，我只想批评自己，只想反省。自己做的不对的地方就应该去改正。 未来还有一块是关于辩论队是去是留的问题，由于时间以及自己按照排序想做的事情冲突，不得不退了校队，并且极力减少自己再院队里面的比赛，但是自己还是比较喜欢这方面。但是没有办法，因为只要打乱了那个优先级排名的话，那么自己所有的事情都会乱。并且我喜欢自己做事情能够专一，最近发现自己在专一度上面没有很用功，后面可能会考虑尝试一下番茄时间。总之对于辩论队的诸多事宜，我最终决定还是仅仅是当作一个爱好，为自己的本命学科让路。 下一个问题是关于坚持，本来我觉得在这个层面是不存在的问题的，但是最近感觉的自己的自制力越来越差，其实毅力也就像肌肉，你只有多练练，才能使毅力这块肌肉越来越硬。所以以后跑步健身都要勤快点，去锻炼毅力这块肌肉。 最后是关于人际交往，有室友层面的，也有朋友层面的，交往一定要懂得度，这个度的把握，不仅要体现在自己身上，还要体现在别人身上。对于某些自以为是，只会偏激并且片面评价别人的人，我觉得还是把他们当作大神供起来吧。 贱人自有贱人收，我没办法弄他们，因为我不是贱人。 最后的最后希望从这个五一假期开始就带来改变，记住自己的优先级安排表，同时也记住坚持和努力，永远与自己的懒惰和松懈战斗下去。 总之对于现在而言​​，从5月1日到接下来放假的时间里，需要完成的目标有： 1、计算机编程语言C++的相关补充（尽量来看，还有暑假可以用来看）。 2、英语四级必须得过，接下来时间把英语听力弄好，每天尽力完成一套英语卷子。 3、体育锻炼 运动，马上夏天了，如果不想显示出自己的肥肉的话，得好好努力了。 ​4、保证接下来不挂科。允许不再以拿奖学金为主要目的。 5​、闲暇时间都看点自己感兴趣的书籍，不要再刷电视剧了。（这一点尽量控制）]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年中秋节感慨]]></title>
    <url>%2F2017%2F10%2F05%2F2017%E5%B9%B4%E4%B8%AD%E7%A7%8B%E8%8A%82%E6%84%9F%E6%85%A8%2F</url>
    <content type="text"><![CDATA[我一直以来觉得生活的意义就是上进，就是毫无理由的提升自己，让自己变的更有价值，更有意义。这种思想产生于小时候受到的好好学习，努力考上大学的功利思想吧。但是也就是这种思想促使我一步一步走到现在，虽然没有太大的成就，但是也与周围的人拉开了距离。很久以前自己的这种思想也经常延申出另外一种表现方式。那就是比较。我觉得现阶段在我生活里的所有上进，所有快乐和所有成就感全部都来自于比较。我的大学比某些人好，我某些优点比某些人好，我比某些人更懂得生活，这些都会让我感到一种优越性质的快乐，就是我比别人行，我比别人厉害的快乐。但是反观这种快乐的来源，虽然从一定的角度上，他可能促进了我对上进意义的探索，但是也限制了我对未来意义上的追逐。比如说，我今天看到一个以我所谓的评判标准比我差劲的一个人，我会开心。但是当我看到一个比我厉害，或者说是我认为没有我厉害但是却做了一件我觉得很了不起的一件事情，这个时候我会难过，因为我不知道自己能不能做的跟他一样好，或者说是比他还要好。我之前觉得这是一种嫉妒心里，羡慕妒忌别人比我好的，却殊不知别人是付出了多大的代价达到这一步的。我知道有的时候妒忌心真的没有办法避免，至少我是没有办法去避免这种不好的心里，但是将这一点往深层次去考虑，这何尝不是一种自卑心里呢？曾经的我极度鄙视嫉妒心里，所以认为一切比较都是没有必要的，一切比较都是满足自己虚无的虚荣心，但是这样做的后果又是什么样的呢？这样做的后果是害怕比较，厌恶上进，难道这一切真的只是比较错了吗，还是说那种虚无的妒忌心真的毁灭一切的根源吗？我觉得可能还是内心深处弱点，我觉得这可能需要我接下来几十年的经历和历练去完善的问题，自卑。这里说的自卑可能不是那种口头上的什么我不行，我真的不行。我觉得这不叫做自卑，那叫做自暴自弃。自卑的心理我觉得纯粹是来自于价值观中的悲观体系，和性格中无法避免的软弱以及懦弱。可能这一系列的说法特别宽泛和抽象，那我举个例子。比如说我现在热衷于唱歌，如果我发现一个不是那种天赋流，仅仅是通过努力提升上去的人，唱歌突然变得很厉害了，按照正常人的想法，第一也许会妒忌，或者是倾佩。但是这两者之后我的反应就是难过与害怕。也许这里害怕这个词用的过于夸张，但是我想说的这个词用的很准确。我一向觉得有些事情如果发生在别人的身上那就是别人的事情，跟我与我自己所处于的世界是无关的。这是我基本的理念，但是我为什么会感到害怕呢？究竟是害怕什么呢？仅仅是害怕别人做的更好觉得自己会被嘲笑吗？我觉得可能是我性格上的问题，我可能还是有点需要被肯定，被积极对待的心理。简单来说是需要得到更多的爱与关怀。当遇到这样的事情之后，我的第一反应是他做的更好了，我为什么做不到，那肯定是我自己太没用了，自己太没用了，那么别人一定不会注意到这么失败的自己，因为自己太没用了。而且最致命的可能就是，觉得自己无论怎么努力都无法超过他。到最后虽然自己崇尚生活在自己的世界里，但是还是用别人的价值观和别人的成功与失败的来衡量自己。我觉得这是我这一个阶段需要解决的问题。归根到底，也是自己不够强大，内心世界还没有像钢铁一般。说实话，目前的我找不到解决这个很好的办法，但是可以一步一步的改变，而且这些改变也在我的身上潜移默化的进行着，比如说，更加坦然的面对自己，面对生活中的别人的优点与缺点，不再仇视比较，不再过多的去关注比较后的快乐与悲伤，虽然现在还是会有一些优越性质的高兴与难过，但是不会去主导自己心情。虽然仍然无法专注与自己的生活，但是一路走来我觉得自己成长的心路历程也是我最伟大的财富。祝自己中秋节快乐。]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>中秋节</tag>
        <tag>青春</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于军训体制的一些思考]]></title>
    <url>%2F2017%2F09%2F15%2F%E5%85%B3%E4%BA%8E%E5%86%9B%E8%AE%AD%E4%BD%93%E5%88%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[今天是军训的第七天，到了军训最后的阶段了，按照大家的说法和教官们的默许，最后几天就是纯放松型的交友盛会。回顾最先开始的几天，我觉得所有对这对生活里美好的期望全部被一些存在与生理上的痛苦所摧毁。在最初开始的几天里，我现在唯一记下去的就是我们的教官连长是如何吼我们，用他所谓的阶级思想来压榨我们的自由，我不知道自己这样的说法是不是属于正确的，因为在我们国家这种部队制度，本来就是军人务必服从命令的思想支撑。在此之前我的所有思想体系，全部都是基于一点，任何人都不能阻挡住我的自由。说实话，这种思想我认真想了想，就是考虑了下产生这种思想的原因，大概率可能是青春期里的叛逆？还是独立思想及独立人格作怪？我曾经在一本书里看到的一句话，人永远不可能完全自由，也就是不可能完全跟着天性的方向行走，因为社会这个产物，本来就是各种规则相互碰撞的结果。但是在现在这种部队制度越来越变味。我所理解服从命令应该是助于管理，以便于提升完成任务的效率。而现在这种服从命令越来越多的转化成了对权利的一种狂热，也就是所谓的官大你一级压死你。越来越多的人用命令进行压迫做一些无法理解甚至是利己的事情，也就是越来越多的在部队里面的人开始崇拜权利。于是越来越多的军痞产生了。我觉得军人在任何时候首先要做的事严格要求自己，比如说一些基本的军人常识，不要总是要求别人做到，然而自己却做不到。反而违背了军人服从命令的初衷。我知道并且也相信着我所遇见的军人中有很大一部分只能被称作为军痞，但是这个世界上正直的军人一定很多的。但是有这样的经历也不可能完全避免掉，在这些天里，我收获最多的是我会被磨平的急性子和自己的忍耐能力。虽然每天都在倒计时数数还剩下多少天，虽然每天都在心底里与这种在我看来毫无意义甚至是毁灭人性的虐待作斗争，但是我知道这种时候可以反抗，可以直接甩脸就走，但是自己已经成人了，成人必须具备这样的一个观点，成人的世界里必须遵守规则。不遵守规则的人直接出局。所以就会有忍耐的存在。现在真的是什么决定最后的承担者必须是自己了，对自己负责，遵守游戏规则。这次军训前面很累后面很轻松，新的生活即将开始，准备好自己的健身计划，英语和读书计划，这是你需要做的事情。最后来一句振奋人心的鸡汤。未来的你一定会感谢现在拼命努力的自己。]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>青春</tag>
        <tag>经历</tag>
        <tag>军训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遗失的2016与无限可能的2017]]></title>
    <url>%2F2017%2F08%2F01%2F%E9%81%97%E5%A4%B1%E7%9A%842016%E4%B8%8E%E6%97%A0%E9%99%90%E5%8F%AF%E8%83%BD%E7%9A%842017%2F</url>
    <content type="text"><![CDATA[与上一次写下博客的时间实在是过去了太久太久，从去年高考的意外失败，到今年高考过后不知道是应该开心还是惋惜的局面。我知道自己并不是一个强调高考一定是一件关乎生死的大事。之所以选择复读这条路呢，是觉得不甘心，因为知道自己是一个容易受环境影响的人，不甘心就此平庸下去。于是这一年就像是消失，不再关心网上的一些动态。先开始是抱着苦读书的心态加入到了复读的队伍中，但是等到真正融入到那个环境中自己一个致命的毛病再一次犯了，开始轻视自己最后的目标。开始浪，开始没有高三那年这么不认真学习。虽然最后结果不差，从湖北省的66000多名跳到了24000名，但是我觉得如果当时自己不那么轻视高考的话，肯定会更好。但是人生就是人生，经历过才会刻苦铭心。这一年说长也不长，说短呢，倒也是盼了数不清的日日夜夜。在复读的班级里我见过各式各样的颓废，与各式各样的惨淡，还有各式各样的对梦想的摧残与亵渎，甚至在有一些人身上完全不用跟他们谈论梦想。我觉得这就是一种提前衰老的世俗气和死气，跟他们相互交流的过程中，难免不会被其沾染分毫。由于种种原因换到外面的合租寝室与另外一个复读班级。不过还是经常用一些稀奇古怪的理由去翘课。现在想来没有指责，也没有什么引以为豪的变态想法，只剩下一种好笑的想法。不过在复读的过程中，我有一次还经历请来了警察，事情的原因是我忍受不了一些狗血与荒谬的规定，我于是就与其对着干，然后对方以我闹事为名请来了警察。就跟警察好好聊聊呗。最后得出的结论，也就是从这件事情得出来的想法，社会上是存在狗眼看人低的现象，也存在某些荒谬的规定，但是如果你没有改变这些规则的能力与筹码的时候，你最好还是忍下来，免得最后受伤害和出笑话的都是你。最后6个月和7个月的时候换了寝室，跟两个自认为玩的不错的朋友合租了房子，之所以会产生矛盾就是觉得模糊了朋友与室友的关系。我觉得这一点我到大学去一定得注意。朋友是志同道合的，是可以交心的。而室友则是只是住在一起，有的时候不需要有共同的奋斗目标，只是住在一起，衣食住行上的相互照应。室友没有必要会成为好朋友。这就是以后需要注意的地方了。然后就是体重问题了，这个是硬伤，本来去年去复读前体重为84公斤，好不容易瘦下来的，现在才刚刚恢复到顶尖水平。不过加油吧。这个东西是急不来的慢慢加油一定会看到成效的，正所谓，玉树则不达嘛。不过以后还是要有一个好的健身计划和健康的作息时间表。要说这一年成长了么，我觉得主要是由以前理性的思维变得更加多元以及更加深入，谢谢奇葩说和狼人杀这两项事物让我看到了这个世界上还存在着诸多可能性。呵呵，年轻就有无限可能嘛还有一个月就要读大学。虽然有时候觉得这个大学也选的不怎么样，毕竟可以当作是滑档下来读的一所大学，但是听到一句话，你没有到这个学校的第一名，你是没有资格指责这个学校对你是没有益处的，因为在这个学校里面你总是会有上升的空间。以前真的有一种心态，就是特别想找一个对象，好好过，好好风花雪月，曾经也堕落过，也糜乱过，有的时候想想我们这个年纪很容易把欣赏当作是喜欢，把一种羡慕的想成为当作是爱情，到最后反而使爱情的真谛隐下去了，我觉得爱情就是平等，精神上的平等，互相成长，互相加深对人生的理解，也许有的时候性和欲望会常常来干涉，但是无论如何都占据不了爱情的真谛。我年纪还小，对婚姻的理解还尚在上一辈之间，他们让我感受到最多的是生活的迫不得已，也就是无可奈何的一起过日子。会不会结婚，能不能结婚，这都不是现在应该考虑的问题，我一生都会秉持着一个理念，Follow my heart 。我现在所做的一起努力使为了让未来的我在事情的抉择方面能更加靠近本心本愿一边。当然现在还不能把大学最终朝哪个方向定下来。但是勇敢，无畏，我觉得是人生中最重要的品质。在我的视角里荒废的2016年，就给2017年的我无限的可能。在今后的生活中我觉得一句话可以成为我的路标没有什么可以通向真诚，因为真诚是通向一切道路。真诚面对人，面对事，面对今后可能出现的无限挫折难过，以及开心完美与胜利。未来无论如何，总之我真诚，我坦荡，我会让这无限的可能尽可能的按照我心想象的方向前进。加油。因为你叫王舒啸。]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>青春</tag>
        <tag>经历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015年年度总结]]></title>
    <url>%2F2015%2F12%2F02%2F2015%E5%B9%B4%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今年是一个神奇的一年，做了许多以前没有想过的事情。但也碰触到了一些禁忌的事。泰戈尔也说过，人天生最强大的力量便是成长。对，就是成长。我们每一个人生来就不是完美的，我知道自己的缺点，自己的懦弱，自己在2015年所犯下的错误。但是还好，已经过去了，我也应该长大了。我也同样记得柴静说过的，只有同样经历过的人才有资格说我理解你。2015年上半年经历过一场车祸，终于从小孩子的认知，强行提升到了成人阶段，虽然有诸多不愿，但是，仍在慢慢适应。高二上学期，高二下学期，高三。时间过得很快。我理解了很多以前不理解的，看到了以前看不到的。人真的只有经历过痛苦才会知道自己真正想要的是什么。有的时候欲望，贪念，真的会毁掉一个人，但是也只有承受住来自与其磨难才可以真正成人。 但是由于自己的意志力不够，总是失败，但是我也不会妥协，抗争到底，这才是我。不过说到意志力，何谓意志力呢，个人觉得是一种抗逆的能力。抗拒痛苦和诱惑的能力。不巧，曾经拥有过的品质，由于生活过于安逸，再逐渐消失。比如说自己的拖延症，说大不大，但是说小也不小。我讨厌痛苦，这就是拖延症本质的原因。包括，给自己的任务完成不了，这也是其原因造成的。没有毅力。容易在家人面前控制不住自己的情绪。新的一年，我一定会改变这些。这一年里，也结识了许多人，逐渐知道社会7上的人情冷暖，以及人脉。我不想知道这些，但是现在能做的也就是默默的接受，总好比一味的抗拒。自己的性格也改了很多，一切朝好的方向进行转变。现在的我，也会学习每个人自己所遇到人的优点，从而改变自己。也许缓慢，但是方向是对的。关于你自己，我知道有的时候会有一种奇异的感觉包围着你，但是请相信一切的一切都会好的。打破常规，遵循本心。只当做看阴阳造化了。今后的日子，我希望自己能够坦荡做人，活出真实的自己，与自己的邪念抗争到底，完成自己的目标，过一种“没有任何借口”的生活。对自己，对别人，对一切负责。最后的最后，祝自己高考圆满，不求痴心妄想，只求问心无愧。]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看见与经历]]></title>
    <url>%2F2015%2F08%2F29%2F%E7%9C%8B%E8%A7%81%E4%B8%8E%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[一直以来都是想写点什么，距离我上一次发博文也已经过去将近半年了，这半年里，也可以说这2015年里对我的改变也是挺大的。知道什么是苦，什么是乐，什么是欲望，什么是爱。今天是距离高三开学的最后一天，不知道我为什么总是这么喜欢做这样的事，直到最后一步才开始完成。我知道来自于自身里的缺陷。我懒，我没有过大的自制力，也没有太强的执行力。 我很懦弱，所以逃避。我一直坚信着一个人最可怕的并不是弱点，而是在有生之年并不去改变这些缺点。强点就是将自己的懦弱 前些日子也看过一些书籍，这本书对我的启发很大，并不能说这本书给了我很大的感受，因为那都是别人的生活，别人的人生历练。但是他打开了我通向这个世界的大门。我知道生，也知道死，也知道爱，只是有的亲身经历过，有的并没有经历过。我知道主观，也知道客观。这些带给我的都只是我人生路上的一个经历。曾经的我认为要对身边的人无下限的好，也曾经认为自己已经很成熟。认为自己的消极的态度就是成熟之人必备的。错错错。真正的成熟就是要在外界的压力和内界的蜕变下找到真正的自己，所谓破而后立，当你已经立到不能再破的时候，你也就形成了自己的思想理论和自己有别于他人的鲜明个性。而往往来说这个过程却是要花费一辈子的时间。 马上这个暑假也过去了，在这个暑假里，我由衷的觉得欲望和爱之间的关系，我可以做一个只有欲望的人，面对形形色色的人不动自己的生色。我目前觉得找一个与自己惺惺相惜的人那种默契才是我真正需要的。当人考虑这些东西要等到大半年之后，等我高三结束之时，也就是我人生觉醒之刻。这个夏天学会了一个人去旅行，学会了看题图，学会了处理自己与运动之间的关系。明天我将再次踏上战场，整装待发。 一直相信自己，从不会失望。 墨橹 写于 8月30日]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>经历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【书记】活着]]></title>
    <url>%2F2015%2F04%2F06%2F%E3%80%90%E4%B9%A6%E8%AE%B0%E3%80%91%E6%B4%BB%E7%9D%80%2F</url>
    <content type="text"><![CDATA[我今天要分享的小说是活着，这本小说讲述的是一个人与命运之间的关系，他们无法接受对方，但同时也没有办法背离对方。这本书我的很多朋友都看过，他们为故事里的悲剧角色叹息，甚至有几个感性的朋友每每谈起这本书总会泪滴点点。这本书如果整个看下来我看过9遍，只是一部分一部分的看的话，我看过不止十八遍。虽然这里没有像‘书读百遍，其义自现’的体会，但还是有了自己感受。首先我先声明我讲的东西并不深刻，也没有深度。你们知道什么叫作深刻么？其实一个人的存在并不深刻，但是这个人背后所浓缩的某些特点，与整个社会的客观存在某种现象的相联系，这才是深刻。我并不想去批判那个时代所呈现的劣根，因为这常常才是使人绝望的地方.我现在就向大家简要介绍一下《活着》这本书的故事剧情：故事里的主人公叫做福贵，是一个阔绰的少爷，他娶了一个妻子家珍，并且有一个4岁的女儿叫做凤霞。之后的悲剧也就是从这里开始的。福贵因为参与赌博被黑，卖掉了房子，输了全家三代积累下来的财富，自己怀孕的妻子家珍被老丈人无情带走。留下女儿和母亲相依为命，再过了一年多的苦生活后，家珍就带着一岁的儿子有庆回来，开始了一家人的平凡的农民生活。但是就在不久之后，福贵的母亲病了，福贵去城镇里请大夫，但是被国民党军抓取做壮丁，辗转两年被解放军所救，即后也就跟这解放军回家了。此时家里，母亲已经去世，女儿凤霞在一次高烧后变成了聋哑人，听妻子说母亲临终前一遍一遍的对妻子说，福贵是不会去赌博的。福贵也就在家里安顿下来，过了好几年，因为家里穷，只能卖女儿，让儿子去上学，最后女儿跑回来不忍送走，就留下来了。日子就这么一天天的过去，有一天因为县长的老婆生孩子要输血，结果儿子有庆被一个不负责任的大夫，给抽死了。后来竟然发现县长竟然是福贵当年相依为命的战友春生，不过春生之后也死于文化大革命。过了好几年，凤霞嫁了一个偏头女婿二喜，不久后死于产后大出血。两个孩子去世后，妻子家珍把外孙接到乡下来住，可没过多久就安安静静的死了。女婿二喜之后死于一场事故，死的时候外孙苦根仅仅4岁，还不知道死的概念。只留下祖孙俩人活着，但是好景不长，小苦根也意外失去了自己的生命。晚年的福贵买了一头老牛，取名为福贵。一起安享晚年。我这里并不想去讲这本书里所呈现出来的现实，也不想去评价这本书里的人物形象。这本书我看了很多遍，我甚至认为他们就像是我曾经与我精神交流的朋友。因为朴素，所以真实；因为真实，所以真挚；因为真挚，所以才会深深的触动我。在这里我只是想讲由这本书里我主管里延伸出来的3个问题吗，并且用我自己的生活感悟和经验，主观描述，客观阐述，解决的这三个问题 什么是活着。 为什么要活着。 怎么活着。首先第一个问题：什么才是活着。众所周知，生活的三大主题，生，死，爱。这三大永恒的主题将会影响我们的一生，生死相互对立而制衡，但是爱可以超越它们。（这里的爱并不只是男女之间的情愫，也并不是人与人之间产生的情感，具体来说它是一种主观感受，比如说喜怒哀乐恨，他们都是爱的一种表现）这里就为大家拓展下爱。大家谈到爱免不到就会想到《罗密欧与朱丽叶》，《梁山伯与祝英台》这两篇都是凄美且经典的爱情故事，他们所传达出来的思想则是”我爱你，所以我要为你殉情“大家知道随后即出的电影《泰坦尼克号》为什么那么有名，仅仅谈爱情一举超过了前面两部影片呢，甚至达到近几十年无人能敌的新的高峰呢，因为其提出了一个在当时特别前卫的思想理论‘我爱你，所以我就为你活下去，连同你的那一份一起活下去。”这就是爱，一定程度里爱可以超越生死。接下来便是我个人对生死的看法了，因为我有过这方面的经历所以我有这个资格拿出来来给大家分享，其实我今年17岁。在此之前对生死一点概念都是没有的，何谓生，何谓死呢，之前我的主观感觉就是教科书的生与死。直到我经历他。大家知道接触生死的第一感觉是什么吗？也许大家并不知道，仅仅只是以为是害怕，是恐惧。那么你就错了，并不是这样。接触生死的第一感觉不是恐慌，而恰恰是兴奋，我无法描述是一种怎样的兴奋，因为持续的时间特别短，大概可以类比为是一个从没有吃过糖的孩子，第一次吃糖的感觉，多少有点新鲜感在里面。之后就是一种安不下心的恐惧感，这种感觉没有经历过的人是不知道的，那是一种无法装出来的感觉。事后我也进行相关资料的查阅，好像是一个叫什么卡的理论科学家发表的一篇论文叫《生死论》里提到人在濒临死亡的那一刻，潜意识里已经把自己当作死亡，这时的恐惧将是对生活以及其他人或事物的无限眷念产生的。所以就像我的一个老师所讲的这个时候的人第一想法就是想自己最亲近的人，比如说妈妈。呵呵。我当时也是无法静下心，心里一直想如果妈妈在身边就好了，就好像这个人可以给你带来无尽的心安。之后过了一会儿后自己的心就静下来了，那种静下来的感觉叫做庆幸。感谢自己他妈的还活着。说句实话，那次的经历让我之后的一个月很不好过去，但是他对我最大的意义就是他完全打开了我对外界事物感知，就像一个美妙的气孔被揭开，然后进行气体交流的感觉。只有到了那个时候我才真正的知道到底什么是活着。就像我前面所说的爱是一切感受的源泉，所以活着就是我们在这个世界上主观上存在的感受。包括生，包括死，包括爱，包括我们生活的任何一种主观感觉，这就是活着。 我们为什么要活着我很反感很多专家类的人物整天批判中国人没有信仰，中国人的信仰就是“好死不如赖活着，无论发生什么活着就行了。”活着这本书也就是讲为什么活着这个问题的，福贵在书里是这么形容自己的一生：&quot;我是有时候想想伤心，有时候想想又很踏实”一个早已进去垂暮之年的老人尚且如此，全家人的葬都是这样一位老人送走的，其中的滋味是我们所没办法想象的。那联系到实际，我们为什么活着呢，其实这个问题古往今来无数人士都参与过探讨，都没有得出一个科学性的结论。他们的探讨的过程大多数都是微观细胞的存在形式，和宏观宇宙的神秘意图。由我个人的观点，并没有 微及细胞，大至宇宙，也不像这本书里的观点。活着并不是为了活着以外的事物而活着，而是为了活着本身而活着。围绕这一个比较抽象的说法，也就展开了福贵的一生。中国有一个成语叫做千钧一发。让一根头发去承受三万斤的重压，但是头发并没有断。这就是中国人的韧性。真正强大的人并不是看他征服了什么，而是看他可以承受什么。所以我的答案也就由此而产生活着就是为了坚持，坚持去爱，坚持享受所有由活着带来的一切主观感受，坚持忍受由死去带来的一切恐惧体会，这就是活着。我的观点也就是这个，也许十年后我会推翻我的理论，（我已经推翻了我小时候很多的想法理论。）但至少现在不会。 第三，我们应该怎么活。这里其实就要客观的来讲一下这本书的局限性。这本书里讲的是上个世纪从解放后的土地改革、人民公社制度、大炼钢铁、三年自然灾害、文化大革命之间，讲的只是底层人民对于温饱问题矛盾，缺少的则是精神世界的建设。当然在那个年代谈精神年代就像说梦话一样。但是现在的社会水平已经高于当年很多倍了，但是现在的人民幸福度却远低当年。这又是为什么呢？唯一可以解释的原因就是，人们解决了温饱类的问题后，精神世界的匮乏甚至是溃烂，出现了极大的问题。那么怎么解决呢。物质和精神上的协调与平衡该如何做到呢？一切随心，随自己的主观感觉，随自己想要完成的事情。人为什么会不快乐，大家知道么？是由于我们个人的主观感觉被客观规律法则所牵制，导致我们并不快乐。而往往这些客观法则规律常常是没有最正确的理由的，比如说为什么评判现在一个人书读的好，就一切都好。为什么长大后赚钱的多少是评判一个人是否成功的重要依据。实现人生价值评判方式有很多，为什么单单只是这一点。那还有为什么男大当婚，女大当嫁…还有很多问题我们问不出来缘由，这些都是整个社会所给予的。那么为什么社会要这样规定呢？肯定是对整个社会的和谐稳定有益处。但同时也造成了巨大的压力给个人。按照幸福最大化原理，没有人，或者说是没有生物从本质上讲是喜欢痛苦和苦难的。然而面对这一切压力，但总是有人活的潇洒。比如庄子的物我合一，陶渊明的物我两忘，这些都是境界上的潇洒。而我们该如何做到这些呢？唯有修心。提高心理素质和承受能力，寻觅物质与精神守恒的一点。这就是我们活着该做的事情。人生的最高的境界便是淡。我没有达到这个境界，所以我没有办法为大家展开。但是按照自己的心活下去，我相信万法同一。殊途总会同归的。 写与2015年4月6日。]]></content>
      <categories>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>书评</tag>
        <tag>创作</tag>
      </tags>
  </entry>
</search>

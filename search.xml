<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[äººç”Ÿç¬¬ä¸€åœºè¯å‰§---ä¸€ä¸ªäººçš„èå£«æ¯”äºš]]></title>
    <url>%2F2019%2F12%2F08%2F%E4%BA%BA%E7%94%9F%E7%AC%AC%E4%B8%80%E5%9C%BA%E8%AF%9D%E5%89%A7-%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E8%8E%8E%E5%A3%AB%E6%AF%94%E4%BA%9A%2F</url>
    <content type="text"><![CDATA[è¿™æ¬¡å¯ä»¥è¯´äººç”Ÿçš„ç¬¬ä¸€åœºè¯å‰§ï¼Œæœ¬æ¥å°±æ˜¯æœ‰ä¸€ç‚¹ä¸æƒ³å»ï¼Œæ¯•ç«Ÿæœ€è¿‘è‡ªå·±çš„çŠ¶æ€å¹¶æ²¡æœ‰æ¢å¤è¿‡æ¥ï¼Œä¸Šæ¬¡ç”Ÿæ—¥çš„èŠ±è´¹é¢„ç®—ï¼Œä¹Ÿæ˜¯è¶…äº†ä¸€ç‚¹ï¼Œç„¶åç§‰æŒç€ä¸å¤ªæƒ³ä¹±èŠ±é’±çš„æƒ³ï¼Œäºæ˜¯å°±æœ‰ç‚¹ä¸æƒ³å»ã€‚ æ„Ÿè°¢æœ‹å‹çš„åšæŒï¼Œè®©æˆ‘æ„Ÿå—åˆ°äº†åˆæµ…åˆ°æ·±çš„å¿ƒçµäº¤æµã€‚ è¿™æ˜¯æˆ‘æ¥è§¦åˆ°çš„ç¬¬ä¸€åœºå…¨è‹±æ–‡ç‹¬ç™½çš„è¯å‰§äº†ï¼Œå…¨ç¨‹å°±æ˜¯ä¸€ä¸ªå¹´è¿‡åŠç™¾çš„ç¾å›½è€çˆ·çˆ·ä¸Šå°è¡¨æ¼”ï¼Œé€šè¿‡å¤šç§è¡¨æƒ…ï¼Œå§¿æ€ï¼Œè¯­æ°”ï¼Œå°è¯å±•ç°å¤šä¸ªè§’è‰²çš„ç‹¬è§’æˆã€‚è€Œå±•ç¤ºçš„è§’è‰²å¤§è‡´å¦‚ä¸‹ï¼š ä¸»è§’çš„å­¦ç”Ÿæ—¶ä»£ ä¸»è§’çš„çˆ¶äº² ä¸»è§’çš„èå£«æ¯”äºšè€å¸ˆ ä¸»è§’çš„æˆå¹´æ—¶ä»£ ä¸»è§’èå£«æ¯”äºšè€å¸ˆçš„å­¦ç”Ÿ è¯´å¥å®è¯ï¼Œè‡ªå·±å®åœ¨æ˜¯ç®—ä¸ªç²—äººï¼Œå¯¹æ¯”è¯å‰§äººå£«æ¥è¯´ï¼Œæˆ‘å®åœ¨æ˜¯æ— æ³•æ¥æ”¶åˆ°è¿™ç§ä¸æ˜¯ç‰¹åˆ«å¼ºçƒˆçš„ç”»é¢æ„Ÿä»¥åŠåŠ¨æƒ…çš„èƒŒæ™¯éŸ³ä¹çš„äº¤æµã€‚ä»¥è‡³äºæˆ‘åˆšå¼€å§‹çœ‹è¿™ä¸ªè¯å‰§çš„æ—¶å€™ï¼Œè§‰å¾—æœ‰ç‚¹å¸¦æœ‰ä½ä¿—æ€§è´¨çš„æ— æ³•å…±æƒ…ã€‚æ­£æ˜¯ç”±äºæ˜¯å…¨è‹±æ–‡ç‹¬ç™½ï¼Œæ²¡æœ‰ä»»ä½•é¢å¤–çš„é…éŸ³ï¼Œä¸é“å…·ï¼Œè€ƒéªŒè§‚ä¼—çš„å…±æƒ…èƒ½åŠ›ï¼Œä»¥åŠè‹±è¯­èƒ½åŠ›ï¼ˆè™½ç„¶æˆ‘æ¯ä¸ªå•è¯éƒ½èƒ½å¤Ÿå¤§è‡´å¬æ‡‚ï¼Œä½†æ˜¯è¿æˆä¸€ä¸ªå¥å­å®åœ¨æ˜¯æœ‰ç‚¹å¼ºäººæ‰€éš¾äº†ï¼‰ã€‚ä½†æ˜¯æ›´è€ƒéªŒçš„å´æ˜¯æ¼”å‘˜çš„ä¸´åœºèƒ½åŠ›ï¼Œä»¥åŠå„ç§æƒ…ç»ªè¯­æ°”çš„è½¬å˜èƒ½åŠ›ã€‚åªèƒ½è¯´è§‚ä¼—å‘æœ‰ç‚¹ç²¾æ¹›ï¼Œå¦‚æœè¯»è¿‡èå£«æ¯”äºšçš„é€‰é›†å†æ¥è§‚çœ‹å¯èƒ½åˆæ˜¯ä¸å¤ªä¸€æ ·çš„æ„Ÿå—å§ã€‚ ä¸ªäººç†è§£ï¼Œè¿™éƒ¨è¯å‰§æ˜¯å°†ä½œè€…äº²èº«ç»å†çš„æ•…äº‹ï¼Œå’Œèå£«æ¯”äºšçš„å‰§æœ¬è¯å‰§ï¼Œä»£å…¥åˆ°ä¸€ä¸ªèå£«æ¯”äºšæ‚²å‰§ç²¾ç¥çš„æ ¡é•¿ä¹‹é—´å‘ç”Ÿçš„æ•…äº‹ã€‚ å¦‚æœç”±å‰§æƒ…ä¸Šè¿›è¡Œä¸€ä¸ªåˆ’åˆ†ï¼ŒåŸºæœ¬ä¸Šå¯ä»¥åˆ†æˆå››ä¸ªéƒ¨åˆ† ä¸»è§’ä¸èå£«æ¯”äºšè¯å‰§é›†çš„åˆè¯†è¿™ä¸ªåœ°æ–¹å°±æ˜¯ä½œè€…è¢«è€å¸ˆæ ¡é•¿é€¼è¿«è¯»çš†å¤§æ¬¢å–œä¸­é—´çš„ä¸€æ®µï¼Œç”±äºæ€»æ˜¯è¯»é”™ï¼Œäºæ˜¯ç´§å¼ çš„å°¿è£¤å­ã€‚å‰§æƒ…ä¸Šæ˜¾å¾—å¾ˆä¸€èˆ¬ï¼Œä¸»è¦è§’è‰²æœ‰ä¸¤ä¸ªï¼Œä½†æ˜¯æ¼”å‘˜å‰å®³çš„æ˜¯åœ¨ä¸¤ç§è§’è‰²ä¸­è½¬å˜ä¸­æ¸¸åˆƒæœ‰ä½™ï¼Œå¹¶ä¸”å°†å­¦ç”Ÿçš„ç´§å¼ æ„Ÿè¡¨ç°çš„å”¯å¦™å”¯ä¿ï¼Œè¦çŸ¥é“ï¼Œè¿™ä»…ä»…åªæ˜¯é äº†å°è¯ä»¥åŠè‚¢ä½“è¯­è¨€ï¼Œå¹¶æ²¡æœ‰å…¶ä»–å¤šä½™çš„è¡¨ç°å½¢å¼ã€‚ è¿™ä¸ªåœ°æ–¹ä¹Ÿæ˜¯åˆšåˆšå¼€å§‹å…±æƒ…çš„åœ°æ–¹äº†ï¼Œä»æœ€å…ˆå¼€å§‹çš„çœ‹ä¸æ‡‚çš„æƒŠè®¶ï¼Œåˆ°åé¢å¯¹äºä¸€ä¸ªè¯è¯­ é—èµ  äº§ç”Ÿäº†è«å¤§çš„å…´è¶£ è¿™ä¹Ÿæ˜¯ä¸»è§’å°¿è£¤å­çš„ä¸»è¦åŸå› äº†ï¼Œè¿™ä¸€åœºæˆåè€Œç»“åˆå¤§å®¶çš„æƒ³è±¡åŠ›ï¼Œåè€Œæ˜¾å¾—ç‰¹åˆ«æœ‰è¶£ï¼Œå› ä¸ºæ¯ä¸€ç§åœºæ™¯è¢«èµ‹äºˆäº†æƒ³è±¡åŠ›è·å¾—äº†ç‹¬ç‰¹çš„ç”Ÿå‘½åŠ›ï¼Œå‰§æƒ…çš„æ¨è¿›ä¹Ÿåˆ°äº†ä¸‹ä¸€ä¸ªé˜¶æ®µã€‚ ä¸»è§’ä¸çˆ¶äº²çš„å¯¹è¯ä¸»è§’ç”±äºåœ¨å­¦æ ¡é‡Œé¢å‡ºäº†ä¸‘ï¼Œä¸æ•¢å†å»å­¦æ ¡ï¼Œè¢«çˆ¶äº²å¼€è§£ï¼Œäºæ˜¯æ•¢äºå»å­¦æ ¡äº†ã€‚çˆ¶äº²å¼€è§£ä¸»è§’çš„é‚£æ®µè¯ï¼Œè®©æˆ‘è®°å¿†æ·±åˆ»ï¼Œå¯èƒ½æ˜¯æœ€è¿‘å¯¹äºç»†èŠ‚æƒ…æ„Ÿçš„å†ç°ï¼ŒçœŸå¿ƒçš„è§‰å¾—ä¸­å›½æ™®é€šå®¶åº­çš„äº²å­å…³ç³»å……æ»¡äº†æ²‰é‡ï¼Œè¢«ç»æµå‹çš„åªå‰©ä¸‹ç°å®ï¼Œå¸Œæœ›è‡ªå·±ä»¥åèƒ½å¤Ÿå†²ç ´æŸç¼šæ”¹å˜è¿™ä¸€åˆ‡ã€‚æˆ‘å¸Œæœ›ä¸çˆ¶æ¯æˆ–è€…æ˜¯å­å¥³çš„å…³ç³»ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰èƒ½å¤Ÿå¤šä¸€äº›è½»æ¾æ„‰æ‚¦ï¼Œä¸è¦è¢«ç„¦è™‘çš„æ‹…å¿ƒæ‰€æŸç¼šã€‚æ‰€è°“çˆ¶æ¯å­å¥³ä¸€åœºï¼Œä¸è¿‡çœŸåˆ‡å…³ç³»ä¸­æœ€æœ‰ç¼˜åˆ†çš„ç›¸è¿ï¼Œä¸è¦è¶Šçˆ±è¶Šæ²‰é‡ã€‚ ä¸»è§’ä¸å‘ç”Ÿæ‚²å‰§è€å¸ˆçš„æ•…äº‹ã€Œæœ‰æ—¶é—´å†å»è¡¥ä¸Šã€ ä¸»è§’ä¸è€å¹´è€å¸ˆçš„æ•…äº‹æ¢è¨€ä¹‹ï¼Œæ•´éƒ¨è¯å‰§æœ€ä»¤æˆ‘æ„ŸåŠ¨çš„å°±æ˜¯è¿™ä¸ªåœ°æ–¹ï¼Œç”±è€å¹´çš„æ ¡é•¿è¯´å‡ºå…¨ä¸–ç•Œæ˜¯ä¸€ä¸ªå¤§èˆå°ï¼Œæ‰€æœ‰çš„ç”·ç”·å¥³å¥³ä¸è¿‡æ˜¯ä¸€äº›æ¼”å‘˜ï¼›ä»–ä»¬éƒ½æœ‰ä¸‹åœºçš„æ—¶å€™ï¼Œä¹Ÿæœ‰ä¸Šåœºçš„æ—¶å€™ã€‚ä¸€ä¸ªäººçš„ä¸€ç”Ÿä¸­æ‰®æ¼”ç€å¥½å‡ ä¸ªè§’è‰²ï¼Œä»–çš„è¡¨æ¼”å¯ä»¥åˆ†ä¸ºä¸ƒä¸ªæ—¶æœŸã€‚æœ€åˆæ˜¯å©´å­©ï¼Œåœ¨ä¿å§†çš„æ€€ä¸­å•¼å“­å‘•åã€‚ç„¶åæ˜¯èƒŒç€ä¹¦æŠ¥ã€æ»¡é¢çº¢å…‰çš„å­¦ç«¥ï¼Œåƒèœ—ç‰›ä¸€æ ·æ…¢è…¾è…¾åœ°æ‹–ç€è„šæ­¥ï¼Œä¸æƒ…æ„¿åœ°å‘œå’½ç€ä¸Šå­¦å ‚ã€‚ç„¶åæ˜¯æƒ…äººï¼Œåƒç‚‰ç¶ä¸€æ ·å¹ç€æ°”ï¼Œå†™äº†ä¸€é¦–æ‚²å“€çš„è¯—æ­Œå’ç€ä»–æ‹äººåœ°çœ‰æ¯›ã€‚ç„¶åæ˜¯ä¸€ä¸ªå†›äººï¼Œæ»¡å£å‘ç€å¤æ€ªåœ°èª“ï¼Œèƒ¡é¡»é•¿å¾—åƒè±¹å­ä¸€æ ·ï¼Œçˆ±æƒœç€åèª‰ï¼ŒåŠ¨ä¸åŠ¨å°±è¦æ‰“æ¶ï¼Œåœ¨ç‚®å£ä¸Šå¯»æ±‚ç€æ³¡æ²«ä¸€æ ·å¾—è£åã€‚ç„¶åæ˜¯æ³•å®˜ï¼Œèƒ–èƒ–åœ†åœ†çš„è‚šå­å¡æ»¡äº†é˜‰é¸¡ï¼Œå‡›ç„¶çš„çœ¼å…‰ï¼Œæ•´æ´çš„èƒ¡é¡»ï¼Œæ»¡å˜´éƒ½æ˜¯æ ¼è¨€å’Œè€ç”Ÿå¸¸è°ˆï¼›ä»–è¿™æ ·æ‰®äº†ä»–çš„ä¸€ä¸ªè§’è‰²ã€‚ç¬¬å…­ä¸ªæ—¶æœŸå˜æˆäº†ç²¾ç˜¦çš„è¶¿ç€æ‹–é‹çš„é¾™é’Ÿè€åŸï¼Œé¼»å­ä¸Šæ¶ç€çœ¼é•œï¼Œè…°è¾¹æ‚¬ç€é’±è¢‹ï¼›ä»–é‚£å¹´è½»æ—¶å€™èŠ‚çœä¸‹æ¥çš„é•¿è¢œå­å¥—åœ¨ä»–çš±ç˜ªçš„å°è…¿ä¸Šæ˜¾å¾—å®½å¤§å¼‚å¸¸ï¼›ä»–é‚£æœ—æœ—çš„ç”·å­çš„å£éŸ³åˆå˜æˆäº†å­©å­ä¼¼çš„å°–å£°ï¼Œåƒæ˜¯å¹ç€é£ç¬›å’Œå“¨å­ã€‚ç»ˆç»“ç€è¿™æ®µå¤æ€ªçš„å¤šäº‹çš„å†å²çš„æœ€åä¸€åœºï¼Œæ˜¯å­©ææ—¶ä»£çš„å†ç°ï¼Œå…¨ç„¶çš„é—å¿˜ï¼Œæ²¡æœ‰ç‰™é½¿ï¼Œæ²¡æœ‰çœ¼ç›ï¼Œæ²¡æœ‰å£å‘³ï¼Œæ²¡æœ‰ä¸€åˆ‡ã€‚]]></content>
      <categories>
        <category>æˆé•¿</category>
      </categories>
      <tags>
        <tag>è¯å‰§</tag>
        <tag>èå£«æ¯”äºš</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Compression --- the course of algorithm]]></title>
    <url>%2F2019%2F10%2F10%2FData-Compression-the-course-of-algorithm%2F</url>
    <content type="text"><![CDATA[æ•°æ®å‹ç¼©introductionå‹ç¼©æ•°æ®å¯ä»¥èŠ‚çœå­˜å‚¨æ•°æ®éœ€è¦çš„ç©ºé—´å’Œä¼ è¾“æ•°æ®éœ€è¦çš„æ—¶é—´ï¼Œè™½ç„¶æ‘©å°”å®šå¾‹è¯´é›†æˆèŠ¯ç‰‡ä¸Šçš„æ™¶ä½“ç®¡æ¯ 18-24 ä¸ªæœˆç¿»ä¸€å€ï¼Œå¸•é‡‘æ£®å®šå¾‹è¯´æ•°æ®ä¼šè‡ªå·±æ‹“å±•æ¥å¡«æ»¡å¯ç”¨ç©ºé—´ï¼Œä½†æ•°æ®å‹ç¼©è¿˜æ˜¯æœ€ç»æµçš„åšæ³•ã€‚ æ•°æ®å‹ç¼©çš„åŸºæœ¬æ¨¡å‹å¦‚ä¸‹ï¼Œå¾ˆç®€å•ï¼Œå‹ç¼©å’Œè§£å‹ï¼Œå‹ç¼©ç‡å³ C(B) å’Œ B çš„æ¯”ç‰¹æ•°ä¹‹æ¯”ã€‚ æ•°æ®å‹ç¼©å¯¹è±¡çš„æœ¬è´¨å®é™…ä¸Šå°±æ˜¯å°†äºŒè¿›åˆ¶æ–‡ä»¶ï¼ŒæŠ½è±¡å±‚æ¬¡ä¸ºæ¯”ç‰¹æµï¼Œ ä¸‹é¢ç›´æ¥ç»™å‡ºäº†ç›¸åº”è¯»å†™äºŒè¿›åˆ¶çš„ç±» è¿™é‡Œ javaçš„é»˜è®¤å¤„ç†æ˜¯åŸºäº8ä½å­—èŠ‚æµ è¿™é‡Œæˆ‘ä¸¾å‡ºä¸€ä¸ªç®€å•çš„æ•°æ®å‹ç¼©çš„ä¾‹å­ å°†æ—¥æœŸ 12/31/1990 è¿™ä¸ªå­—ç¬¦ä¸²è¿›è¡Œå‹ç¼© ä¸Šé¢å°±å¯ä»¥è½»è€Œæ˜“ä¸¾çš„çœ‹å‡ºæ¥ å‹ç¼©çš„å¥½å¤„ã€‚ç¬¬ä¸€å¼ å›¾å°±æ˜¯åŸæ¥çš„å†™æ³•ï¼Œç¬¬äºŒå¼ å›¾å°±æ˜¯å°†å…¶æ¢æˆintç±»å‹è¿›è¡Œå‹ç¼©ç¬¬ä¸‰å¼ å›¾åˆ™æŒ‰ç…§ç‰¹å®šçš„å‹ç¼©è¿›è¡Œå‹ç¼© è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¹¶ä¸å­˜åœ¨é€šç”¨çš„å‹ç¼©ç®—æ³• å½“ç„¶ï¼Œè¿™é‡Œå­˜åœ¨ä¸€ç§å¯ä»¥ä¾›äººç±»é˜…è¯»çš„æ¯”ç‰¹æµå½¢å¼ï¼Œè¿™ä¸ªè¢«ç§°ä¸º è½¬å‚¨ã€‚ä¸‹é¢å›¾ï¼Œå°±æ˜¯ä¸€äº›ä¾‹å­ï¼š BinaryDump å°†æ¯”ç‰¹æµæŒ‰ 0 å’Œ 1 è¾“å‡ºæ¥ï¼›HexDump å°†æ¯”ç‰¹æµç»„ç»‡æˆ 8 ä½å¹¶ç”¨ä¸¤ä½çš„ 16 è¿›åˆ¶æ•°è¡¨ç¤ºï¼›PictureDump åˆ™å°†æ¯”ç‰¹æµå˜ä¸º Picture å¯¹è±¡ï¼Œå…¶ä¸­ç™½è‰²åƒç´ è¡¨ç¤º 0ï¼Œé»‘è‰²åƒç´ è¡¨ç¤º 1ã€‚ run-length Codingæ¸¸ç¨‹ç¼–ç ï¼Œå°±æ˜¯ä¸“é—¨ç”¨æ¥å¤„ç†å†—æ‚çš„æ•°æ®ï¼Œä»–æ˜¯é€šè¿‡è®¡ç®—é‡å¤çš„ä¸ªæ•°ï¼Œæ¥æœ€ç»ˆå†³å®šå‹ç¼©çš„å½¢å¼ï¼Œå°±åƒä¸‹å›¾ï¼š ä¸Šé¢è¿™é‡Œå°±æ˜¯ç”¨çš„4ä½è®¡æ•°ï¼Œè€Œä¸‹é¢çš„ä»£ç åˆ™æ˜¯ä½¿ç”¨äº†8ä½è®¡æ•°ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738public class RunLength &#123; private final static int R = 256; // maximum run-length conut private final static int lgR = 8; // number of bits per conut public static void compress() &#123; char cnt = 0; boolean b, old = false; while (!BinaryStdIn.isEmpty()) &#123; b = BinaryStdIn.readBoolean(); if (b != old) &#123; BinaryStdOut.write(cnt); cnt = 0; old = !old; &#125; else &#123; // ç”±äºè¿™ä¸ªåœ°æ–¹æ˜¯å…«ä½è®¡æ•°ï¼Œæ‰€ä»¥æœ€å¤§çš„é™åˆ¶ä¹Ÿå°±æ˜¯255 if (cnt == 255) &#123; BinaryStdOut.write(cnt); cnt = 0; BinaryStdOut.write(cnt); &#125; &#125; cnt++; &#125; BinaryStdOut.write(cnt); BinaryStdOut.close(); &#125; public static void expand() &#123; boolean bit = false; while (!BinaryStdIn.isEmpty()) &#123; int run = BinaryStdIn.readInt(lgR); // read 8-bit conut from standard input for (int i = 0; i &lt; run; i++) BinaryStdOut.write(bit); // write 1 bit to standard output bit = !bit; &#125; BinaryStdOut.close(); // pad 0s for byte alignment &#125;&#125; è¿™ç§ç­–ç•¥ä¸“é—¨å¯¹ä»˜ç»å¸¸å‡ºç°çš„ï¼Œå†—æ‚çš„æ¯”ç‰¹æµæ˜¯ååˆ†æœ‰æ•ˆçš„ï¼Œæ¸¸ç¨‹ç¼–ç çš„ä¸€ä¸ªåº”ç”¨å°±æ˜¯å‹ç¼©ä½å›¾ï¼Œä½å›¾è¢«å¹¿æ³›çš„ç”¨äºä¿å­˜å›¾ç‰‡å’Œæ‰«ææ–‡æ¡£ã€‚ å°±åƒè¿™å¼ å›¾ï¼Œå·¦è¾¹ç»è¿‡å‹ç¼©ä¹‹åæå¤§ç¨‹åº¦ä¸Šå°äº†å¾ˆå¤šã€‚ è¿™é‡Œçš„æ¸¸ç¨‹ç¼–ç ä¸é€‚ç”¨äºå«æœ‰å¤§é‡çŸ­æ¸¸ç¨‹çš„è¾“å…¥ï¼Œè€Œä¸æ˜¯æ‰€æœ‰æˆ‘ä»¬å¸Œæœ›å‹ç¼©çš„æ¯”ç‰¹éƒ½èƒ½åƒä¸Šé¢ä¸€æ ·é‡å¤ä¸ªæ•°å¤šï¼Œä¸”å†—æ‚ã€‚æ‰€ä»¥æ¥ä¸‹æ¥æˆ‘ä»¬å°±ä»‹ç»ä¸¤ç§é€‚ç”¨äºå¤šç§ç±»å‹çš„æ–‡ä»¶å‹ç¼©ç®—æ³•ã€‚ Huffman Compressionå“ˆå¤«æ›¼å‹ç¼© è¿™é‡Œç›´æ¥ä»‹ç»äº†ä¸€ä¸ªæ‘©æ–¯å¯†ç ï¼Œä½†æ˜¯åƒæ‘©æ–¯å¯†ç è¿™ä¸€ç±»çš„ç¼–ç å¾ˆå®¹æ˜“äº§ç”Ÿå¤šä¹‰æ€§ï¼Œæ‰€ä»¥å¯†ç ä¹‹é—´è¿˜æœ‰ä¸€å®šçš„é—´éš™éš”å¼€ã€‚ å¤šä¹‰æ€§çš„æœ¬è´¨åŸå› æ˜¯æœ‰äº›å­—ç¬¦çš„ç¼–ç æ˜¯å…¶å®ƒå­—ç¬¦ç¼–ç çš„å‰ç¼€ï¼Œæ‰€ä»¥æ‰å¯èƒ½ä¼šæœ‰ä¸åŒçš„è§£è¯»ã€‚è€Œæœ‰ç§ç‰¹æ®Šçš„å˜é•¿ç¼–ç â€”â€”å‰ç¼€ç ï¼ˆprefix-free codeï¼‰ï¼Œå­—ç¬¦ç¼–ç è‚¯å®šä¸æ˜¯å…¶å®ƒå­—ç¬¦ç¼–ç çš„å‰ç¼€ï¼Œä¹Ÿå°±ä¸å­˜åœ¨å¤šä¹‰æ€§çš„é—®é¢˜ã€‚ è¿™é‡Œè¡¨ç¤ºè¿™ç§å‰ç¼€ç ï¼Œå¯ä»¥å¾ˆè‡ªç„¶çš„ä½¿ç”¨å­—å…¸æ ‘æ¥è¿›è¡Œè¡¨ç¤º èŠ‚ç‚¹ä»£ç è¿™é‡Œç›´æ¥ç”¨ä»£ç è¡¨ç¤ºï¼š 1234567891011121314151617181920private static class Node implements Comparable&lt;Node&gt; &#123; private final char ch; // used only for leaf nodes private final int freq; // used only for compress private final Node left, right; public Node(char ch, int freq, Node left, Node right) &#123; this.ch = ch; this.freq = freq; this.left = left; this.right = right; &#125; private boolean isLeaf() &#123; return left == null &amp;&amp; right == null; &#125; public int compareTo(Node that) &#123; return this.freq - that.freq; &#125;&#125; å­—ç¬¦é¢‘ç‡åœ¨ä¸‹é¢ç”Ÿæˆæœ€ä¼˜å‰ç¼€ç çš„æ—¶å€™ä¼šä½¿ç”¨åˆ°ã€‚ å½“ç„¶ï¼Œåœ¨ä¸‹é¢ä½¿ç”¨å‰ï¼Œå¾—å°†è¿™ä¸ªè¡¨ç¤ºå‰ç¼€ç çš„å­—å…¸æ ‘ä¸€æ ·ç»™å‹ç¼©è¿›å…¥åˆ°æ¯”ç‰¹æµï¼Œè€Œè¿™é‡Œå°±ç›´æ¥ä½¿ç”¨å‰åºéå†äº†ã€‚ å½“ç„¶ï¼Œéœ€è¦å°†å¶å­èŠ‚ç‚¹ä¸å…¶ä»–çš„èŠ‚ç‚¹åŒºåˆ†å¼€æ¥çš„è¯ï¼Œåˆ°å¶å­èŠ‚ç‚¹çš„æ—¶å€™ä¼šå…ˆè¾“å‡ºä¸€ä¸ªtrueï¼Œæ„æ€å°±æ˜¯1ï¼Œè€Œå…¶ä»–çš„èŠ‚ç‚¹åˆ™æ˜¯0ï¼Œé™„åœ¨å¼€å¤´çš„Trieç›¸å¯¹å°±ä¼šæ˜¾å¾—å¾ˆå°ï¼Œæ²¡æœ‰ä»€ä¹ˆå…³ç³»ã€‚ ä¸Šé¢å·²ç»å°†å‹ç¼©å­—å…¸æ ‘ï¼Œä»¥åŠè§£å‹ç¼©å­—å…¸æ ‘éƒ½è®²åˆ°äº†ï¼Œæ¥ä¸‹æ¥å°±æ˜¯æ„é€ è¿™ä¸ªå‰ç¼€ç å­—å…¸æ ‘äº†ã€‚ å®é™…ä¸Šï¼Œå“ˆå¤«æ›¼çš„åšæ³•å¾ˆå¥½æè¿°ï¼šé¦–å…ˆä½ è¦çŸ¥é“å­—ç¬¦å‡ºç°çš„é¢‘ç‡ï¼Œç„¶åæ¯æ¬¡æŒ‘ä¸¤ä¸ªæœ€å°çš„åŠ èµ·æ¥ï¼ŒåŠ èµ·æ¥çš„å€¼å†å’ŒåŸæ¥çš„é‚£äº›ä¸€èµ·é‡å¤æŒ‘ä¸¤ä¸ªæœ€å°çš„åŠ èµ·æ¥ï¼Œä»ä¸‹å¾€ä¸Šæ¥æˆ Trieã€‚ æ„é€ ä»£ç 12345678910111213141516171819private static Node buildTrie(int[] freq) &#123; MinPQ&lt;Node&gt; pq = new MinPQ&lt;Node&gt;(); for (char i = 0; i &lt; R; i++) if (freq[i] &gt; 0) pq.insert(New Node(i, freq[i], null, null)); // merge two smallest tries while (pq.size() &gt; 1) &#123; Node x = pq.delMin(); Node y = pq.delMin(); Node parent = new Node('\0', x.freq + y.freq, x, y); // è¿™é‡Œæœ‰ç‚¹ç±»ä¼¼äºå¹¿æœçš„æ“ä½œï¼Œè¿™æ ·çš„åšæ³•å°±æ˜¯ç›´æ¥å°†æ¯ä¸€ä¸ªæœ€å°çš„å€¼å¼„å‡ºæ¥ï¼Œç„¶ååˆ†åˆ«ç»™å…¶è®¾ç½®çˆ¶äº²èŠ‚ç‚¹ pq.insert(parent); &#125; // æœ€åä¸€å®šä¸€å®šå°±æ˜¯æ ¹èŠ‚ç‚¹äº†ã€‚ return pa.delMin();&#125; æœ€ä¼˜è§£è¯æ˜è¿™ä¸ªåœ°æ–¹ç›®å‰å¯¹è‡ªå·±ä¸ä½œè¦æ±‚ï¼Œè´´ä¸¤ä¸ªç½‘å€ æ–‡å­—è®²è§£ è§†é¢‘è®²è§£ LZW-compressionLZW å‹ç¼©ç®—æ³•æ˜¯è‡ªé€‚åº”æ€§çš„ï¼ˆadaptiveï¼‰æ¨¡å‹ï¼Œåœ¨è¯»å…¥æ–‡æœ¬çš„æ—¶å€™å­¦ä¹ å¹¶æ›´æ–°æ¨¡å‹ï¼Œä¸éœ€è¦å°†æ¨¡å‹é™„åœ¨æ¯”ç‰¹æµä¸­ç”¨äºè§£å‹ï¼Œä½†è§£å‹çš„æ—¶å€™åªèƒ½ä»æ–‡æœ¬å¼€å¤´å¼€å§‹ã€‚ å‹ç¼©ä¾‹å­å±•å¼€å’Œå‹ç¼©ç±»ä¼¼ï¼Œæœ‰ä¸‹é¢å‡ ä¸ªæ­¥éª¤ï¼š åˆ›å»ºç¬¦å·è¡¨ï¼Œä½†è¿™æ¬¡ç¼–ç ä¸ºé”®ï¼Œå¯¹åº”çš„å­—ç¬¦ä¸²ä¸ºå€¼ã€‚åˆå§‹åŒ–ç¬¦å·è¡¨ï¼ŒåŠ å…¥å•ä¸ªå­—ç¬¦çš„é”®å€¼å¯¹ã€‚ä»å‹ç¼©æ–‡ä»¶è¯»å…¥ W ä½çš„ç¼–ç ï¼Œè¾“å‡ºç¼–ç å¯¹åº”çš„å­—ç¬¦ä¸²ã€‚é¢„è¯»ä¸‹ä¸€ä¸ªç¼–ç ï¼Œå¾—åˆ°ä¸‹ä¸ªå­—ç¬¦ï¼Œç±»ä¼¼åœ°æ›´æ–°ç¬¦å·è¡¨ã€‚é‡å¤ä¸Šä¸¤æ­¥ç›´åˆ°è¯»å…¥ç»“æŸç¼–ç ã€‚ä¾‹å›¾å³å±•å¼€ä¸Šé¢å‹ç¼©å½¢æˆçš„ç¼–ç ã€‚ ä¸€å¼€å§‹è¯»å…¥ 8 ä½ç¼–ç  41ï¼Œä»ç¬¦å·è¡¨å¯çŸ¥å¯¹åº”å­—ç¬¦ä¸² Aï¼Œè¾“å‡º A åé¢„è¯»ä¸‹ä¸€ä¸ªç¼–ç  42ï¼Œå¯¹åº” Bï¼Œäºæ˜¯å¾€ç¬¦å·è¡¨ä¸­åŠ å…¥æ–°é”®å€¼å¯¹ (81, AB)ï¼›ç°åœ¨è¯»åˆ°ç¼–ç  42ï¼Œè¾“å‡º B å¹¶é¢„è¯» 52 å¾—åˆ° Rï¼Œæ‰€ä»¥åŠ å…¥ (82, BR) â€¦ ç›´åˆ°è¯»å…¥ç¼–ç  80ï¼Œè¡¨ç¤ºæ–‡ä»¶ç»“æŸã€‚ ä¼¼ä¹å±•å¼€å’Œå‹ç¼©å·®ä¸å¤šï¼Œç”šè‡³æ›´ç®€å•ï¼Œå› ä¸ºä¸éœ€è¦æ‰¾æœ€é•¿å‰ç¼€ï¼Œç¬¦å·è¡¨ç›´æ¥ç”¨æ•°ç»„ç®€å•å®ç°ã€‚ä½†æ˜¯ï¼Œå±•å¼€æœ‰æ—¶ä¼šç¢°åˆ°ä¸€ä¸ªç‰¹æ®Šçš„æƒ…å†µï¼š å‹ç¼©å­—ç¬¦ä¸² ABABABA ç¼–ç æˆ 41 42 81 83 80ï¼Œç°åœ¨å¯¹è¿™ç¼–ç è¿›è¡Œå±•å¼€ã€‚ç¼–ç  41 è¾“å‡º Aï¼Œé¢„è¯» 42 ååŠ å…¥ (81, AB) æ›´æ–°ç¬¦å·è¡¨ï¼›ç¼–ç  42 è¾“å‡º Bï¼Œé¢„è¯» 81 çŸ¥é“ä¸‹ä¸ªå­—ç¬¦æ˜¯ Aï¼ŒåŠ å…¥ (82, BA)ï¼›ç¼–ç  81 è¾“å‡º ABï¼Œé¢„è¯» 83 å¡ä½ï¼Œå› ä¸ºç¬¦å·è¡¨ä¸­è¿˜æ²¡æœ‰è¿™ä¸ªé”®ã€‚ ä½†æ˜¯ï¼Œè¿™ç§æ—¶å€™æˆ‘ä»¬è¿˜æ˜¯å¯ä»¥çŸ¥é“ AB çš„ä¸‹ä¸€ä¸ªå­—ç¬¦æ˜¯ä»€ä¹ˆçš„ã€‚å‡è®¾ AB åé¢çš„å­—ç¬¦åˆ†åˆ«ä¸º ğ‘1ï¼Œğ‘2ï¼Œğ‘3ï¼Œå¡ä½çš„æ—¶å€™ï¼ˆæ›´æ–°è¦åŠ å…¥çš„ç¼–ç å’Œé¢„è¯»åˆ°çš„ç¼–ç ä¸€æ ·ï¼‰è‚¯å®šæœ‰ ABğ‘1=ğ‘1ğ‘2ğ‘3,æ‰€ä»¥ä¸‹ä¸ªå­—ç¬¦å³ Aï¼ŒåŠ å…¥ (83, ABA) å³å¯ã€‚ 1234567891011121314151617181920212223public static void expand() &#123; int i; // å½“å‰æ›´æ–°ç¬¦å·è¡¨è¦åŠ å…¥çš„ç¼–ç  String[] st = new String[L]; for (i = 0; i &lt; R; i++) st[i] = "" + (char) i; st[i++] = " "; // ä¾‹å›¾ä¸­è¡¨ç¤ºæ–‡ä»¶ç»“æŸçš„ 0x80 int codeword = BinaryStdIn.readInt(W); String val = st[codeword]; while (true) &#123; BinaryStdOut.write(val); codeword = BinaryStdIn.readInt(W); // é¢„è¯»çš„ç¼–ç  if (codeword == R) break; String s = st[codeword]; if (i == codeword) // è¦åŠ å…¥çš„ç¼–ç å’Œé¢„è¯»çš„ç¼–ç ç›¸åŒ s = val + val.charAt(0); if (i &lt; L) st[i++] = val + s.charAt(0); val = s; &#125; BinaryStdOut.close();&#125; å…³äºç¬¬äºŒç§å‹ç¼©æ–¹å¼ æœ‰ç‚¹ä¸æ˜¯å¾ˆå¥½ç†è§£ï¼Œå¯ä»¥é…åˆç®—æ³•è§†é¢‘è¯¾ä¸€èµ·é£Ÿç”¨ï¼Œè¿™é‡Œå°±å¯ä»¥ä¸ç”¨ä¼ è¾“æ¨¡å‹å±•å¼€å‹ç¼©ï¼Œç¼–ç æ–‡ä»¶äº†ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>æ™®æ—æ–¯é¡¿ç®—æ³•è¯¾</tag>
        <tag>æ•°æ®å‹ç¼©</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Regular Expressions --- the course of algorithm]]></title>
    <url>%2F2019%2F10%2F09%2FRegular-Expressions-the-course-of-algorithm%2F</url>
    <content type="text"><![CDATA[Regular Expressionsæ­£åˆ™è¡¨è¾¾å¼åœ¨æ–‡æœ¬ä¸­æŸ¥æ‰¾å­å­—ç¬¦ä¸²åªæ˜¯å¯»æ‰¾ä¸€ä¸ªå•ä¸€çš„å­—ç¬¦ä¸²ï¼Œä½†ç»å¸¸çš„æˆ‘ä»¬å¯èƒ½ä¸çŸ¥é“è¿™ä¸ªå­—ç¬¦ä¸²çš„å®Œæ•´ä¿¡æ¯ï¼Œæˆ–æ˜¯å¯»æ‰¾çš„æ˜¯å»åˆæŸç§æ¨¡å¼çš„ä¸€äº›å­—ç¬¦ä¸²ï¼Œå³æ‰€è°“ æ¨¡å¼åŒ¹é…ï¼ˆPattern Matchingï¼‰ã€‚ æ­£åˆ™è¡¨è¾¾å¼ï¼ˆRegular Expressionsï¼‰ å°±æ˜¯ç”¨æ¥æè¿°æ¨¡å¼çš„ï¼Œè¡¨ç¤ºç¬¦åˆæŸç§æ¨¡å¼çš„å­—ç¬¦ä¸²çš„é›†åˆï¼ˆå¯èƒ½æ˜¯æ— é™çš„ï¼‰ï¼Œå®ƒæœ‰ä¸‹é¢å‡ ç§åŸºæœ¬æ“ä½œï¼š å°±æ˜¯æ™®é€šçš„æ­£åˆ™è¡¨è¾¾å¼é‡Œé¢çš„æ“ä½œã€‚ è¿æ¥ã€æˆ–ã€é—­åŒ…å’Œæ‹¬å·ï¼Œéƒ½ä¸éš¾ç†è§£ã€‚å…¶ä¸­é—­åŒ…è¡¨ç¤ºè‹¥å¹²ä¸ªè‡ªèº«è¿æ¥ï¼Œå¯ä»¥æ˜¯é›¶ä¸ªã€‚ ç„¶åä»–ä¸€èˆ¬æœ‰ä»¥ä¸‹è¿™äº›ç¼©ç•¥æ–¹å¼ å…³äºå®Œæ•´çš„æ­£åˆ™è¡¨è¾¾å¼ å¯ä»¥å»çœ‹çœ‹ æ­£åˆ™è¡¨è¾¾å¼é€ŸæŸ¥è¡¨ åŸºæœ¬ä¸Šå¸¸ç”¨çš„æ­£åˆ™è¡¨è¾¾å¼ å› ä¸ºä¹‹å‰æ¥è§¦è¿‡æ­£åˆ™è¡¨è¾¾å¼ï¼Œæ‰€ä»¥è¿™ä¸ªåœ°æ–¹ä¹Ÿå°±ä¸å†å¤šä½™èµ˜è¿°äº†ã€‚ REs And NFAså…¶å®ï¼Œæ­£åˆ™è¡¨è¾¾å¼å’Œç¡®å®šå‹æœ‰ç©·è‡ªåŠ¨æœºé—´å­˜åœ¨ç€äºŒå…ƒæ€§ï¼ˆdualityï¼‰ï¼Œå³ Kleene å®šç†æ‰€è¯´ï¼šå¯¹ä»»æ„ DFA å­˜åœ¨ç€æè¿°åŒæ ·å­—ç¬¦ä¸²é›†åˆçš„æ­£åˆ™è¡¨è¾¾å¼ï¼Œå¯¹ä»»æ„æ­£åˆ™è¡¨è¾¾å¼å­˜åœ¨ç€è¯†åˆ«åŒæ ·å­—ç¬¦ä¸²é›†åˆçš„ DFAã€‚ å°±åƒä¹‹å‰å­¦ä¹ KMPçš„æ—¶å€™æ„é€ çš„DFAï¼Œè¿™é‡Œå…¶å®ä¹Ÿå¯ä»¥æ„é€ ä¸€ä¸ªDFAï¼Œå°±åƒè¿™æ · å½“ç„¶åº”ç”¨åœ¨KMPä¸Šé¢çš„DFAæ˜¯çº¿æ€§æ—¶é—´çš„æ€§èƒ½ä¿è¯ï¼Œä½†æ˜¯è¿™ä¸ªåŠæ³•å¹¶ä¸å¯è¡Œï¼Œå› ä¸ºæ­£åˆ™è¡¨è¾¾å¼å¯¹åº”çš„DFAçš„çŠ¶æ€æ•°ç›®å¯èƒ½æ˜¯æŒ‡æ•°çº§çš„ã€‚ äºæ˜¯ï¼Œå°±æ¥äº†è§£ä¸€ä¸‹ éç¡®å®šå‹æœ‰é™çŠ¶æ€è‡ªåŠ¨æœºï¼ŒçŠ¶æ€ä¹‹é—´çš„è½¬ç§»å¹¶ä¸æ˜¯ç¡®å®šçš„ã€‚ æ­£åˆ™è¡¨è¾¾å¼ç”¨æ‹¬å·æ‹¬èµ·ã€‚ æ­£åˆ™æ¯ä¸ªç¬¦å·å¯¹åº” NFA ä¸€ä¸ªçŠ¶æ€ï¼Œå†åŠ ä¸ªæ¥å—çŠ¶æ€ã€‚ æ¥å—ç©ºä¸²ğœ–ï¼Œä¸æ‰«æä¸‹ä¸ªå­—ç¬¦è€Œç›´æ¥æ”¹å˜çŠ¶æ€ï¼ˆä¸‹å›¾çº¢çº¿ï¼‰ï¼Œä¸ç¡®å®šæ€§æ‰€åœ¨ã€‚ æ‰«æå­—ç¬¦ï¼ŒåŒ¹é…è½¬ç§»åˆ°ä¸€ä¸‹ä¸ªçŠ¶æ€ï¼ˆä¸‹å›¾é»‘çº¿ï¼‰ã€‚ åœ¨æ‰«æå®Œå…¨éƒ¨æ–‡æœ¬å­—ç¬¦åï¼Œå¦‚æœæœ‰ ä»»ä¸€ è½¬ç§»åºåˆ—åˆ°è¾¾æ¥å—çŠ¶æ€ï¼Œåˆ™åŒ¹é…æˆåŠŸã€‚ NFA-constructioné¦–å…ˆå…ˆè®²ä¸€ä¸‹å®ƒçš„æ„é€ è¿‡ç¨‹ æœ€å…ˆå¼€å§‹çš„çŠ¶æ€ï¼Œæœ€åä¸€ä¸ªä½ç½®è¡¨ç¤ºå®ŒæˆåŒ¹é… æ‰€æœ‰å­—ç¬¦ç›´æ¥æŒ‡å‘ä¸‹ä¸€ä¸ª æ‹¬å·æˆ–è€…ç©ºçš„ï¼Œå°±ç›´æ¥å¾€ä¸‹é¢æŒ‡å°±è¡Œäº† é—­åŒ…ï¼Œæ¯”è¾ƒå·§å¦™ ä¸è¿‡åˆ†ä¸¤ç§æƒ…å†µï¼Œä¾‹å­é‡Œé¢çš„å°±æ˜¯ç¬¬ä¸€ç§æƒ…å†µ ç¬¦å· â€˜|â€™ æœ€åå†æ¥ä¸¤ä¸ªç©ºè½¬ç§» å½“ç„¶ï¼Œåœ¨å®Œæˆä¸Šé¢çš„æ„é€ çš„è¿‡ç¨‹ä¸­ï¼Œéœ€è¦å€ŸåŠ©æ•°æ®ç»“æ„æ ˆï¼Œç¢°åˆ°å·¦æ‹¬å·æˆ–è€…â€˜|â€™çš„æ—¶å€™å°±ç›´æ¥å°†å…¶çš„ç¼–å·å‹åˆ°æ ˆå†…ï¼Œç¢°åˆ°å³æ‹¬å·å°±å¼¹å‡ºæ ˆé¡¶ï¼Œå¦‚æœå¯¹äºçš„æ˜¯å…¶ä»–ä¸œè¥¿ï¼Œå°±ç›´æ¥æ ¹æ®ä¸Šé¢çš„å›¾æ¥é¡ºåº”ç»“æœï¼Œå…·ä½“çœ‹ä»£ç ã€‚ 12345678910111213141516171819202122232425// è¿™é‡Œå°±æ˜¯ç›´æ¥ç”¨æœ‰å‘å›¾æ¥è¿›è¡Œè¡¨ç¤ºã€‚private Digraph buildNFA() &#123; Digraph g = new Digraph(M + 1); // é¡¶ç‚¹æ•°åŠ 1 Stack&lt;Integer&gt; ops = new Stack&lt;Integer&gt;(); for (int i = 0; i &lt; M; i++) &#123; int lp = i; if (re[i] == '(' || re[i] == '|') ops.push(i); else if (re[i] == ')') &#123; int or = ops.pop(); if (re[or] == '|') &#123; lp = ops.pop(); g.addEdge(lp, or + 1); g.addEdge(or + 1, lp); &#125; else lp = or; &#125; if (i &lt; M - 1 &amp;&amp; re[i + 1] == '*') &#123; g.addEdge(lp, i + 1); g.addEdge(i + 1, lp); &#125; if (re[i] == '(' || re[i] == '*' || re[i] == ')') g.addEdge(i, i + 1); &#125; return g;&#125; NFA-simulationé¦–å…ˆæˆ‘ä»¬è¿™æ ·æ¥è¡¨ç¤º NFAï¼šç”¨æ•´æ•° 0 åˆ° Mï¼ˆæ­£åˆ™é•¿åº¦ï¼‰æ¥æ ‡å·çŠ¶æ€ï¼ˆåƒä¸Šå›¾ï¼‰ï¼Œç”¨æ•°ç»„ re æ¥å­˜å‚¨æ­£åˆ™è¡¨è¾¾å¼ï¼Œç”¨æœ‰å‘å›¾æ¥å­˜å‚¨ç©ºè½¬ç§» è‡³äºæ€ä¹ˆæ¨¡æ‹Ÿ NFA è¾“å…¥æ–‡æœ¬è¿è¡Œï¼Œæ„Ÿè§‰ç±»ä¼¼å¹¿æœï¼Œç»´æŠ¤æ¯ä¸€æ­¥æ‰€æœ‰å¯èƒ½èµ°åˆ°çš„çŠ¶æ€ï¼Œä¸‹ä¸€æ­¥å†æ‹“å±•è¿™äº›çŠ¶æ€ï¼Œè¦æ˜¯æ–‡æœ¬æµç»“æŸé‚£æ­¥çš„çŠ¶æ€é‡ŒåŒ…å«æ¥å—çŠ¶æ€ï¼Œå°±è¡¨ç¤ºåŒ¹é…æˆåŠŸã€‚ä¾‹å›¾ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041public class NFA &#123; private char[] re; // match transitions private Digraph G; // epsilon transition digraph private int M; // number of states public NFA(String regexp) &#123; M = regexp.length(); re = regexp.toCharArray(); G = buildEpsilonTransitionDigraph(); &#125; public boolean recognizes(String txt) &#123; // states reachable from start by epsilon transitions Bag&lt;Integer&gt; pc = new Bag&lt;Integer&gt;(); DirectedDFS dfs = new DirectedDFS(G, 0); for (int v = 0; v &lt; G.V(); v++) if (dfs.marked(v)) pc.add(v); for (int i = 0; i &lt; txt.length(); i++) &#123; // states reachable after scanning past txt.charAt(i) Bag&lt;Integer&gt; match = new Bag&lt;Integer&gt;(); for (int v : pc) &#123; if (v == M) continue; // åŒ¹é…æ—¶ç›´æ¥åŠ ä¸Šä¸‹ä¸€ä¸ªçŠ¶æ€ if ((re[v] == txt.charAt(i)) || re[v] == '.') match.add(v + 1); &#125; //æœ€åçš„ç»“æœå°±æ˜¯ match é‡æ–°å¤åˆ¶äº†ä¸€éä¸Šè¿°çš„å…¨éƒ¨ dfs = new DirectedDFS(G, match); // æ‹“å±•ä¸Šä¸€æ­¥çš„æ‰€æœ‰çŠ¶æ€ pc = new Bag&lt;Integer&gt;(); for (int v = 0; v &lt; G.V(); v++) if (dfs.marked(v)) pc.add(v); &#125; // accept if can end in state M for (int v : pc) if (v == M) return true; return false; &#125;&#125; å›¾æ–‡ å¤§éƒ¨åˆ†å€Ÿé‰´ åšå®¢ è‹¥ä¾µæƒï¼Œå¿…åˆ ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>java</tag>
        <tag>æ™®æ—æ–¯é¡¿ç®—æ³•è¯¾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BoggleSolver]]></title>
    <url>%2F2019%2F09%2F28%2FBoggleSolver%2F</url>
    <content type="text"><![CDATA[é¢˜ç›® è§£æè¿™é“é¢˜çš„æ„æ€å°±æ˜¯ ç»™ä½ ä¸€ä¸ªå››ä¹˜ä»¥å››çš„æ–¹å—ï¼Œç„¶åå†è¿™ä¸ªæ–¹å—é‡Œé¢éå†æ‰€æœ‰èƒ½åˆ°çš„ä½ç½®ï¼Œå…«ä¸ªæ–¹å‘ï¼Œæ¯ä¸ªä½ç½®åªèƒ½èµ°ä¸€æ¬¡ï¼Œæ–¹å—ä¸Šé¢å„æœ‰ä¸€ä¸ªå­—æ¯ï¼Œèµ°è¿‡æ¯ä¸€ä¸ªå­—æ¯ä¹‹åæ„æˆä¸€ä¸ªå•è¯ï¼Œç„¶åçœ‹è¿™ä¸ªå•è¯æœ€ååœ¨ä¸åœ¨å­—å…¸ä¸­ï¼Œä¸”èƒ½å¾—åˆ°å¤šå°‘åˆ†ï¼Ÿ æœ€å…ˆå¼€å§‹çš„æƒ³æ³•ï¼Œæ˜¯ç”¨ä¸€ä¸ªbfsï¼Œç„¶åå°†æ¯ä¸€ä¸ªéå†æ¯ä¸€ä¸ªå•è¯ï¼Œç„¶åå†è®²æ¯ä¸€ä¸ªå•è¯æ”¾å…¥åˆ°å…¶ä¸­è¿›è¡Œåˆ¤æ–­ï¼Œè¿™æ ·çš„è¯ï¼Œæ—¶é—´å¤æ‚åº¦ä¼šç‰¹åˆ«é«˜ï¼Œæ²¡ä¸€ä¸ªå•è¯éƒ½è¦éå†å…¨éƒ¨ä½ç½®ï¼Œå¹¶ä¸” ä¸€äº›å•è¯æ²¡æœ‰çš„å‰ç¼€ï¼Œæ¯”å¦‚ï¼Œæ²¡æœ‰Y å¼€å¤´çš„å•è¯çš„è¯ï¼Œé‚£ä¹ˆæˆ‘åœ¨ä»Yè¿™é‡Œå¼€å§‹èµ°çš„è¯ï¼Œä¼šæµªè´¹ç‰¹åˆ«å¤šçš„ç²¾åŠ›ã€‚ æ‰€ä»¥ï¼Œçœ‹äº†ä¸€ä¸‹è§£æï¼Œæ˜¯ç›´æ¥ç”¨å­—å…¸æ ‘å»å­˜å‚¨ï¼Œç„¶åéå†ä½ç½®ï¼Œå°±ç›¸å½“äºéå†å­—å…¸æ ‘ä¸€æ ·ã€‚ æ‰¾æ—¶é—´å¾—é‡æ–°å†™ä¸€ä¸‹ã€‚è‡ªå·±åšçš„å¾ˆä¸å¯¹çš„åœ°æ–¹å°±åœ¨äºï¼Œè‡ªå·±ç”¨çš„bfsï¼Œæ³¨æ„çš„æ˜¯è¿™ä¸ªçŠ¶æ€å¹¶ä¸æ˜¯å¾ªåºæ¸è¿›çš„å˜åŒ–ï¼Œè€Œæ˜¯æ¯ä¸€ä¸ªçŠ¶æ€éƒ½ä¸ä¸€æ ·ï¼Œå¦‚æœè¦ç”¨bfsçš„è¯ï¼Œé‚£ä¹ˆæ¯ä¸€ä¸ªçŠ¶æ€éƒ½è¦å­˜è¿›å»å¤§é‡çš„ä¸œè¥¿é‡ç½®ï¼Œæ‰€ä»¥ï¼Œè¿™å°±æ˜¯ä¸å‡†ç¡®çš„åœ°æ–¹ã€‚ è´´ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146import edu.princeton.cs.algs4.Bag;import java.util.HashSet;import edu.princeton.cs.algs4.Stack;public class BoggleSolver&#123; //è‡ªå·±å»ºç«‹çš„ å­—å…¸æ ‘ï¼Œè¿™æ ·æ–¹ä¾¿åé¢dfsæŸ¥è¯¢çš„æ—¶å€™çš„å‰ªæã€‚ private Node root; private BoggleBoard board; private int col,row; private HashSet&lt;String&gt; allwords; private Bag&lt;Integer&gt;[] adj; private boolean[] vis; private Stack&lt;Integer&gt; dice; private class Node &#123; int val = 0; private Node[] next = new Node[26]; &#125; public BoggleSolver(String[] dictionary) &#123; root = new Node(); for (int i = 0; i &lt; dictionary.length; i++) &#123; put(dictionary[i]); &#125; &#125; private void put(String word) &#123; root = put(root, word, 0); &#125; //è¿™é‡Œå°±æ˜¯ç›´æ¥æ„é€ å‡ºä¸€ä¸ªå­—å…¸æ ‘ï¼Œé€šè¿‡è¿™ä¸ªå­—å…¸æ ‘æ¥å­˜å‚¨æ‰€æœ‰å­—ç¬¦ï¼Œå¹¶ä¸”å‰ªædfsã€‚ private Node put(Node x, String word, int d) &#123; if (x == null) x = new Node(); if (d == word.length()) &#123; x.val = 1; return x; &#125; int c = word.charAt(d) - 'A'; x.next[c] = put(x.next[c], word, d + 1); return x; &#125; private int get(String word) &#123; Node x = get(root, word, 0); if (x == null) return 0; return x.val; &#125; private Node get(Node x, String word, int d) &#123; if (x == null) return null; if (d == word.length()) return x; int c = word.charAt(d) - 'A'; return get(x.next[c], word, d + 1); &#125; private boolean check(int i, int j) &#123; return i &gt;= 0 &amp;&amp; i &lt; row &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; col; &#125; public Iterable&lt;String&gt; getAllValidWords(BoggleBoard board) &#123; this.board = board; allwords = new HashSet&lt;&gt;(); row = board.rows(); col = board.cols(); //è¿™ä¸ªåœ°æ–¹çš„å†™æ³•éœ€è¦æ³¨æ„ä¸€ä¸‹ã€‚ adj = (Bag&lt;Integer&gt;[]) new Bag[row * col]; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; int v = i * col + j; adj[v] = new Bag&lt;Integer&gt;(); //è¿™é‡Œå°±ç›¸å½“äºå›¾è®ºé‡Œé¢çš„å»ºç«‹è¾¹ï¼Œç›´æ¥ç»™åé¢dfsæä¾›æ¡ä»¶ if (check(i - 1, j)) adj[v].add((i - 1) * col + j); if (check(i + 1, j)) adj[v].add((i + 1) * col + j); if (check(i, j - 1)) adj[v].add(i * col + j - 1); if (check(i, j + 1)) adj[v].add(i * col + j + 1); if (check(i + 1, j - 1)) adj[v].add((i + 1) * col + j - 1); if (check(i + 1, j + 1)) adj[v].add((i + 1) * col + j + 1); if (check(i - 1, j - 1)) adj[v].add((i - 1) * col + j - 1); if (check(i - 1, j + 1)) adj[v].add((i - 1) * col + j + 1); &#125; &#125; //æ¥ä¸‹æ¥å°±åˆ°äº† dfsæœå›¾çš„æ—¶å€™ //æœ€å…ˆå¼€å§‹æˆ‘ä¸ªäººçš„æƒ³æ³•æ˜¯åœ¨è¿™ä¸ªåœ°æ–¹ç”¨bfsæ¥è¿›è¡Œï¼Œå½“æ—¶å‘ç°åˆ°åé¢å­˜åœ¨å¾ˆå¤šçš„é—®é¢˜ï¼Œæ¯”å¦‚æ—¶é—´å¤æ‚åº¦æ˜¯ç‰¹åˆ«é«˜çš„ã€‚ for(int i = 0; i &lt; row * col; i++) &#123; vis = new boolean[row * col]; dice = new Stack&lt;Integer&gt;(); vis[i] = true; dice.push(i); //è¿™ä¸ªåœ°æ–¹éœ€è¦ç•™æ„çš„æ˜¯ rootåœ¨è¿™é‡Œå¹¶æ²¡æœ‰å…¶ä»–çš„å«ä¹‰ char c = getLetter(i); if (c == 'Q') dfs(i, root.next['Q' - 'A'].next['U' - 'A'], "QU", dice); else dfs(i, root.next[c - 'A'], c + "", dice); //ç”±äºè¿™ä¸ªåœ°æ–¹å‰é¢å°±ç›´æ¥é‡æ–°å®šä¹‰äº†ï¼Œæ‰€ä»¥å°±ä¸éœ€è¦é‡‡ç”¨æ¸…ç©ºæ“ä½œäº†ã€‚ &#125; return allwords; &#125; private char getLetter(int v) &#123; return board.getLetter(v / col , v % col); &#125; private void dfs(int v, Node x, String prefix, Stack&lt;Integer&gt;dices) &#123; if (prefix.length() &gt; 2 &amp;&amp; x != null &amp;&amp; x.val == 1) &#123; allwords.add(prefix); &#125; for (int w : adj[v]) &#123; char c = getLetter(w); if (!vis[w] &amp;&amp; x != null &amp;&amp; x.next[c - 'A'] != null) &#123; dice.push(w); vis[w] = true; if (c == 'Q') &#123; dfs(w, x.next['Q' - 'A'].next['U' - 'A'], prefix + "QU", dice); &#125; else dfs(w, x.next[c - 'A'], prefix + c, dice); int d = dice.pop(); vis[d] = false; &#125; &#125; &#125; public int scoreOf(String word) &#123; if (get(word) == 0) return 0; else &#123; int len = word.length(); if (len &lt;= 2) return 0; else if(len == 3 || len == 4) return 1; else if (len == 5) return 2; else if (len == 6) return 3; else if (len == 7) return 5; else return 11; &#125; &#125;&#125; å½“ç„¶ï¼Œè¿™æ¬¡çš„ä½œä¸šåé¢è¿˜æœ‰åç»­ï¼Œåç»­çš„åœ°æ–¹å°±æ˜¯ ç›´æ¥æ„æˆä¸€ä¸ªæ¡†æ¶è¿›è¡Œå†™ï¼Œç›´æ¥å°†è¿™ä¸ªæ¸¸æˆå…·è±¡åŒ–ï¼Œç­‰è‡ªå·±ç†Ÿæ‚‰äº†ä¹‹åï¼Œå†å°†ä»£ç è´´å‡ºæ¥ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>java</tag>
        <tag>æ™®æ—æ–¯é¡¿ç®—æ³•å¤§ä½œä¸š</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Substring Search --- kmp]]></title>
    <url>%2F2019%2F09%2F20%2FSubstring-Search-kmp%2F</url>
    <content type="text"><![CDATA[Substring Searchè¿™é‡Œä¸»è¦è®²çš„æ˜¯kmpç®—æ³•ã€‚ java from the course of algorithmIntroductionåœ¨é•¿åº¦ä¸º N çš„æ–‡æœ¬é‡Œå¯»æ‰¾é•¿åº¦ä¸º M çš„æ¨¡å¼ï¼ˆå­ä¸²ï¼‰ï¼Œå…¸å‹æƒ…å†µæ˜¯ N &gt;&gt; Mã€‚ è¿™é‡Œå°±éœ€è¦æ‰©å±•ä¸¤ç§åšæ³•ï¼Œæš´åŠ›ä¸kmpç®—æ³•äº†ã€‚ Brute Forceé¦–å…ˆå…ˆæ¥çœ‹ä¸€ä¸‹æš´åŠ›æŸ¥æ‰¾ã€‚ å°±æš´åŠ›åœ°ä¸¤ä¸ªå¾ªç¯ï¼ŒæŸ¥æ‰¾æ–‡æœ¬çš„æ¯ä¸ªä½ç½®ï¼Œæœ€åæƒ…å†µä¸‹éœ€è¦è¿‘ä¼¼MNæ¬¡å­—ç¬¦æ¯”è¾ƒ 123456789101112public static int search(String pat, String txt) &#123; int M = pat.length(); int N = txt.length(); for (int i = 0; i &lt;= N - M; i++) &#123; int j; for (j = 0; j &lt; M; j++) if (txt.charAt(i + j) != pat.charAt(j)) break; if (j == M) return i; // index in txt where pattern starts return N; // not found &#125;&#125; æš´åŠ›ç®—æ³•å¤§å¤šæ•°æƒ…å†µä¸‹ä¼šè·‘çš„ç‰¹åˆ«æ…¢ï¼Œå› ä¸ºå»ºç«‹åœ¨çº¯æš´åŠ›çš„åšæ³•ï¼Œä¼šå­˜åœ¨å¾ˆå¤šå›é€€çš„æƒ…å†µï¼Œäºæ˜¯å°±ä¼šè·‘çš„å¾ˆæ…¢ã€‚ æ‰€ä»¥æš´åŠ›ç®—æ³•å¹¶ä¸æ˜¯æ€»èƒ½æ»¡è¶³æˆ‘ä»¬çš„éœ€æ±‚ï¼Œæˆ‘ä»¬å¸Œæœ›æœ‰çº¿æ€§æ—¶é—´çº§åˆ«çš„æ€§èƒ½ä¿è¯ï¼Œå¸Œæœ›é¿å…åœ¨æ–‡æœ¬æµä¸­å›é€€ã€‚ Knuth-Morris-PrattKMPç®—æ³•å°±å¯ä»¥è§£å†³ä¸Šé¢æ‰€è¯´çš„é—®é¢˜ï¼Œä¸ç”¨å›é€€ï¼Œæœ€å¤šä¹Ÿå°±è®¿é—®ä¸€æ¬¡å°±å¯ä»¥è§£å†³é—®é¢˜ é¦–å…ˆå…ˆè¦äº†è§£ä¸€ä¸ªåè¯ Deterministic Finite State Automaton ç¡®å®šå‹æœ‰ç©·ï¼ˆçŠ¶æ€ï¼‰è‡ªåŠ¨æœºï¼ˆDFAï¼‰ï¼Œæ˜¯ä¸€ä¸ªæŠ½è±¡çš„å­—ç¬¦ä¸²æŸ¥æ‰¾æœºå™¨ã€‚ çŠ¶æ€æ•°ç›®æ˜¯æœ‰ç©·çš„ï¼ˆåŒ…æ‹¬åˆå§‹çŠ¶æ€å’Œç»ˆç»“çŠ¶æ€ï¼‰ã€‚ æ¯ä¸ªçŠ¶æ€å¯¹æ¯ä¸ªå­—ç¬¦æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªè½¬ç§»ã€‚ è½¬ç§»åˆ°ç»ˆç»“çŠ¶æ€åˆ™æ¥å—è¿™ä¸ªå­—ç¬¦ä¸²ï¼Œå³å«æœ‰æˆ‘ä»¬å¯»æ‰¾çš„å­ä¸²ï¼ˆæ¨¡å¼ï¼‰ã€‚ å…¶ä¸­ dfa[i][j] è¡¨ç¤ºçŠ¶æ€ j é‡åˆ°å­—ç¬¦ i ä¼šè½¬ç§»åˆ°ä¸‹ä¸€ä¸ªçŠ¶æ€ï¼Œå¹¶ä¸åŒ…æ‹¬ç»ˆç»“çŠ¶æ€ã€‚ ç°åœ¨æŸ¥æ‰¾å­ä¸²å°±å¾ˆç®€å•å•¦ï¼Œä¸€å¼€å§‹åœ¨åˆå§‹çŠ¶æ€ï¼Œæ–‡æœ¬æµè¯»åˆ°å“ªä¸ªå­—ç¬¦å°±å¾€å“ªæ¡è·¯èµ°ï¼Œè¦æ˜¯èµ°åˆ°äº†ç»ˆç»“çŠ¶æ€ï¼Œä¹Ÿå°±è¡¨ç¤ºæ‰¾åˆ°äº†å­ä¸²ã€‚åƒæˆ‘ä»¬è¿™æ ·æ„é€ çš„ DFAï¼Œèµ°åˆ°çŠ¶æ€å‡ ï¼Œå°±è¯´æ˜å·²ç»åŒ¹é…äº†å¤šå°‘ä¸ªå­—ç¬¦å…¶å®ï¼Œæ‰€ä»¥èµ°åˆ°ç»ˆç»“çŠ¶æ€å°±è¡¨ç¤ºå…¨éƒ¨åŒ¹é…ã€‚ å°±åƒè¿™æ · 12345678public int seach (String txt) &#123; int i,j,N = txt.length(); for (i = 0, j = 0; i &lt; N &amp;&amp; j &lt; M; i++) j = dfa[txt.chaAt(i)][j]; if (j == M) return i - M; //è¿™ç§æƒ…å†µå°±æ˜¯æ²¡æœ‰æ‰¾åˆ° else return N;&#125; ä»¥ä¸Šçš„åŒ¹é…è¿‡ç¨‹ç‰¹åˆ«è½»æ¾ï¼Œé‡è¦çš„å°±æ˜¯ä¸‹é¢æ„é€ dfaè¿™ä¸ªæ•°ç»„çš„è¿‡ç¨‹ã€‚ Construct DFA åŒ¹é…æƒ…å†µ åŒ¹é…çš„æ—¶å€™è½¬ç§»å°±ç‰¹åˆ«å¥½åŠï¼Œç›´æ¥è¿›è¡Œåˆ°ä¸‹ä¸€ä¸ªçŠ¶æ€å°±å¯ä»¥äº†ã€‚ ä¸åŒ¹é…çš„æƒ…å†µ å…³é”®åœ¨ä¸åŒ¹é…æ—¶è¯¥å¦‚ä½•è½¬ç§»ã€‚ å‡è®¾åœ¨çŠ¶æ€ j æ—¶è¯»åˆ°çš„ä¸‹ä¸€ä¸ªå­—ç¬¦ c ä¸ç­‰äºè¦æ‰¾çš„å­ä¸²çš„ç¬¬ j + 1 ä¸ªå­—ç¬¦ï¼ˆpat.charAt(j)ï¼Œä» 0 æ ‡å·ï¼‰ï¼Œé‚£ä¹ˆè¿™ä¸ªæ—¶å€™ï¼Œæˆ‘ä»¬ä»æ–‡æœ¬æµä¸­æœ€è¿‘è¯»å‡ºçš„ j - 1 ä¸ªå­—ç¬¦å³ä¸º pat[1..j - 1] + cï¼Œå°±æ˜¯æš´åŠ›ç®—æ³•è¦é‡æ–°æ‰«æçš„éƒ¨åˆ†ã€‚ å½“å‰é¦–å­—æ¯åˆ°çŠ¶æ€ j å‡ºç°äº†ä¸åŒ¹é…ï¼ŒæŒ‰æš´åŠ›ç®—æ³•è¯¥ä¸¢å¼ƒå®ƒä»ä¸‹ä¸€ä¸ªå­—æ¯å†å¼€å§‹ï¼Œå³ pat[1]ï¼Œå†ä¸€è·¯é‡æ–°æ‰«æåˆ° cã€‚æ‰€ä»¥ï¼Œç°åœ¨çŠ¶æ€ j é‡åˆ° c è¯¥æ€ä¹ˆè½¬ç§»ï¼Œå®é™…ä¸Šå’Œå­—ç¬¦ä¸² pat[1.. j - 1] + c åœ¨ DFA ä¸­æ‰€åˆ°çŠ¶æ€ç¢°åˆ° c çš„è½¬ç§»ç›®æ ‡ä¸€æ ·æ‰å¯¹ã€‚äºæ˜¯æˆ‘ä»¬è¿™ä¹ˆè®¡ç®— dfa[c][j]ï¼šåœ¨ DFA ä¸Šæ¨¡æ‹Ÿ pat[1.. j - 1]ï¼Œç„¶åç›´æ¥å–å­—ç¬¦ c çš„è½¬ç§»ã€‚ ä¸‹é¢ä¸¾ä¸ªä¾‹å­ è®¡ç®—çŠ¶æ€5çš„æ—¶å€™ å¦‚ä½•å»è€ƒè™‘å­—ç¬¦A å’Œ å­—ç¬¦Bçš„è½¬ç§» å…·ä½“å¯ä»¥çœ‹ä¸‹é¢çš„ä»£ç ï¼Œå› ä¸ºè¿™é‡Œå­˜åœ¨ä¸€ä¸ª restart state ç›´æ¥ç”¨ xæ¥è¡¨ç¤ºï¼Œå› ä¸ºè¿™é‡Œçš„çŠ¶æ€æœ‰çš„æ—¶å€™å¯ä»¥ç›´æ¥è½¬ç§»åˆå§‹çŠ¶æ€ 1234567891011121314public KMP (String pat) &#123; this.pat = pat; M = pat.length(); dfa = new int [R][M]; //è®¾ç½®åˆå§‹çŠ¶æ€ //è¿™é‡Œçš„ç‰ˆæœ¬å°±æ˜¯æ„é€ æœ‰é™ç±»å‹çš„è‡ªåŠ¨æœºï¼Œå¸®åŠ©è®°å½•çŠ¶æ€è¿ç§» dfa[pat.chaAt(0)][0] = 1; for (int x = 0, j = 1; j &lt; M; j++) &#123; for (int c = 0; c &lt; R; c++) dfa[c][j] = dfa[c][x]; dfa[pat.charAt(j)][j] = j + 1; x = dfa[pat.charAt(j)][x]; &#125;&#125; ä¸è¿‡è¿™ä¸ªç®—æ³•çš„å¤æ‚åº¦ ä¼˜åŒ–ä¹‹å ä¹Ÿè¾¾åˆ°äº† (o(M) + o(N)) * å­—æ¯è¡¨ äºæ˜¯ C++ ç‰ˆæœ¬é‡Œé¢ä¼šå†æ¬¡è¿›è¡Œä¼˜åŒ– æ³¨ï¼š è¿™é‡Œè¿˜æœ‰ä¸¤å¼ ç®—æ³•Boyer-Moore ä¸ Rabin-Karp è¿™ä¸ªåšå®¢ä¸­æœ‰è¯¦ç»†çš„è®²è§£ï¼Œå°±ä¸å†é‡å¤è®°å½•äº†ã€‚ C++ from some template in acmå½“ä¸Šé¢çš„æœ‰é™å‹è‡ªåŠ¨æœºä¼˜åŒ–çš„ç‰ˆæœ¬ï¼Œæœ€åå¯¼è‡´çš„ç»“æœå°±æ˜¯ æ¯ä¸€éƒ½å¾—éå†ä¸€éå­—æ¯è¡¨ æ‰€ä»¥æœ‰æ²¡æœ‰å…¶ä»–åŠæ³•æ¥è¿›è¡Œä¼˜åŒ–å‘¢ æ‰€ä»¥å°±æœ‰äº† æ”¹è¿›çš„kmpç®—æ³•åˆ©ç”¨ æ¨¡å¼ä¸²ä¸­çš„ æœ€é•¿å‰ç¼€ä¸æœ€é•¿åç¼€çš„å…³ç³»æ¥æ„é€ nextæ•°ç»„ å°±åƒè¿™ä¸ªæ ·å­ äºæ˜¯è¿™é‡Œå°±å…ˆè®²è§£ä¸€ä¸‹ æ„é€ nextæ•°ç»„çš„è¿‡ç¨‹æˆ‘ä»¬è§„å®šä»»ä½•ä¸€ä¸ªä¸²ï¼Œnext[1]=0ã€‚(ä¸ç”¨next[0]ï¼Œä¸ä¸²çš„æ‰€æœ‰å¯¹åº”)ï¼Œä»æ˜¯ä¸€å¼ åŠ¨å›¾æå®šé—®é¢˜ï¼š é€šè¿‡æŠŠnextå€¼â€œçœ‹â€å‡ºæ¥ï¼Œæˆ‘ä»¬å†æ¥åˆ†ænextå€¼ï¼Œè¿™å°±å¾ˆå®¹æ˜“å¾—åˆ°è¶…çº§æœ‰åçš„å…¬å¼äº†ï¼Œè¿™ä¸ªå¼å­å¯¹åé¢çš„ç®—æ³•ç†è§£å¾ˆé‡è¦ï¼æ‰€ä»¥å…ˆè¦çœ‹æ‡‚è¿™ä¸ªå¼å­ï¼Œå¦‚æœä¸Šé¢çš„å†…å®¹é€šä¸‹æ¥äº†ï¼Œè¿™ä¸ªåº”è¯¥å¾ˆå®¹æ˜“çœ‹æ‡‚äº†ï¼š é¦–å…ˆæ˜¯æ„é€ nextæ•°ç»„çš„è¿‡ç¨‹ã€‚ ä»£ç å¦‚ä¸‹ï¼š12345678910111213int getNext(string p) &#123; int lenp = p.size(); next[0] = -1; int j = -1; int i = 0; while (i &lt; lenp - 1) &#123; if (j == -1 || p[j] == p[i]) &#123; next[++i] = ++j; &#125; else j = next[j]; &#125;&#125; å½“ç„¶ è¿™æ ·å†™nextæ•°ç»„æ˜¯å®Œå…¨æ²¡æœ‰é—®é¢˜ï¼Œä½†æ˜¯ å¦‚æœæœ‰ä¸€ç§æƒ…å†µp[next[j]] == p[j] å½“å‡ºç°è¿™æ ·çš„æƒ…å†µè¯¥å¦‚ä½•è§£å†³å‘¢ï¼Ÿç›´æ¥çœ‹å›¾ã€‚ æ¯”å¦‚ï¼Œå¦‚æœç”¨ä¹‹å‰çš„next æ•°ç»„æ–¹æ³•æ±‚æ¨¡å¼ä¸²â€œababâ€çš„next æ•°ç»„ï¼Œå¯å¾—å…¶next æ•°ç»„ä¸º-1 0 0 1ï¼ˆ0 0 1 2æ•´ä½“å³ç§»ä¸€ä½ï¼Œåˆå€¼èµ‹ä¸º-1ï¼‰ï¼Œå½“å®ƒè·Ÿä¸‹å›¾ä¸­çš„æ–‡æœ¬ä¸²å»åŒ¹é…çš„æ—¶å€™ï¼Œå‘ç°bè·Ÿcå¤±é…ï¼Œäºæ˜¯æ¨¡å¼ä¸²å³ç§»j - next[j] = 3 - 1 =2ä½ã€‚ å³ç§»2ä½åï¼Œbåˆè·Ÿcå¤±é…ã€‚äº‹å®ä¸Šï¼Œå› ä¸ºåœ¨ä¸Šä¸€æ­¥çš„åŒ¹é…ä¸­ï¼Œå·²ç»å¾—çŸ¥p[3] = bï¼Œä¸s[3] = cå¤±é…ï¼Œè€Œå³ç§»ä¸¤ä½ä¹‹åï¼Œè®©p[ next[3] ] = p[1] = b å†è·Ÿs[3]åŒ¹é…æ—¶ï¼Œå¿…ç„¶å¤±é…ã€‚é—®é¢˜å‡ºåœ¨å“ªå‘¢ï¼Ÿ é—®é¢˜å‡ºåœ¨ä¸è¯¥å‡ºç°p[j] = p[ next[j] ]ã€‚ä¸ºä»€ä¹ˆå‘¢ï¼Ÿç†ç”±æ˜¯ï¼šå½“p[j] != s[i] æ—¶ï¼Œä¸‹æ¬¡åŒ¹é…å¿…ç„¶æ˜¯p[ next [j]] è·Ÿs[i]åŒ¹é…ï¼Œå¦‚æœp[j] = p[ next[j] ]ï¼Œå¿…ç„¶å¯¼è‡´åä¸€æ­¥åŒ¹é…å¤±è´¥ï¼ˆå› ä¸ºp[j]å·²ç»è·Ÿs[i]å¤±é…ï¼Œç„¶åä½ è¿˜ç”¨è·Ÿp[j]ç­‰åŒçš„å€¼p[next[j]]å»è·Ÿs[i]åŒ¹é…ï¼Œå¾ˆæ˜¾ç„¶ï¼Œå¿…ç„¶å¤±é…ï¼‰ï¼Œæ‰€ä»¥ä¸èƒ½å…è®¸p[j] = p[ next[j ]]ã€‚å¦‚æœå‡ºç°äº†p[j] = p[ next[j] ]å’‹åŠå‘¢ï¼Ÿå¦‚æœå‡ºç°äº†ï¼Œåˆ™éœ€è¦å†æ¬¡é€’å½’ï¼Œå³ä»¤next[j] = next[ next[j] ]ã€‚ æ‰€ä»¥å°±éœ€è¦æ›´æ”¹ä¸€ä¸‹ ä¸‹é¢çš„ä»£ç  12345678910111213141516171819int getNext(string p) &#123; int lenp = p.size(); next[0] = -1; int j = -1; int i = 0; while (i &lt; lenp - 1) &#123; if (j == -1 || p[j] == p[i]) &#123; //é‡ç‚¹å°±åœ¨ä¸‹é¢è¿™ä¸ªåœ°æ–¹ i++; j++; if (p[i] != p[j]) next[i] = j; //è¿™ä¸ªåœ°æ–¹å°±æ”¾å…¥å…¶ç»§ç»­è¿›å…¥é€’å½’ã€‚ else next[i] = next[j]; &#125; else j = next[j]; &#125;&#125; åé¢å°±åªå‰©ä¸‹ä¸€å¼€å§‹åŒ¹é…è¿‡ç¨‹äº†ã€‚ 1234567891011121314int kmp (string s,string p) &#123; int i = 0,j = 0; int slen = s.size(); int plen = p.size(); while (i &lt; slen &amp;&amp; j &lt; plen) &#123; if (j == -1 || s[i] = p[j]) &#123; i ++ ; j ++ ; &#125; else j = next[j]; &#125; if (j == plen) return i - j; else return -1;&#125; åé¢è¿˜æœ‰ä¸¤ç§æ‹“å±•ç±»å‹çš„ç®—æ³•BMç®—æ³• ä¸ sundayç®—æ³•è¿™ä¸¤ç§ç®—æ³• æœ‰æ—¶é—´çš„æƒ…å†µä¸‹å†æ¥æ€»ç»“ è¿™é‡Œç›´æ¥è´´å‡ºç½‘å€åšå®¢]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>java</tag>
        <tag>å­—ç¬¦ä¸²</tag>
        <tag>kmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tries --- the course of algorithm]]></title>
    <url>%2F2019%2F09%2F17%2FTries-the-course-of-algorithm%2F</url>
    <content type="text"><![CDATA[å•è¯æŸ¥æ‰¾æ ‘(å­—å…¸æ ‘)é¦–å…ˆå…ˆè´´å‡º è¦å®ç°çš„api: R-way Triesè¿™é‡Œå®ç°çš„è¦ç‚¹å°±æ˜¯åœ¨æ¯ä¸€ä¸ªnodeç±»é‡Œé¢åŠ å…¥ä¸€ä¸ªæ•°ç»„å»è®°å½•æ¯ä¸€ä¸ªå­—ç¬¦å¯èƒ½å­˜åœ¨çš„node æ„æ€å°±æ˜¯ 256ä¸ª ç®—ä¸Šæ‰€æœ‰ASCIIé‡Œé¢çš„ è¿™é‡Œå°±ä¸è´´å‡ºå…·ä½“å‡½æ•°è¡¨ç¤ºåŠŸèƒ½çš„ç¤ºæ„å›¾äº†ã€‚ Tries: Java implementaion1234567891011121314151617181920212223242526272829303132333435363738394041public class TriesST&lt;Value&gt; &#123; private static final int R = 256; private Node root = new Node(); private static class Node &#123; private Object value; private Node[] next = new Node[R]; &#125; public void put (String key, Value val) &#123; root = put(root, key, val, 0); &#125; private Node put(Node x, String key, Value val, int d) &#123; if (x == null) x = new Node(); if (d == key.length()) &#123; x.val = val; return x; &#125; char c = key.charAt(d); x.next[c] = put(x.next[c], key, val, d + 1); return x; &#125; public boolean contains (String key) &#123; return get(key) != null; &#125; public Value get(String key) &#123; Node x = get(root, key, 0); if (x == null) return null; return (Value)x.val; &#125; private Node get(Node x, String key, int d) &#123; if (x == null) return null; if (d == key.length()) return x; char c = key.charAt(d); return get(x.next[c], key, d + 1); &#125;&#125; æ€»çš„æ¥è¯´ï¼Œä¸Šé¢è¿™ä¸ªç®—æ³•å¯ä»¥å¾ˆå¿«åŒ¹é…åˆ°å­—ç¬¦ä¸²ï¼Œä½†æ˜¯ç‰¹åˆ«éƒèŠ¬ç©ºé—´ï¼Œå› ä¸ºå…¶æœ‰å¾ˆå¤šè¯¯ç”¨çš„ç©ºèŠ‚ç‚¹ï¼Œå¹¶ä¸”ç©ºé“¾æ¥ä¹Ÿå¤ªå¤šäº†ã€‚ Tries: deletionåˆ é™¤å•è¯æŸ¥æ‰¾æ ‘ä¸­çš„æŸä¸ªå­—ç¬¦ä¸²æ—¶ï¼Œé¦–å…ˆè¦æ‰¾åˆ°å®ƒï¼Œç„¶åæŠŠæœ€åä¸€ä¸ªèŠ‚ç‚¹çš„å€¼ç½®ç©ºï¼Œå†é€’å½’åˆ é™¤æ²¡æœ‰éç©ºé“¾æ¥çš„ç©ºå€¼èŠ‚ç‚¹ã€‚ä¾‹å­ï¼š è¿™é‡Œæ²¡æœ‰ä¾‹å­ï¼Œå°±ç›´æ¥ç»™å‡ºç›¸åº”çš„å›¾äº†ã€‚ Ternary Search Triesè¿™é‡Œæœ‰ç‚¹å€Ÿé‰´å¿«æ’çš„æ€æƒ³ï¼Œå°†æ¯ä¸€ä¸ªèŠ‚ç‚¹åˆ†æˆä¸‰ä¸ªé“¾æ¥ï¼Œå¤§äºï¼Œå°äºï¼Œç­‰äºä¸‰å‘å•è¯æŸ¥æ‰¾æ ‘ï¼Œå¦‚å›¾ï¼š è¿™é‡Œä¹Ÿä¸å†è¯¦ç»†è®²è§£å…¶æ’å…¥ï¼Œæ„é€ ï¼Œåˆ é™¤çš„è¿‡ç¨‹äº†ï¼Œç±»ä¼¼äºå‰é¢ã€‚ TST: Java implementation123456789101112131415161718192021222324252627282930313233343536373839404142434445public class TST&lt;Value&gt; &#123; private Node root; private class Node &#123; private Value val; private char c; private Node left, mid, right; &#125; public void put(String key, Value val) &#123; root = put(root, key, val, 0); &#125; private Node put(Node x, String key, Value val, int d) &#123; char c = key.charAt(d); if (x == null) &#123; x = new Node(); x.c = c; &#125; if (c &lt; x.c) x.left = put(x.left, key, val, d); else if (c &gt; x.c) x.right = put(x.right, key, val, d); else if (d &lt; key.length() - 1) x.mid = put(x.mid, key, val, d + 1); else x.val = val; return x; &#125; public boolean contains(String key) &#123; return get(key) != null; &#125; public Value get(String key) &#123; Node x = get(root, key, 0); if (x == null) return null; return x.val; &#125; private Node get(Node x, String key, int d) &#123; if (x == null) return null; char c = key.charAt(d); if (c &lt; x.c) return get(x.left, key, d); else if (c &gt; x.c) return get(x.right, key, d); else if (d &lt; key.length() - 1) return get(x.mid, key, d + 1); else return x; &#125;&#125; TSTçš„å¤æ‚åº¦å…¶å®æœ‰ç‚¹æ—¶å€™æ˜¯å’Œçº¢é»‘æ˜¯ç›¸å½“ï¼ŒæŸ¥æ‰¾çš„æ•ˆç‡æœ‰çš„æ—¶å€™æ˜¯è·Ÿå“ˆå¸Œçš„ç¬¦å·è¡¨ä¹Ÿå·®ä¸å¤šï¼Œæ‰€ä»¥å¯èƒ½é€šè¿‡ç›¸åº”çš„å¹³è¡¡æ“ä½œæ¥ä¿æŒå…¶çš„æ€§èƒ½ã€‚ ä¸è¿‡æœ‰çš„æ—¶å€™è¿˜å¯ä»¥å°†å…¶ä¸R-way tries ç»“åˆèµ·æ¥ ä¸Šé¢è™½ç„¶ç©ºé—´ä¸Šé¢ä¼šå¤šèŠ±ä¸€ç‚¹ï¼Œä½†æ˜¯æŸ¥æ‰¾æ€§èƒ½ä¼šå¤§å¤§æå‡ã€‚ Character-based OperationsKeys è¿”å›å…¶çš„æ‰€æœ‰çš„å­˜å‚¨çš„å­—ç¬¦ä¸² å°±åƒä¸­åºéå†è¿™æ£µæ ‘ 123456789101112131415public Iterable&lt;String&gt; keys() &#123; Queue&lt;String&gt; queue = new Queue&lt;String&gt;(); collect(root, "", queue); return queue;&#125;// prefix: sequence of characters on path from root to xprivate void collect(Node x, String prefix, Queue&lt;String&gt; q) &#123; if (x == null) return; //åªæœ‰åœ¨æ»¡è¶³äº†è¿™ä¸ªæ¡ä»¶æ‰ä¼šå…¥é˜Ÿã€‚ if (x. val != null) q.enqueue(prefix); for (char c = 0; c &lt; R; c++) collect(x.next[c], prefix + c, q);&#125; Prefix 12345678public Iterable&lt;String&gt; keyWithPrefix(String prefix) &#123; Queue&lt;String&gt; queue = new Queue&lt;String&gt;(); // x: root of subtrie for all strings // beginning with given prefix Node x = get(root, prefix, 0); collect(x, prefix, queue); return queue;&#125; Longest Prefix 123456789101112public String longestPrefixOf(String query) &#123; int length = search(root, query, 0, 0); return query.substring(0, length);&#125;private int search(Node x, String query, int d, int length) &#123; if (x == null) return length; if (x.val != null) length = d; if ( d == query.length()) return length; char c = query.charAt(d); return search(x.next[c], query, d + 1, length);&#125; åé¢ç»§ç»­æåˆ°äº† å‰ç¼€æ ‘ä¸åç¼€æ ‘ã€‚ å‚è€ƒè¯¥åšå®¢ ä¾µåˆ ]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>java</tag>
        <tag>å­—ç¬¦ä¸²</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Radix Sort --- the course of algorithm]]></title>
    <url>%2F2019%2F09%2F17%2FRadix-Sort-the-course-of-algorithm%2F</url>
    <content type="text"><![CDATA[åŸºæ•°æ’åºè¯¾ç¨‹åœ°å€ String in javaChar Data TypeC è¯­è¨€ä¸­çš„å­—ç¬¦æ•°æ®ç±»å‹å ä¸€ä¸ªå­—èŠ‚ï¼ˆ8 æ¯”ç‰¹ï¼‰ï¼Œæœ€å¤šåªèƒ½è¡¨ç¤º 256 ä¸ªå­—ç¬¦ã€‚æ”¯æŒ 7 ä½çš„æ ‡å‡† ASCII(American Standard Code for Information Interchangeï¼Œç¾å›½æ ‡å‡†ä¿¡æ¯äº¤æ¢ç¼–ç )ï¼Œæœ€é«˜ä½ç”¨äºå¥‡å¶æ ¡éªŒã€‚æˆ–æ˜¯æ‹“å±•çš„ ASCIIï¼Œæœ€é«˜ä½ç”¨æ¥ç¡®å®šé™„åŠ çš„ 128 ä¸ªç‰¹æ®Šçš„å­—ç¬¦ã€‚ è€Œjavaä¸­çš„å­—ç¬¦æ•°æ®ç±»å‹å ä¸¤ä¸ªå­—èŠ‚ï¼Œæ”¯æŒ16ä½çš„Unicodeç¼–ç ã€‚ String Data Typejava String api æ¥ä¸‹æ¥å°±æ˜¯javaä¸­ä¸¤ç§å­—ç¬¦ä¸²ç±»å‹çš„æ¯”è¾ƒï¼Œä¸€ç§æ˜¯Stringï¼Œå¦å¤–ä¸€ç§å°±æ˜¯StringBuilder è¿™ä¸¤ç§ä¹‹é—´çš„åŒºåˆ«å°±åœ¨äº ä¸€ä¸ªæ˜¯å†…éƒ¨å¯å˜ï¼Œå¦å¤–ä¸€ç§å°±æ˜¯å†…éƒ¨ä¸å¯å˜ã€‚ ç„¶è€Œ è¿˜æœ‰ä¸€ç§StringBuffer è¿™ç§ä¸å‰é¢åè€…çš„ç›¸æ¯”å°±æ˜¯çº¿ç¨‹å®‰å…¨ä¸å¦çš„åŒºåˆ«äº†ã€‚ Key-indexed countingå› ä¸ºä¸€èˆ¬å­—ç¬¦ä¸²ä¸­åŸºäºæ’åºçš„æ¯”è¾ƒ åŸºæœ¬ä¸Šè‡³å°‘éƒ½æ˜¯éœ€è¦NlgNçš„æ¯”è¾ƒï¼Œç„¶åæœ‰ä¸€ç§åŸºæ•°æ¯”è¾ƒçš„åŠæ³•è¯ç”Ÿï¼Œç§°ä½œé”®ç´¢å¼•è®¡æ•°æ¯”è¾ƒæ³• è®¾æƒ³æœ‰ä¸ªæ•°ç»„ a = {d, a, c, f, f, b, d, b, f, b, e, a} è¦æ’åºï¼ŒçŸ¥é“æ€»å…±æœ‰ 6 ä¸ªä¸åŒçš„å­—æ¯ï¼Œè¦å…ˆç»Ÿè®¡å®ƒä»¬å‡ºç°çš„é¢‘æ•°ã€‚ å­—æ¯ a çš„é”®ä¸º 0 ï¼ˆa[i] - â€˜aâ€™ï¼‰ï¼Œå‡ºç°çš„æ¬¡æ•°åœ¨ count æ•°ç»„ä¸­çš„ç´¢å¼•ä¸ºé”®å€¼åŠ ä¸€ã€‚ java implements 123456789101112131415int R = 6;int N = a.length;int[] count = new int[R + 1];for (int i = 0; i &lt; N; i++) count[a[i] - 'a' + 1]++;//éå†ä¸€écountæ•°ç»„for (int i = 0; i &lt; R; i++) count[i + 1] += count[i];//ç°åœ¨ count æ•°ç»„ä¸­ä¿å­˜çš„å³å¯¹åº”å­—æ¯åœ¨æ’å¥½åºçš„æ•°ç»„ä¸­å¼€å§‹çš„ç´¢å¼•å€¼ï¼Œåƒä¸¤ä¸ª d åº”è¯¥æ”¾åœ¨ a[6] å’Œ a[7]ã€‚char[] aux = new char[N];for (int i = 0; i &lt; N; i++) aux[count[a[i] - 'a']++] = a[i]; è¾…åŠ©æ•°ç»„ aux å€ŸåŠ© count æ•°ç»„æ‰¾åˆ°äº†æ¯ä¸ª a[i] çš„ä½ç½®ã€‚æ³¨æ„ count æ•°ç»„åœ¨è¿™ä¸€æ­¥ä¸­è¿˜ä¼šæ”¹å˜ï¼Œæ¯æ¬¡è¦åŠ ä¸€ï¼Œä¸‹æ¬¡ç›¸åŒçš„ a[i] å°±ä¼šæ”¾åœ¨ä¸‹ä¸€ä¸ªä½ç½®ã€‚æ‰€ä»¥è¿™ä¸ªç®—æ³•ä¹Ÿæ˜¯ç¨³å®šçš„ï¼ˆstableï¼‰ï¼Œç›¸åŒå…ƒç´ é—´çš„ç›¸å¯¹é¡ºåºä¸ä¼šæ”¹å˜ã€‚ æœ€åæŠŠ aux æ•°ç»„ä¸€ä¸ªä¸ªèµ‹å€¼å›åŸæ•°ç»„ï¼Œå³å®Œæˆäº†æ’åºã€‚ é”®ç´¢å¼•è®¡æ•°æ³•æ’åºåªéœ€è¦å‡ ä¸ªä¸€é‡å¾ªç¯ï¼Œä¸éœ€è¦æ¯”è¾ƒï¼Œåªè¦ R åœ¨ N çš„ä¸€ä¸ªå¸¸æ•°å› å­èŒƒå›´å†…ï¼Œå®ƒå°±æ˜¯ä¸€ä¸ªçº¿æ€§æ—¶é—´çº§åˆ«çš„æ’åºæ–¹æ³•ã€‚ LSD Radix Sortä½ä½ä¼˜å…ˆæ’åºï¼Œå°±æ˜¯å°†ç­‰é•¿çš„å­—ç¬¦ä¸²è¿›è¡Œæ’åºï¼Œå¿…é¡»æ˜¯ç­‰é•¿çš„å­—ç¬¦ä¸²è¿›è¡Œæ’åºï¼Œéœ€è¦åšçš„æ˜¯ä»å³å‘å·¦è¿›è¡Œæ’åº è¿™ä¸ªæ’åºæ˜¯ç¨³å®šçš„ï¼Œç›¸åŒé”®ä¹‹é—´çš„ç›¸å¯¹é¡ºåºæ˜¯ä¸ä¼šæ”¹å˜çš„ï¼Œæ„æ€å°±æ˜¯åœ¨iå‰é¢çš„ï¼Œåœ¨i + 1æ’å®Œå­—åï¼Œä¾ç„¶è¿˜æ˜¯åœ¨iå‰é¢ï¼Œå¦‚æœæ˜¯ç›¸åŒé”®çš„æƒ…å†µä¸‹ã€‚ LSD: Java Implementation123456789101112131415161718192021public class LSD &#123; public static void sort(String []a,int w) &#123; int R = 256; int N = a.length; String[] aux = new String[N]; //ä»åå¾€å‰é¢ä¾æ¬¡è¿›è¡Œæ’åº for (int d = w - 1; d &gt;= 0; d--) &#123; int[] count = new int [R + 1]; for (int i = 0; i &lt; N; i++) count[a[i].charAt(d) + 1] ++; for (int r = 0; r &lt; R; r++) count[r + 1] += count[r]; for (int i = 0; i &lt; N; i++) aux[count[a[i].charAt(d)]++] = a[i]; for (int i = 0; i &lt; N; i++) a[i] = aux[i]; &#125; &#125;&#125; å¯¹äºå…¸å‹çš„åº”ç”¨,R(åŸºæ•°)è¿œå°äºN(æ€»æ•°),å¯¹å®šé•¿(W)çš„å­—ç¬¦ä¸²æ’åºçš„æ—¶é—´æ˜¯MNçº§åˆ«ã€‚ MSD Radix Sorté«˜ä½æ’åºï¼Œæœ‰åˆ«äºä½ä½æ’åºçš„æ˜¯ï¼Œå…¶å¯ä»¥å¯¹ä¸ç­‰é•¿çš„å­—ç¬¦ä¸²è¿›è¡Œæ’åºï¼Œä»å·¦å‘å³è¿›è¡Œä¸€ä½ä¸€ä½çš„æ‰«æï¼Œç„¶åå†é€’å½’çš„å¯¹å­å­—ç¬¦ä¸²è¿›è¡ŒåŸºæ•°æ’åºã€‚ å°±åƒè¿™æ ·ï¼š å› ä¸ºæ¶‰åŠåˆ°é€’å½’ï¼Œæ‰€ä»¥å¿…é¡»å¾—è®¾ç½®ä¸€ä¸‹é€’å½’å‡ºå£ï¼Œç”¨ä¸€ä¸‹å‡½æ•°ç›´æ¥è®¾ç½®é€’å½’å‡ºå£ 1234private static int charAt(String s, int d) &#123; if (d &lt; s.length) return s.charAt(d); else return -1;&#125; MSD: Java Implementationç”±äºä¸Šé¢å¤šäº†ä¸€ä¸ªé”®ï¼Œæ‰€ä»¥ç°åœ¨countçš„æ•°ç»„å¤§å°å¿…é¡»æ˜¯R + 2 12345678910111213141516171819202122232425262728293031323334public static void sort(String[] a) &#123; aux = new String[a.length]; sort(a, aux, 0, a.length - 1, 0);&#125;private static void sort(String[] a, String[] aux, int lo, int hi, int d) &#123; if (hi &lt;= lo) return; int[] count = new int[R + 2]; for (int i = lo; i &lt;= hi; i++) count[charAt(a[i], d) + 2]++; for (int r = 0; r &lt; R + 1; r++) count[r + 1] += count[r]; for (int i = lo; i &lt;= h; i++) aux[count[charAt(a[i], d) + 1]++] = a[i]; for (int i = lo; i &lt;= hi; i++) a[i] = aux[i -lo]; // sort R subarrays recursively for (int r = 0; r &lt; R; r++) sort(a, aux, lo + count[r], lo + count[r + 1] - 1, d + 1);&#125;//å¦å¤–ç”¨äºè¾…åŠ©çš„æ•°ç»„auxå¯ä»¥é‡å¤ä½¿ç”¨ï¼Œä½†æ˜¯æ¯ä¸€æ¬¡éƒ½éœ€è¦æ–°çš„countæ•°ç»„ï¼Œä¸ä»…è€—è´¹ç©ºé—´ï¼Œè¿˜éœ€è¦æ—¶é—´å»åˆå§‹åŒ–ï¼Œæ‰€ä»¥å¯¹äºå°å‹çš„å­æ•°ç»„ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨æ’å…¥æ’åºç›´æ¥è¿›è¡Œæ”¹å–„public static void sort(String[] a, int lo, int hi, int d) &#123; for (int i = lo; i &lt;= hi; i++) for (int j = i; j &gt; lo &amp;&amp; less(a[j], a[j - 1], d); j--) exch(a, j, j -1);&#125;private static boolean less(String v, String w, int d) &#123; return v.substring(d).compareTo(w.substring(d)) &lt; 0;&#125; MSDç®—æ³•çš„æ€§èƒ½å–å†³äºè¦è¾“å…¥çš„æ•°æ®ï¼Œæœ€åçš„æƒ…å†µä¸‹éœ€è¦æ£€æŸ¥çš„æ‰€æœ‰çš„å­—ç¬¦ï¼Œå’ŒLSDä¸€æ ·éƒ½æ˜¯çº¿æ€§çš„æ—¶é—´çº§åˆ«ã€‚ 3-way Radix Quicksortä¸‰ç›¸åˆ‡åˆ†çš„æ€æƒ³å…¶å®å¾ˆç®€å•ï¼ŒåŸºäºMSDçš„æ€æƒ³ï¼ŒåŠ å…¥äº†å¿«æ’ï¼Œå°†ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²çš„é¦–å­—æ¯ï¼Œè¿›è¡Œåˆ‡åˆ†ï¼Œåˆ†æˆå¤§äºï¼Œå°äºï¼Œç­‰äºè¯¥å­—æ¯çš„ç»„åˆï¼Œç„¶åå†åˆ†åˆ«è¿›å…¥åˆ°å­å­—ç¬¦ä¸²ä¸­è¿›è¡Œé€’å½’ä½¿ç”¨ã€‚ 3-way String Quicksort: Java Implementation12345678910111213141516171819202122private static void sort(String[] a) &#123; sort(a, 0, a.length - 1, 0);&#125;private static void sort(String []a, int lo, int hi, int d) &#123; if (lo &gt;= hi) return; int lt = lo, gt = hi; int v = charAt(a[lo], d); int i = lo + 1; while (i &lt;= gt) &#123; int t = charAt(a[i], d); if (t &lt; v) exch(a, lt++, i++); else if (t &gt; v) exch(a,i,gt--); else i++; &#125; //è¿™é‡Œæ˜¯å†æ¬¡æ¯”è¾ƒå‰é¢çš„æ•°ç»„è¿›è¡Œä¸‰ç›¸åˆ‡åˆ†ã€‚ sort(a, lo, lt - 1, d); //è¿™é‡Œçš„æ„æ€ç¬¬ä¸€ä¸ªå­—æ¯æ˜¯ç›¸åŒçš„ï¼Œæ‰€ä»¥å¯ä»¥å¼€å§‹é€’å½’ç¬¬äºŒä¸ªå­—æ¯äº† if (v &gt;= 0) sort(a, lt, gt, d + 1); sort(a, gt + 1, hi, d);&#125; Suffix Arrayså­—ç¬¦ä¸²åç¼€æ•°ç»„ æœ‰å¾ˆå¤šåº”ç”¨ï¼Œæ¯”å¦‚å…³é”®è¯æŸ¥æ‰¾ï¼Œæœ€é•¿é‡å¤å­å­—ç¬¦ç­‰ç­‰ã€‚ 1234567public static String[] suffixes(String s) &#123; int N = s.length(); String[] suffixes = new String[N]; for (int i = 0; i &lt; N; i++) suffixes[i] = s.substring(i, N); return suffixes;&#125; å¯¹äºåç¼€æ•°ç»„è¿›è¡Œæ’åºï¼Œå°±å¯ä»¥æŠŠç›¸åŒçš„å­—ç¬¦ä¸²ç»™å®‰æ’åˆ°ä¸€èµ·äº†ï¼Œè¿™æ ·çš„è¯æŸ¥æ‰¾å…³é”®è¯ä¹Ÿå°±å¿«äº†å¾ˆå¤šã€‚ å°±åƒè¿™æ ·ï¼Œæœ€é•¿é‡å¤å­å­—ç¬¦ä¸²ä¹Ÿå·®ä¸å¤š LRS: Java Implementation12345678910111213141516171819public String lrs(String s) &#123; int N = s.length(); String[] suffixes = new String[N]; for (int i = 0; i &lt; N; i++) suffixes[i] =s.substring(i, N); Arrays.sort(suffixes); String lrs = ""; for (int i = 0; i &lt; N - 1; i++) &#123; // compute longest common prefix // between adjacent suffixes insorted order int len = lcp(suffixes[i], suffixes[i + 1]); if (len &gt; lrs.length()) lrs = suffixes[i].substring(0, len); &#125; return lrs;&#125; ä¸è¿‡æœ€åçš„æƒ…å†µ,åº”è¯¥ä¼šè¾¾åˆ° n$^{2}$ã€‚å› ä¸ºè¾“å…¥å­—ç¬¦ä¸²é‡å¤æ—¶ï¼Œéœ€è¦å¾ˆå¤šæ¬¡æ¯”è¾ƒæ‰èƒ½å®Œæˆæ’åºï¼Œæ‰€ä»¥è¿™é‡Œä»‹ç»äº†å¦å¤–ä¸€ç§ç®—æ³• Manber-Myer MSD ç®—æ³• æœ‰å…´è¶£çš„è¯ å¯ä»¥è‡ªå·±å»æŸ¥ä¸€æŸ¥ è¿™é‡Œå°±ä¸åœ¨å¤šè¯´äº†ã€‚ æœ¬ç¯‡æ–‡ç« å€Ÿé‰´è¯¥åšå®¢ è‹¥ä¾µåˆ ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>java</tag>
        <tag>å­—ç¬¦ä¸²</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BaseballElimination]]></title>
    <url>%2F2019%2F09%2F14%2FBaseballElimination%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥é¢˜ç›® è§£æé¢˜ç›®æ„æ€ç»™ä½ næ”¯é˜Ÿä¼ï¼Œç„¶åæ¯ä¸€ä¸ªé˜Ÿä¼æœ‰ä¸‰ä¸ªå‚æ•°ï¼Œèµ¢å¾—æ¯”èµ›ï¼Œè¾“çš„æ¯”èµ›ï¼Œä»¥åŠè¿˜æœ‰å¤šå°‘åœºæ¯”èµ›æ²¡æ‰“ï¼Œç„¶åå†ç»™ä¸€ä¸ªæ‰€æœ‰å‰©ä½™æ¯”èµ›çš„ç¤ºæ„å›¾ï¼Œæ¥è¡¨ç¤ºå‰©ä½™æ¯”èµ›è°ä¸è°å»æ‰“ã€‚è·èƒœæ¡ä»¶æ˜¯ åªæœ‰ä¸€æ”¯é˜Ÿä¼èƒœåˆ©ï¼Œå…¶ä½™çš„å…¨éƒ¨ç›´æ¥è¢«æ·˜æ±°ã€‚ ç°åœ¨éœ€è¦åšçš„æ˜¯è¯„ä¼°å…¶ä¸­çš„ä¸€æ”¯é˜Ÿä¼æ˜¯å¦è¢«æ·˜æ±°ã€‚ æ·˜æ±°æ–¹å¼æœ‰ä¸¤ç§ ç¬¬ä¸€ç§ï¼Œè¯„ä¼°é˜Ÿä¼çš„æœ€å¤§è·èƒœæ•°ï¼Œï¼ˆç®—ä¸Šå…¶è¿˜æ²¡æœ‰æ‰“çš„æ¯”èµ›å…¨éƒ¨èµ¢ï¼‰ï¼Œè¿˜æ˜¯æ²¡æœ‰æŸäº›é˜Ÿä¼å·²ç»è·å–çš„èƒœåˆ©æ¯”èµ›æ•°å¤šï¼Œé‚£ä¹ˆåˆ™å¯ä»¥è¯´è¿™ä¸ªé˜Ÿä¼å·²ç»è¢«æ·˜æ±°äº†ã€‚ ç¬¬äºŒç§ï¼Œéœ€è¦å»ºç«‹ä¸€ä¸ªæœ€å¤§æµçš„å›¾ï¼Œç„¶åé€šè¿‡æœ€å¤§æµçš„å›¾ï¼Œæ¥åˆ¤æ–­æ˜¯å¦å·²ç»åœ¨æ•°å­¦ä¸Šè¢«æ·˜æ±°äº†ã€‚ æœ€å¤§æµçš„å»ºç«‹æ–¹æ³•è¿™é‡Œä¸€å…±éœ€è¦å»ºç«‹ 2 + n - 1 + $C_{2}^{n - 1}\textrm{}$ ä¸ªèŠ‚ï¼Œåˆ†åˆ«æ˜¯æºç‚¹ä¸æ±‡ç‚¹ï¼ŒåŠ ä¸Šé˜Ÿä¼èŠ‚ç‚¹ä¸æ¯”èµ›èŠ‚ç‚¹ï¼Œå°±åƒä¸‹é¢è¿™ä¸€å¼ å›¾ å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œè¯„åˆ¤æ–¹å¼ï¼Œå¦‚æœä»Sç‚¹å‡ºå‘çš„è¾¹é‡Œ æµé‡éƒ½ç­‰äºå®¹é‡çš„è¯ï¼Œé‚£ä¹ˆ æ­¤æ—¶çš„flow ä¸€å®šç­‰åŒäº æœ€å¤§æµï¼Œ è¯´æ˜å…¶ä»–é˜Ÿä¼ç”¨äº†ä¹ç‰›äºŒè™ä¹‹åŠ›æ‰€åšåˆ°çš„æœ€å¥½çš„ç»“æœä¹Ÿå°±æ˜¯ä¸è¯„ä¼°é˜Ÿä¼æ‰“æˆå¹³æ‰‹ã€‚ è€Œå¦‚æœflowå¤§äºæœ€å¤§æµï¼Œåˆ™è¯´æ˜ï¼Œæœ‰ä¸€äº›ä»så‡ºå‘çš„è¾¹å¹¶æ²¡æœ‰è¾¾åˆ°å®¹é‡ï¼Œ å†è¿˜æœ‰æ¯”èµ›æ²¡æœ‰æ‰“å®Œçš„æ—¶å€™ï¼Œå°±å·²ç»æœ‰é˜Ÿä¼åˆ†æ•°è·Ÿè¯„ä¼°é˜Ÿä¼çš„åˆ†æ•°ä¸€æ ·äº†ï¼Œåˆ™è¯´æ˜è¯„ä¼°é˜Ÿä¼å·²ç»è¢«æ·˜æ±°äº†ã€‚ ä»£ç å¦‚ä¸‹123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185package Programming_Assignment_8;import edu.princeton.cs.algs4.FlowEdge;import edu.princeton.cs.algs4.FlowNetwork;import edu.princeton.cs.algs4.FordFulkerson;import edu.princeton.cs.algs4.In;import java.util.HashMap;import java.util.HashSet;import java.util.Map;public class BaseballElimination &#123; private int flows; private final int[] win; private final int[] lose; private final int[] left; private final int[][] remain; private String[] teams; private final int teamnum; private HashMap&lt;Integer,Integer&gt;pos; private final HashMap&lt;String, Integer&gt; map; private HashSet&lt;String&gt; set; private int allv; private int gameTeams; public BaseballElimination(String filename) &#123; if (filename == null) throw new IllegalArgumentException("Wrong file name..."); In in = new In(filename); teamnum = Integer.parseInt(in.readLine()); teams = new String[teamnum]; map = new HashMap&lt;String, Integer&gt;(); win = new int[teamnum]; lose = new int [teamnum]; left = new int[teamnum]; remain = new int[teamnum][teamnum]; int tot = 0; while (in.hasNextLine()) &#123; String readline = in.readLine().trim(); String []token = readline.split(" +"); map.put(token[0], tot); teams[tot] = token[0]; win[tot] = Integer.parseInt(token[1]); lose[tot] = Integer.parseInt(token[2]); left[tot] = Integer.parseInt(token[3]); for (int i = 0; i &lt; teamnum; i++) &#123; if (i == tot) remain[tot][i] = 0; else remain[tot][i] = Integer.parseInt(token[4 + i]); &#125; tot++; &#125; &#125; public int numberOfTeams() &#123; return teamnum; &#125; public Iterable&lt;String&gt; teams() &#123; return map.keySet(); &#125; public int wins(String team) &#123; valid(team); Integer id = map.get(team); return win[id]; &#125; public int losses(String team) &#123; valid(team); Integer id = map.get(team); return lose[id]; &#125; public int remaining(String team) &#123; valid(team); Integer id = map.get(team); return left[id]; &#125; public int against(String team1, String team2) &#123; valid(team1); valid(team2); Integer id1 = map.get(team1); Integer id2 = map.get(team2); return remain[id1][id2]; &#125; private FlowNetwork buildFlowNetwrok(String team) &#123; valid(team); Integer id = map.get(team); int most = win[id] + left[id]; gameTeams = (teamnum - 1) * (teamnum - 2) / 2; allv = gameTeams + teamnum - 1 + 2; flows = 0; pos = new HashMap&lt;&gt;(); int s = 0, t = allv - 1; int gameIndex = 1; //æ¯”èµ›ç»“ç‚¹ int indexi = gameTeams;// çƒé˜ŸèŠ‚ç‚¹ int indexj = indexi; double max = Double.POSITIVE_INFINITY; FlowNetwork flowNetwork = new FlowNetwork(allv); for (int i = 0; i &lt; teamnum; i++) &#123; if (id == i) continue; indexi++; indexj = indexi; if(win[i] &gt; most) return null; for (int j = i + 1; j &lt; teamnum; j++) &#123; if (j == id) continue; indexj++; flows += remain[i][j]; flowNetwork.addEdge(new FlowEdge(s,gameIndex,remain[i][j])); flowNetwork.addEdge(new FlowEdge(gameIndex,indexi,max)); flowNetwork.addEdge(new FlowEdge(gameIndex,indexj,max)); gameIndex++; &#125; pos.put(indexi,i); flowNetwork.addEdge(new FlowEdge(indexi,t,most - win[i])); &#125; return flowNetwork; &#125; private void valid(String team) &#123; if (team == null) throw new IllegalArgumentException("Wrong teams"); if (!map.containsKey(team)) throw new IllegalArgumentException("Not in the team"); &#125; public boolean isEliminated(String team) &#123; valid(team); FlowNetwork flowNetwork = buildFlowNetwrok(team); int id = map.get(team); if (flowNetwork == null) &#123; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; teamnum; i++) &#123; if (id == i) continue; if (win[id] + left[id] &lt; win[i]) &#123; set.add(teams[i]); &#125; &#125; return true; &#125; FordFulkerson fordFulkerson = new FordFulkerson(flowNetwork,0,allv - 1); if (flows &gt; fordFulkerson.value()) &#123; set = new HashSet&lt;&gt;(); for (int i = gameTeams + 1; i &lt; allv - 1 ;i++) &#123; //å…¶å®è¿™ä¸ªåœ°æ–¹æ˜¯ä¸€ç›´å¼„ä¸æ¸…æ¥šè¿™ä¸ªå‡½æ•°ï¼Œä¸»è¦æ˜¯å¼„ä¸æ¸… ä¸ºä»€ä¹ˆè¿™ä¸ªç‚¹åœ¨æœ€å°å‰²ä¸Šé¢ å°±å¯ä»¥è¯æ˜å‡º æ¥è‡ªsç‚¹çš„è¾¹ æµé‡ä¸ç­‰äºå®¹é‡ //æŸ¥é˜…äº†ç›¸å…³èµ„æ–™ï¼Œæœ€åå‘ç°ï¼Œå…¶å® è¿™é‡Œincut å°±ç›¸å½“äºå‰²è¾¹ç›´æ¥å°†æ•´å¼ å›¾ä¸€åˆ†ä¸º2ï¼Œè¿™é‡Œæ˜¯é è¿‘æºç‚¹sçš„ //æ¢è¨€ä¹‹ï¼Œå°±æ˜¯åœ¨è·‘å®Œæœ€åä¸€éå¯»æ‰¾å¢å¹¿è·¯çš„æ—¶å€™ï¼Œæ˜¯å¦ä¼šæœ‰åœ¨å…¶å‰©ä½™çš„è·¯å¾„ä¸Šï¼Œæ„æ€å°±æ˜¯ å½“æˆ‘æŸ¥çœ‹é˜Ÿä¼çš„ç‚¹çš„æ—¶å€™ï¼Œåªè¦æ²¡æœ‰å‰©ä½™çš„æµé‡ï¼Œå°±ä¸€å®šä¸ä¼šéå†åˆ°è¿™ä¸ªç‚¹ä¸Š if (fordFulkerson.inCut(i)) &#123; int Id = pos.get(i); set.add(teams[Id]); &#125; &#125; return true; &#125; return false; &#125; public Iterable&lt;String&gt; certificateOfElimination(String team) &#123; valid(team); if (isEliminated(team)) return set; return null; &#125;&#125; æ³¨æ„ä¸Šé¢æ‰€è¯´çš„ä½ç½®ï¼Œincut è¿™é‡Œå°±æ˜¯æ ‡è®°æ˜¯å¦æœ‰ä½ç½®è¿˜æœ‰å‰©ä½™ï¼Œå½“æœ€åä¸€æ¬¡åœ¨æ‰¾å¢å¹¿è·¯çš„æ—¶å€™ï¼Œé‚£ä¹ˆè¿™äº›ä½ç½®å°±æ˜¯æ²¡æœ‰æ»¡çš„ä½ç½® æ€»ç»“è§‰å¾—è¿™æ¬¡å¤§ä½œä¸šåšçš„ç‰¹åˆ«è¯¡å¼‚ï¼Œä¸»è¦æ˜¯é¢˜ç›®å¥½äº†å¥½ä¹…æ—¶é—´æ‰ç†è§£å…¶çœŸæ­£çš„æ„æ€ï¼Œè¿˜æœ‰å¯èƒ½æ˜¯å¯¹äºæœ€å¤§æµçš„æ¦‚å¿µç†è§£çš„è¿˜æ˜¯ä¸å¤Ÿé€å½»ï¼Œè¿™å°±æ˜¯æˆ‘ä¸ªäººçš„é—®é¢˜ï¼Œæ¥ä¸‹æ¥æ‰€éœ€è¦åšçš„å°±æ˜¯ ä¸‹ä¸€æ¬¡çš„å¤§ä½œä¸šï¼Œä»¥åŠå¥½å¥½ç†è§£ä¸€ä¸‹ æœ€å¤§æµ æœ€å°å‰²å®šç†ä¹‹é—´çš„å˜åŒ–ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>java</tag>
        <tag>æ™®æ—æ–¯é¡¿ç®—æ³•è¯¾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SeamCarver]]></title>
    <url>%2F2019%2F09%2F10%2FSeamCarver%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é¢˜ç›®é“¾æ¥ é¢˜ç›®è¯¦å›¾ è§£æè¿™é“é¢˜æ˜¯æˆ‘è¿™å‡ æ¬¡åšè¿™ä¸ªjavaå¤§ä½œä¸šé‡Œé¢ï¼Œè¿˜ç‰¹åˆ«æœ‰æ„æ€çš„ä¸€æ¬¡ä½œä¸šï¼Œä¸»è¦æ˜¯è¿™æ¬¡ä»‹ç»çš„è¿™ä¸ªç®—æ³•ç‰¹åˆ«æµå¼Šï¼Œæ„Ÿè§‰ç‰¹åˆ«å¸¸è§ï¼Œå°±æ˜¯å‘ç°äº2007å¹´çš„ç®—æ³•ï¼Œå¹¶ä¸”åº”ç”¨äº Photoshopå†…æ ¸çš„ç®—æ³•ï¼Œç”¨äºå›¾ç‰‡çš„æ‹‰ä¼¸ä¸ç¼©æ”¾ã€‚ å…ˆå¼€å§‹æ˜¯ä½œä¸ºæœ€çŸ­è·¯é‡Œé¢çš„ç®—æ³•å‡ºç°ï¼Œæ„Ÿè§‰ç‰¹åˆ«çš„æ‡µé€¼ï¼Œå› ä¸ºå®Œå…¨ä¸çŸ¥é“è¯¥æ€ä¹ˆä¸‹æ‰‹ï¼Œä¸è¿‡åé¢å°±å¥½å¾ˆå¤šäº†ï¼Œæ„æ€å°±æ˜¯ä½¿ç”¨ä¸€ä¸ªç‰¹å®šçš„å…¬å¼ï¼Œå°†æ¯ä¸€ä¸ªåƒç´ ç‚¹ä¸å‘¨å›´8ä¸ªæ–¹å‘çš„ç‚¹çš„å·®å¼‚ç›¸è”ç³»ï¼Œä½œä¸ºæ•´ä¸ªåƒç´ ç‚¹çš„æƒå€¼ï¼Œç„¶åä»ä¸åŒäºæ‹‰ä¼¸çš„æ–¹å‘ï¼Œä»é¡¶éƒ¨åˆ°åº•éƒ¨æ‰¾ä¸€æ¡åƒç´ ç‚¹æƒå€¼æœ€å°çš„è·¯çº¿ï¼Œç„¶åå°†è¿™æ¡è·¯çº¿è¿›è¡Œåˆ é™¤ï¼Œæœ€åä¾¿å¾—åˆ°ç»“æœã€‚ ç„¶åæ‰¾æœ€çŸ­è·¯çš„åŠæ³•ï¼Œè¿™é‡Œä½¿ç”¨çš„å°±æ˜¯ å¯¹æ¯ä¸€ä¸ªç‚¹ï¼Œè‡³ä¸Šè€Œä¸‹çš„æ¾å¼›ï¼Œæœ€ç»ˆå¾—åˆ°ç»“æœï¼Œè¿™æ¬¡ä½œä¸šåªæ˜¯çœ‹ç€æœ‰ç‚¹å“äººï¼Œä½†æ˜¯å…¶å®è¿˜æ˜¯ç‰¹åˆ«ç®€å•çš„ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223import edu.princeton.cs.algs4.Picture;public class SeamCarver &#123; //è¿™é‡Œå›¾åƒä¼šå‘ç”Ÿæ”¹å˜ï¼Œæ‰€ä»¥è¿™é‡Œä¸èƒ½ç›´æ¥å†™å®šä¹‰æˆä¸å˜é‡ private int width; private int height; private int [][] picture; private double [][] energy; // create a seam carver object based on the given picture public SeamCarver(Picture picture) &#123; if (picture == null) throw new IllegalArgumentException(); this.height = picture.height(); this.width = picture.width(); this.picture = new int [width][height]; for (int i = 0; i &lt; this.width; i++) &#123; for (int j = 0; j &lt; this.height; j++) &#123; this.picture[i][j] = picture.getRGB(i, j); &#125; &#125; renewenergy(); &#125; private void validateindex(int col, int row) &#123; if (row &lt; 0 || row &gt;= height || col &lt; 0 || col &gt;= width) &#123; throw new IllegalArgumentException("Wrong index"); &#125; return; &#125; private void renewenergy() &#123; energy = new double[width][height]; for (int i = 0; i &lt; width; i++) &#123; for (int j = 0; j &lt; height; j++) &#123; calculatenergy(i, j); &#125; &#125; &#125; private void calculatenergy(int x, int y) &#123; validateindex(x, y); if (x == 0 || y == 0 || x == width - 1 || y == height - 1) &#123; energy[x][y] = 1000.0; return; &#125; int rgbUp = picture[x][y - 1]; int rgbDown = picture[x][y + 1]; int rgbLeft = picture[x - 1][y]; int rgbRight = picture[x + 1][y]; double rx = Math.pow(((rgbLeft &gt;&gt; 16) &amp; 0xFF) - ((rgbRight &gt;&gt; 16) &amp; 0xFF), 2); double gx = Math.pow(((rgbLeft &gt;&gt; 8) &amp; 0xFF) - ((rgbRight &gt;&gt; 8) &amp; 0xFF), 2); double bx = Math.pow(((rgbLeft &gt;&gt; 0) &amp; 0xFF) - ((rgbRight &gt;&gt; 0) &amp; 0xFF), 2); double ry = Math.pow(((rgbUp &gt;&gt; 16) &amp; 0xFF) - ((rgbDown &gt;&gt; 16) &amp; 0xFF), 2); double gy = Math.pow(((rgbUp &gt;&gt; 8) &amp; 0xFF) - ((rgbDown &gt;&gt; 8) &amp; 0xFF), 2); double by = Math.pow(((rgbUp &gt;&gt; 0) &amp; 0xFF) - ((rgbDown &gt;&gt; 0) &amp; 0xFF), 2); energy[x][y] = Math.sqrt(rx + gx + bx + ry + gy + by); return; &#125; public Picture picture() &#123; Picture tmp = new Picture(width, height); for (int i = 0; i &lt; width; i++) &#123; for (int j = 0; j &lt; height; j++) &#123; tmp.setRGB(i, j, picture[i][j]); &#125; &#125; return tmp; &#125; public int width() &#123; return width; &#125; public int height() &#123; return height; &#125; public double energy(int x, int y) &#123; validateindex(x, y); return energy[x][y]; &#125; private void transform() &#123; int temp = height; height = width; width = temp; double [][] en = new double[width][height]; int [][] p = new int[width][height]; for (int i = 0; i &lt; width; i++) &#123; for (int j = 0; j &lt; height; j++) &#123; en[i][j] = energy[j][i]; p[i][j] = picture[j][i]; &#125; &#125; energy = en; picture = p; &#125; public int[] findHorizontalSeam() &#123; transform(); int [] res = findVerticalSeam(); transform(); return res; &#125; private void relaxVertical(double[][] disTo, int[][]edgeTo, int x, int y) &#123; validateindex(x, y); if (disTo[x][y + 1] &gt; disTo[x][y] + energy[x][y + 1]) &#123; disTo[x][y + 1] = disTo[x][y] + energy[x][y + 1]; edgeTo[x][y + 1] = x; &#125; if (x &gt; 0 &amp;&amp; disTo[x - 1][y + 1] &gt; disTo[x][y] + energy[x - 1][y + 1]) &#123; disTo[x - 1][y + 1] = disTo[x][y] + energy[x - 1][y + 1]; edgeTo[x - 1][y + 1] = x; &#125; if (x &lt; width - 1 &amp;&amp; disTo[x + 1][y + 1] &gt; disTo[x][y] + energy[x + 1][y + 1]) &#123; disTo[x + 1][y + 1] = disTo[x][y] + energy[x + 1][y + 1]; edgeTo[x + 1][y + 1] = x; &#125; &#125; public int[] findVerticalSeam() &#123; int [] seam = new int[height]; double [][] disTo = new double [width][height]; int [][] edgeTo = new int [width][height]; for (int i = 0; i &lt; width; i++) &#123; for (int j = 0; j &lt; height; j++) &#123; if (j == 0) disTo[i][j] = energy[i][j]; else disTo[i][j] = Double.POSITIVE_INFINITY; &#125; &#125; //è¿™é‡Œçš„é¡ºåºé”™äº†ï¼Œå› ä¸º è¿™é‡Œæ¯”è¾ƒç‰¹æ®Šçš„æ˜¯çŸ©é˜µçš„å­˜æ³•ï¼Œæ‰€ä»¥å¿…é¡»å°†å¾ªç¯ç¿»è¿‡æ¥è¿›è¡Œå­˜å– for (int j = 0; j &lt; height - 1; j++) &#123; for (int i = 0; i &lt; width; i++) &#123; relaxVertical(disTo, edgeTo, i, j); &#125; &#125; double min = Double.POSITIVE_INFINITY; int index = -1; for (int i = 0; i &lt; width; i++) &#123; if (min &gt; disTo[i][height - 1]) &#123; min = disTo[i][height - 1]; index = i; &#125; &#125; seam[height - 1] = index; for (int i = height - 2; i &gt;= 0; i--) &#123; index = edgeTo[index][i + 1]; seam[i] = index; &#125; return seam; &#125; // remove horizontal seam from current picture public void removeHorizontalSeam(int[] seam) &#123; transform(); removeVerticalSeam(seam); transform(); &#125; private void check(int[] seam) &#123; if (width &lt;= 1 || seam == null || seam.length != height) &#123; throw new IllegalArgumentException(); &#125; for (int i = 0; i &lt; height; i++) &#123; if (seam[i] &lt; 0 || seam[i] &gt; width - 1) &#123; throw new IllegalArgumentException(); &#125; if (i &gt; 0 &amp;&amp; Math.abs(seam[i - 1] - seam[i]) &gt; 1) &#123; throw new IllegalArgumentException(); &#125; &#125; &#125; // remove vertical seam from current picture public void removeVerticalSeam(int[] seam) &#123; check(seam); int min = Integer.MAX_VALUE; int max = 0; for (int i = 0; i &lt; height; i++) &#123; if (seam[i] &gt; max) max = seam[i]; if (seam[i] &lt; min) min = seam[i]; //è¿™ä¸ªåœ°æ–¹å¯ä»¥ç›´æ¥è¯¥ä½ç½®ä¸Šå°†æ¯ä¸€ä¸ªä½ç½®çš„å…ƒç´ è¿›è¡Œå˜åŒ– for (int j = seam[i]; j &lt; width - 1; j++) &#123; picture[j][i] = picture[j + 1][i]; &#125; &#125; width = width - 1; if (min &gt; 0) min--; if (max &gt; width - 1) max = width - 1; for (int j = 0; j &lt; height; j++) &#123; for (int i = min; i &lt;= max; i++) &#123; calculatenergy(i, j); &#125; for (int i = max + 1; i &lt; width - 1; i++) &#123; energy[i][j] = energy[i + 1][j]; &#125; &#125; &#125;&#125; ä¸è¿‡è¿™é‡Œéœ€è¦è‡ªå·±é‡æ¸©ä¸€ä¸‹ ä¸Šä¸€å‘¨çš„ä½œä¸š å°±æ˜¯å›¾çš„apiè¿™äº›éƒ¨åˆ†ï¼Œæœ‰çš„åªæ˜¯ä¼šç”¨c++è·‘ï¼Œç”¨Javaæ€»æ˜¯æ„Ÿè§‰æœ‰ç‚¹åŠ›ä¸ä»å¿ƒï¼Œå¸Œæœ›åé¢å°½å¿«ç†Ÿæ‚‰èµ·æ¥ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>java</tag>
        <tag>æ™®æ—æ–¯é¡¿ç®—æ³•å¤§ä½œä¸š</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WordNet]]></title>
    <url>%2F2019%2F09%2F10%2FWordNet%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ é¢˜ç›® æˆ‘ä¸ªäººè§‰å¾—è¿™ä¸€æ¬¡å¤§ä½œä¸šå¾—é‡æ–°åšä¸€éï¼Œå› ä¸ºå¯¹äºè¿™æ¬¡çš„å¤§ä½œä¸šæœ‰ä¸€äº›åœ°æ–¹ï¼Œæ€»è¿˜æ˜¯å¼„ä¸æ¸…æ¥šï¼Œæœ€å…³é”®çš„å°±æ˜¯è¿™æ¬¡çš„å›¾é‡Œé¢æœ‰ä¸€äº›apiéœ€è¦èŠ±æ—¶é—´å»å¼„æ¸…æ¥š æ‰€ä»¥è¿™é‡Œå°±ä¸è´´è®²è§£äº†ï¼Œæ—¶é—´è¿‡å»å¤ªä¹…äº†ï¼Œåè€Œè‡ªå·±ä¹Ÿæå¿˜äº†ï¼Œæ‰€ä»¥è¿™é‡Œç›´æ¥è´´å‡ºä»£ç  ä»£ç SAP.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174package Programming_Assignment_6;import edu.princeton.cs.algs4.Digraph;import java.util.LinkedList;import java.util.Queue;import java.util.Stack;public class SAP &#123; private int length; private int ancestor; private final Digraph copyG; private int[] distTo1; private int[] distTo2; private boolean[] marked1; private boolean[] marked2; private final Stack&lt;Integer&gt; stack1; private final Stack&lt;Integer&gt; stack2; // constructor takes a digraph (not necessarily a DAG) public SAP(Digraph G) &#123; if (G == null) throw new IllegalArgumentException("argument to G"); copyG = new Digraph(G); distTo1 = new int [G.V()]; distTo2 = new int [G.V()]; marked1 = new boolean[G.V()]; marked2 = new boolean[G.V()]; stack1 = new Stack&lt;&gt;(); stack2 = new Stack&lt;&gt;(); &#125; private void checkVertex(int x) &#123; int v = marked1.length; if (x &lt; 0 || x &gt;= v) throw new IllegalArgumentException(); &#125; private void checkVertices(Iterable&lt;Integer&gt; x) &#123; if (x == null) throw new IllegalArgumentException(); int v = marked1.length; for (Integer vv :x) &#123; if (vv == null) throw new IllegalArgumentException(); if (vv &lt; 0 || vv &gt;= v) throw new IllegalArgumentException(); &#125; &#125; private void init() &#123; while (!stack1.isEmpty()) &#123; int v = stack1.pop(); marked1[v] = false; &#125; while (!stack2.isEmpty()) &#123; int v = stack2.pop(); marked2[v] = false; &#125; &#125; // length of shortest ancestral path between v and w; -1 if no such path public int length(int v, int w) &#123; checkVertex(v); checkVertex(w); compute(v, w); return length; &#125; private void compute(int v, int w) &#123; length = -1; ancestor = -1; distTo1[v] = 0; distTo2[w] = 0; marked1[v] = true; marked2[w] = true; stack1.push(v); stack2.push(w); Queue&lt;Integer&gt; q1 = new LinkedList&lt;&gt;(); Queue&lt;Integer&gt; q2 = new LinkedList&lt;&gt;(); q1.add(v); q2.add(w); bfs(q1, q2); &#125; private void compute(Iterable&lt;Integer&gt; v, Iterable&lt;Integer&gt; w) &#123; length = -1; ancestor = -1; Queue&lt;Integer&gt; q1 = new LinkedList&lt;&gt;(); Queue&lt;Integer&gt; q2 = new LinkedList&lt;&gt;(); for (int x :v) &#123; marked1[x] = true; stack1.push(x); distTo1[x] = 0; q1.add(x); &#125; for (int x: w) &#123; marked2[x] = true; stack2.push(x); distTo2[x] = 0; q2.add(x); &#125; bfs(q1, q2); &#125; private void bfs(Queue&lt;Integer&gt; q1, Queue&lt;Integer&gt; q2) &#123; while (!q1.isEmpty() || !q2.isEmpty()) &#123; if (!q1.isEmpty()) &#123; int v = q1.remove(); if (marked2[v]) &#123; if (distTo1[v] + distTo2[v] &lt; length || length == -1) &#123; ancestor = v; length = distTo1[v] + distTo2[v]; &#125; &#125; if (distTo1[v] &lt; length || length == -1) &#123; for (int w: copyG.adj(v)) &#123; if (!marked1[w]) &#123; distTo1[w] = distTo1[v] + 1; marked1[w] = true; stack1.push(w); q1.add(w); &#125; &#125; &#125; &#125; if (!q2.isEmpty()) &#123; int v = q2.remove(); if (marked1[v]) &#123; if (distTo1[v] + distTo2[v] &lt; length || length == -1) &#123; ancestor = v; length = distTo1[v] + distTo2[v]; &#125; &#125; if (distTo2[v] &lt; length || length == -1) &#123; for (int w:copyG.adj(v)) &#123; if (!marked2[w]) &#123; distTo2[w] = distTo2[v] + 1; marked2[w] = true; stack2.push(w); q2.add(w); &#125; &#125; &#125; &#125; &#125; init(); &#125; // a common ancestor of v and w that participates in a shortest ancestral path; -1 if no such path public int ancestor(int v, int w) &#123; checkVertex(v); checkVertex(w); compute(v, w); return ancestor; &#125; // length of shortest ancestral path between any vertex in v and any vertex in w; -1 if no such path public int length(Iterable&lt;Integer&gt; v, Iterable&lt;Integer&gt; w) &#123; checkVertices(v); checkVertices(w); compute(v, w); return length; &#125; // a common ancestor that participates in shortest ancestral path; -1 if no such path public int ancestor(Iterable&lt;Integer&gt; v, Iterable&lt;Integer&gt; w) &#123; checkVertices(v); checkVertices(w); compute(v, w); return ancestor; &#125;&#125; Wordnet.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147package Programming_Assignment_6;import edu.princeton.cs.algs4.Digraph;import edu.princeton.cs.algs4.In;import edu.princeton.cs.algs4.Topological;import java.util.Map;import java.util.TreeMap;import java.util.TreeSet;public class WordNet &#123; private Map&lt;String, TreeSet&lt;Integer&gt; &gt; synSets; private Map&lt;Integer, String&gt; ssynsets; private Digraph hyperNyms; private int idSum; private int outSum; private SAP sap; // constructor takes the name of the two input files public WordNet(String synsets, String hypernyms) &#123; if (synsets == null || hypernyms == null) &#123; throw new IllegalArgumentException("arguments to WordNet() is null"); &#125; readsynset(synsets); readhypernyms(hypernyms); &#125; private void readsynset(String synsets) &#123; synSets = new TreeMap&lt;String, TreeSet&lt;Integer&gt; &gt;(); this.ssynsets = new TreeMap&lt;Integer, String&gt;(); In synset = new In(synsets); idSum = 0; while (synset.hasNextLine()) &#123; idSum++; String str = synset.readLine(); String[] field = str.split(","); int id = Integer.parseInt(field[0]); this.ssynsets.put(id, field[1]); String[] nons = field[1].split(" "); for (String tmp : nons) &#123; if (synSets.containsKey(tmp)) &#123; if (synSets.containsKey(tmp)) &#123; synSets.get(tmp).add(id); &#125; &#125; else &#123; TreeSet&lt;Integer&gt; ids = new TreeSet&lt;&gt;(); ids.add(id); synSets.put(tmp, ids); &#125; &#125; &#125; &#125; private void readhypernyms(String hypernyms) &#123; hyperNyms = new Digraph(idSum); In hypernym = new In(hypernyms); boolean[] outToal = new boolean[idSum]; while (hypernym.hasNextLine()) &#123; String str = hypernym.readLine(); String[] field = str.split(","); int v = Integer.parseInt(field[0]); for (int i = 1; i &lt; field.length; i++) &#123; int w = Integer.parseInt(field[i]); hyperNyms.addEdge(v, w); &#125; if (!outToal[v] &amp;&amp; field.length &gt; 1) &#123; outSum++; &#125; outToal[v] = true; &#125; isRootRAG(); sap = new SAP(hyperNyms); &#125; private void isRootRAG() &#123; if (idSum - outSum != 1) &#123; throw new IllegalArgumentException("more than one root"); &#125; Topological TO = new Topological(hyperNyms); if (!TO.hasOrder()) &#123; throw new IllegalArgumentException("is not a Root RAG"); &#125; &#125; // returns all WordNet nouns public Iterable&lt;String&gt; nouns() &#123; return synSets.keySet(); &#125; // is the word a WordNet noun? public boolean isNoun(String word) &#123; if (word == null) throw new IllegalArgumentException("word is null"); return synSets.containsKey(word); &#125; public int distance(String nounA, String nounB) &#123; if (nounA == null || nounB == null) &#123; throw new IllegalArgumentException("nounA or nounB is null"); &#125; if (!isNoun(nounA) || !isNoun(nounB)) &#123; throw new IllegalArgumentException("the two noun is not exist"); &#125; TreeSet&lt;Integer&gt; setA = synSets.get(nounA); TreeSet&lt;Integer&gt; setB = synSets.get(nounB); if (setA.size() == 1 &amp;&amp; setB.size() == 1) &#123; return sap.length(setA.last(), setB.last()); &#125; else return sap.length(setA, setB); &#125; // a synset (second field of synsets.txt) that is the common ancestor of nounA and nounB // in a shortest ancestral path (defined below) public String sap(String nounA, String nounB) &#123; if (nounA == null || nounB == null) &#123; throw new IllegalArgumentException(); &#125; if (!isNoun(nounA) || !isNoun(nounB)) &#123; throw new IllegalArgumentException(); &#125; TreeSet&lt;Integer&gt; setA = synSets.get(nounA); TreeSet&lt;Integer&gt; setB = synSets.get(nounB); int ID; if (setA.size() == 1 &amp;&amp; setB.size() == 1) &#123; ID = sap.ancestor(setA.last(), setB.last()); &#125; else ID = sap.ancestor(setA, setB); return ssynsets.get(ID); &#125;&#125; Outcast.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445package Programming_Assignment_6;import edu.princeton.cs.algs4.In;import edu.princeton.cs.algs4.StdOut;public class Outcast &#123; private final WordNet wordnet; public Outcast(WordNet wordnet) &#123; if (wordnet == null) throw new IllegalArgumentException("wrong wordnet"); this.wordnet = wordnet; &#125; public String outcast(String[] nouns) &#123; if (nouns == null) throw new IllegalArgumentException("this nouns is null"); int Maxn = 0; int index = -1; for (int i = 0; i &lt; nouns.length; i++) &#123; int sum = 0; for (int j = 0; j &lt; nouns.length; j++) &#123; if (i == j) continue; int tmp = wordnet.distance(nouns[i], nouns[j]); if (tmp == -1) continue; sum += tmp; &#125; if (sum &gt; Maxn) &#123; Maxn = sum; index = i; &#125; &#125; if (index == -1) throw new IllegalArgumentException("error"); return nouns[index]; &#125; public static void main(String[] args) &#123; WordNet wordnet = new WordNet(args[0], args[1]); Outcast outcast = new Outcast(wordnet); for (int t = 2; t &lt; args.length; t++) &#123; In in = new In(args[t]); String[] nouns = in.readAllStrings(); StdOut.println(args[t] + ": " + outcast.outcast(nouns)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>java</tag>
        <tag>æ™®æ—æ–¯é¡¿ç®—æ³•è¯¾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PATç”²çº§é¢˜ç›®è§£æåŠè€ƒè¯•æ€»ç»“]]></title>
    <url>%2F2019%2F08%2F30%2FPAT%E7%94%B2%E7%BA%A7%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%E5%8F%8A%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[é¦–å…ˆè¿™é‡Œè´´å‡º æ‰€æœ‰é¢˜ç›®çš„è§£æã€‚ç”²çº§é¢˜ç›®è§£æ æœ¬æ¥æœ€å…ˆå¼€å§‹æƒ³çš„æ˜¯ ä¸€é“é¢˜ä¸€é“é¢˜çš„æ€»ç»“ï¼Œä½†æ˜¯åˆ°åé¢å‘ç°å¥½åƒçœŸçš„æ²¡æœ‰è¿™ä¸ªæ—¶é—´ï¼ˆä¸»è¦è¿˜æ˜¯è‡ªå·±æ‡’ï¼Œå®æ„¿æŠŠè¿™ä¸ªæ—¶é—´ç”¨æ¥åˆ·å‰§ï¼‰ è¿™é‡Œä¸èƒ½ç›´æ¥æ’å…¥pdfï¼Œæ‰€ä»¥åªèƒ½è½¬åŒ–ä¸ºå›¾ç‰‡ä¸€ç‚¹ä¸€ç‚¹çš„çœ‹å’¯ è€ƒæ—¶çŠ¶å†µåŒéæ–°å¤§ä¸‰ï¼Œacmé“ç‰Œé€‰æ‰‹ï¼Œç¬¬ä¸€æ¬¡è€ƒç”²çº§ 92/100 ä½†æ˜¯è§‰å¾—æ’åæœ‰ç‚¹å¼± å°†è¿‘300åäº† å‰é¢æ»¡åˆ†å¤§ä½¬ è¿™ä¹ˆæµå¼Šçš„å—ï¼Ÿ ç¬¬ä¸€é“é¢˜çš„æ—¶å€™å¡äº†åŠä¸ªå°æ—¶ï¼Œ ç”¨äº†å„ç§å‰ªæï¼ŒæŠŠæ‰€æœ‰æ²¡æœ‰è¿›ä½çš„æƒ…å†µå…¨éƒ¨å‰”é™¤æ‰äº†ï¼Œä¹Ÿæ³¨æ„åˆ°äº†æ’åºï¼Œ åˆ°æœ€åéƒ½å¼€å§‹æ€€ç–‘è‡ªå·±gcdæ˜¯ä¸æ˜¯å†™é”™äº†ï¼Œ äºæ˜¯æœæ–­æ”¾å¼ƒï¼Œå¼€å§‹å†™ç¬¬äºŒé“é¢˜ã€‚ å†™ç¬¬äºŒé“é¢˜çš„æ—¶å€™ï¼Œç”±äºè¯»è‹±æ–‡è¯»çš„å¾ˆå¿«ï¼Œç„¶åå¼€å§‹å†™ï¼Œ æœ€å…ˆå¼€å§‹ æˆ‘æ˜¯åˆ†ä¸‰ç§æƒ…å†µ mod 3 ï¼Œ3ç§æƒ…å†µå»å†™ï¼Œç„¶åè€ƒè™‘åˆ°å„ç§æƒ…å†µå»ç»ˆæ­¢ï¼Œ ç„¶åå†™å®Œå»æµ‹è¯•æ ·ä¾‹ï¼Œç›´æ¥å†…å­˜å´©äº†ï¼Œä¼°è®¡è¶…é™äº†ï¼Œ ç„¶åè¿™ä¸ªæ—¶å€™ æˆ‘æ—è¾¹çš„é‚£ä½å°å§å§ï¼Œäº¤å·äº†ï¼Ÿï¼ï¼ ä¼¼ä¹ä¸åˆ°ä¸€ä¸ªåŠå°æ—¶ï¼Œç›´æ¥å–Šäº†è€å¸ˆäº¤å·äº†ï¼Œ ç„¶åæˆ‘å¿ƒæ€å°±æœ‰ç‚¹å´©äº†,è¿™é‡Œæƒ³æ‰¾æ‰¾é‚£ä½å°å§å§ (è¥¿å®‰äº¤å¤§ 402è€ƒåœºçš„ 41å· è¿˜æ˜¯ 39 å·çš„å°å§å§)ï¼Œå°å§å§ ä½ çœŸçš„å‰å®³... è¿™ä¸ªæ—¶å€™ç”±äºå¿ƒæ€æœ‰ç‚¹ç‚¸ï¼Œè§‰å¾—å¼ºè¡Œå¼€è¿™é“é¢˜ä¸å¤ªå¯èƒ½äºæ˜¯è½¬åˆ°ç¬¬ä¸‰é¢˜å»äº†ã€‚ ç¬¬ä¸‰é¢˜è·Ÿä¹‹å‰ç”²çº§æœ‰é“é¢˜å¾ˆåƒï¼Œè‡ªå·±è½»æ¾å†™å®Œä»£ç ä¹‹åï¼Œä»¥ä¸ºæ˜¯ååºéå†ï¼Œ ä½†æ˜¯ï¼Œå½“æ²¡æœ‰å·¦å­æ ‘çš„æ—¶å€™ï¼Œå°±å˜æˆå‰ç¼€è¡¨è¾¾å¼äº†ï¼Œ å…ˆå¼€å§‹æ²¡æœ‰æ³¨æ„åˆ°ï¼Œå„ç§åœ°æ–¹å»è°ƒè¯•åŠ hello worldï¼Œå»æ‰¾è¿è¡Œä½ç½®ï¼Œç„¶åï¼Œç­”æ¡ˆè·Ÿæ ·ä¾‹ä¸€æ¨¡ä¸€æ ·çš„æ—¶å€™å»æäº¤ç»“æœå…¨é”™ï¼Œ è¿™ä¸ªæ—¶å€™æˆ‘å‘ç°ï¼Œä¸‡æ¶çš„hello world è¿˜åœ¨æˆ‘çš„è¾“å‡ºç­”æ¡ˆä¸­ï¼ï¼ï¼ æ•´ä¸ªæ—¶é—´èŠ±äº†30å¤šåˆ†é’Ÿå§ æ„Ÿè°¢hello world æ•™ä¼šæˆ‘äººç”Ÿå“²ç†.... ç¬¬å››é“é¢˜ ä¸€çœ‹å°±è§‰å¾—æ˜¯é“æ¿å­é¢˜ï¼Œç›´æ¥å»å†™ dijkstra çš„æ¿å­ï¼Œ å†™å®Œä¹‹åå†çœ‹é¢˜ç›®ï¼Œä¸çŸ¥é“æ˜¯è‹±æ–‡çš„é—®é¢˜ï¼Œè§‰å¾—è¡¨è¿°ä¸Šæœ‰ç‚¹å¥‡æ€ªï¼Œ å…ˆå¼€å§‹è§‰å¾—åªéœ€è¦åˆ¤æ–­æ˜¯ä¸æ˜¯åœ¨æœ€çŸ­è·¯åºåˆ—ä¸Šï¼Œåæ¥æ‰å‘ç°åªéœ€è¦å»åˆ¤æ–­è·ç¦»å°±è¡Œäº†ï¼Œ æ„Ÿè§‰åˆå˜æˆæš´åŠ›æ¯ä¸­çš„æ‰¾è§„å¾‹ï¼Œæ‰€ä»¥å°±ç›´æ¥è¿‡äº†ã€‚ è¿™ä¸ªæ—¶å€™è¿˜æœ‰ä¸€ä¸ªå°æ—¶å·¦å³çš„æ—¶é—´ï¼Œäºæ˜¯è¿™ä¸ªæ—¶å€™è¿”å›ç¬¬äºŒé¢˜ï¼Œåˆ æ‰å…¨éƒ¨ä»£ç ï¼Œé‡æ–°å†™ï¼Œ è®¤è®¤çœŸçœŸé™ä¸‹æ¥è¯»å®Œé¢˜ç›®ï¼Œæ‰å‘ç°è´¼ç®€å•ï¼Œè‡ªå·±æƒ³å¤æ‚äº†ï¼Œ å› ä¸ºä¸å¯èƒ½å‡ºç°ï¼Œå¤§åºåˆ—ç»“æŸï¼Œå°åºåˆ—ä¸ç»“æŸçš„æƒ…å†µï¼Œæƒ³é€šè¿™ä¸ªå°±ç›´æ¥å¼€å§‹å†™ï¼Œ æœç„¶ç›´æ¥å°±ä¸€å‘acäº†ï¼Œè¿˜æ˜¯å¿ƒç†æš—ç¤ºæœ€é‡è¦ï¼Œåªèƒ½è¯´å°å§å§å¤ªå‰å®³äº†ã€‚ è¿˜æœ‰40åˆ†é’Ÿå·¦å³ï¼Œåªå‰©ä¸‹ç¬¬ä¸€é¢˜çš„8åˆ†æ²¡æ‹¿åˆ°æ‰‹äº†ï¼Œ äºæ˜¯å›å»å„ç§æ‰¾è§„å¾‹ï¼Œé‡æ–°ä»”ç»†æ‰£é¢˜ç›®ï¼Œç„¶åå½“æˆ‘å†æ¬¡äº¤çš„æ—¶å€™ï¼Œè¿˜æ˜¯æœ‰é—®é¢˜ ï¼Œ å½“æ—¶å°±å¾ˆæ‡µé€¼ï¼Œè„‘æµ·é‡Œé¢å„ç§ç®—æ³•å¼€å§‹äº¤æ‚ï¼ŒäºŒåˆ†ï¼Œçº¿æ®µæ ‘ï¼Œæ ‘çŠ¶æ•°ç»„ï¼Ÿï¼Ÿï¼Ÿ ç„¶åå†æ¬¡å†·é™ä¸‹æ¥å»å†™çš„æ—¶å€™ï¼Œæˆ‘è®°å¾—æ˜¯è¿˜æœ‰äºŒåå¤šåˆ†é’Ÿçš„æ—¶å€™ æœåŠ¡å™¨ç‚¸äº†ï¼Œ æˆ‘è¿™ä¸ªäººè¿˜æ˜¯æŒºè¿·ä¿¡çš„ï¼Œè§‰å¾—å¤©æ„å¦‚æ­¤ï¼ˆå¥½åƒæäº¤çš„æ—¶é—´ä¹Ÿå æ’åï¼‰å°±ç›´æ¥äº¤äº†èµ°äººäº†ã€‚ ä¸è¿‡ä»Šå¹´åˆšå¤§ä¸‰ï¼Œå¾—æ˜å¹´è€ƒçš„patæˆç»©æ‰ç®—ï¼Œæ‰€ä»¥è¿™æ¬¡å°±å½“æ‰“æ€ªå‡çº§ç»ƒæ‰‹å’¯ï¼Œ ä¸è¿‡ å¬è¯´è¿˜ä¼šè€ƒå¾ˆå¤šé¡¶çº§ç±»ä¼¼çš„é¢˜ç›®ï¼Œä¸‹æ¬¡å¾—æŠŠé¡¶çº§çš„é¢˜ç›®åˆ·ä¸€éå†æ¥è€ƒã€‚ çœ‹åˆ°çŸ¥ä¹é‡Œé¢éƒ½æ˜¯æ»¡åˆ†çš„å¤§ä½¬ï¼Œä¸å¼€å¿ƒã€‚ sad face... è€ƒåæ€»ç»“ç¬¬ä¸€æ¬¡è€ƒç”²çº§ è€ƒäº†92ï¼Œåˆ†æ•°ä¸Šè¿˜ä¸é”™ï¼Œä½†æ˜¯æ’åä¹Ÿå¤ªå¼±é¸¡äº†ï¼Œæ‰è´¹äº†æˆ‘æå‰äº†20å¤šåˆ†é’Ÿäº¤å·ï¼Œæ—©çŸ¥é“è¿™ä¸ªæ’åä¸æ˜¯çœ‹æäº¤é€Ÿåº¦çš„è¯ï¼Œæˆ‘åº”è¯¥åšæŒåˆ°æœ€åä¸€åˆ»çš„ï¼Œå½“æ—¶çš„æƒ³æ³•å°±æ˜¯è§‰å¾— 92åˆ†å¤Ÿäº†ï¼Œå› ä¸ºçŸ¥é“è‡ªå·±æ˜å¹´è¿˜ä¼šå†å»è€ƒä¸€æ¬¡å¼ï¼Œå½“æ—¶ä¼¼ä¹æœ‰ç‚¹è½»æ¾ï¼Œæ‰€æœ‰æœ‰ç‚¹æ¾æ‡ˆï¼Œå¸Œæœ›ä¸‹æ¬¡èƒ½ä¸€æ­¥ç™»å¤©ï¼Œæœ‰çœ‹è¿™é‡Œçš„æœ‹å‹ï¼Œå¯ä»¥ä¸€èµ·çº¦ç€å¤‡è€ƒæ˜å¹´çš„patï¼Œ ä¸è¿‡æœ€è¿‘ä¹Ÿä¸èƒ½æ¾æ‡ˆï¼Œå†è¡¥å‰é¢çš„å‘çš„åŒæ—¶ï¼Œè¿˜è¦å¥½å¥½å‡†å¤‡åé¢çš„å…¶ä»–è€ƒè¯•äº†ã€‚ åŠ æ²¹ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æµ™å¤§pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7.27çº¿æ€§dpä¸åŒºé—´dpé¢˜ç›®è§£æ]]></title>
    <url>%2F2019%2F07%2F27%2F7-27%E7%BA%BF%E6%80%A7dp%E4%B8%8E%E5%8C%BA%E9%97%B4dp%2F</url>
    <content type="text"><![CDATA[A.å¯¼å¼¹è¢­å‡»ä»£ç å¦‚ä¸‹ï¼š123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;int main()&#123; //freopen("test1.in", "r", stdin); //freopen("test1.out", "w", stdout); int T; while (~scanf("%d", &amp;T)) &#123; int dp[T + 5]; int data[T + 5]; data[0] = 0; int num = 0; for (int i = 1; i &lt;= T; i++) &#123; cin &gt;&gt; data[i]; dp[i] = 1; &#125; for (int i = 2; i &lt;= T; i++) &#123; for (int j = i - 1; j &gt;= 1; j--) &#123; if (data[i] &gt; data[j]) &#123; dp[i] = max(dp[i], dp[j] + 1); &#125; num = max(num, dp[i]); &#125; &#125; cout &lt;&lt; num &lt;&lt; endl; &#125; return 0;&#125; B.Common Subsequenceä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;string s1, s2, tmp;int main()&#123; //freopen("test1.in", "r", stdin); //freopen("test1.out", "w", stdout); while (cin &gt;&gt; s1 &gt;&gt; s2) &#123; if (s1.size() &lt; s2.size()) &#123; tmp = s1; s1 = s2; s2 = tmp; &#125; int dp[s1.size() + 10][s1.size() + 10]; memset(dp, 0, sizeof dp); int Max = 0; for (int i = 0; i &lt; s2.size(); i++) &#123; int k = i + 1; for (int j = 0; j &lt; s1.size(); j++) &#123; int l = j + 1; if (s1[j] == s2[i]) &#123; dp[k][l] = dp[k - 1][l - 1] + 1; &#125; else dp[k][l] = max(dp[k - 1][l], dp[k][l - 1]); Max = max(Max, dp[k][l]); &#125; &#125; cout &lt;&lt; dp[s2.size()][s1.size()] &lt;&lt; endl; &#125; return 0;&#125; C.æ»‘é›ªä»£ç å¦‚ä¸‹ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;map&gt;#define INF 0x3f3f3f3f#define N 110using namespace std;int dis[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;int len[N][N], a[N][N];int m, n;int dp(int x, int y)&#123; int tx, ty, k, s, ms; ms = 0; if (len[x][y] != 0) //é€’å½’å‡ºå£ï¼› return len[x][y]; for (k = 0; k &lt;= 3; k++) &#123; tx = dis[k][0] + x; ty = dis[k][1] + y; if (tx &lt; 0 || ty &lt; 0 || tx &gt; m - 1 || ty &gt; n - 1) continue; if (a[tx][ty] &lt; a[x][y]) &#123; s = dp(tx, ty); ms = max(ms, s); &#125; &#125; len[x][y] = ms + 1; return len[x][y];&#125;int main()&#123; //freopen("test1.in", "r", stdin); //freopen("test1.out", "w", stdout); int i, j, Max; while (~scanf("%d%d", &amp;m, &amp;n)) &#123; memset(a, 0, sizeof(a)); memset(len, 0, sizeof(len)); for (i = 0; i &lt; m; i++) for (j = 0; j &lt; n; j++) scanf("%d", &amp;a[i][j]); Max = -1; for (i = 0; i &lt; m; i++) for (j = 0; j &lt; n; j++) Max = max(Max, dp(i, j)); printf("%d\n", Max); &#125; return 0;&#125; D.å°çº¢çº¢ç›Šæ™ºæ¸¸æˆä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int INF = -0x3f3f3f3f; //å®šä¹‰ä¸€ä¸ªæ— ç©·å¤§çš„å€¼const int maxn = 205;int dp[maxn][maxn];int sum[maxn][maxn], n, x;int main()&#123; sum[0][0] = 0; //åˆå§‹åŒ– while (scanf("%d", &amp;n) != EOF) &#123; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;x); sum[i][i] = x; fill(dp[i], dp[i] + maxn, INF); //åˆå§‹åŒ– dp[i][i] = 0; &#125; //åŒºé—´dp for (int len = 2; len &lt;= n; len++) //æšä¸¾åŒºé—´é•¿åº¦ &#123; for (int i = 1; (i + len - 1) &lt;= n; i++) //æšä¸¾åŒºé—´èµ·ç‚¹ &#123; int j = i + len - 1; for (int k = i; k &lt; j; k++) //æšä¸¾ä¸­æ–­ç‚¹ &#123; sum[i][j] = sum[i][k] + sum[k + 1][j]; dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j] + sum[i][j]); &#125; &#125; &#125; printf("%d\n", dp[1][n]); &#125; return 0;&#125; E.æœ€å¤§æ‹¬å·åŒ¹é…æ•°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 105;int dp[maxn][maxn];string V;int main()&#123; while (cin &gt;&gt; V, V[0] != '0') &#123; int n = V.size(); for (int i = 0; i &lt;= n; i++) &#123; memset(dp[i], 0, sizeof(dp[i])); &#125; for (int len = 2; len &lt;= n; len++) &#123; for (int i = 0; i + len - 1 &lt; n; i++) &#123; int j = i + len - 1; if (V[i] == '(' &amp;&amp; V[j] == ')' || V[i] == '[' &amp;&amp; V[j] == ']') &#123; if (i + 1 &gt; j - 1) dp[i][j] = 2; else dp[i][j] = dp[i + 1][j - 1] + 2; &#125; for (int k = i; k &lt; j; k++) &#123; dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j]); &#125; &#125; &#125; cout &lt;&lt; dp[0][n - 1] &lt;&lt; endl; V.clear(); &#125; return 0;&#125; F.çº¢çº¢è·³æ ¼å­ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 1005;int dp[maxn];int num[maxn];//æ€»ç»“ä¸€ä¸‹è¿™ç±»çš„çº¿æ€§DPã€‚//è¿™é‡Œdpæ•°ç»„ä¿å­˜çš„æ˜¯æ¯ä¸€ä¸ªç‚¹ä¸ºæ­¢è¿™ä¸ªä½ç½®ä¸Šçš„é€’å¢å­åºåˆ—ä¹‹å’Œ//ç„¶åè¿™ä¸ªåœ°æ–¹çš„æ¯ä¸€ä¸ªç¡®å®šçš„å€¼å†ä¸ä¹‹å‰çš„å»æ¯”è¾ƒï¼Œæœ€ååŠ ä¸Šç›¸åº”çš„å€¼å³å¯ã€‚int main()&#123; //freopen("test1.in", "r", stdin); //freopen("test1.out", "w", stdout); int T; while (cin &gt;&gt; T &amp;&amp; T) &#123; for (int i = 1; i &lt;= T; i++) &#123; cin &gt;&gt; num[i]; &#125; memset(dp, 0, sizeof dp); dp[1] = num[1]; for (int i = 2; i &lt;= T; i++) &#123; dp[i] = num[i]; for (int j = i - 1; j &gt;= 1; j--) &#123; if (num[i] &gt; num[j]) &#123; dp[i] = max(dp[i], dp[j] + num[i]); &#125; &#125; &#125; int Max = 0; for (int i = 1; i &lt;= T; i++) &#123; Max = max(Max, dp[i]); &#125; cout &lt;&lt; Max &lt;&lt; endl; &#125; return 0;&#125; G.è¯·å®¢çš„çº¢çº¢ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* è¿™é“é¢˜å°±æ˜¯è¢«å‰é¢çš„æ€æƒ³æ‰€å½±å“ï¼Œå…¶å®è¿™é“é¢˜ä¸åƒå‰é¢å‰é¢å‡ ä¸ªçŠ¶æ€ä¸€å®šä¼šå½±å“åˆ°åé¢çš„çŠ¶æ€ï¼Œ ä»…ä»…åªæ˜¯ä¸€ä¸ªä¸€ç»´çš„çº¿æ€§dpï¼Œè€ƒè™‘åˆ°å‰é¢çš„è¿™äº›æƒ…å†µï¼Œä»–æ˜¯å¦å¤–çš„ä¸¤ä¸ªdpæ–¹ç¨‹ç»„è¿›è¡Œæ”¾ä¸ä¸æ”¾çš„æ“ä½œ æ‰€ä»¥ä¸ä¼šæ¶‰åŠåˆ°å¤šä¸ªå¾ªç¯åå¤åˆ°å‰é¢ä¹‹å‰çš„çŠ¶æ€å»å¯»æ‰¾ï¼Œ åªéœ€è¦åœ¨ä¸€æ¬¡éå†çš„è¿‡ç¨‹ä¸­å»å®ç°ç©¶ç«Ÿæ˜¯ä¸€æ¬¡è¿˜æ˜¯ä¸¤æ¬¡çš„æ“ä½œã€‚ è·Ÿç€æ¯ä¸€ä¸ªçŠ¶æ€å¾€ä¸‹é¢æ‰¾å‡ºæ¯ä¸€ä¸ªä½ç½®çš„å±€éƒ¨æœ€ä¼˜è§£ æœ€åå¾—åˆ°ç»“æœã€‚*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 2005;int dp[maxn];int s[maxn];int d[maxn];int main()&#123; //freopen("test1.in", "r", stdin); //freopen("test1.out", "w", stdout); int T; cin &gt;&gt; T; while (T--) &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; s[i]; dp[i] = s[i]; &#125; d[0] = 0; d[1] = 0; for (int i = 2; i &lt;= n; i++) &#123; cin &gt;&gt; d[i]; &#125; dp[0] = 0; dp[1] = s[1]; for (int i = 2; i &lt;= n; i++) &#123; dp[i] = min(dp[i - 1] + s[i], dp[i - 2] + d[i]); &#125; int h = dp[n] / 3600 + 8; int m = dp[n] / 60 % 60; int s = dp[n] % 60; if (h &lt;= 12) printf("%02d:%02d:%02d am\n", h, m, s); else printf("%02d:%02d:%02d pm\n", h, m, s); &#125; return 0;&#125; H.çº¢çº¢ä¸ç³–æœä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100005;int n;int dp[maxn][11];int date[maxn][11];int _time, pie;int main()&#123; //freopen("test1.in", "r", stdin); //freopen("test1.out", "w", stdout); while (scanf("%d", &amp;n) &amp;&amp; n != 0) &#123; memset(date, 0, sizeof date); memset(dp, 0, sizeof dp); int maxTime = 0; for (int i = 0; i &lt; n; i++) &#123; scanf("%d %d", &amp;pie, &amp;_time); date[_time][pie]++; maxTime = max(maxTime, _time); &#125; //ç¬¬ä¸€ç§’çš„è¿è¡Œæ—¶é—´ï¼Œé‡Œé¢æ‰€æœ‰çš„è¿è¡Œæƒ…å†µ dp[1][4] = date[1][4]; dp[1][5] = date[1][5]; dp[1][6] = date[1][6]; //è¿™é‡Œå…¶å®æ˜¯ç”±ç¬¬äºŒæ¬¡è¿è½¬çš„æ—¶é—´æ¥çœ‹ï¼Œå› ä¸ºç¬¬ä¸€ç§’çš„æ—¶é—´æˆ‘å·²ç»å…¨éƒ¨æ ‡è®°ä¸‹æ¥äº†ã€‚ for (int i = 2; i &lt;= maxTime; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; dp[i][j] = dp[i - 1][j]; //ä¸è¿‡éœ€è¦æ³¨æ„çš„æ˜¯ è¿™äº›å…¨éƒ¨éƒ½æ˜¯å‰å‡ ç§’çš„åŠ¨ä½œï¼Œä¸Šä¸€ç§’æ›´æ–°çš„çŠ¶æ€ï¼Œåˆ°ä¸‹ä¸€ç§’åæ‰§è¡Œçš„çŠ¶æ€ //ä¸‹é¢è¿™ä¸ªåœ°æ–¹å°±æ˜¯å¾ˆå¥‡å¹»çš„åœ°æ–¹äº†ï¼Œä¸€å…±ä¸‰ä¸ªçŠ¶æ€ï¼Œå–å‡ºæ¥è¿˜æ˜¯ä¸å–å‡ºæ¥ï¼Œå°±æ˜¯è¿™ä¸‰ç§çŠ¶æ€ //å·¦è¾¹ä¸€ä¸ªä½ç½®å–ï¼Œè¿˜æ˜¯å³è¾¹ä¸€ä¸ªä½ç½®å–ï¼Œè¿˜æ˜¯åŸæœ¬çš„ä½ç½®å»å‡ºæ¥ã€‚ if (j &gt; 0) dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]); if (j &lt; 10) dp[i][j] = max(dp[i][j], dp[i - 1][j + 1]); dp[i][j] += date[i][j]; &#125; &#125; int Max = 0; for (int i = 0; i &lt; 11; i++) &#123; Max = max(Max, dp[maxTime][i]); &#125; cout &lt;&lt; Max &lt;&lt; endl; &#125; return 0;&#125; I.è€å·¦çš„çŸ©é˜µä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* è¿™ä¸ªåœ°æ–¹å°±ç›´æ¥å°±æ˜¯ç­”æ¡ˆçš„æ€è·¯äº†ï¼Œç”±ä¸€ç§å€’å™çš„æ–¹æ³•å¾€å‰é¢æ¨ï¼Œå°†å¯¹è§’çº¿å­˜å‚¨çš„æ•°ï¼Œ å°±æ˜¯å½“å‰èƒ½å­˜å‚¨åˆ°çš„æœ€å¤§çš„çŸ©é˜µã€‚ çŠ¶æ€è½¬ç§»æ–¹ç¨‹å°±æ˜¯ dp[i][j] ç”± dp[i - k][j]ä¸ dp[i][j - k] æ˜¯å¦ç›¸ç­‰ç„¶åå†æ¥å­˜å‚¨ ä¸è¿‡è¿™é‡Œæœ‰ä¸€ä¸ªæŠ€å·§å°±æ˜¯ æ¯ä¸€ä¸ªä»…ä»…åªæ˜¯å­˜å‚¨è¿™ä¸ªæ•°ç»„èƒ½å¤Ÿæ‰¿å—çš„æœ€å¤§å€¼ã€ è‡ªå·±æƒ³çš„åŠæ³•æ²¡æœ‰è€ƒè™‘åˆ°çŠ¶æ€çš„è¿ç§»ï¼Œä¹Ÿå°±æ˜¯æ²¡æœ‰è€ƒè™‘åˆ°çŠ¶æ€ä¸çŠ¶æ€ä¹‹é—´çš„è”ç³»ï¼Œè¿™é‡Œå°±å±•ç°å‡ºæ¥äº†ã€‚ å°†æ¯ä¸€ä¸ªå€¼å­˜å‚¨åˆ°dp[i - 1][j + 1] ä¸Šï¼Œç„¶åå†ä¸€æ¬¡å¯¹å…¶è¿›è¡ŒéªŒè¯ã€‚ */#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int n;const int maxn = 1005;char ch[maxn][maxn];int dp[maxn][maxn];int main()&#123; //freopen("test2.in", "r", stdin); //freopen("test2.out", "w", stdout); while (cin &gt;&gt; n &amp;&amp; n) &#123; getchar(); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; ch[i][j]; dp[i][j] = 1; &#125; getchar(); &#125; int Max = 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = n; j &gt;= 1; j--) &#123; if (i == 1 || j == n) continue; int tmp = dp[i - 1][j + 1]; for (int k = 1; k &lt;= tmp; k++) &#123; if (ch[i - k][j] == ch[i][j + k]) dp[i][j]++; else break; &#125; Max = max(Max, dp[i][j]); &#125; &#125; printf("%d\n", Max); &#125; return 0;&#125; J.é˜¿æ˜¥å–æ•°å­—ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* è¿™é“é¢˜ç›®å°±æ˜¯å…¸å‹çš„åŒºé—´DPçš„é¢˜ç›®äº†ï¼Œå¯¹ä¸€ä¸ªåŒºé—´é‡Œé¢çš„å€¼è¿›è¡ŒåŠ¨æ€è§„åˆ’çš„æ±‚è§£ï¼Œå°±åƒä¸‹é¢çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ dp[i][j] = max(dp[i + 1][j] + num[i] *(n + i - j), dp[i][j - 1] + num[j] * (n + i - j)); è¿™é“é¢˜å”¯ä¸€ç‰¹åˆ«éš¾æƒ³åˆ°çš„æ˜¯ï¼Œè¿™é“é¢˜ç›®æ˜¯ä¸€é“é€†åºæ±‚è§£çš„é—®é¢˜ï¼Œ æ„æ€å°±æ˜¯ä»åé¢çš„çŠ¶æ€å¾€å‰é¢æ¨ï¼Œè¿™å½“æ—¶çš„æˆ‘å°±å®Œå…¨æ²¡æœ‰æƒ³åˆ°äº†ã€‚*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;using namespace std;int n;const int maxn = 2005;int dp[maxn][maxn];int num[maxn];int main()&#123; //freopen("test3.in", "r", stdin); //freopen("test3.out", "w", stdout); while (~scanf("%d", &amp;n)) &#123; memset(dp, 0, sizeof dp); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;num[i]); dp[i][i] = num[i]; &#125; for (int i = n; i &gt;= 1; i--) &#123; for (int j = i; j &lt;= n; j++) &#123; //è¿™é‡Œä¹˜ä»¥ n + i - j å…¶å®ä¸€å¼€å§‹çš„å˜å½¢å°±æ˜¯ n - (j - i + 1) + 1 dp[i][j] = max(dp[i + 1][j] + num[i] * (n + i - j), dp[i][j - 1] + num[j] * (n + i - j)); &#125; &#125; printf("%d\n", dp[1][n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>ä¹ é¢˜è§£æ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7.26_è®°å¿†åŒ–æœç´¢å’ŒèƒŒåŒ…ä¹ é¢˜è§£æ]]></title>
    <url>%2F2019%2F07%2F26%2F7-26-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E5%92%8C%E8%83%8C%E5%8C%85%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[A.å°è¾‰è¾‰ç©ç§¯æœ¨ä»£ç å¦‚ä¸‹ï¼š1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;cmath&gt;using namespace std;long long a[60] = &#123;1, 2&#125;;long long f(int n) &#123; if (a[n]) return a[n]; return a[n] = f(n - 2) + f(n - 1);&#125;int main()&#123; std::ios::sync_with_stdio(false); cin.tie(0); int N; while (cin &gt;&gt; N) &#123; cout &lt;&lt; f(N - 1) &lt;&lt; endl; &#125; return 0; return 0;&#125; è¿™é“é¢˜å°±ä»…ä»…åªæ˜¯ç”¨åˆ°äº†ä¸€ä¸ªé€’å½’å’Œè®°å¿†åŒ–æœç´¢ï¼Œå±äºåŸºç¡€ç®€å•çš„é¢˜ç›®ã€‚ B.å…¥ä¾µå’Œåå‡»ä»£ç å¦‚ä¸‹ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; std::ios::sync_with_stdio(false); cin.tie(0); int T; cin &gt;&gt; T; while (T--) &#123; int n; cin &gt;&gt; n; int dp[n + 5]; int num[n + 5]; for (int i = 0; i &lt; n;i ++) &#123; cin &gt;&gt; num[i]; &#125; //memset(dp,1,sizeof dp); //fill (num,num+n,1); dp[0] = 1; for (int i = 1;i &lt; n; i++) &#123; dp[i] = 1; //è¿™ä¸ªåœ°æ–¹çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼Œéœ€è¦å»ç»†æƒ³æ¯”è¾ƒä¸€ä¸‹ã€‚ for (int j = 0; j &lt; i; j++) &#123; if (num[i] &lt;= num[j]) &#123; dp[i] = max(dp[i],dp[j] + 1); &#125; &#125; &#125; int Max = -1; for (int i = 0; i &lt; n; i++) &#123; Max = max(Max,dp[i]); &#125; cout &lt;&lt; n - Max &lt;&lt; endl; // 9 17 8 19 3 // 1 1 2 1 3 &#125; return 0;&#125; C.çº¢çº¢æ•°é’ç¥¨ä»£ç å¦‚ä¸‹ï¼š1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* å…¶å®è¿™é“é¢˜ä¹Ÿç®—æ˜¯ä¸€é“ç‰¹åˆ«ç®€å•çš„é¢˜ç›®ï¼Œè¿˜æ˜¯åŠ¨æ€è§„åˆ’é‡Œé¢æœ€åŸºç¡€çš„é—®é¢˜ï¼Œä½†æ˜¯æ€»æ˜¯å®¹æ˜“å»å¼„æ··ã€‚ è®°å¾—è‡ªå·±å½“æ—¶çš„é—®é¢˜å°±åœ¨äº è¿™é‡Œæ¯ä¸€æ¬¡ç›¸åŠ çš„å’Œï¼Œå¦‚ä½•ä¿è¯åé¢åŠ äº†è´Ÿæ•°ä¹‹åï¼Œå†æ¬¡åŠ ä¸Šä¸€ä¸ªæ­£æ•°ä¸è¢«å½±å“å‘¢ï¼Œ ä¸‹é¢çš„æ³¨é‡Šé‡Œé¢æœ‰å†™ï¼Œ å› ä¸ºé¢˜ç›®ä¸­é™åˆ¶äº†ï¼Œå¦‚æœè¿™é“é¢˜æœ‰å¤šä¸ªç­”æ¡ˆï¼Œæ¯”å¦‚è¯´ å‰é¢ä¸åé¢ç›¸åŠ ä¸ºé›¶ï¼Œä½†æ˜¯åé¢çš„é‚£ä¸ªæ­£æ•°æ­£å¥½ä½œä¸ºæœ€åçš„æ­£ç¡®ç­”æ¡ˆçš„è¯ æ¯”å¦‚ 1 2 -3 8 10 -1 1 2 -3 æ­£å¥½ç›¸åŠ ä¸º0 ä½†æ˜¯é¢˜ç›®ä¸­è¦æ±‚çš„ åºåˆ— 1 2 -3 8 ä½œä¸ºæœ€åçš„ç»“æœåºåˆ—ã€‚ è‡ªå·±å½“æ—¶ä¹Ÿåœ¨è¿™ä¸€å—ä¸Šé¢çº ç»“ã€‚*/#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; std::ios::sync_with_stdio(false); int m; cin &gt;&gt; m; int num[m + 5]; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; num[i]; &#125; int left = 0; int tmpleft = 0; int right = m - 1; int tmp = 0; int Max = -1; for (int i = 0; i &lt; m; i ++) &#123; tmp += num[i]; if (tmp &lt; 0) &#123; tmp = 0; tmpleft = i + 1; &#125; else if (tmp &gt; Max) &#123; Max = tmp; right = i; left = tmpleft; &#125; &#125; if (Max &gt;= 0) cout &lt;&lt; Max &lt;&lt; " " &lt;&lt; num[left] &lt;&lt; " " &lt;&lt; num[right] &lt;&lt; endl; else cout &lt;&lt; 0 &lt;&lt; " " &lt;&lt; num[0] &lt;&lt; " " &lt;&lt; num[m - 1] &lt;&lt; endl; return 0;&#125; D.Charm Braceletä»£ç å¦‚ä¸‹ï¼š12345678910111213141516171819202122232425262728293031323334/* ç¬¬ä¸€é“é¢˜å±äºä¸€ä¸ªç®€å•çš„01èƒŒåŒ…æ¨¡æ¿é¢˜ç›®ï¼Œè¿™é‡Œä¸å¤šè¯´ å¯ä»¥ç›´æ¥å¥—æ¨¡æ¿ã€‚*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int n,m;int dp[13000];int w[3500],v[3500];int main()&#123; while (cin &gt;&gt; n &gt;&gt; m) &#123; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; w[i] &gt;&gt; v[i]; &#125; memset(dp,0,sizeof dp); for (int i = 1; i &lt;= n; i++) &#123; for (int j = m; j &gt;= w[i]; j--) &#123; dp[j] = max(dp[j],dp[j - w[i]] + v[i]); &#125; &#125; cout &lt;&lt; dp[m] &lt;&lt; endl; &#125; return 0;&#125; E.çº¢çº¢ç»åœ°æ±‚ç”Ÿä»£ç å¦‚ä¸‹ï¼š1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* ä¸€æ®µç®€å•çš„æ¨¡æ¿é¢˜ç›®ï¼Œä¸è¿‡éœ€è¦å¼„æ¸…æ¥šçš„ ä¸€ç»´æ•°ç»„ä¸äºŒç»´æ•°ç»„åœ¨è¿™é‡Œç›¸åº”çš„åŒºåˆ«ï¼Œå¾€å¾€è¿™é‡Œä¼šäº§ç”Ÿå¾ˆå¤§çš„åŒºåˆ«ï¼Œ æ¯”å¦‚ç¬¬äºŒä¸ªå¾ªç¯çš„å¼€å§‹æ¡ä»¶ï¼Œå› ä¸ºè¿™é‡Œæ˜¯ç”±å­é—®é¢˜çš„å †ç§¯ï¼Œç„¶åä¸€ç‚¹ä¸€ç‚¹å‘ä¸Šå‡æœ€ç»ˆå¾—åˆ°çš„é—®é¢˜ï¼Œæ‰€ä»¥è¿™ææœ€å¥½æ§åˆ¶èƒŒåŒ…çš„æ”¾ä¸ä¸æ”¾çš„é—®é¢˜ã€ å°±æ¯”å¦‚æˆ‘åœ¨è¿™é“é¢˜ç›®çš„ç¬¬äºŒä¸ªé—®é¢˜ä¸­å‡ºç°çš„é”™è¯¯ï¼Œå°±æ˜¯å°†j=0è¿™ä¸ªæ¡ä»¶ç›´æ¥æ è¿‡å»äº†ï¼Œå…¶å®è¿™é‡Œæ˜¯ä¸å¯¹çš„ã€‚*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1010;long long weight[maxn],value[maxn],dp[maxn][maxn];long v,w;int main()&#123; int T; cin &gt;&gt; T; while(T--) &#123; cin &gt;&gt; w &gt;&gt; v; value[0] = 0; weight[0] = 0; for (int i = 1; i &lt;= w; i++) &#123; cin &gt;&gt; value[i]; &#125; for (int i = 1; i &lt;= w; i++) &#123; cin &gt;&gt; weight[i]; &#125; memset(dp, 0, sizeof dp); for (int i = 1; i &lt;= w; i++) &#123; for (int j = 0; j &lt;= v; j++) &#123; if (j &gt;= weight[i]) &#123; dp[i][j] = max(dp[i - 1][j],dp[i - 1][j - weight[i]] + value[i]); &#125; else dp[i][j] = dp[i - 1][j]; &#125; &#125; cout &lt;&lt; dp[w][v] &lt;&lt; endl; &#125; return 0;&#125; F.ä¸€å¡é€šä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041/* ä¸€ç»´æ»šåŠ¨æ•°ç»„çš„åšæ³•ï¼Œç”±äºæ˜¯01èƒŒåŒ…ï¼Œæ‰€ä»¥ç›´æ¥å¥—æ¨¡æ¿*/#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n; int d[1010]; int dp[1010]; while (cin &gt;&gt; n &amp;&amp; n) &#123; memset(d, 0, sizeof(d)); memset(dp, 0, sizeof(dp)); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; d[i]; &#125; int p; cin &gt;&gt; p; sort(d + 1, d + n + 1); if (p &lt; 5) &#123; cout &lt;&lt; p &lt;&lt; endl; &#125; else &#123; for (int i = 1; i &lt; n; i++) &#123; for (int j = p - 5; j &gt;= d[i]; j--) &#123; dp[j] = max(dp[j], dp[j - d[i]] + d[i]); &#125; &#125; cout &lt;&lt; p - dp[p - 5] - d[n] &lt;&lt; endl; &#125; &#125; return 0;&#125; ç¬¬äºŒç§æ–¹æ³•ï¼š12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* äºŒç»´æ•°ç»„ç›´æ¥å¥—æ¨¡æ¿*//* è¿™é“é¢˜ç¥å¥‡çš„åœ°æ–¹å°±åœ¨äº å…¶çš„é‡é‡é™åˆ¶äºä»·å€¼é‡åˆåœ¨äº†ä¸€èµ·ï¼Œæ‰€ä»¥å¯¹äºè¿™é“é¢˜è€Œè¨€å°±æ˜¯åªèƒ½é‡åˆçš„å»å†™çŠ¶æ€è½¬ç§»æ–¹ç¨‹äº† å¦å¤–éœ€è¦æ³¨æ„çš„æ˜¯æœ€åè¾“å‡ºç»“æœçš„åŠæ³•ï¼Œæ˜¯å°†æœ€åä¸€ä¸ªç‰©å“äº¤ç»™å‰©ä¸‹çš„æœ€å¤§çš„é’±å»è´­ä¹°ï¼Œè¿™æ ·èƒ½å½»åº•ç”¨å…‰æœ€åçš„é’±è´¢*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int n,m;const int maxn = 1010;int num[maxn],dp[maxn][maxn];int main()&#123; while (cin &gt;&gt; n &amp;&amp; n) &#123; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; num[i]; &#125; cin &gt;&gt; m; sort(num + 1, num + 1 + n); if (m &lt; 5) &#123; cout &lt;&lt; m &lt;&lt; endl; continue; &#125; memset(dp,0,sizeof dp); //è¿™é‡Œä¸ä¸Šé¢ä¸€ç»´æ»šåŠ¨æ•°ç»„ä¸å¤ªä¸€æ ·çš„æ˜¯ï¼Œä¸€ç»´æ»šåŠ¨æ•°ç»„æ˜¯ä¸èƒ½æœ‰å¯¹ç‰©å“é™åˆ¶çš„æ“ä½œã€‚ //æ„æ€å°±æ˜¯ æˆ‘äºŒç»´æ•°ç»„å¯ä»¥ç®—å‡ºn-1ä¸ªæ•°ï¼Œç„¶åç®—å‡ºæœ€åä¸€ä¸ªæ•°ç»™å‡ºçš„é’±æ•°dp[i - 1][j] //è€Œä¸€ç»´æ•°ç»„ç”±äºåªæœ‰ä¸€ä¸ªå‚æ•°å°±æ˜¯ä½“ç§¯å®¹é‡çš„å‚æ•°dp[i] //æ‰€ä»¥ä¸‹é¢å¤šç®—äº†ä¸€ä¸ªï¼Œæœ€åå†é€šè¿‡è®¡ç®—å‡ºn-1ä¸ªç‰©å“çš„ä½“ç§¯ï¼Œå†å‡å»ç›¸åº”çš„é’±æ•°ï¼Œå¾—åˆ°æœ€ç»ˆç­”æ¡ˆã€‚ for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= m - 5; j++) &#123; if (j &gt;= num[i]) &#123; dp[i][j] = max(dp[i - 1][j],dp[i - 1][j - num[i]] + num[i]); &#125; else dp[i][j] = dp[i - 1][j]; &#125; &#125; cout &lt;&lt; m - dp[n - 1][m - 5] - num[n] &lt;&lt; endl; &#125; return 0;&#125; G.çº¢çº¢å‡è‚¥è®°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* è¿™é“é¢˜ä½¿ç”¨äºŒç»´æ•°ç»„å°±ä¸€ç›´å°±ä¼šè¶…æ—¶ å…·ä½“çš„æˆ‘ä¹Ÿä¸å¤ªæ¸…æ¥šï¼Œä½†æ˜¯ æ²¡æœ‰åŠæ³• åªèƒ½ä½¿ç”¨ä¸€ç»´æ»šåŠ¨æ•°ç»„ï¼Œè¿›è¡Œäº†ç›¸åº”çš„ç©ºé—´ä¼˜åŒ– ä¸è¿‡è¿™é‡Œéœ€è¦è¡¥å……å‡ ä¸ªçŸ¥è¯†ç‚¹ ç¬¬ä¸€ å…³äºäºŒç»´æ•°ç»„çš„å®Œå…¨èƒŒåŒ…çŠ¶æ€è½¬ç§»æ–¹ç¨‹ dp[i][j] = max (dp[i - 1][j],dp[i - 1][j - k * c[i]] + k * v[i]); ç”±ä¸Šé¢è¿™ä¸ªå¼å­å°±å¯ä»¥å¾—å‡ºï¼ŒçŠ¶æ€è½¬ç§»æ–¹ç¨‹ äºæ˜¯ ä¸€ç§ç©ºé—´ä¼˜åŒ–çš„å†™æ³• æ˜¯ç›´æ¥å†™æˆ max(dp[i - 1][j]ï¼Œdp[i][j - w[i]] + v[i]) ç¬¬äºŒ å¦‚æœæ¢æˆæ»šåŠ¨æ•°ç»„çš„è¯ è®°ä½ ç¬¬äºŒä¸ªå¾ªç¯çš„ä¸¤ä¸ªé¡ºåºï¼Œå¦‚æœæ˜¯å€’å™çš„è¯ åˆ™å°±æ˜¯è¦ä¿è¯æ¯ä¸€ä¸ªç‰©å“åªä¼šå–ä¸€æ¬¡ï¼Œä½†æ˜¯å¦‚æœæ˜¯æ­£åºçš„è¯ï¼Œé‚£ä¹ˆå°±ä¸éœ€è¦ä¿è¯ä¸Šé¢æ‰€è¯´çš„é¡ºåºäº†ã€‚ è€Œè¿™é‡Œå®˜æ–¹çš„è§£é‡Š å°±åœ¨è¿™é‡Œ ï¼š è®© v é€’å‡æ˜¯ä¸ºäº†ä¿è¯ç¬¬iæ¬¡å¾ªç¯ä¸­çš„çŠ¶æ€F[i;v]æ˜¯ç”±çŠ¶æ€F[i-1;v-Ci]é€’æ¨è€Œæ¥ã€‚ æ¢å¥è¯è¯´ï¼Œè¿™æ­£æ˜¯ä¸ºäº†ä¿è¯æ¯ä»¶ç‰©å“åªé€‰ä¸€æ¬¡ï¼Œä¿è¯åœ¨è€ƒè™‘â€œé€‰å…¥ç¬¬ i ä»¶ç‰©å“â€è¿™ä»¶ç­– ç•¥æ—¶ï¼Œä¾æ®çš„æ˜¯ä¸€ä¸ªç»æ— å·²ç»é€‰å…¥ç¬¬ i ä»¶ç‰©å“çš„å­ç»“æœF[i-1;v-Ci]ã€‚è€Œç°åœ¨å®Œå…¨èƒŒ åŒ…çš„ç‰¹ç‚¹æ°æ˜¯æ¯ç§ç‰©å“å¯é€‰æ— é™ä»¶ï¼Œæ‰€ä»¥åœ¨è€ƒè™‘â€œåŠ é€‰ä¸€ä»¶ç¬¬ i ç§ç‰©å“â€è¿™ç§ç­–ç•¥æ—¶ï¼Œ å´æ­£éœ€è¦ä¸€ä¸ªå¯èƒ½å·²é€‰å…¥ç¬¬ i ç§ç‰©å“çš„å­ç»“æœF[i;v-Ci]ï¼Œæ‰€ä»¥å°±å¯ä»¥å¹¶ä¸”å¿…é¡»é‡‡ç”¨v é€’å¢çš„é¡ºåºå¾ªç¯ã€‚è¿™å°±æ˜¯è¿™ä¸ªç®€å•çš„ç¨‹åºä¸ºä½•æˆç«‹çš„é“ç†ã€‚*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include&lt;cstdio&gt;using namespace std;int n, a, b, m;const int maxn = 110;int happiness[maxn], kaluli[maxn];int dp[110000];int main()&#123; while (~scanf("%d",&amp;n)) &#123; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d %d",&amp;happiness[i],&amp;kaluli[i]); &#125; scanf("%d",&amp;m); memset(dp,0,sizeof dp); for (int i = 1; i &lt;= n; i++) &#123; for (int j = kaluli[i]; j &lt;= m; j++) &#123; dp[j] = max(dp[j],dp[j - kaluli[i]] + happiness[i]); &#125; &#125; printf("%d\n",dp[m]); &#125; return 0;&#125; H.Piggy-Bankä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* è¿™é“é¢˜æ˜¯ä¸€ä¸ªå®Œå…¨èƒŒåŒ…çš„è£¸é¢˜ï¼Œå¯¹äºè¿™é“é¢˜è€Œè¨€æ›´åŠ ç¥å¥‡çš„åœ°æ–¹å°±åœ¨äºå…¶å®æ±‚æœ€å°å€¼è€Œä¸æ˜¯æ±‚æœ€å¤§å€¼ æ‰€ä»¥åœ¨æœ€å…ˆå¼€å§‹åˆå§‹åŒ–çš„æ—¶å€™ä¸åº”è¯¥å»åˆå§‹åŒ–ä¸º0ï¼Œè€Œåº”è¯¥åˆå§‹åŒ–ä¸ºæ— ç©·å¤§ è€Œåƒä¸‡ä¸è¦å¿˜è®°äº†å†åˆå§‹åŒ–çš„æ—¶å€™ä¸€å®šè¦å¯¹ç¬¬ä¸€ä¸ªçŠ¶æ€è¿›è¡Œä¸€ä¸ªå•ç‹¬èµ‹å€¼æ˜¯ç­‰äº0ï¼Œè¿˜æ˜¯ç­‰äºæ— ç©·å¤§ï¼Œè¿™ä¸ªç­‰åˆ°æ—¶å€™å†çœ‹ã€‚*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt; using namespace std;int _beg,_end;const int maxn = 505;int v[maxn],w[maxn];int dp[10010];int main()&#123; int T; cin &gt;&gt; T; while (T--) &#123; scanf("%d %d",&amp;_beg,&amp;_end); int bottle = _end - _beg; int n; scanf("%d",&amp;n); for (int i = 1; i &lt;= n; i++)&#123; scanf("%d %d",&amp;v[i],&amp;w[i]); &#125; memset(dp,0x3f3f3f3f,sizeof dp); dp[0] = 0; for (int i = 1; i &lt;= n;i ++) &#123; for (int j = w[i]; j &lt;= bottle; j++) &#123; dp[j] = min(dp[j],dp[j - w[i]] + v[i]); &#125; &#125; if (dp[bottle] != 0x3f3f3f3f) cout &lt;&lt; "The minimum amount of money in the piggy-bank is " &lt;&lt; dp[bottle] &lt;&lt; "." &lt;&lt; endl; else cout &lt;&lt; "This is impossible." &lt;&lt; endl; &#125; return 0;&#125; I.ç¾å…ƒçš„å›°æƒ‘ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425import java.util.Scanner;import java.math.BigInteger;public class Main &#123; public static void main(String[] args) &#123; int n,k; Scanner in = new Scanner(System.in); while (in.hasNext()) &#123; BigInteger[] dp = new BigInteger[1005]; n = in.nextInt(); k = in.nextInt(); dp[0] = new BigInteger("1"); for (int i = 1; i &lt;= n; i++) &#123; dp[i] = new BigInteger("0"); &#125; for (int i = 1; i &lt;= k; i++) &#123; for (int j = i; j &lt;= n; j++) &#123; dp[j] = dp[j].add(dp[j - i]); &#125; &#125; System.out.println(dp[n]); &#125; &#125;&#125; J.Coins123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/* è¿™é“é¢˜ç¥å¥‡çš„åœ°æ–¹å°±æ˜¯å°†å¤šé‡èƒŒåŒ…çš„è£¸é¢˜è¿›è¡Œäº†æ”¹å˜ï¼Œ ä¸»è¦å°±æ˜¯æ¯ä¸€æ¬¡å¢åŠ çš„ä»·å€¼ä¼šå‘ç”Ÿæ”¹å˜ï¼Œè¿™æ‰æ˜¯æœ€å…³é”®çš„åœ°æ–¹ã€‚ è¿™é‡Œçš„ä»·å€¼å°±ä¸å†æ˜¯ä¸ªæ•°ï¼Œè€Œæ˜¯è¿›è¡Œä¸€ä¸ªæ‰“è¡¨ï¼Œé€šè¿‡è¿™ä¸ªæ‰“è¡¨æ¥åˆ¤æ–­è¿™ä¸ªé‡é‡æ˜¯å¦èƒ½å¤Ÿè¾¾åˆ°ã€‚*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int n;int bag;bool dp[100040];int value[105],number[105];int cnt = 0;void zeroonepack(int weight, int value)&#123; for (int j = bag; j &gt;= weight; j--) &#123; if (!dp[j] &amp;&amp; dp[j - weight])&#123; dp[j] = true; cnt ++; &#125; &#125;&#125;//å®Œå…¨èƒŒåŒ…void completepack(int weight, int value)&#123; for (int j = weight; j &lt;= bag; j++) &#123; if (!dp[j] &amp;&amp; dp[j - weight]) &#123; dp[j] = true; cnt ++; &#125; &#125;&#125;//å¤šé‡èƒŒåŒ…void multilpack(int weight, int number, int value)&#123; //ç¬¬ä¸€ç§æƒ…å†µå°±æ˜¯ å¦‚æœè¿™ä»¶ç‰©å“æ‰€æœ‰çš„é‡é‡æ˜¯å°äºèƒŒåŒ…çš„é‡é‡çš„è¯ //é‚£ä¹ˆå¯¹äºèƒŒåŒ…è€Œè¨€ è¿™ä¸ªç‰©å“æ˜¯å¯ä»¥å–æ— é™å¤§ã€‚ if (bag &lt;= number * weight) &#123; completepack(weight, value); return; &#125; //è€Œè¶…è¿‡çš„è¿™ä¸ªèŒƒå›´çš„å°±åªèƒ½ä½¿ç”¨01èƒŒåŒ… ç„¶åä½¿ç”¨äºŒè¿›åˆ¶çš„æ–¹æ³• //å°†æ¯ä¸€ç±»å‹çš„èƒŒåŒ…è¿›è¡Œä¸€ä¸ªåˆ†ç»„ //åé¢å†ä¾æ¬¡åˆ†åˆ«ä½¿ç”¨å¤šé‡èƒŒåŒ…ã€‚ int k = 1; while (k &lt; number) &#123; zeroonepack(k * weight, k * value); number = number - k; k = k * 2; &#125; zeroonepack(number * weight, number * value);&#125;int main()&#123; while (cin &gt;&gt; n &gt;&gt; bag &amp;&amp; n &amp;&amp; bag) &#123; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; value[i]; &#125; for (int i = 1; i &lt;= n;i ++) &#123; cin &gt;&gt; number[i]; &#125; cnt = 0; memset(dp,0,sizeof dp); dp[0] = 1; for (int i = 1; i &lt;= n ;i ++) &#123; multilpack(value[i],number[i],value[i]); &#125; cout &lt;&lt; cnt &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>ä¹ é¢˜è§£æ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA 1013 ä¸¤ç§æ–¹æ³•è§£å†³ç‚¹ä¸è·¯å¾„çš„å…³ç³»]]></title>
    <url>%2F2019%2F07%2F24%2FPTA-1013-%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%E7%82%B9%E4%B8%8E%E8%B7%AF%E5%BE%84%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[è¿™é“é¢˜å¾ˆæœ‰è¶£ï¼Œè¿™é‡Œç›´æ¥è´´å‡ºé¢˜ç›®ã€‚ è¿™é“é¢˜çº¯ç²¹å°±æ˜¯ç»™å‡ºä¸€ç³»åˆ—è¾¹ä¸ç‚¹çš„å…³ç³»ï¼Œç„¶åå†å»æ‰ä¸€ä¸ªç‚¹ï¼Œçœ‹çœ‹å‰©ä½™éœ€è¦å¤šå°‘ä¸ªç‚¹æ‰èƒ½è¿æ¥æˆä¸€ä¸ªå®Œæ•´çš„å›¾ã€‚ ç¬¬ä¸€ç§æ–¹æ³•å¹¶æŸ¥é›†123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/* è¿™é“é¢˜æœ€å…ˆå¼€å§‹çœŸçš„æ˜¯ä¸çŸ¥é“ä½•ä»å…¥æ‰‹ï¼Œå› ä¸ºæœ¬èº«å¯¹äºå›¾è®ºçš„ç›¸å…³çŸ¥è¯†å¹¶ä¸æ˜¯ç‰¹åˆ«åœ¨è¡Œ è¿™é“é¢˜çš„ä¸¤ç§æ–¹æ³•ï¼Œç¬¬ä¸€å°±æ˜¯å¹¶æŸ¥é›†ï¼Œç¬¬äºŒå°±æ˜¯åˆ©ç”¨dfséå†å®Œæ‰€æœ‰éœ€è¦éå†çš„ç‚¹ã€‚*/#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cmath&gt;using namespace std;int N,M,K;const int maxn = 1005;int fa[maxn];//å†æ¬¡é”™åœ¨äº†è¿™ç§åœ°æ–¹ï¼ŒèŒƒå›´å°äº†ï¼Œè¿™é‡Œé¢˜ç›®è™½ç„¶å¹¶æ²¡æœ‰ç»™å‡ºç›¸åº”çš„èŒƒå›´//ä½†æ˜¯æŒ‰ç…§æ¯ä¸€æ¡è¾¹ä¹‹é—´çš„é“¾æ¥æ¥çœ‹ï¼Œè¿™é‡Œéœ€è¦åŠ å¤§å…¶çš„èŒƒå›´ã€‚pair&lt;int,int&gt; pp[maxn * maxn];void init() &#123; for (int i = 0; i &lt;= N; i++) &#123; fa[i] = i; &#125;&#125;int find(int x) &#123; if (fa[x] != x) fa[x] = find(fa[x]); return fa[x];&#125;void merge(int x,int y) &#123; int fx = find(x); int fy = find(y); if (fx != fy) &#123; fa[fx] = fy; &#125;&#125;int main()&#123; std::ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; N &gt;&gt; M &gt;&gt; K; int a,b; for (int i = 0; i &lt; M; i++) &#123; cin &gt;&gt; a &gt;&gt; b; pp[i].first = a; pp[i].second = b; &#125; int tmp; for (int i = 0; i &lt; K; i++) &#123; cin &gt;&gt; tmp; init(); for (int j = 0; j &lt; M; j++) &#123; if (pp[j].first != tmp &amp;&amp; pp[j].second != tmp) &#123; merge(pp[j].first,pp[j].second); &#125; &#125; int cnt = 0; for (int i = 1; i &lt;= N; i++) &#123; if (fa[i] == i) cnt++; &#125; if (N == 1) cout &lt;&lt; 0 &lt;&lt; endl; else if (N == 2) cout &lt;&lt; 0 &lt;&lt; endl; else cout &lt;&lt; cnt - 2 &lt;&lt; endl; &#125; return 0;&#125; ç¬¬äºŒç§æ–¹æ³• é€šè¿‡dfsæ·±æœåè¿›è¡Œæ ‡è®°1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 1008;int N,M,K;bool dis[maxn][maxn];bool vis[maxn];void dfs(int x) &#123; vis[x] = true; for (int i = 1; i &lt;= N; i++) &#123; if (vis[i] == false &amp;&amp; dis[x][i] == true) &#123; dfs(i); &#125; &#125;&#125;int main()&#123; std::ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; N &gt;&gt; M &gt;&gt; K; int a,b; memset(dis,false,sizeof dis); for (int i = 0; i &lt; M; i++) &#123; cin &gt;&gt; a &gt;&gt; b; dis[a][b] = dis[b][a] = true; &#125; int tmp; for (int i = 0; i &lt; K; i++) &#123; memset(vis,false,sizeof vis); cin &gt;&gt; tmp; vis[tmp] = true; int cnt = 0; for (int i = 1; i &lt;= N; i++) &#123; if (vis[i] == false) &#123; dfs(i); cnt++; &#125; &#125; cout &lt;&lt; cnt - 1 &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA 1010 äºŒåˆ†çš„åŸºæœ¬åº”ç”¨]]></title>
    <url>%2F2019%2F07%2F14%2FPTA-1010-%E4%BA%8C%E5%88%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[è¿™é“é¢˜ç›®æ˜¯ä¸€ä¸ªè¾¹ç•Œçš„äºŒåˆ†é—®é¢˜ï¼Œå¯ä»¥æŒ‰ç…§é¡ºåºè¿›è¡Œæ±‚è§£ï¼Œä½†æ˜¯åé¢æœ‰é—®é¢˜ä¼šå‡ºé”™ï¼Œç„¶åæ›´åŠ å‘çˆ¹çš„æ˜¯ï¼Œæœ€å‰é¢çš„å‰ç½®æ¡ä»¶éœ€è¦å¼„æ¸…æ¥š ç›´æ¥è´´å‡ºä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cmath&gt;using namespace std;long long to_num(const string &amp;b,long long radix) &#123; long long res = 0; int lenb = b.size() - 1; for (int i = 0; i &lt; b.size();i++) &#123; if (b[i] &gt;= '0' &amp;&amp; b[i] &lt;='9') &#123; res += (b[i] - '0') * pow(radix,lenb--); &#125; else &#123; res += (b[i] - 'a' + 10) * pow(radix,lenb--); &#125; if (res &lt; 0) return -1; &#125; return res;&#125;int main()&#123; std::ios::sync_with_stdio(false); string a,b; int tag; long long radix; cin &gt;&gt; a &gt;&gt; b &gt;&gt; tag &gt;&gt; radix; if (a == b) &#123; cout &lt;&lt; radix &lt;&lt; endl; return 0; &#125; if (tag == 2) &#123; swap(a,b); &#125; long long tmp = 0; int len = a.size() - 1; for (int i = 0; i &lt; a.size(); i++) &#123; if (a[i] &gt;= '0' &amp;&amp; a[i] &lt;='9') &#123; tmp += (a[i] - '0') * pow(radix,len--); &#125; else &#123; tmp += (a[i] - 'a' + 10) * pow(radix,len--); &#125; &#125; int Max = -1; int mm; for (int i = 0; i &lt; b.size(); i++) &#123; if (b[i] &gt;= '0' &amp;&amp; b[i] &lt;='9') &#123; mm = b[i] - '0'; &#125; else &#123; mm = b[i] - 'a' + 10; &#125; Max = max(Max,mm); &#125; int lenb = b.size() - 1; bool flag = false; //å°±æ˜¯è¿™é‡Œå…³äºè¾¹ç•Œçš„é—®é¢˜ï¼ŒçœŸçš„è¦æŠŠæˆ‘ææ­»äº† // è¿™é‡Œçš„ç¬¬ä¸€ä¸ªæ ·ä¾‹å°±æ˜¯ å°±åº”è¯¥æ˜¯ä»–çš„å€¼å°äºå…¶çš„è¾¹ç•Œï¼Œæ­£å¥½å°±æ˜¯ Max ç­‰äº2çš„æ—¶å€™ã€‚ //å°†ä¸¤ä¸ªè¾¹ç•Œå€¼ç»™å¼„æ¸…æ¥šã€‚ long long low = Max + 1; long long high = max(tmp,low); long long mid = -1; while (low &lt;= high) &#123; mid = (low + high) &gt;&gt; 1; long long tp = to_num(b,mid); if (tp == -1 || tp &gt; tmp) &#123; high = mid - 1; &#125; else if (tp &lt; tmp) low = mid + 1; else if (tp == tmp) &#123; flag = true; break; &#125; &#125; /* è¿™é‡Œå…¶å®æ˜¯ä¸€ä¸ªé¡ºåºæŸ¥æ‰¾çš„è¿‡ç¨‹ï¼Œä½†æ˜¯ç”±äºå¾ªç¯æ¬¡æ•°å¤ªå¤šï¼Œæ‰€ä»¥å¿…é¡»è¿›è¡ŒäºŒåˆ†ä¼˜åŒ–ã€‚ for (ans = Max; ans &lt;= tmp; ans++) &#123; res = 0; for (int i = 0; i &lt; b.size();i++) &#123; if (b[i] &gt;= '0' &amp;&amp; b[i] &lt;='9') &#123; res += (b[i] - '0') * pow(ans,lenb--); &#125; else &#123; res += (b[i] - 'a' + 10) * pow(ans,lenb--); &#125; &#125; if (tmp == res) &#123; flag = true; break; &#125; &#125;*/ if (flag == true &amp;&amp; mid &gt;= 1) cout &lt;&lt; mid &lt;&lt; endl; else cout &lt;&lt; "Impossible" &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA 1007 æœ€å¤§åºåˆ—å’Œé—®é¢˜]]></title>
    <url>%2F2019%2F07%2F13%2FPTA-1007-%E6%9C%80%E5%A4%A7%E5%BA%8F%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[è¿™é“é¢˜æ˜¯ä¸€é“ç®€å•çš„åŠ¨æ€è§„åˆ’ï¼Œå¯èƒ½æ˜¯å¤ªä¹…æ²¡æœ‰åšè¿™æ–¹é¢çš„é¢˜ç›®äº†ï¼Œæ€»æ˜¯å¯¹è¿™ä¸€éƒ¨åˆ†å¿˜è®°ï¼Œå…¶å®æœ€ç»ˆç»“æœå°±æ˜¯ä¸€ä¸ªè´ªå¿ƒè§£å†³é—®é¢˜ã€‚ è´´å‡ºä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/* å…¶å®è¿™é“é¢˜ä¹Ÿç®—æ˜¯ä¸€é“ç‰¹åˆ«ç®€å•çš„é¢˜ç›®ï¼Œè¿˜æ˜¯åŠ¨æ€è§„åˆ’é‡Œé¢æœ€åŸºç¡€çš„é—®é¢˜ï¼Œä½†æ˜¯æ€»æ˜¯å®¹æ˜“å»å¼„æ··ã€‚ è®°å¾—è‡ªå·±å½“æ—¶çš„é—®é¢˜å°±åœ¨äº è¿™é‡Œæ¯ä¸€æ¬¡ç›¸åŠ çš„å’Œï¼Œå¦‚ä½•ä¿è¯åé¢åŠ äº†è´Ÿæ•°ä¹‹åï¼Œå†æ¬¡åŠ ä¸Šä¸€ä¸ªæ­£æ•°ä¸è¢«å½±å“å‘¢ï¼Œ ä¸‹é¢çš„æ³¨é‡Šé‡Œé¢æœ‰å†™ï¼Œ å› ä¸ºé¢˜ç›®ä¸­é™åˆ¶äº†ï¼Œå¦‚æœè¿™é“é¢˜æœ‰å¤šä¸ªç­”æ¡ˆï¼Œæ¯”å¦‚è¯´ å‰é¢ä¸åé¢ç›¸åŠ ä¸ºé›¶ï¼Œä½†æ˜¯åé¢çš„é‚£ä¸ªæ­£æ•°æ­£å¥½ä½œä¸ºæœ€åçš„æ­£ç¡®ç­”æ¡ˆçš„è¯ æ¯”å¦‚ 1 2 -3 8 1 2 -3 æ­£å¥½ç›¸åŠ ä¸º0 ä½†æ˜¯é¢˜ç›®ä¸­è¦æ±‚çš„ åºåˆ— 1 2 -3 8 ä½œä¸ºæœ€åçš„ç»“æœåºåˆ—ã€‚ è‡ªå·±å½“æ—¶ä¹Ÿåœ¨è¿™ä¸€å—ä¸Šé¢çº ç»“ã€‚*/#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; std::ios::sync_with_stdio(false); int m; cin &gt;&gt; m; int num[m + 5]; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; num[i]; &#125; int left = 0; int tmpleft = 0; int right = m - 1; int tmp = 0; int Max = -1; for (int i = 0; i &lt; m; i ++) &#123; tmp += num[i]; //In case that the maximum subsequence is not unique, //output the one with the smallest indices i and j (as shown by the sample case). if (tmp &lt; 0) &#123; tmp = 0; tmpleft = i + 1; &#125; else if (tmp &gt; Max) &#123; Max = tmp; right = i; left = tmpleft; &#125; &#125; //If all the K numbers are negative, then its maximum sum is defined to be 0, //and you are supposed to output the first and the last numbers of the whole sequence. if (Max &gt;= 0) cout &lt;&lt; Max &lt;&lt; " " &lt;&lt; num[left] &lt;&lt; " " &lt;&lt; num[right] &lt;&lt; endl; else cout &lt;&lt; 0 &lt;&lt; " " &lt;&lt; num[0] &lt;&lt; " " &lt;&lt; num[m - 1] &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA 1004 ç®€å•çš„dfs]]></title>
    <url>%2F2019%2F06%2F27%2FPTA-1004-%E7%AE%80%E5%8D%95%E7%9A%84dfs%2F</url>
    <content type="text"><![CDATA[è¿™é‡Œç›´æ¥è´´å‡ºé¢˜ç›®ï¼š ä»£ç å¦‚ä¸‹ï¼š12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;cmath&gt;using namespace std;int n,m;vector&lt;int&gt; kids[105];int maxlever = 0;int nums[105];void dfs(int root,int depth) &#123; if (kids[root].size() == 0) &#123; maxlever = max(depth,maxlever); nums[depth]++; return; &#125; for (int i = 0; i &lt; kids[root].size() ; i++) &#123; dfs(kids[root][i],depth + 1); &#125;&#125;int main()&#123; std::ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; int fa,num; int tmp; memset(nums,0,sizeof nums); for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; fa &gt;&gt; num; for (int i = 0 ; i &lt; num; i ++) &#123; cin &gt;&gt; tmp; kids[fa].push_back(tmp); &#125; &#125; dfs(1,0); cout &lt;&lt; nums[0] ; for (int i = 1; i &lt;= maxlever; i++ ) &#123; cout &lt;&lt; " " &lt;&lt; nums[i]; &#125; cout &lt;&lt; endl; return 0;&#125; æˆ‘å¯èƒ½æ˜¯å¤ªä¹…æ²¡æœ‰å†™ä»£ç äº†ï¼Œä¸Šé¢è¿™æ ·ä¸€é“æ°´é¢˜ï¼Œæˆ‘å…ˆå¼€å§‹å°±è¢«å®Œå®Œå…¨å…¨çš„å¼„ç³Šæ¶‚äº†ï¼Œè¿™é“é¢˜å°±æ˜¯ä¸€ä¸ªç®€å•çš„dfsï¼Œé¦–å…ˆå…ˆæŠŠæ•°ä¹‹é—´çš„å¯¹åº”å…³ç³»ä¸€ç‚¹ä¸€ç‚¹çš„æ‰“é€šï¼Œç„¶åå†æ ¹æ®åé¢dfsçš„é€’å½’å¯ä»¥å¾—å‡ºæ¥ï¼Œå°±æ˜¯ä¸€ä¸ªç®€å•çš„æ ¹æ®æ ¹èŠ‚ç‚¹ä¸€ç‚¹ä¸€ç‚¹çš„å¾€åé¢é€’å½’æœç´¢ï¼Œç„¶åè¾¾åˆ°ç»ˆç‚¹ä¹‹åï¼Œè®°å¾—æŠŠè¿™ä¸€ä¸ªå±‚çš„å¶å­ç»“ç‚¹æ•°åŠ ä¸€ï¼Œè¿™é‡Œæ³¨æ„ä¸¤ç‚¹ï¼Œå¯ä»¥å‘ç° åœ¨cinçš„å¤„ç†é‡Œé¢ï¼Œå¯ä»¥ç›´æ¥å°†00ï¼Œ01ï¼Œ02ï¼Œç›´æ¥å˜æˆç›¸åº”çš„0ï¼Œ1ï¼Œ2ï¼›]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA 1003 Dijkstra ---- å…³äºDijkstraå•æºæœ€çŸ­è·¯çš„ç›¸åº”æ€»ç»“]]></title>
    <url>%2F2019%2F06%2F25%2FPTA-1003-Dijkstra-%E5%85%B3%E4%BA%8EDijkstra%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%9A%84%E7%9B%B8%E5%BA%94%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[é¦–å…ˆ è¿™é‡Œå…ˆè´´å‡ºé¢˜ç›® è§£é¢˜ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 505;const int inf = 0x3f3f3f3f;int n,m,_beg,_end;int people[maxn];bool vis[maxn];int _map[maxn][maxn];int dis[maxn];int paths[maxn];int Maxvalue[maxn];void Dijkstra(int beg) &#123; memset(dis,inf,sizeof dis); memset(vis,false,sizeof vis); dis[beg] = 0; paths[beg] = 1; Maxvalue[beg] = people[beg]; for (int i = 0; i &lt; n; i++) &#123; int Min = 0x3f3f3f, index = -1; for (int j = 0; j &lt; n; j++) &#123; if (!vis[j] &amp;&amp; dis[j] &lt; Min) &#123; Min = dis[j]; index = j; &#125; &#125; if (index == -1) break; vis[index] = true; for (int j = 0; j &lt; n; j++) &#123; if (!vis[j] &amp;&amp; _map[index][j] != inf) &#123; if (dis[index] + _map[index][j] &lt; dis[j]) &#123; dis[j] = dis[index] + _map[index][j]; paths[j] = paths[index]; Maxvalue[j] = Maxvalue[index] + people[j]; &#125; else if (dis[index] + _map[index][j] == dis[j]) &#123; paths[j] += paths[index]; Maxvalue[j] = max(Maxvalue[j],Maxvalue[index] + people[j]); &#125; &#125; &#125; &#125;&#125;int main()&#123; std::ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; _beg &gt;&gt; _end; for (int i = 0 ; i &lt; n; i++) &#123; cin &gt;&gt; people[i]; &#125; int x,y,val; memset(_map,inf,sizeof _map); for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; val; _map[x][y] = val; _map[y][x] = val; &#125; Dijkstra(_beg); cout &lt;&lt; paths[_end] &lt;&lt; " " &lt;&lt; Maxvalue[_end] &lt;&lt; endl; return 0;&#125; è¿™é‡Œæ˜æ˜¾å°±æ˜¯å…³äºDijkstraçš„è£¸é¢˜ï¼Œå˜åŒ–çš„åœ°æ–¹å°±æ˜¯åŠ äº†ä¸€ä¸¤ä¸ªå†…ç½®æ•°ç»„ï¼Œä½œä¸ºçŠ¶æ€çš„å˜åŒ–ï¼Œç±»ä¼¼äºåŠ¨æ€è§„åˆ’ï¼Œåˆ°åé¢å°±å¯ä»¥è§£é¢˜è§£å‡ºæ¥äº†ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ•°è®ºæ€»ç»“]]></title>
    <url>%2F2019%2F05%2F06%2F%E6%95%B0%E8%AE%BA%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[æ•°è®ºæ€»ç»“æ¥è‡ªè¥¿åŒ—å·¥ä¸šå¤§å­¦çš„è®²ä¹‰ä»¥åŠé¢˜ç›®çš„æ€»ç»“ ç´ æ•°è¿ç®—å®éªŒèŒƒä¾‹è¿™é‡Œå°†çš„å°±æ˜¯ä¸ç´ æ•°ç›¸å…³çš„ç­›æ³•ï¼Œè¿™é‡Œä»‹ç»ä¸¤ç§ç­›æ³•ã€‚ ç´ æ•°çš„çº¿æ€§ç­›æ³•åŸƒå¼ç­›æ³•12345678910111213141516//æœ€æ™®é€šçš„åŸƒå¼ç­›æ³•memset(check, 0, sizeof(check));int tot = 0;for (int i = 2; i &lt;= n; ++i)&#123; if (!check[i]) &#123; prime[tot++] = i; &#125; // ä¸‹é¢å…¶å®ç”¨ä¹˜æ³•å’Œç”¨åŠ æ³•éƒ½æ˜¯ä¸€æ ·çš„ï¼Œè€Œè¿™é‡Œå°±æ˜¯ä¹˜æ³•çš„åŸå› å°±åœ¨äºï¼Œå‡å°‘äº†å¾ªç¯æ¬¡æ•° // å”¯ä¸€æ²¡æœ‰è¢«ä¼˜åŒ–çš„åœ°æ–¹å°±åœ¨äº æ¯ä¸€ä¸ªæ•°å­—è¢«é‡å¤æ ‡è®°äº†å¾ˆå¤šæ¬¡ï¼Œè€Œåé¢çš„æ¬§æ‹‰ç­›å°±ä¼šé™åˆ¶æ ‡è®°æ¬¡æ•°ä¸ºä¸€æ¬¡ for (int j = i * i; j &lt;= n; j *= i) &#123; check[j] = 1; &#125;&#125; æ¬§æ‹‰ç­›æ³• 12345678910111213141516171819202122232425262728293031//è¿›é˜¶ç‰ˆçš„çº¿æ€§ç­›æ³•//è´¨æ•°æ•°ç»„int prime[MAXN];//åˆ¤æ–­æ¯ä¸€ä¸ªæ•° æ•°ç»„int check[MAXL];int tot = 0;memset(check, 0, sizeof(check));for (int i = 2; i &lt; MAXL; ++i)&#123; if (!check[i]) &#123; prime[tot++] = i; &#125; for (int j = 0; j &lt; tot; ++j) &#123; //å¤§è‡´æ„æ€å°±åœ¨äº å°†æ¯ä¸€ä¸ªæ•°çš„ä¸è´¨æ•°æ•°ç»„é‡Œé¢çš„æ•°è¿›è¡Œç›¸ä¹˜ï¼Œæœ€åå¾—åˆ°çš„ç»“æœå­˜åœ¨checkä¸­å» //éœ€è¦æ³¨æ„çš„å°±æ˜¯ ä¸€æ—¦å½“å‰çš„æ•°èƒ½è¢«æ•´é™¤çš„æ—¶å€™ å°±ç«‹é©¬é€€å‡ºï¼Œè¿™æ ·ä»£è¡¨æ¯ä¸€ä¸ªæ•°å­—éƒ½ä¼šè¢«è‡ªå·±çš„æœ€å°è´¨å› æ•°ç»™æ•´é™¤å‡ºæ¥ã€‚ if (i * prime[j] &gt; MAXL) &#123; break; &#125; check[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; break; &#125; &#125;&#125; ç„¶åä¸‹é¢å°±ç”±ä¸Šé¢ä¸¤ç§çº¿æ€§ç­›æ³•å¼•ç”³å‡ºæ¥ä¸‹é¢ä¸¤ä¸ªç»“è®º æ¯ä¸€ä¸ªå¤§äº4çš„å¶æ•°å¯ä»¥å†™æˆä¸¤ä¸ªå¥‡ç´ æ•°çš„å’Œã€‚(poj 2262) æ¯ä¸€ä¸ªå¤§äº8çš„æ•°å­—å¯ä»¥åˆ†ä¸º4ä¸ªç´ æ•°çš„å’Œã€‚(uva 10168) å¤§ç´ æ•°çš„å®éªŒèŒƒä¾‹ä¸€èˆ¬è¿™é‡Œè¿˜å­˜åœ¨ä¸€äº›è¶…è¿‡ç»™å‡ºçš„ç´ æ•°è¡¨çš„èŒƒå›´ï¼Œæˆ–è€…æ˜¯æ‰“è¡¨åˆ°é‚£ä¸ªåœ°æ–¹ä¸€å®šä¼šåè¶…ä¹‹ç±»çš„é¢˜ç›®ï¼Œè¿™é‡Œéƒ½ä½¿ç”¨ä¸€ç§ç±»ä¼¼äºåŒºé—´ç­›æ³•çš„åŠæ³•å»è§£å†³é—®é¢˜ã€‚ æ¯”å¦‚ uva 10871: æ‰“å‡º 2 åˆ° æ ¹å·nèŒƒå›´çš„è¡¨ï¼Œç„¶åè¶…è¿‡è¿™ä¸ªèŒƒå›´çš„æ•°ï¼Œå¯¹äºè¿™ä¸ªæ•°é‡Œé¢çš„æ•°å…¨éƒ¨å»é™¤ä»¥å‰é¢æ‰“è¡¨äº§ç”Ÿçš„ç´ æ•°è¡¨ï¼Œçœ‹èƒ½ä¸èƒ½é™¤å°½ï¼Œæ¥åˆ¤æ–­è¿™ä¸ªå¤§æ•´æ•°æ˜¯å¦æ˜¯ç´ æ•°ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122/* è¿™é“é¢˜ å…¶å®åˆ©ç”¨äº†ç´ æ•°è¡¨ä¹‹åï¼Œå°±æ˜¯ä¸€ä¸ªä¸€æ¬¡éå†çš„è¿‡ç¨‹äº† ä¸è¿‡æˆ‘æ²¡æœ‰æƒ³åˆ°çš„æ˜¯ï¼Œ è¿™é“é¢˜å…¶å®å·²ç»æå‰å°†æ¯ä¸€ä¸ªsumç»™è®°å½•ä¸‹æ¥äº†ï¼Œå°±ç›¸å½“äºä¸€ä¸ªæ‰“è¡¨çš„æ–¹å¼ã€‚ å¦å¤–è¿™é“é¢˜ç¬¬äºŒä¸ªçˆ†ç‚¹å°±åœ¨äº å½“è¶…å‡ºäº†è¡¨èŒƒå›´å†…çš„å¤§æ•°æ€ä¹ˆåŠï¼Œè¿™é‡Œå°±å¯ä»¥ç”¨åˆ†ä¸¤ç§ï¼Œç¬¬ä¸€ç§æ˜¯åœ¨è¿™ç§æƒ…å†µçš„ç›´æ¥çœ‹è¡¨ï¼Œ å¦å¤–ä¸€ç§å°±æ˜¯ç”¨ è¿™ä¸ªæ•°å»mod è¡¨å†…çš„æ¯ä¸€ä¸ªè´¨æ•°ï¼Œè¿™æ ·å¯ä»¥åŠ å¿«æ—¶é—´ã€‚*/#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 10011;bool u[maxn];int su[maxn];int num = 0;void prepare()&#123; int i, j; memset(u, true, sizeof(u)); for (i = 2; i &lt; maxn; ++i) &#123; if (u[i]) &#123; su[++num] = i; &#125; for (j = 1; j &lt;= num; ++j) &#123; if (i * su[j] &gt; maxn) &#123; break; &#125; u[i * su[j]] = false; if (i % su[j] == 0) &#123; break; &#125; &#125; &#125;&#125;bool pri(int x)&#123; if (x &lt;= 10010) &#123; return u[x]; &#125; int i; for (i = 1; i &lt;= num; ++i) &#123; if (x % su[i] == 0) &#123; return false; break; &#125; &#125; return true;&#125;int main()&#123; prepare(); int t; scanf("%d", &amp;t); while (t--) &#123; int n; scanf("%d", &amp;n); int i, j; int s[n + 1]; s[0] = 0; for (i = 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;s[i]); s[i] += s[i - 1]; &#125; bool ok = false; for (i = 2; i &lt;= n; ++i) &#123; for (j = 1; j + i - 1 &lt;= n; ++j) &#123; int k = s[i + j - 1] - s[j - 1]; if (pri(k)) &#123; ok = true; printf("Shortest primed subsequence is length %d:", i); for (k = 1; k &lt;= i; ++k) &#123; printf(" %d", s[j + k - 1] - s[j + k - 2]); &#125; printf("\n"); break; &#125; &#125; if (ok) &#123; break; &#125; &#125; if (!ok) &#123; printf("This sequence is anti-primed.\n"); &#125; &#125; return 0;&#125; æ±‚è§£ä¸å®šæ–¹ç¨‹å’ŒåŒä½™çš„å®éªŒèŒƒä¾‹è¿™ä¸€ä¸ªç« èŠ‚çš„ä¸œè¥¿åŸºæœ¬ä¸Šå¯ä»¥è¯´æ˜¯å¥ å®šäº†æ•°è®ºçš„åŸºç¡€ï¼Œæ‰€ä»¥è¿™éƒ¨åˆ†çš„ä¸œè¥¿è¯·åŠ¡å¿…æŒæ¡ã€‚ é¦–å…ˆè¿™é‡Œå…ˆè´´å‡º gcd å’Œ exgcdçš„ä»£ç  æ¬§å‡ é‡Œå¾—ç®—æ³•1234int gcd(int a,int b) &#123; if (b == 0) retuan a; return gcd(b,a % b);&#125; exgcd æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•12345678910111213int exgcd (int a,int b, int &amp;x,int &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; int t = exgcd(b,a % b,x,y); int d = x; x = y; y = d - (a / b) * y; return t;&#125; æ¬§å‡ é‡Œå¾—ç®—æ³•æ˜¯ç”¨æ¥æ±‚è§£æœ€å¤§å…¬çº¦æ•°çš„ç”±æ¬§å‡ é‡Œå¾—å…¬å¼æ¨å‡º å¦‚æœ aä¸b äº’ç´ ï¼Œé‚£ä¹ˆb * t + a ä¸ b ä¹Ÿä¸€å®šäº’ç´ ã€‚ è¿™é‡Œè´´å‡ºä¸€é“é¢˜ å°±æ˜¯å¯¹äºä¸Šé¢gcdå…¬å¼çš„å‘¨æœŸæ€§çš„åˆ©ç”¨ happy poj 2773 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* è¿™é“é¢˜ç›®å°±æ˜¯åœ¨äºå¯¹äºgcdçš„å‘¨æœŸæ€§çš„ä½¿ç”¨ã€‚ è¿™é“é¢˜å°±åˆ©ç”¨äº†ä¸mäº’ç´ çš„æ•°å¯¹må»è†œå…·æœ‰å‘¨æœŸæ€§*/#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;int s[1000005];int gcd(int a, int b)&#123; if (b == 0) &#123; return a; &#125; else &#123; return gcd(b, a % b); &#125;&#125;int main()&#123; int m, k; while (scanf("%d%d", &amp;m, &amp;k) != EOF) &#123; int i; int num = 0; for (i = 1; i &lt;= m; i++) &#123; if (gcd(m, i) == 1) &#123; s[num++] = i; &#125; &#125; //è¿™é‡Œå…¶å®è¿›è¡Œäº†ä¸¤ç§æƒ…å†µï¼šä¸€ç§åˆšå¥½é™¤å°½çš„æƒ…å†µï¼Œ //å’Œå¦å¤–ä¸€ç§æ²¡æœ‰åˆšå¥½é™¤å°½çš„æƒ…å†µã€‚ if (k % num == 0) &#123; //è¿™é‡Œå‡ä¸€çš„ç›®çš„æ˜¯åˆšåˆšå¥½é™¤å°½ï¼Œå‡å»ä¸€ä¸ªåé¢å¥½åŠ ä¸Šä¸€ä¸ªai; printf("%d\n", (k / num - 1) * m + s[num - 1]); &#125; else &#123; //åé¢çš„åˆ™å°±ä½“ç°åœ¨äº†ä½™æ•°è¿™ä¸ªåœ°æ–¹ã€‚ï¼Œä¹‹æ‰€ä»¥å‡å»1æ˜¯å› ä¸ºnumä¸å¯èƒ½ç®—ä¸Šçš„æœ€åä¸€ä¸ª printf("%d\n", k / num * m + s[k % num - 1]); &#125; &#125; return 0;&#125; æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•æ˜¯ç”¨æ¥æ±‚æœ€å¤§å…¬çº¦æ•°å’Œä¸å®šæ–¹ç¨‹çš„é€šè§£ è¿™é‡ŒåŒæ ·ä¹Ÿè´´å‡ºä¸€é“æ¨¡æ¿æ ·é¢˜ä½œä¸ºç¤ºèŒƒ The Balance poj 2142 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/* è¿™é“é¢˜å°±åœ¨äºå…¶å¾ˆå‰å®³çš„æ˜¯ è§£é‡Šäº†ecgcdçš„çœŸæ­£çš„ç”¨é€”ã€‚ è¿™é“é¢˜è¯´éš¾ä¹Ÿä¸æ˜¯å¾ˆéš¾ï¼Œåªæ˜¯æ•™ä¼šäº†ä¸€äº›æ•°è®ºé¢˜ç›®å…¨éƒ¨çš„ä»£ç è¯¥å¦‚ä½•å»å†™ã€‚ å…¸å‹çš„æ±‚ ä¸å®šæ–¹ç¨‹çš„åšæ³• ax + by = d; æ±‚è§£ ä¸€ä¸ª xï¼Œy çš„æ»¡è¶³æ¡ä»¶çš„ç‰¹è§£ã€‚ è¿™é‡Œå†™ä¸€ä¸‹æ±‚è§£æ­¥éª¤ ï¼š ç¬¬ä¸€æ­¥ é¦–å…ˆå…ˆå¾—å‡ºè¿™ä¸ªæ–¹ç¨‹ï¼Œç„¶åå¯¹æ–¹ç¨‹ä¸¤è¾¹åŒæ—¶é™¤ä»¥gcd(a,b); åœ¨æ­¥å…¥ç¬¬äºŒæ­¥çš„è¿‡ç¨‹ä¸­æœ‰ä¸€ä¸ªåˆ¤æ–­ å°±æ˜¯çœ‹d å¯¹äº gcd(a,b)çš„æ¯”è¾ƒæƒ…å†µï¼Œå†³å®šè¿™ä¸ªä¸å®šæ–¹ç¨‹æ˜¯å¦æœ‰è§£ï¼› ç¬¬äºŒæ­¥ å°±æ˜¯ç›´æ¥ç”¨æœªåˆå§‹åŒ–çš„ x,y å¸¦å…¥exgcdæ±‚è§£ å¯ä»¥å¾—åˆ°ä¸€ä¸ª x,yçš„å…¶ä¸­ä¸€ä¸ªç‰¹è§£ ç¬¬ä¸‰æ­¥ å°†å¾—åˆ°çš„ç‰¹è§£ä¹˜ä»¥ç›¸åº”çš„æ‰©å¤§çš„d_å€ï¼Œæœ€åæŒ‰ç…§é¢˜ç›®è§„å®šçš„æ¡ä»¶è¿›è¡Œæ•´æ”¹æœ€ç»ˆå¾—å‡ºç»“æœ å…¶ä¸­éœ€è¦æ³¨æ„çš„æ˜¯ ä¸Šé¢å¾—åˆ°çš„ç‰¹è§£ï¼Œåªæœ‰åœ¨ax + by æ­£å¥½ç­‰äºgcd(a,b)çš„æ—¶å€™ æ‰ä¼šåŒæ—¶æ»¡è¶³ã€‚*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;int gcd(int a,int b) &#123; if (b == 0) return a; return gcd(b,a % b);&#125;int exgcd(int a,int b,int &amp;x,int &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; int t = exgcd(b,a % b,x,y); int _x = x; int _y = y; x = _y; y = _x - (a/b) * _y; return t;&#125;int a,b,d;int a_,b_,d_;int x,y;//é€šè§£int q;int x1,x2,y1,y2;int main()&#123; while (scanf("%d %d %d",&amp;a,&amp;b,&amp;d) &amp;&amp; a &amp;&amp; b &amp;&amp; d) &#123; q = gcd(a,b); a_ = a / q; b_ = b / q; d_ = d / q; int k = exgcd(a_,b_,x,y); x1 = x * d_; x1 = (x1 % b_ + b_) % b_; y1 = (d - x1 * a) / b; if (y1 &lt; 0) y1 = -y1; y2 = y * d_; y2 = (y2 % a_ + a_) % a_; x2 = (d - y2 * b) / a; if (x2 &lt; 0) x2 = -x2; if (x1 + y1 &lt; x2 + y2) printf("%d %d\n",x1,y1); else printf("%d %d\n",x2,y2); &#125; return 0;&#125; è¿™é‡Œè¿˜æ˜¯è®²æ±‚è§£ä¸å®šæ–¹ç¨‹çš„æ­¥éª¤å†è¯¦ç»†çš„è¿‡ä¸€é å¾—åˆ°ä¸å®šæ–¹ç¨‹ax + by = mï¼Œå…ˆåˆ¤æ–­ m æ˜¯å¦æ˜¯gcd(a,b)çš„å€æ•°ï¼Œå¦‚æœæ˜¯è¯´æ˜æ–¹ç¨‹æœ‰è§£ï¼Œå¦‚æœä¸æ˜¯æ–¹ç¨‹åˆ™æ²¡æœ‰è§£ æœ‰è§£ä¹‹åï¼Œæ–¹ç¨‹ä¸¤è¾¹åŒæ—¶é™¤ä»¥gcd(a,b)ï¼Œç„¶åå°†é‡æ–°å¾—åˆ°çš„a,bå€¼å¸¦å…¥åˆ°æ‰©å±•æ¬§å‡ é‡Œå¾—çš„æ–¹ç¨‹å¼ä¸­å¾—åˆ°ä¸¤ä¸ªé€šè§£x,yï¼Œ éœ€è¦å°†å¾—åˆ°çš„x æˆ–è€… y å€¼ æ‰©å¤§ ç»é™¤åçš„må€¼ï¼Œå› ä¸ºæ‰©å±•æ¬§å‡ é‡Œå¾—æ±‚çš„ä¸å®šæ–¹ç¨‹é»˜è®¤å°±æ˜¯ç­‰äº1çš„ã€‚å¯¹äºè¿™é“é¢˜è€Œè¨€ï¼Œæƒ³è¦æ±‚æœ€å°çš„æ­£æ•´æ•°çš„é€šè§£ï¼Œäºæ˜¯å°± (x % b + b) % b, è¿™é‡Œå°±æ˜¯é˜²æ­¢C++å–ä½™å¸¦æ¥çš„è´Ÿæ•°å½±å“ã€‚ ä¸‹é¢è¿˜æœ‰ä¸€é“é¢˜ ä¹Ÿæ˜¯æ±‚å‡ºä¸å®šæ–¹ç¨‹çš„è§£ï¼Œä½†æ˜¯æœ‰ä¸€ç‚¹ç‚¹ä¸åŒã€‚ One Person Game zoj3593 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/* è¿™é‡Œçš„ä¸ä¸Šé¢ä¸€é“é¢˜ä¸ä¸€æ ·çš„åœ°æ–¹å°±åœ¨äº åé¢é™åˆ¶æ¡ä»¶ä¸å¤ªç›¸åŒã€‚ å‰é¢ä¸€é“é¢˜ä¸Šé¢æ±‚å‡ºçš„ä¸€ä¸ªç‰¹è§£ï¼Œä½†æ˜¯ å–modä¹‹åå¾—åˆ°çš„ç»“æœï¼Œ æ‰€ä»¥ç”¨æ”¹å˜åçš„å˜é‡å€¼ï¼Œæ¥æ±‚å¦å¤–ä¸€ä¸ªã€‚ è€Œè¿™é“é¢˜ä¸ä¸€æ ·çš„æ˜¯æ˜¯é€šè¿‡æ±‚è§£ç­”æ¡ˆ ç„¶å æ ¹æ®ç‰¹è§£æ¥ç®—ç»“æ„æ¥ç®—ã€‚*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;long long _beg,_end,a,b;const long long inf = 0x3f3f3f3f;long exgcd(long long a,long long b,long long &amp;x,long long &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; long long t = exgcd(b,a % b,x,y); int x_ = x; int y_ = y; x = y_; y = x_ - (a / b) * y_; return t;&#125;int main()&#123; int T; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; _beg &gt;&gt; _end &gt;&gt; a &gt;&gt; b; long long res = _end - _beg; long long d,x,y; d = exgcd(a,b,x,y); if (res % d != 0) &#123; cout &lt;&lt; -1 &lt;&lt; endl; continue; &#125; x *= res / d; y *= res / d; a = a / d; b = b / d; long long ans = inf * inf,tmp; long long mid = (y - x) / (a + b); for (int i = mid - 1; i &lt;= mid + 1; i++) &#123; long long x1 = x + i * b; long long y1 = y - i * a; if (x1 * y1 &gt;= 0) tmp = max(abs(x1),abs(y1)); else tmp = abs(x1 - y1); ans = min(ans,tmp); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; è¿™é“é¢˜ä¸ä¸€æ ·çš„æ˜¯ ä»–ä¸æ˜¯åƒå‰é¢æ±‚å‡ºé€šè§£ä¹‹åæ±‚ä¸€ä¸ªæœ€å°æˆ–è€…æœ€å¤§ï¼Œæˆ‘çš„ç†è§£å°±æ˜¯ å› ä¸º å…¶ç®—å‡ºæ¥çš„é€šè§£ä¸º x = xo + k b,y = yo - k a ,å…¶å®å°†è¿™é‡Œä¸¤ä¸ªç‰¹è§£ ç›´æ¥å½“æˆ0æ¥ç®—ï¼Œå› ä¸ºé¢˜ç›®è¦æ±‚æœ€å°ï¼Œå¹¶ä¸” a , b çš„å·®è·è¿˜ä¸èƒ½å¤ªå¤§ï¼Œå°±ç›´æ¥æ±‚å‡º kçš„èŒƒå›´ ç„¶å å¯¹å…¶è¿›è¡ŒåŠ 1 å‡1çš„æ“ä½œå¾—å‡ºæœ€åç»“æœã€‚ è®¡ç®—åŒä½™æ–¹ç¨‹ä¸åŒä½™æ–¹ç¨‹ç»„å…³äºåŒä½™ç†è®ºï¼Œè‡ªå·±çš„å…¶ä»–ç›¸å…³åšå®¢å·²ç»å­˜åœ¨è®²è§£è¿™é‡Œå°±ä¸åœ¨è¿‡å¤šä»‹ç»äº†ï¼Œ è¿™é‡Œæœ‰ä¸€é“ç»å…¸çš„é¢˜ï¼Œä»¥åæœ‰æ—¶é—´æ’ä¸€ä¸‹ä»£ç ã€‚ è¿™é‡Œå†æ¬¡æ€»ç»“ä¸€ä¸‹ä¸€å…ƒçº¿æ€§åŒä½™æ–¹ç¨‹çš„è§£æ³•ã€‚ é¦–å…ˆé¦–å…ˆ çº¿æ€§åŒä½™æ–¹ç¨‹å¯ä»¥è¡¨ç¤ºä¸º ax =- b(mod m) å°±è¿™æ ·å¯ä»¥è¡¨ç¤ºä¸ºä¸€ä¸ªä¸å®šæ–¹ç¨‹å¼ ax = b + ym; å…ˆæ±‚å‡º b % gcd(a,m) åˆ¤æ–­å…¶æ˜¯å¦ä¸º0ï¼Œå¦‚æœä¸ä¸º0ï¼Œé‚£ä¹ˆä»¥ä¸Šçš„åŒä½™æ–¹ç¨‹å¼æˆ–è€…ä¸å®šæ–¹ç¨‹å¼æ— è§£ã€‚å¦‚æœ å¾—åˆ°çš„ç»“æœä¸ºjï¼Œé‚£ä¹ˆè¯´æ˜è¯¥æ–¹ç¨‹æœ‰ jä¸ª mod m ä¸åŒä½™çš„è§£ d = gcd(a,m); å½“ç”¨æ¬§å‡ é‡Œå¾—ç®—æ³•æ±‚å‡ºä»¥ä¸Šçš„è§£ä¹‹å å¾—åˆ°å…¶å®æ˜¯ ax=- d(mod m) è¿™ä¸€åŒä½™æ–¹ç¨‹ä¸­ x çš„è§£ã€‚æ‰€ä»¥è¯´äººè¯å°±æ˜¯ å½“æ±‚å‡ºäº†é‚£ä¸ªç‰¹è§£ä¹‹å å†å»ä¹˜ä»¥ä¹‹å‰ çš„ B å€¼ æœ€åmod må¾—åˆ°æœ€ç»ˆåŒä½™æ–¹ç¨‹çš„è§£ã€‚2 å…³äºè®¡ç®—åŒä½™æ–¹ç¨‹ï¼Œå…¶å®ä¸æ±‚è§£æ‰©å±•æ¬§å‡ é‡Œå¾—é€šè§£çš„æ•ˆæœæ˜¯ä¸€æ ·çš„ï¼Œ C_Loop poj2115 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/* è¿™é“é¢˜å…¶å®å†ä¸€æ¬¡æ¶‰åŠåˆ° exgcdçš„å¦å¤–ä¸€ä¸ªç”¨æ³• è¿™ä¸ªç”¨æ³•ä»ç„¶æ˜¯ä»å…¶ä¸­æ±‚è§£ä¸å®šæ–¹ç¨‹çš„ä½œç”¨ä¸­å»¶ä¼¸è¿‡æ¥çš„ã€‚ è¿™é“é¢˜å°±æ˜¯ä¸€ä¸ªç®€å•çš„ä¸€ç»´çš„çº¿æ€§æ±‚ä½™è¿‡ç¨‹ï¼Œ å¯¹äºè¿™é“é¢˜å°±æ˜¾ç¤ºä¸€ä¸‹ çº¿æ€§åŒä½™çš„è¿‡ç¨‹ é¦–å…ˆ çº¿æ€§åŒä½™æ–¹ç¨‹å¯ä»¥è¡¨ç¤ºä¸º ax =- b(mod m) å°±è¿™æ ·å¯ä»¥è¡¨ç¤ºä¸ºä¸€ä¸ªä¸å®šæ–¹ç¨‹å¼ ax = b + ym; æ‰€ä»¥ç¬¬ä¸€æ­¥ å…ˆæ±‚å‡º b % gcd(a,m) åˆ¤æ–­å…¶æ˜¯å¦ä¸º0ï¼Œå¦‚æœä¸ä¸º0ï¼Œé‚£ä¹ˆä»¥ä¸Šçš„åŒä½™æ–¹ç¨‹å¼æˆ–è€…ä¸å®šæ–¹ç¨‹å¼æ— è§£ã€‚ å¦‚æœ å¾—åˆ°çš„ç»“æœä¸ºjï¼Œé‚£ä¹ˆè¯´æ˜è¯¥æ–¹ç¨‹æœ‰ jä¸ª mod m ä¸åŒä½™çš„è§£ d = gcd(a,m); å½“ç”¨æ¬§å‡ é‡Œå¾—ç®—æ³•æ±‚å‡ºä»¥ä¸Šçš„è§£ä¹‹å å¾—åˆ°å…¶å®æ˜¯ ax` =- d(mod m) è¿™ä¸€åŒä½™æ–¹ç¨‹ä¸­ x`çš„è§£ã€‚ æ‰€ä»¥æ ¹æ®åˆ¤æ–­dæ˜¯å¦ç­‰äº0 å¯ä»¥æ±‚å‡ºç¬¬ä¸€ä¸ªè§£é‡Šx0 = x` * (b / d) mod m; è€Œå…¶ä½™d - 1çš„è§£å°±æ˜¯ xi = (x0 + i *(m / d)) mod m; æ‰€ä»¥è¯´äººè¯å°±æ˜¯ å½“æ±‚å‡ºäº†é‚£ä¸ªç‰¹è§£ä¹‹å å†å»ä¹˜ä»¥ä¹‹å‰ çš„ B å€¼ æœ€åmod må¾—åˆ°æœ€ç»ˆåŒä½™æ–¹ç¨‹çš„è§£ã€‚*/#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;map&gt;using namespace std;long long exgcd(long long a,long long b,long long &amp;x,long long &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; long long t = exgcd(b,a % b,x,y); long long d = x; x = y; y = d - (a / b) * y; return t;&#125;long long gcd (long long a,long long b) &#123; if (b == 0) return a; return gcd(b,a % b);&#125;long long a,b,c,k;long long x,y;int main()&#123; while (scanf("%lld %lld %lld %lld",&amp;a,&amp;b,&amp;c,&amp;k)) &#123; if (a == 0 &amp;&amp; b == 0 &amp; c == 0 &amp;&amp; k ==0) break; long long gap = b - a; k = ((long long)1 &lt;&lt; k); gap = (gap % k + k) % k; if (gap == 0) &#123; printf("0\n"); continue; &#125; long long q = exgcd(c,k,x,y); if (gap % q) &#123; printf("FOREVER\n"); continue; &#125; //å‰é¢å±äºåˆ¤æ–­è¿‡ç¨‹ï¼Œåé¢å°±æ˜¯æ­£å¸¸çš„ecgcdçš„ ä¸å®šæ–¹ç¨‹æ±‚è§£äº† //æ‰€ä»¥éœ€è¦åšçš„äº‹æƒ…å°±æ˜¯ æ–¹ç¨‹ä¸¤è¾¹åŒæ—¶é™¤ä»¥gcd c = c / q; gap = gap / q; k = k / q; long long xx = exgcd(c,k,x,y); x *= gap; x = (x % k + k) % k; printf("%lld\n",x); &#125; return 0;&#125; æ¥ä¸‹æ¥å°±æ˜¯ä¸€é“æ±‚è§£é€†å…ƒçš„é—®é¢˜äº†ã€‚ å®šç† åŒä½™æ–¹ç¨‹ ax =- 1(mod m)æœ‰è§£ å½“ä¸”ä»…ä»…å½“ gcd(a,m) = æ—¶å€™æˆç«‹ï¼Œä¸”å…¶çš„æ‰€æœ‰è§£éƒ½åŒä½™ Modular Inverse zoj 3609 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;int exgcd(int a,int b,int &amp;x,int &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; int t = exgcd(b,a % b,x,y); int d = x; x = y; y = d - (a / b) * y; return t; &#125;int a,b,q,x,y;int main()&#123; int T; while (cin &gt;&gt; T) &#123; while (T--) &#123; cin &gt;&gt; a &gt;&gt; b; q = exgcd(a,b,x,y); //å°±æ˜¯è¿™é‡Œå¤šäº†åˆ¤æ–­å…¶æ˜¯å¦ä¸º0çš„æ¡ä»¶ã€‚ if (q != 1) &#123; printf("Not Exist\n"); continue; &#125; //è¿™é‡Œå°±æ˜¯å¤„ç†0çš„æƒ…å†µ x = (x % b + b) % b; if (x == 0) cout &lt;&lt; b &lt;&lt; endl; else cout &lt;&lt; x &lt;&lt; endl; &#125; &#125; return 0;&#125; åŒä½™æ–¹ç¨‹ç»„ ï¼ˆä¸­å›½å‰©ä½™å®šç†ï¼‰è¿™é‡Œè´´å‡º æ±‚è§£åŒä½™æ–¹ç¨‹ç»„çš„é˜¶æ¢¯æ­¥éª¤ å°†é¢˜ç›®ä¸­ç»™å‡ºçš„æ‰€æœ‰åŒä½™æ–¹ç¨‹ç»„åˆ—å‡ºæ¥ï¼Œå½¢å¦‚ a =- ai (mod ni),å¹¶ä¸”å°†æ¯ä¸€ä¸ªniç›¸ä¹˜èµ·æ¥ å¾—åˆ°ä¸€ä¸ª n ã€‚ï¼ˆæˆ–è€…æ˜¯æ±‚å…¶å…¨éƒ¨çš„æœ€å°å…¬å€æ•°ï¼‰ ç„¶åé€šè¿‡å…¬å¼ è®¡ç®—å‡º mi = n / niï¼Œç„¶åå†é€šè¿‡mi è®¡ç®—å‡ºmiæ¨¡ n çš„é€† å°±æ˜¯é€šè¿‡ æ‰©å±•æ¬§å‡ é‡Œå¾—å…¬å¼å»æ±‚è§£æ¯ä¸€ä¸ªåŒä½™æ–¹ç¨‹ mi * x =- 1 (mod ni); ç„¶åå†è®¡ç®—æ¯ä¸€ä¸ª ci = mi * miçš„é€†ã€‚ æœ€åé€šè¿‡å…¬å¼ a = ((å…¨éƒ¨ç›¸åŠ )ai * ci ) mod nâ€¦ Biorhythms poj 1006 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/* è¿™é“é¢˜ç›®å…¶å®æ˜¯ä¸¥æ ¼æŒ‰ç…§ä¸­å›½å‰©ä½™å®šç†æ¥è®¡ç®—çš„ï¼Œæœ€åæ±‚è§£çš„ç»“æœå®é™…ä¸Šæ˜¯è®¡ç®—å‡ºæ¥çš„ä¸‰ä¸ªåŒä½™çš„ç»“æœï¼ŒåŒæ—¶æ»¡è¶³å¤šä¸ªåŒä½™æ–¹ç¨‹çš„ä¸€ä¸ªå…±åŒçš„ç»“æœ ä¸è¿‡ä¸‹é¢çš„æ­¥éª¤éœ€è¦å¼„æ¸…æ¥šï¼Œç¬¬ä¸€æ­¥æ˜¯å…ˆæ±‚å‡ºæ¯ä¸€ä¸ªåŒä½™çš„ må€¼ï¼Œç„¶åå†é€šè¿‡æ±‚mé€†ï¼Œç„¶åå°†å…¶ç›¸ä¹˜å¾—åˆ°ci æœ€åä¹˜ä»¥æ¯ä¸€é¡¹çš„ci æœ€åæ±‚è§£çš„ç»“æœå»modä¸Šä¸€ä¸ªæœ€ç»ˆçš„mod nå°±è¡Œäº†*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;cmath&gt;using namespace std;int p,e,i,d;int exgcd (int a,int b, int &amp;x,int &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; int t = exgcd(b,a % b,x,y); int d = x; x = y; y = d - (a / b) * y; return t;&#125;int m1,m2,m3;int n1,n2,n3;int n = 21252;int x,x2,x3;int y,y2,y3;//å¤„ç†C++ ä¸­ % å‡ºè´Ÿæ•°çš„æƒ…å†µint _mod(int x,int b) &#123; return (x % b + b) % b;&#125;int main()&#123; int Case = 1; while (scanf("%d %d %d %d",&amp;p,&amp;e,&amp;i,&amp;d)) &#123; if (p == -1 &amp;&amp; e == -1 &amp;&amp; i == -1 &amp;&amp; d== -1) break; m1 = n / 23; m2 = n / 28; m3 = n / 33; int q1 = exgcd(m1,23,x,y); int q2 = exgcd(m2,28,x2,y2); int q3 = exgcd(m3,33,x3,y3); x = _mod(x,23) * m1; x2 = _mod(x2,28) * m2; x3 = _mod(x3,33) * m3; int res = x * p + x2 * e + x3 * i - d; res = res % n; if (res &lt;= 0) res += n; cout &lt;&lt; "Case "&lt;&lt; Case++ &lt;&lt;": the next triple peak occurs in "&lt;&lt;res &lt;&lt;" days." &lt;&lt; endl; &#125; return 0;&#125; ç‰¹æ®Šçš„åŒä½™å¼å¨å°”é€Šå®šç†å¦‚æœ p æ˜¯ç´ æ•°ï¼Œ(p - 1)! =- -1 (mod p)æˆç«‹ æ„æ€å°±æ˜¯ å¦‚æœ pæ˜¯ç´ æ•°çš„æƒ…å†µï¼Œ(p - 1)! + 1 mod p æ­£å¥½å¯ä»¥ç­‰äº0. YAPTCHA uva 4382 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;sstream&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define MOD 2018#define LL long long#define ULL unsigned long long#define Pair pair&lt;int, int&gt;#define mem(a, b) memset(a, b, sizeof(a))#define _ ios_base::sync_with_stdio(0), cin.tie(0)using namespace std;const int maxn = 3e6 + 10, INF = 0x7fffffff;int vis[maxn], ans[maxn];//è¿™é‡Œæ˜¯ä¸€ç§ç®€å•çš„ç­›æ³•,ç›¸å½“äºä¸€ä¸ªç®€å•çš„åŸƒå¼ç­›æ³•ã€‚void init()&#123; mem(vis, 0); for (int i = 2; i &lt;= sqrt(maxn + 0.5); i++) if (!vis[i]) for (int j = i * i; j &lt; maxn; j += i) vis[j] = 1;&#125;void f()&#123; mem(ans, 0); for (int i = 1; i &lt;= 1e6; i++) &#123; int temp = 3 * i + 7; ans[i] = ans[i - 1] + (1 - vis[temp]); &#125;&#125;int main()&#123; init(); f(); int T, n; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; cout &lt;&lt; ans[n] &lt;&lt; endl; &#125; return 0;&#125; è´¹é©¬å°å®šç† å¦‚æœpæ˜¯ç´ æ•°ï¼Œaæ˜¯æ­£æ•´æ•°ï¼Œgcd(a,p) = 1,åˆ™ açš„p - 1 æ¬¡å¹‚ åŒä½™ 1 mod p. what day is that day zoj 37851234567891011121314151617181920212223242526272829303132/* è¿™é“é¢˜è®²è¿°çš„å°±æ˜¯è´¹é©¬å°å®šç†ï¼Œè¿™é“é¢˜ç›®å…³é”®ç‚¹å°±æ˜¯åœ¨ï¼Œå‰é¢å¯¹äºå‘¨æœŸmodçš„æ±‚å–ï¼Œåº”ç”¨äº†è´¹é©¬å°å®šç†ï¼Œæœ€åå¾—å‡ºçš„ç»“è®ºã€‚*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int num[1000];char day[10][10] = &#123;"Saturday", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday"&#125;;int pow(int x)&#123; int ans = 1; for (int i = 1; i &lt;= x; i++) ans = (ans * x) % 7; return ans;&#125;int main()&#123; for (int i = 1; i &lt;= 300; i++) num[i] = (pow(i) + num[i - 1]) % 7; int T; scanf("%d", &amp;T); while (T--) &#123; int n; scanf("%d", &amp;n); printf("%s\n", day[num[n % 294]]); &#125; return 0;&#125; ä¼ªç´ æ•°å…¶äº§ç”Ÿçš„åŸå› å°±åœ¨äºè´¹é©¬å°å®šç†çš„é€†ä¸æˆç«‹ï¼Œå¦‚æœaæ˜¯ä¸€ä¸ªæ­£æ•´æ•°ï¼Œå¦‚æœnæ˜¯ä¸€ä¸ªæ­£åˆæ•°ï¼Œå¹¶ä¸”açš„næ¬¡å¹‚ åŒä½™ a (mod n) åˆ™ç§°nä¸ºä»¥aä¸ºåŸºçš„ä¼ªç´ æ•°ã€‚ Pseudoprime numbers poj 3641 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* è¿™é“é¢˜ä¸æ–­çš„å‡ºç°runtime error ç”¨java çš„æ—¶å€™ è¿™ä¸ªæ—¶å€™æˆ‘å°±ä¸å¤ªæ¸…æ¥šæ˜¯ä¸ºä»€ä¹ˆäº†ã€‚ åé¢è¿˜éœ€è¦å¼„æ¸…æ¥šä¸€ä»¶äº‹æƒ…å°±æ˜¯ ç©¶ç«Ÿä»€ä¹ˆæ—¶å€™æ‰èƒ½å¤Ÿç”¨æ¬§æ‹‰èµ›çš„æ—¶é—´å»æ‰“è¡¨ï¼Œè¿™é‡Œå°±ä¸å¤ªæ¸…æ¥š æœ‰çš„æ—¶å€™ç”¨æ¬§æ‹‰ç­›æ‰“è¡¨åè€Œå‡ºç°é”™è¯¯çš„ç­”æ¡ˆã€‚ */#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;cmath&gt;using namespace std;long long _mod(long long x,long long y,long long mod) &#123; long long ans = 1; while (y) &#123; if (y &amp; 1) ans = ans * x % mod; y &gt;&gt;= 1; x = x * x % mod; &#125; return ans;&#125;bool is_prime(long long x) &#123; for (int i = 2; i &lt;= sqrt(x) + 0.5; i++) &#123; if (x % i == 0) return false; &#125; return true;&#125;long long q,a;int main()&#123; while (scanf("%lld %lld",&amp;q,&amp;a) &amp;&amp; q &amp;&amp; a) &#123; if (is_prime(q)) &#123; printf("no\n"); continue; &#125; long long ans = _mod(a,q,q); if (ans == a) printf("yes\n"); else printf("no\n"); &#125; return 0;&#125; æ¥ä¸‹æ¥è¿˜æœ‰ä¸€é“é¢˜ï¼Œå¯ä»¥æ ¹æ®javaçš„ä¸€ä¸ªå‡½æ•°ç›´æ¥å¾—å‡ºç»“æœï¼Œä½†æ˜¯åŒæ ·ä¹Ÿå¯ä»¥é€šè¿‡C++ çš„å¤§ç´ æ•°çš„æ£€æµ‹æ–¹æ³•ä»è€Œå¾—å‡ºç»“æœã€‚ 123456789101112131415161718192021import java.util.Scanner;import java.math.BigInteger;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n; BigInteger a; while (in.hasNext()) &#123; n = in.nextInt(); int cnt = 0; for (int i = 0; i &lt; n; i++) &#123; a = in.nextBigInteger(); if (a.isProbablePrime(3)) cnt++; &#125; System.out.println(cnt); &#125; in.close(); return; &#125;&#125; C++ å‰é¢æœ‰è®²çš„è¶…å‡ºåŒºé—´çš„æµ‹å®šæ–¹æ³•ã€‚ 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;math.h&gt;int is_prime(int x)&#123; int tp = (int)sqrt(x * 1.0); for (int i = 2; i &lt;= tp; ++i) &#123; if (x % i == 0) &#123; return 0; &#125; &#125; return 1;&#125;int main()&#123; int n; while (~scanf("%d", &amp;n)) &#123; int ans = 0, tp; for (int i = 0; i &lt; n; ++i) &#123; scanf("%d", &amp;tp); if (tp == 2) &#123; ++ans; &#125; else if (tp &amp; 1) &#123; ans += is_prime(tp); &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125; æ¬§æ‹‰å®šç†æ¬§æ‹‰å‡½æ•°è¡¨ç¤ºçš„æ˜¯åˆ°nä¹‹å‰ä¸näº’ç´ çš„ä¸”ä¸è¶…è¿‡nçš„æ­£æ•´æ•°çš„ä¸ªæ•°ã€‚ å¦‚æœ nå’Œaæ˜¯äº’ç´ çš„æ­£æ•´æ•°ï¼Œåˆ™ açš„ æ¬§æ‹‰å‡½æ•°n åŒä½™1 mod n]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>acm</tag>
        <tag>æ•°è®º</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[èƒŒåŒ…åˆçº§åŠç›¸åº”é¢˜ç›®æ€»ç»“]]></title>
    <url>%2F2019%2F05%2F01%2F%E8%83%8C%E5%8C%85%E5%88%9D%E7%BA%A7%E5%8F%8A%E7%9B%B8%E5%BA%94%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[èƒŒåŒ…åˆçº§è®²è§£è¿™é‡Œå¯¹äºåŠ¨æ€è§„åˆ’é‡Œé¢ä¸€ä¸ªç®€å•åŸºç¡€çš„é—®é¢˜è¿›è¡Œæ€»ç»“ï¼ŒåŒ…æ‹¬ 01èƒŒåŒ…ï¼Œå®Œå…¨èƒŒåŒ…ï¼Œå¤šé‡èƒŒåŒ…ï¼Œæ··åˆèƒŒåŒ…â€¦ 01èƒŒåŒ…é¢˜ç›® æœ‰Nä»¶ç‰©å“å’Œä¸€ä¸ªå®¹é‡ä¸ºV çš„èƒŒåŒ…ã€‚æ”¾å…¥ç¬¬iä»¶ç‰©å“è€—è´¹çš„è´¹ç”¨æ˜¯Ci1ï¼Œå¾—åˆ° çš„ä»·å€¼æ˜¯Wi ã€‚æ±‚è§£å°†å“ªäº›ç‰©å“è£…å…¥èƒŒåŒ…å¯ä½¿ä»·å€¼æ€»å’Œæœ€å¤§ã€‚ åŸºæœ¬æ€è·¯ ç”¨å­é—®é¢˜å®šä¹‰çŠ¶æ€:å³F [i, v]è¡¨ç¤ºå‰iä»¶ç‰©å“æ°æ”¾å…¥ä¸€ä¸ªå®¹é‡ä¸ºvçš„èƒŒåŒ…å¯ ä»¥è·å¾—çš„æœ€å¤§ä»·å€¼ã€‚åˆ™å…¶çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¾¿æ˜¯:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657**å¯¹äºäºŒç»´dpæ•°ç»„çš„ä¼ªä»£ç å¦‚ä¸‹**F[0,0..V] â†0 fori â†1toNforv â†Ci toVF[i,v] â† max&#123;F[i âˆ’ 1,v],F[i âˆ’ 1,v âˆ’ Ci] + Wi&#125;**ä¼˜åŒ–ç©ºé—´çš„å¤æ‚åº¦**ä½¿ç”¨æ»šåŠ¨æ•°ç»„ï¼Œä»¥åŠè¿›è¡Œå‹ç¼©ç©ºé—´ã€‚ä¼ªä»£ç å¦‚ä¸‹ï¼šF [0..V ] â†0 fori â†1toNforv â†V toCiF[v] â†max&#123;F[v],F[vâˆ’Ci]+Wi&#125;**åˆå§‹åŒ–çš„ç»†èŠ‚**&gt;æˆ‘ä»¬çœ‹åˆ°çš„æ±‚æœ€ä¼˜è§£çš„èƒŒåŒ…é—®é¢˜é¢˜ç›®ä¸­ï¼Œäº‹å®ä¸Šæœ‰ä¸¤ç§ä¸å¤ªç›¸åŒçš„é—®æ³•ã€‚ æœ‰çš„é¢˜ç›®è¦æ±‚â€œæ°å¥½è£…æ»¡èƒŒåŒ…â€æ—¶çš„æœ€ä¼˜è§£ï¼Œæœ‰çš„é¢˜ç›®åˆ™å¹¶æ²¡æœ‰è¦æ±‚å¿…é¡»æŠŠèƒŒ åŒ…è£…æ»¡ã€‚ä¸€ç§åŒºåˆ«è¿™ä¸¤ç§é—®æ³•çš„å®ç°æ–¹æ³•æ˜¯åœ¨åˆå§‹åŒ–çš„æ—¶å€™æœ‰æ‰€ä¸åŒã€‚&gt;å¦‚æœæ˜¯ç¬¬ä¸€ç§é—®æ³•ï¼Œè¦æ±‚æ°å¥½è£…æ»¡èƒŒåŒ…ï¼Œé‚£ä¹ˆåœ¨åˆå§‹åŒ–æ—¶é™¤äº†F [0]ä¸º0ï¼Œå…¶ å®ƒF [1..V ]å‡è®¾ä¸ºâˆ’âˆï¼Œè¿™æ ·å°±å¯ä»¥ä¿è¯æœ€ç»ˆå¾—åˆ°çš„F [V ]æ˜¯ä¸€ç§æ°å¥½è£…æ»¡èƒŒåŒ…çš„ æœ€ä¼˜è§£ã€‚&gt;å¦‚æœå¹¶æ²¡æœ‰è¦æ±‚å¿…é¡»æŠŠèƒŒåŒ…è£…æ»¡ï¼Œè€Œæ˜¯åªå¸Œæœ›ä»·æ ¼å°½é‡å¤§ï¼Œåˆå§‹åŒ–æ—¶åº”è¯¥ å°†F [0..V ]å…¨éƒ¨è®¾ä¸º0ã€‚#### é¢˜ç›®æ€»ç»“ ##### 1.Charm Bracelet (poj3624)```C++/* ç¬¬ä¸€é“é¢˜å±äºä¸€ä¸ªç®€å•çš„01èƒŒåŒ…æ¨¡æ¿é¢˜ç›®ï¼Œè¿™é‡Œä¸å¤šè¯´ å¯ä»¥ç›´æ¥å¥—æ¨¡æ¿ã€‚*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int n,m;int dp[13000];int w[3500],v[3500];int main()&#123; while (cin &gt;&gt; n &gt;&gt; m) &#123; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; w[i] &gt;&gt; v[i]; &#125; memset(dp,0,sizeof dp); for (int i = 1; i &lt;= n; i++) &#123; for (int j = m; j &gt;= w[i]; j--) &#123; dp[j] = max(dp[j],dp[j - w[i]] + v[i]); &#125; &#125; cout &lt;&lt; dp[m] &lt;&lt; endl; &#125; return 0;&#125; 2.Bone_Collector(hdu 2602)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* ä¸€æ®µç®€å•çš„æ¨¡æ¿é¢˜ç›®ï¼Œä¸è¿‡éœ€è¦å¼„æ¸…æ¥šçš„ ä¸€ç»´æ•°ç»„ä¸äºŒç»´æ•°ç»„åœ¨è¿™é‡Œç›¸åº”çš„åŒºåˆ«ï¼Œå¾€å¾€è¿™é‡Œä¼šäº§ç”Ÿå¾ˆå¤§çš„åŒºåˆ«ï¼Œ æ¯”å¦‚ç¬¬äºŒä¸ªå¾ªç¯çš„å¼€å§‹æ¡ä»¶ï¼Œå› ä¸ºè¿™é‡Œæ˜¯ç”±å­é—®é¢˜çš„å †ç§¯ï¼Œç„¶åä¸€ç‚¹ä¸€ç‚¹å‘ä¸Šå‡æœ€ç»ˆå¾—åˆ°çš„é—®é¢˜ï¼Œæ‰€ä»¥è¿™ææœ€å¥½æ§åˆ¶èƒŒåŒ…çš„æ”¾ä¸ä¸æ”¾çš„é—®é¢˜ã€ å°±æ¯”å¦‚æˆ‘åœ¨è¿™é“é¢˜ç›®çš„ç¬¬äºŒä¸ªé—®é¢˜ä¸­å‡ºç°çš„é”™è¯¯ï¼Œå°±æ˜¯å°†j=0è¿™ä¸ªæ¡ä»¶ç›´æ¥æ è¿‡å»äº†ï¼Œå…¶å®è¿™é‡Œæ˜¯ä¸å¯¹çš„ã€‚*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1010;long long weight[maxn],value[maxn],dp[maxn][maxn];long v,w;int main()&#123; int T; cin &gt;&gt; T; while(T--) &#123; cin &gt;&gt; w &gt;&gt; v; value[0] = 0; weight[0] = 0; for (int i = 1; i &lt;= w; i++) &#123; cin &gt;&gt; value[i]; &#125; for (int i = 1; i &lt;= w; i++) &#123; cin &gt;&gt; weight[i]; &#125; memset(dp, 0, sizeof dp); for (int i = 1; i &lt;= w; i++) &#123; for (int j = 0; j &lt;= v; j++) &#123; if (j &gt;= weight[i]) &#123; dp[i][j] = max(dp[i - 1][j],dp[i - 1][j - weight[i]] + value[i]); &#125; else dp[i][j] = dp[i - 1][j]; &#125; &#125; cout &lt;&lt; dp[w][v] &lt;&lt; endl; &#125; return 0;&#125; 3.é¥­å¡123456789101112131415161718192021222324252627282930313233343536373839404142/* è¿™é“é¢˜ç¥å¥‡çš„åœ°æ–¹å°±åœ¨äº å…¶çš„é‡é‡é™åˆ¶äºä»·å€¼é‡åˆåœ¨äº†ä¸€èµ·ï¼Œæ‰€ä»¥å¯¹äºè¿™é“é¢˜è€Œè¨€å°±æ˜¯åªèƒ½é‡åˆçš„å»å†™çŠ¶æ€è½¬ç§»æ–¹ç¨‹äº† å¦å¤–éœ€è¦æ³¨æ„çš„æ˜¯æœ€åè¾“å‡ºç»“æœçš„åŠæ³•ï¼Œæ˜¯å°†æœ€åä¸€ä¸ªç‰©å“äº¤ç»™å‰©ä¸‹çš„æœ€å¤§çš„é’±å»è´­ä¹°ï¼Œè¿™æ ·èƒ½å½»åº•ç”¨å…‰æœ€åçš„é’±è´¢*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int n,m;const int maxn = 1010;int num[maxn],dp[maxn][maxn];int main()&#123; while (cin &gt;&gt; n &amp;&amp; n) &#123; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; num[i]; &#125; cin &gt;&gt; m; sort(num + 1, num + 1 + n); if (m &lt; 5) &#123; cout &lt;&lt; m &lt;&lt; endl; continue; &#125; memset(dp,0,sizeof dp); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= m - 5; j++) &#123; if (j &gt;= num[i]) &#123; dp[i][j] = max(dp[i - 1][j],dp[i - 1][j - num[i]] + num[i]); &#125; else dp[i][j] = dp[i - 1][j]; &#125; &#125; cout &lt;&lt; m - dp[n - 1][m - 5] - num[n] &lt;&lt; endl; &#125; return 0;&#125; å®Œå…¨èƒŒåŒ…å®Œå…¨èƒŒåŒ…è¿™é‡Œä¸01èƒŒåŒ…ç›¸ç±»ä¼¼ï¼Œä½†æ˜¯åŒºåˆ«å°±åœ¨äºæ¯ä¸€ä¸ªç§ç±»çš„èƒŒåŒ…å¯ä»¥å–æ— æ•°ä¸ª 1234567ä¸€èˆ¬éƒ½æ˜¯å°†å…¶è½¬åŒ–ä¸º01èƒŒåŒ…çš„æ–¹æ³•æ±‚è§£ï¼Œç”¨ä¸€ä¸ªæ»šåŠ¨æ•°ç»„æ¥è¿›è¡Œè¡¨ç¤ºï¼Œä¸è¿‡éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå…¶ä¸01èƒŒåŒ…çš„ç¬¬äºŒä¸ªå¾ªç¯ä¸åŒåœ°æ–¹å®Œå…¨èƒŒåŒ…çš„ä¼ªä»£ç ï¼š```pydef CompletePack(F, C, W ) forv â†CtoVF[v] â†max&#123;F[v],f[vâˆ’C]+W&#125; é¢˜ç›®ä¸‹é¢è´´å‡ºå…³äºå®Œå…¨èƒŒåŒ…çš„é¢˜ç›® 1.å‡è‚¥1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* è¿™é“é¢˜ä½¿ç”¨äºŒç»´æ•°ç»„å°±ä¸€ç›´å°±ä¼šè¶…æ—¶ å…·ä½“çš„æˆ‘ä¹Ÿä¸å¤ªæ¸…æ¥šï¼Œä½†æ˜¯ æ²¡æœ‰åŠæ³• åªèƒ½ä½¿ç”¨ä¸€ç»´æ»šåŠ¨æ•°ç»„ï¼Œè¿›è¡Œäº†ç›¸åº”çš„ç©ºé—´ä¼˜åŒ– ä¸è¿‡è¿™é‡Œéœ€è¦è¡¥å……å‡ ä¸ªçŸ¥è¯†ç‚¹ ç¬¬ä¸€ å…³äºäºŒç»´æ•°ç»„çš„å®Œå…¨èƒŒåŒ…çŠ¶æ€è½¬ç§»æ–¹ç¨‹ dp[i][j] = max (dp[i - 1][j],dp[i - 1][j - k * c[i]] + k * v[i]); ç”±ä¸Šé¢è¿™ä¸ªå¼å­å°±å¯ä»¥å¾—å‡ºï¼ŒçŠ¶æ€è½¬ç§»æ–¹ç¨‹ äºæ˜¯ ä¸€ç§ç©ºé—´ä¼˜åŒ–çš„å†™æ³• æ˜¯ç›´æ¥å†™æˆ max(dp[i - 1][j]ï¼Œdp[i][j - w[i]] + v[i]) ç¬¬äºŒ å¦‚æœæ¢æˆæ»šåŠ¨æ•°ç»„çš„è¯ è®°ä½ ç¬¬äºŒä¸ªå¾ªç¯çš„ä¸¤ä¸ªé¡ºåºï¼Œå¦‚æœæ˜¯å€’å™çš„è¯ åˆ™å°±æ˜¯è¦ä¿è¯æ¯ä¸€ä¸ªç‰©å“åªä¼šå–ä¸€æ¬¡ï¼Œä½†æ˜¯å¦‚æœæ˜¯æ­£åºçš„è¯ï¼Œé‚£ä¹ˆå°±ä¸éœ€è¦ä¿è¯ä¸Šé¢æ‰€è¯´çš„é¡ºåºäº†ã€‚ è€Œè¿™é‡Œå®˜æ–¹çš„è§£é‡Š å°±åœ¨è¿™é‡Œ ï¼š è®© v é€’å‡æ˜¯ä¸ºäº†ä¿è¯ç¬¬iæ¬¡å¾ªç¯ä¸­çš„çŠ¶æ€F[i;v]æ˜¯ç”±çŠ¶æ€F[i-1;v-Ci]é€’æ¨è€Œæ¥ã€‚ æ¢å¥è¯è¯´ï¼Œè¿™æ­£æ˜¯ä¸ºäº†ä¿è¯æ¯ä»¶ç‰©å“åªé€‰ä¸€æ¬¡ï¼Œä¿è¯åœ¨è€ƒè™‘â€œé€‰å…¥ç¬¬ i ä»¶ç‰©å“â€è¿™ä»¶ç­– ç•¥æ—¶ï¼Œä¾æ®çš„æ˜¯ä¸€ä¸ªç»æ— å·²ç»é€‰å…¥ç¬¬ i ä»¶ç‰©å“çš„å­ç»“æœF[i-1;v-Ci]ã€‚è€Œç°åœ¨å®Œå…¨èƒŒ åŒ…çš„ç‰¹ç‚¹æ°æ˜¯æ¯ç§ç‰©å“å¯é€‰æ— é™ä»¶ï¼Œæ‰€ä»¥åœ¨è€ƒè™‘â€œåŠ é€‰ä¸€ä»¶ç¬¬ i ç§ç‰©å“â€è¿™ç§ç­–ç•¥æ—¶ï¼Œ å´æ­£éœ€è¦ä¸€ä¸ªå¯èƒ½å·²é€‰å…¥ç¬¬ i ç§ç‰©å“çš„å­ç»“æœF[i;v-Ci]ï¼Œæ‰€ä»¥å°±å¯ä»¥å¹¶ä¸”å¿…é¡»é‡‡ç”¨v é€’å¢çš„é¡ºåºå¾ªç¯ã€‚è¿™å°±æ˜¯è¿™ä¸ªç®€å•çš„ç¨‹åºä¸ºä½•æˆç«‹çš„é“ç†ã€‚*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include&lt;cstdio&gt;using namespace std;int n, a, b, m;const int maxn = 110;int happiness[maxn], kaluli[maxn];int dp[110000];int main()&#123; while (~scanf("%d",&amp;n)) &#123; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d %d",&amp;happiness[i],&amp;kaluli[i]); &#125; scanf("%d",&amp;m); memset(dp,0,sizeof dp); for (int i = 1; i &lt;= n; i++) &#123; for (int j = kaluli[i]; j &lt;= m; j++) &#123; dp[j] = max(dp[j],dp[j - kaluli[i]] + happiness[i]); &#125; &#125; printf("%d\n",dp[m]); &#125; return 0;&#125; 2.Dollar Dayz12345678910111213141516171819202122232425import java.util.Scanner;import java.math.BigInteger;public class Main &#123; public static void main(String[] args) &#123; int n,k; Scanner in = new Scanner(System.in); while (in.hasNext()) &#123; BigInteger[] dp = new BigInteger[1005]; n = in.nextInt(); k = in.nextInt(); dp[0] = new BigInteger("1"); for (int i = 1; i &lt;= n; i++) &#123; dp[i] = new BigInteger("0"); &#125; for (int i = 1; i &lt;= k; i++) &#123; for (int j = i; j &lt;= n; j++) &#123; dp[j] = dp[j].add(dp[j - i]); &#125; &#125; System.out.println(dp[n]); &#125; &#125;&#125; 3.Piggy-Bank1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* è¿™é“é¢˜æ˜¯ä¸€ä¸ªå®Œå…¨èƒŒåŒ…çš„è£¸é¢˜ï¼Œå¯¹äºè¿™é“é¢˜è€Œè¨€æ›´åŠ ç¥å¥‡çš„åœ°æ–¹å°±åœ¨äºå…¶å®æ±‚æœ€å°å€¼è€Œä¸æ˜¯æ±‚æœ€å¤§å€¼ æ‰€ä»¥åœ¨æœ€å…ˆå¼€å§‹åˆå§‹åŒ–çš„æ—¶å€™ä¸åº”è¯¥å»åˆå§‹åŒ–ä¸º0ï¼Œè€Œåº”è¯¥åˆå§‹åŒ–ä¸ºæ— ç©·å¤§ è€Œåƒä¸‡ä¸è¦å¿˜è®°äº†å†åˆå§‹åŒ–çš„æ—¶å€™ä¸€å®šè¦å¯¹ç¬¬ä¸€ä¸ªçŠ¶æ€è¿›è¡Œä¸€ä¸ªå•ç‹¬èµ‹å€¼æ˜¯ç­‰äº0ï¼Œè¿˜æ˜¯ç­‰äºæ— ç©·å¤§ï¼Œè¿™ä¸ªç­‰åˆ°æ—¶å€™å†çœ‹ã€‚*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt; using namespace std;int _beg,_end;const int maxn = 505;int v[maxn],w[maxn];int dp[10010];int main()&#123; int T; cin &gt;&gt; T; while (T--) &#123; scanf("%d %d",&amp;_beg,&amp;_end); int bottle = _end - _beg; int n; scanf("%d",&amp;n); for (int i = 1; i &lt;= n; i++)&#123; scanf("%d %d",&amp;v[i],&amp;w[i]); &#125; memset(dp,0x3f3f3f3f,sizeof dp); dp[0] = 0; for (int i = 1; i &lt;= n;i ++) &#123; for (int j = w[i]; j &lt;= bottle; j++) &#123; dp[j] = min(dp[j],dp[j - w[i]] + v[i]); &#125; &#125; if (dp[bottle] != 0x3f3f3f3f) cout &lt;&lt; "The minimum amount of money in the piggy-bank is " &lt;&lt; dp[bottle] &lt;&lt; "." &lt;&lt; endl; else cout &lt;&lt; "This is impossible." &lt;&lt; endl; &#125; return 0;&#125; å¤šé‡èƒŒåŒ…å¤šé‡èƒŒåŒ…ä¸å®Œå…¨èƒŒåŒ…æœ€å¤§çš„ä¸åŒå°±æ˜¯åœ¨äºï¼Œå®Œå…¨èƒŒåŒ…å…¶çš„æ¯ä¸€ä¸ªèƒŒåŒ…å–å€¼å¯ä»¥å–æ— æ•°ä¸ªï¼ˆç›¸å¯¹äºèƒŒåŒ…å®¹é‡è€Œè¨€ï¼‰è€Œå¤šé‡èƒŒåŒ…çš„æ„æ€å°±æ˜¯ç›¸å¯¹äºèƒŒåŒ…å®¹é‡è€Œè¨€ å–ä¸æ»¡ï¼Œåœ¨å–ä¸æ»¡çš„åŒæ—¶è¿˜èƒ½å¤Ÿå†åŠ å…¥å…¶çš„èƒŒåŒ…ï¼Œæ•…ï¼Œè¿™é‡Œå°±ä¸ºå¤šé‡èƒŒåŒ… æ¨¡æ¿ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;const int maxn = 100005;//ä¸‰ä¸ªå±æ€§å€¼ ä¸€ä¸ªé‡é‡ æ•°é‡ ä»¥åŠä»·å€¼int weight[maxn],number[maxn],value[maxn];//çŠ¶æ€å­˜å‚¨int dp[maxn &lt;&lt; 4];//èƒŒåŒ…çš„å®¹é‡int bag; int n;//01èƒŒåŒ… void zeroonepack(int weight,int value) &#123; for (int j = bag; j &gt;= weight; j--) &#123; dp[j] = max(dp[j],dp[j - weight] + value); &#125;&#125;//å®Œå…¨èƒŒåŒ…void completepack(int weight,int value) &#123; for (int j = weight; j &lt;= bag; j++) &#123; dp[j] = max(dp[j],dp[j - weight] + value); &#125;&#125;//å¤šé‡èƒŒåŒ…void multilpack(int weight,int number,int value) &#123; //ç¬¬ä¸€ç§æƒ…å†µå°±æ˜¯ å¦‚æœè¿™ä»¶ç‰©å“æ‰€æœ‰çš„é‡é‡æ˜¯å°äºèƒŒåŒ…çš„é‡é‡çš„è¯ //é‚£ä¹ˆå¯¹äºèƒŒåŒ…è€Œè¨€ è¿™ä¸ªç‰©å“æ˜¯å¯ä»¥å–æ— é™å¤§ã€‚ if (bag &lt;= number * weight) &#123; completepack(weight,value); return; &#125; //è€Œè¶…è¿‡çš„è¿™ä¸ªèŒƒå›´çš„å°±åªèƒ½ä½¿ç”¨01èƒŒåŒ… ç„¶åä½¿ç”¨äºŒè¿›åˆ¶çš„æ–¹æ³• //å°†æ¯ä¸€ç±»å‹çš„èƒŒåŒ…è¿›è¡Œä¸€ä¸ªåˆ†ç»„ //åé¢å†ä¾æ¬¡åˆ†åˆ«ä½¿ç”¨å¤šé‡èƒŒåŒ…ã€‚ int k = 1; while (k &lt;= number) &#123; zeroonepack(k * weight,k * value); number = number - k; k = k * 2; &#125; zeroonepack(number * weight, number * value);&#125;int main()&#123; cin &gt;&gt; bag &gt;&gt; n; for (int i = 1; i &lt;= n ;i ++) &#123; cin &gt;&gt; weight[i] &gt;&gt; number[i] &gt;&gt; value[i]; &#125; for (int i = 1; i &lt;= n ;i ++) &#123; multilpack(weight[i],number[i],value[i]); &#125; cout &lt;&lt; dp[bag] &lt;&lt; endl; return 0;&#125; ç›¸åº”é¢˜ç›®æ€»ç»“1. Space Elevator1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* ä¸€é“å¤šé‡èƒŒåŒ…çš„è£¸é¢˜ç›®ï¼Œè¿™é“é¢˜è™½ç„¶å¹¶æ²¡æœ‰å»å¥—ç”¨å¤šé‡èƒŒåŒ…çš„è£¸æ¨¡æ¿ï¼Œä½†æ˜¯è¿™é“é¢˜ç¥å¥‡çš„åœ°æ–¹å°±åœ¨äºå…¶å¯¹äº èƒŒåŒ…çš„æ•°é‡è¿›è¡Œäº†å†ä¸€æ¬¡çš„å¾ªç¯ï¼Œç„¶åå†æ¥çœ‹çœ‹æœ‰æ²¡æœ‰ç¬¦åˆçš„ç‰¹ç‚¹ã€‚ ç„¶åå…¶çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¹Ÿæ˜¯ç‰¹åˆ«çš„æœ‰æ„æ€ï¼š dp[k] |= dp[k - node[i].h] ä¸è¿‡è¿™ä¸ª |= åˆ°åé¢å»å®˜ç½‘æŸ¥è¯¢ä¸€ä¸‹æœ€åçš„ç»“æœçš„æ„æ€.*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Node &#123; int h,a,c; bool operator &lt; (const Node &amp;n) const &#123; return a &lt; n.a; &#125;&#125;node[450];int dp[40050];int main()&#123; int K; while (cin &gt;&gt; K) &#123; for (int i = 1; i &lt;= K; i++) &#123; cin &gt;&gt; node[i].h &gt;&gt; node[i].a &gt;&gt; node[i].c; &#125; memset(dp,0,sizeof dp); dp[0] = 1; sort(node + 1, node + 1 + K); for (int i = 1; i &lt;= K ;i ++) &#123; for (int j = 1; j &lt;= node[i].c; j++) &#123; for (int k = node[i].a; k &gt;= node[i].h; k-- )&#123; dp[k] |= dp[k - node[i].h]; &#125; &#125; &#125; int cnt = 0; for (int i = node[K].a; i &gt;= 0; i--) &#123; if (dp[i]) &#123; cnt = i; break; &#125; &#125; cout &lt;&lt; cnt &lt;&lt; endl; &#125; return 0;&#125; 2. Coins123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/* è¿™é“é¢˜ç¥å¥‡çš„åœ°æ–¹å°±æ˜¯å°†å¤šé‡èƒŒåŒ…çš„è£¸é¢˜è¿›è¡Œäº†æ”¹å˜ï¼Œ ä¸»è¦å°±æ˜¯æ¯ä¸€æ¬¡å¢åŠ çš„ä»·å€¼ä¼šå‘ç”Ÿæ”¹å˜ï¼Œè¿™æ‰æ˜¯æœ€å…³é”®çš„åœ°æ–¹ã€‚ è¿™é‡Œçš„ä»·å€¼å°±ä¸å†æ˜¯ä¸ªæ•°ï¼Œè€Œæ˜¯è¿›è¡Œä¸€ä¸ªæ‰“è¡¨ï¼Œé€šè¿‡è¿™ä¸ªæ‰“è¡¨æ¥åˆ¤æ–­è¿™ä¸ªé‡é‡æ˜¯å¦èƒ½å¤Ÿè¾¾åˆ°ã€‚*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int n;int bag;bool dp[100040];int value[105],number[105];int cnt = 0;void zeroonepack(int weight, int value)&#123; for (int j = bag; j &gt;= weight; j--) &#123; if (!dp[j] &amp;&amp; dp[j - weight])&#123; dp[j] = true; cnt ++; &#125; &#125;&#125;//å®Œå…¨èƒŒåŒ…void completepack(int weight, int value)&#123; for (int j = weight; j &lt;= bag; j++) &#123; if (!dp[j] &amp;&amp; dp[j - weight]) &#123; dp[j] = true; cnt ++; &#125; &#125;&#125;//å¤šé‡èƒŒåŒ…void multilpack(int weight, int number, int value)&#123; //ç¬¬ä¸€ç§æƒ…å†µå°±æ˜¯ å¦‚æœè¿™ä»¶ç‰©å“æ‰€æœ‰çš„é‡é‡æ˜¯å°äºèƒŒåŒ…çš„é‡é‡çš„è¯ //é‚£ä¹ˆå¯¹äºèƒŒåŒ…è€Œè¨€ è¿™ä¸ªç‰©å“æ˜¯å¯ä»¥å–æ— é™å¤§ã€‚ if (bag &lt;= number * weight) &#123; completepack(weight, value); return; &#125; //è€Œè¶…è¿‡çš„è¿™ä¸ªèŒƒå›´çš„å°±åªèƒ½ä½¿ç”¨01èƒŒåŒ… ç„¶åä½¿ç”¨äºŒè¿›åˆ¶çš„æ–¹æ³• //å°†æ¯ä¸€ç±»å‹çš„èƒŒåŒ…è¿›è¡Œä¸€ä¸ªåˆ†ç»„ //åé¢å†ä¾æ¬¡åˆ†åˆ«ä½¿ç”¨å¤šé‡èƒŒåŒ…ã€‚ int k = 1; while (k &lt; number) &#123; zeroonepack(k * weight, k * value); number = number - k; k = k * 2; &#125; zeroonepack(number * weight, number * value);&#125;int main()&#123; while (cin &gt;&gt; n &gt;&gt; bag &amp;&amp; n &amp;&amp; bag) &#123; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; value[i]; &#125; for (int i = 1; i &lt;= n;i ++) &#123; cin &gt;&gt; number[i]; &#125; cnt = 0; memset(dp,0,sizeof dp); dp[0] = 1; for (int i = 1; i &lt;= n ;i ++) &#123; multilpack(value[i],number[i],value[i]); &#125; cout &lt;&lt; cnt &lt;&lt; endl; &#125; return 0;&#125; æ··åˆèƒŒåŒ…å°†01èƒŒåŒ… å®Œå…¨èƒŒåŒ… å¤šé‡èƒŒåŒ…çš„ä¸‰ç§èƒŒåŒ… è¿›è¡Œä¸€ä¸ªæ··åˆæœ€ç®€å•çš„è§£å†³æ–¹æ³•å°±æ˜¯å°†å…¶åˆ†å¼€è¿›è¡Œæ¥ç®— ä¸¾ä¸ªä¾‹å­ å°±æ˜¯ ä¸€é“é¢˜å¯èƒ½æœ‰å¤šä¸ªèƒŒåŒ…ï¼Œé€šè¿‡è¿™å¤šä¸ªèƒŒåŒ…æ¥è¿›è¡Œåˆ¤æ–­é¢˜ç›®ä¸­æ‰€è¦æ±‚è§£çš„å€¼ã€‚ é¢˜ç›®1.Fewest coins1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/* è¿™é“é¢˜ç›®ç¥å¥‡çš„åœ°æ–¹ æ˜¯ä¸¤ä¸ªèƒŒåŒ…çš„é—®é¢˜ çš„æ€»å’Œï¼Œå…¶å®ä¹Ÿç®—ä½œæ˜¯ä¸€ä¸ªç®€å•çš„é¢˜ç›®ï¼Œä½†æ˜¯ è¿™é“é¢˜å”¯ä¸€å¤æ‚çš„åœ°æ–¹å°±åœ¨äºå¯¹äºèƒŒåŒ…é—®é¢˜çš„ç†è§£ æ„æ€å°±æ˜¯å¦‚ä½•å°†ä¸€ä¸ªçœ‹ä¸Šå»ä¸æ˜¯èƒŒåŒ…çš„é—®é¢˜è½¬æ¢æˆä¸€ä¸ªèƒŒåŒ…é—®é¢˜ é¦–å…ˆçš„æ€è·¯å°±æ˜¯æ¥åˆ¤æ–­æ˜¯ä¸€ä¸ªä»€ä¹ˆç±»å‹çš„èƒŒåŒ… æ˜ å°„åˆ°è¿™é“é¢˜ä¸Šé¢å¯ä»¥å‘ç° å‰é¢ä»˜é’±çš„è¿‡ç¨‹æ˜¯ä¸€ä¸ªå¤šé‡èƒŒåŒ… åé¢ä»˜é’±çš„è¿‡ç¨‹æ˜¯ä¸€ä¸ªå®Œå…¨èƒŒåŒ… ä¸è¿‡æ·±å…¥ç†è§£äº†å¡å…¥ çŠ¶æ€æ–¹ç¨‹ ç¬¬ä¸€æ¬¡åœ¨ä»·å€¼é‚£ä¸ªåœ°æ–¹å‡ºç°äº†é”™è¯¯ã€‚ æœ€ç»ˆçš„ä»·å€¼ä¸åº”è¯¥æ˜¯ç›¸æ¯”æ€»æ˜¯çš„é’±æ•°ï¼Œè€Œåº”è¯¥æ˜¯æœ€å°èƒ½å¤Ÿè¾¾åˆ°çš„èƒŒåŒ…æ•°ã€‚*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;const int maxn = 30005;int dp[maxn],back[maxn];int value[105],number[105];int bag;int n,k;void zeroonepack(int weight,int value)&#123; for (int j = bag ; j &gt;= weight; j--) &#123; dp[j] = min(dp[j],dp[j - weight] + value); &#125;&#125;void completepack(int weight,int value) &#123; for (int j = weight; j &lt;= bag; j++) &#123; dp[j] = min(dp[j],dp[j - weight] + value); &#125;&#125;void mutipack(int weight,int value,int number) &#123; if (number * weight &gt;= bag) &#123; completepack(weight,value); return; &#125; int k = 1; while (k &lt; number) &#123; zeroonepack(k * weight,k * value); number = number - k; k *= 2; &#125; zeroonepack(number * weight , number * value);&#125;int main()&#123; while (cin &gt;&gt; n &gt;&gt; k) &#123; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; value[i] ; &#125; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; number[i]; &#125; memset(dp,0x3f3f3f3f,sizeof dp); memset(back,0x3f3f3f3f,sizeof back); dp[0] = 0; back[0] = 0; bag = k + 20000; for (int i = 1; i &lt;= n; i++) &#123; for (int j = value[i]; j &lt;= bag; j++) &#123; back[j] = min(back[j],back[j - value[i]] + 1); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; mutipack(value[i],1,number[i]); &#125; int ans = 0x3f3f3f3f; for (int i = k; i &lt;= bag; i++) &#123; ans = min(ans,back[i - k] + dp[i]); &#125; if (ans == 0x3f3f3f3f) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>acm</tag>
        <tag>èƒŒåŒ…ä¹è®²</tag>
        <tag>åŠ¨æ€è§„åˆ’</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[effective java item 6]]></title>
    <url>%2F2019%2F03%2F28%2Feffective-java-item-6%2F</url>
    <content type="text"><![CDATA[Item 6: Avoid creating unnecessary objects It is often appropriate to reuse a single object instead of creating a new function- ally equivalent object each time it is needed. Reuse can be both faster and more stylish. An object can always be reused if it is immutable å»åå¤çš„ä½¿ç”¨ä¸€ä¸ªå•ä¸€çš„å¯¹è±¡ï¼Œè€Œä¸æ˜¯å†æ¬¡åˆ›å»ºä¸€ä¸ªæ–°å¯¹è±¡å†éœ€è¦çš„æ—¶å€™è¿™æ ·çš„åšæ³•æ˜¯éå¸¸åˆé€‚çš„ã€‚é‡å¤ä½¿ç”¨å¯ä»¥åŒæ—¶å¾ˆå¿«æœ‰ç¬¦åˆç°ä»£è§„åˆ™ã€‚ç„¶åä¸€ä¸ªå¯¹è±¡å¯ä»¥è¢«æ€»æ˜¯åå¤ä½¿ç”¨å¦‚æœå…¶æ˜¯ä¸å˜çš„è¯ã€‚ ä¸‹é¢æœ‰ä¸€ä¸ªåŸºæœ¬ç®€å•çš„ä¾‹å­ 12String s = new String("bikini"); // DON'T DO THIS!String s = "bikini"; å‰è€…æ˜¯ä¸å¯ä»¥é‡‡å–çš„ï¼Œå› ä¸ºå…¶æ–°å»ºäº†ä¸¤ä¸ªå¯¹è±¡ï¼Œå¹¶ä¸”ç¬¬äºŒä¸ªæ–°å»ºçš„å¯¹è±¡ç›´æ¥èµ‹å€¼ç»™ç¬¬ä¸€ä¸ªæ–°å»ºçš„å¯¹è±¡ï¼Œè€Œåè€…å¯å–çš„åœ°æ–¹å°±åœ¨äºå…¶ç›´æ¥èµ‹å€¼ç»™äº†ç¬¬ä¸€ä¸ªå¯¹è±¡ï¼Œä¸å­˜åœ¨åˆ›å»ºä¸€ä¸ªæ–°çš„å¯¹è±¡ã€‚ You can often avoid creating unnecessary objects by using static factory meth- ods (Item 1) in preference to constructors on immutable classes that provide both. ä½ å¯ä»¥ç»å¸¸é€šè¿‡ç”¨é™æ€çš„å·¥å‚æ–¹æ³•ç¦æ­¢åˆ›å»ºä¸€ä¸ªä¸å¿…è¦çš„å¯¹è±¡è€Œä¸æ˜¯ä½¿ç”¨ä¸ä¼šæ”¹å˜çš„ç±»æˆ–è€…æ˜¯ä¸€ä¸ªæ„é€ å™¨ã€‚ For example, the factory method Boolean.valueOf(String) is preferable to the constructor Boolean(String), which was deprecated in Java 9. The constructor must create a new object each time itâ€™s called, while the factory method is never required to do so and wonâ€™t in practice. è¿™é‡Œä¸¾ä¸ªä¾‹å­ï¼Œå·¥å‚æ–¹æ³•å°±åƒä¸Šé¢æä¾›çš„ç›¸æ¯”äºå…¶çš„æ„é€ å‡½æ•°è€Œè¨€ï¼Œä¸éœ€è¦å†æ¯æ¬¡è°ƒç”¨çš„æ—¶å€™æ„å»ºä¸€ä¸ªæ–°çš„å¯¹è±¡ï¼Œè€Œä¸”å¦‚æœåå¤åˆ©ç”¨çš„æ˜¯ä¸€ä¸ªä¸å˜çš„å¯¹è±¡çš„è¯ï¼Œä½ å¯ä»¥ä¿è¯çš„æ˜¯ï¼Œæ‰¾ä¸ªå¯¹è±¡æ°¸è¿œéƒ½ä¸ä¼šæ”¹å˜ã€‚ Unfortunately, itâ€™s not always obvious when youâ€™re creating such an object. Suppose you want to write a method to determine whether a string is a valid Roman numeral. Hereâ€™s the easiest way to do this using a regular expression ä¸å¹¸çš„æ˜¯ï¼Œå½“ä½ åˆ›å»ºä¸€ä¸ªè¿™æ ·çš„å¯¹è±¡çš„æ—¶å€™ä¸æ€»æ˜¯é‚£ä¹ˆçš„æ˜æ˜¾ï¼Œå‡è®¾ä½ æƒ³è¦å†™ä¸€ä¸ªæ–¹æ³•å»åˆ¤æ–­ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¦æ˜¯ç½—é©¬æ•°å­—ï¼Œä¸‹é¢æœ‰ä¸€ä¸ªç®€å•çš„åŠæ³•æ¥è¿›è¡Œåˆ¤æ–­ï¼š1234// Performance can be greatly improved! static boolean isRomanNumeral(String s) &#123; return s.matches("^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)" + "(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$"); &#125; While String.matches is the easiest way to check if a string matches a regular expression, itâ€™s not suitable for repeated use in performance-critical situations. è¿™é€šå¸¸æ˜¯ä¸€ä¸ªæœ€ç®€å•çš„æ–¹æ³•å»åˆ¤æ–­æ˜¯å¦ä¸€ä¸ªå­—ç¬¦ä¸²å»åŒ…å«å¸¸è§„çš„è¯­æ³•æ“ä½œï¼Œç„¶è€Œå…¶å¹¶ä¸é€‚åˆå¤šæ¬¡ä½¿ç”¨å³å¤šæ¬¡è°ƒç”¨çš„åœºæ™¯ä¸‹é¢ã€‚ The problem is that it internally creates a Pattern instance for the regular expression and uses it only once, after which it becomes eligible for garbage collection. Creating a Pattern instance is expensive because it requires compiling the regular expression into a finite state machine. è€Œè¿™ä¸ªçš„é—®é¢˜å°±åœ¨äºå…¶åˆ›å»ºäº†ä¸€ä¸ªPatternçš„å®ä¾‹ç»™ç›¸åº”çš„æ­£åˆ™è¡¨è¾¾å¼ï¼Œè€Œä¸”ä»…ä»…åªæ˜¯ä½¿ç”¨äº†ä¸€æ¬¡ï¼Œç„¶åå°±ç›´æ¥è¢«javaåƒåœ¾å›æ”¶å™¨ç»™å›æ”¶äº†ï¼Œè€Œåˆ›å»ºä¸€ä¸ªPatternçš„å®ä¾‹çš„ä»£ä»·æ˜¯éå¸¸æ˜‚è´µçš„ï¼Œå› ä¸ºå…¶éœ€è¦compilingè¿™ä¸ªæ­£åˆ™è¡¨è¾¾å¼åˆ°ç›¸åº”çš„æœºå™¨é‡Œé¢å»ã€‚ 1234567// Reusing expensive object for improved performance public class RomanNumerals &#123; private static final Pattern ROMAN = Pattern.compile( "^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)" + "(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$"); static boolean isRomanNumeral(String s) &#123; return ROMAN.matcher(s).matches(); &#125; &#125; If the class containing the improved version of the isRomanNumeral method is initialized but the method is never invoked, the field ROMAN will be initialized needlessly. It would be possible to eliminate the initialization by lazily initializing the field (Item 83) the first time the isRomanNumeral method is invoked, but this is not recommended. As is often the case with lazy initialization, it would compli- cate the implementation with no measurable performance improvement (Item 67). è¿˜æœ‰ä¸€ç§ä¼˜åŒ–çš„æ–¹æ¡ˆå°±åœ¨äºï¼Œå¦‚æœä¸Šé¢è¿™ä¸ªç±»æ°¸è¿œéƒ½æ²¡æœ‰è¢«è°ƒç”¨çš„è¯ï¼Œé‚£ä¹ˆä¸Šé¢ç›´æ¥è®¾ç½®æˆé™æ€çš„æˆå‘˜å˜é‡å°±ä¼šå‡ºç°æ„é€ å¯¹è±¡çš„æµªè´¹ï¼Œæ„æ€å°±æ˜¯å¦‚æœæ²¡æœ‰è¢«è°ƒç”¨å°±ä¼šæœ‰æµªè´¹ï¼Œäºæ˜¯æœ‰ä¸€ç§æ–¹æ³•å°±æ˜¯æŒ‰ç…§ä¹‹å‰çš„å•å®ä¾‹åŒ–ç±»é‚£æ ·ï¼Œåœ¨æ„é€ å‡½æ•°é‡Œé¢åŠ ä¸Šï¼Œå¦‚æœè¢«è°ƒç”¨äº†ï¼Œé‚£ä¹ˆå°±ä¼šåˆ›å»ºä¸€ä¸ªfinalçš„å¯¹è±¡ã€‚ Another way to create unnecessary objects is autoboxing, which allows the programmer to mix primitive and boxed primitive types, boxing and unboxing automatically as needed. Autoboxing blurs but does not erase the distinction between primitive and boxed primitive types. è¿˜å­˜åœ¨ä¸€ç§æ–¹å¼å»åˆ›å»ºä¸€äº›ä¸å¿…è¦çš„å¯¹è±¡ï¼Œå°±æ˜¯è‡ªåŠ¨æ‰“åŒ…è¡Œä¸ºï¼Œå°±æ˜¯å°†åŸç”Ÿçš„ç±»å‹ï¼Œè‡ªåŠ¨æ‰“åŒ…æˆäº†å°è£…ç±»å‹ï¼Œè¿™æ ·ä¹Ÿä¼šé€ æˆè®¸å¤šä¸éœ€è¦çš„å¯¹è±¡ï¼Œæœ‰äº›å¯¹è±¡ä»…ä»…åªæ˜¯ä½¿ç”¨äº†ä¸€æ¬¡ã€‚å°±åƒä¸‹é¢è¿™ä¸ªä¾‹å­ï¼š1234567// Hideously slow! Can you spot the object creation? private static long sum() &#123; Long sum = 0L; for (long i = 0; i &lt;= Integer.MAX_VALUE; i++) sum += i; return sum; &#125; ä¸Šé¢çš„è¿™ä¸ªä¾‹å­å°±æ˜¯åœ¨åŠ æ³•çš„æ—¶å€™ä½¿longçš„ç±»å‹è‡ªåŠ¨åŒ…è£…æˆä¸€ä¸ªLongç±»å‹ï¼Œè¿™æ ·åˆ™é€ æˆäº†å¾ˆå¤šä¸å¿…è¦çš„å¼€é”€ã€‚ The present item says, â€œDonâ€™t create a new object when you should reuse an existing one,â€while Item 50 says, â€œDonâ€™t reuse an existing object when you should create a new one.â€ Note that the penalty for reusing an object when defensive copying is called for is far greater than the penalty for needlessly creating a duplicate object. Failing to make defensive copies where required can lead to insidious bugs and security holes; creating objects unnecessarily merely affects style and performance. æ€»è€Œè¨€ä¹‹ï¼Œå½“ä½ å¯ä»¥å¹¶ä¸”åº”è¯¥é‡å¤åˆ©ç”¨ä¸€ä¸ªå·²ç»å­˜åœ¨çš„ä¸€ä¸ªå¯¹è±¡çš„æ—¶å€™ï¼Œä¸è¦é‡å¤åˆ›å»ºä¸€ä¸ªæ–°çš„å¯¹è±¡ï¼Œè€Œç¬¬äº”åæ¡æé†’çš„æ˜¯ å½“ä½ éœ€è¦ä¸€ä¸ªæ–°çš„å¯¹è±¡çš„æ—¶å€™ä¸è¦å»é‡å¤å¼•ç”¨ä¸€ä¸ªå­˜åœ¨çš„æ—§å¯¹è±¡ã€‚è®°ä½ä¸€äº›ä¿æŠ¤æ€§è´¨copyå®é™…ä¸Šæ˜¯å¹¶ä¸å¯å–çš„ï¼Œè¿™ä¸ªåœ¨åé¢ä¼šæ¶‰åŠåˆ°ï¼Œå…¶å®è¿™é‡Œä¸C++é‡Œé¢çš„çŸ¥è¯†æœ‰ç‚¹å»åˆï¼Œå…³äºå·¦å€¼å¼•ç”¨ä¸å³å€¼å¼•ç”¨çš„çŸ¥è¯†ã€‚]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>java</tag>
        <tag>effective_java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[effective java item 5]]></title>
    <url>%2F2019%2F03%2F26%2Feffective-java-item-5%2F</url>
    <content type="text"><![CDATA[Item 5: Prefer dependency injection to hardwiring resources Many classes depend on one or more underlying resources. For example, a spell checker depends on a dictionary. It is not uncommon to see such classes imple- mented as static utility classes (Item 4): æœ‰ä¸€äº›ç±»ä¾èµ–ä¸€äº›æ½œåœ¨çš„èµ„æºï¼Œå°±åƒä¸€ä¸ªå­—ç¬¦ä¸²æ£€æŸ¥å™¨ ä¾é å­—å…¸ï¼Œæ‰€ä»¥ä¹Ÿå°±ä¸æ˜¯å¾ˆç‰¹æ®Šè§åˆ°ä¸€äº›ç±»è¢«ç¿»è¯‘æˆé™æ€çš„å·¥å…·ç±»ã€‚ Similarly, itâ€™s not uncommon to see them implemented as singletons (Item 3): å°±åƒä¸€äº›ç±»ç›´æ¥è¢«ç¿»è¯‘æˆå•ä¸€å®ä¾‹ç±»ã€‚ 12345678// Inappropriate use of singleton - inflexible &amp; untestable! public class SpellChecker &#123; private final Lexicon dictionary = ...; private SpellChecker(...) &#123;&#125; public static INSTANCE = new SpellChecker(...); public boolean isValid(String word) &#123; ... &#125; public List&lt;String&gt; suggestions(String typo) &#123; ... &#125; &#125; Static utility classes and singletons are inappropriate for classes whose behavior is parameterized by an underlying resource. é™æ€çš„å·¥å…·ç±»å’Œå•ä¸€å®ä½“ç±»ï¼Œä¼šåœ¨å­˜åœ¨å¤šç§å‚æ•°æ›¿æ¢ç»™åŸºç¡€èµ„æºï¼Œï¼ˆå°±åƒä¸Šé¢çš„æ£€æŸ¥å™¨æœ‰å¤šç§ç‰ˆæœ¬çš„å­—å…¸èµ„æºä¸€æ ·ï¼‰ï¼Œé‚£ä¹ˆè¿™äº›ç±»å°±ä¼šå˜å¾—ç‰¹åˆ«ä¸åˆé€‚ã€‚ A simple pattern that satisfies this requirement is to pass the resource into the constructor when creating a new instance. This is one form of dependency injection: the dictionary is a dependency of the spell checker and is injected into the spell checker when it is created. åªæœ‰ä¸€ç§åŠæ³•å°±æ˜¯åœ¨æ„å»ºçš„æ—¶å€™ æ„å»ºå‡½æ•°é‡Œé¢ç›´æ¥ç»™äºˆç›¸åº”çš„æ„é€ å™¨ï¼Œè¿™æ ·æ—¢ç»´æŠ¤äº†å•å®ä¾‹åŒ–ï¼Œåˆè§£å†³äº†ä¸Šé¢å¤šç‰ˆæœ¬çš„é—®é¢˜ã€‚ 123456789// Dependency injection provides flexibility and testability public class SpellChecker &#123; private final Lexicon dictionary; public SpellChecker(Lexicon dictionary) &#123; this.dictionary = Objects.requireNonNull(dictionary); &#125; public boolean isValid(String word) &#123; ... &#125; public List&lt;String&gt; suggestions(String typo) &#123; ... &#125; &#125; In summary, do not use a singleton or static utility class to implement a class that depends on one or more underlying resources whose behavior affects that of the class, and do not have the class create these resources directly. Instead, pass the resources, or factories to create them, into the constructor (or static factory or builder). This practice, known as dependency injection, will greatly enhance the flexibility, reusability, and testability of a class. æ€»è€Œè¨€ä¹‹ï¼Œä¸è¦åœ¨å®ç°ä¸€ä¸ªé™æ€å·¥å…·ç±»æˆ–è€…ä¸€ä¸ªå•å®ä¾‹ç±»çš„æ—¶å€™çš„åŒæ—¶å»å®ç°ä¸€ä¸ªå¤šä¸ªèµ„æºæ›¿æ¢çš„ç±»ï¼Œè¿™æ ·ä¼šå½±å“å…¶ä»–çš„ç±»ï¼Œå¹¶ä¸”è¿èƒŒäº†è¿™ä¸ªç±»æœ€å…ˆå¼€å§‹çš„æœ¬æ„ï¼Œå¥½çš„è§£å†³åŠæ³•å°±æ˜¯åœ¨ç±»çš„æ„é€ å‡½æ•°é‡Œé¢åŠ ä¸Šè¯¥èµ„æºæˆ–è€…å¸¦ä¸Šè¯¥å·¥å‚æ–¹æ³•ã€‚ å¦å¤–å¯¹äºä¸Šé¢ä¸€ä¸ªå‡½æ•°è¿›è¡Œè®²è§£Objects.requireNonNull;å…¶çš„ä»£ç å½¢å¼å¦‚ä¸‹ï¼š 12345public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>java</tag>
        <tag>effective_java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[effective java item 4]]></title>
    <url>%2F2019%2F03%2F16%2Feffective-java-item-4%2F</url>
    <content type="text"><![CDATA[Item 4: Enforce noninstantiability with a private constructorå¼ºè¿«ä¸èƒ½å®ä¾‹åŒ–çš„ç±»ï¼Œæ‹¥æœ‰ä¸€ä¸ªç§æœ‰çš„æ„é€ å‡½æ•°ã€‚ Occasionally youâ€™ll want to write a class that is just a grouping of static methods and static fields. Such classes have acquired a bad reputation because some people abuse them to avoid thinking in terms of objects, but they do have valid uses. ä¹Ÿè®¸æœ‰çš„æ—¶å€™ï¼Œä½ éœ€è¦å†™ä¸€ä¸ªç±»ï¼Œæ‹¥æœ‰ä¸€äº›é™æ€çš„å˜é‡ä¸å‡½æ•°ï¼Œè€Œå½“æœ‰äººç»™è¿™äº›ç±»å®ä¾‹åŒ–çš„æ—¶å€™ï¼Œè¿™äº›ç±»å¾€å¾€å°±å…·æœ‰ä¸€äº›ä¸å¤ªå¥½çš„å£ç¢‘ã€‚å› ä¸ºè¿™äº›ç±»å¹¶ä¸æ˜¯å½“æˆå¯¹è±¡ï¼Œä»…ä»…åªæ˜¯å½“æˆä¸€ä¸ªå·¥å…·ã€‚ (As of Java 8, you can also put such methods in the interface, assuming itâ€™s yours to modify.) Lastly, such classes can be used to group methods on a final class, since you canâ€™t put them in a subclass åœ¨java8çš„æ—¶å€™ä½ å¯ä»¥æŠŠä¸€äº›å‡½æ•°ç›´æ¥æ”¾åœ¨æ¥å£é‡Œé¢ï¼Œè€Œæœ€è¿‘ä¸€äº›ç±»å¯ä»¥å¸®ç”¨åšæ˜¯ä¸€ç³»åˆ—çš„å‡½æ•°ç¾¤ï¼Œä¸è¿‡ä½ ä¸èƒ½å°†ä»–ä»¬æ”¾åˆ°å¯ä»¥ç»§æ‰¿çš„å­ç±»é‡Œé¢å»ã€‚ Such utility classes were not designed to be instantiated: an instance would be nonsensical. In the absence of explicit constructors, however, the compiler pro- vides a public, parameterless default constructor. To a user, this constructor is indistinguishable from any other. è€Œä¸€äº›åŠŸèƒ½ç±»å‹çš„ç±»ä¸æ˜¯è¢«è®¾è®¡æˆå¯å®ä¾‹åŒ–çš„ï¼Œæ˜¯å› ä¸ºå®ä¾‹åŒ–å¾€å¾€æ²¡æœ‰æ„æ€ï¼Œè€Œè¿™ä¸ªæ—¶å€™ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨çš„æä¾›å…¬å¼€ä¸”æ²¡æœ‰å‚æ•°çš„æ„é€ å‡½æ•°ï¼Œå¯¹äºå®¢æˆ·åŠå…¶ä½¿ç”¨è€…è€Œè¨€ï¼Œå¿…é¡»ä½¿è¿™ç±»æ„é€ å‡½æ•°éšè—èµ·æ¥ã€‚ Attempting to enforce noninstantiability by making a class abstract does not work. The class can be subclassed and the subclass instantiated. ç„¶åä»…ä»…åªæ˜¯å¼ºè¿«è¿™äº›ç±»å˜æˆæŠ½è±¡ç±»æ˜¯å®Œå…¨è¾¾ä¸åˆ°æ•ˆæœçš„ï¼Œå› ä¸ºè¿™äº›ç±»è¿˜ä¼šè¢«ç»§æ‰¿ï¼Œè€Œç»§æ‰¿å…¶çš„å­ç±»å¾€å¾€è¿˜ä¼šè¢«å®ä¾‹åŒ–ã€‚ A default construc- tor is generated only if a class contains no explicit constructors, so a class can be made noninstantiable by including a private constructor: ç„¶åæœ€åçš„ç»“æœå°±æ˜¯åªèƒ½ç»™ç±»å®‰ç½®ä¸€ä¸ªç§æœ‰çš„æ„é€ å‡½æ•°æ‰èƒ½é¿å…ä»¥ä¸Šé—®é¢˜ã€‚ å°±åƒå¦‚ä¸‹ä»£ç ï¼š12345678// Noninstantiable utility class public class UtilityClass &#123; // Suppress default constructor for noninstantiability private UtilityClass() &#123; throw new AssertionError(); &#125; ...// Remainder omitted &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>effective_java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[effective java item 3]]></title>
    <url>%2F2019%2F03%2F15%2Feffective-java-item-3%2F</url>
    <content type="text"><![CDATA[Item 3: Enforce the singleton property with a private constructor or an enum type A singleton is simply a class that is instantiated exactly once [Gamma95]. Single- tons typically represent either a stateless object such as a function (Item 24) or a system component that is intrinsically unique. é¦–å…ˆå…ˆè§£é‡Šä¸€ä¸‹ singleton è¿™ä¸ªæ˜¯è¡¨ç¤ºä¸€ä¸ªç±»åªä¼šè¢«å®ä¾‹åŒ–ä¸€æ¬¡çš„ç±»ï¼Œä¸€èˆ¬ç”¨äºä¸€äº›å‡½æ•°ç±»å‹çš„åŠŸèƒ½ï¼Œä»¥åŠæŸäº›ä¸€åŒçš„ç‹¬ä¸€æ— äºŒçš„é‡è¦ç»„æˆæˆåˆ†ã€‚ There are two common ways to implement singletons. Both are based on keeping the constructor private and exporting a public static member to provide access to the sole instance. In one approach, the member is a final field ç°åœ¨æœ‰ä¸¤ç§åŠæ³•å»å®ç°è¿™ç§å•å®ä¾‹çš„æƒ…å†µï¼ŒåŸºäºä¿è¯å…¶çš„æ„é€ å‡½æ•°ç§æœ‰åŒ–ï¼Œå’Œè¾“å‡ºå…¬å¼€é™æ€æˆå‘˜æ¥ä¿æŠ¤å”¯ä¸€çš„å®ä¾‹ï¼Œä¸€èˆ¬è¿™ä¸ªå®ä¾‹éƒ½æ˜¯finalçš„å˜é‡ã€‚ 123456// Singleton with public final field public class Elvis &#123; public static final Elvis INSTANCE = new Elvis(); private Elvis() &#123; ... &#125; public void leaveTheBuilding() &#123; ... &#125; &#125; ä»¥ä¸Šçš„ä¾‹å­å°±æ˜¯åœ¨é™æ€åŠ è½½çš„è¿‡ç¨‹ä¸­å°±ç›´æ¥è°ƒç”¨è¿™ä¸ªå®ä¾‹ç±»çš„å‡½æ•°ï¼Œå¤–éƒ¨æ— æ³•ç›´æ¥å»æ„é€ è¿™ä¸ªç±»ï¼Œæ‰€ä»¥ä¹Ÿå°±ç›´æ¥é€ æˆè¿™ä¸ªç±»åªèƒ½å¤Ÿè¢«è®¿é—®ä¸€æ¬¡ã€‚ In the second approach to implementing singletons, the public member is a static factory method ç¬¬äºŒç§æ–¹æ³•è·å¾—è¿™ç§å•å®ä¾‹åŒ–çš„ç±»ï¼Œç›´æ¥ä½¿ç”¨ä¸€ä¸ªgetç±»å‹çš„å‡½æ•°ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ä¸€ç§ä½ é‚£ä¸ªæ‡’æƒ°æ ‡è®°çš„æ–¹æ³•ï¼Œç›´åˆ°è°ƒç”¨çš„æ—¶å€™æ‰å¼€å§‹å®ä¾‹åŒ–è¿™ä¸ªç±»ã€‚ One advantage of the static factory approach is that it gives you the flexibility to change your mind about whether the class is a singleton without changing its API. The factory method returns the sole instance, but it could be modified to return, say, a separate instance for each thread that invokes it. ç¬¬ä¸€ä¸ªå‡½æ•°å°±æ˜¯ç»™ä½ çµæ´»æ€§å»æ”¹å˜è¿™ä¸ªç±»æ˜¯å¦æ˜¯å•å®ä¾‹åŒ–ï¼Œå…¶çš„é™æ€å·¥å‚æ–¹æ³•æ˜¯è¿”å›è¿™ä¸ªç±»çš„å”¯ä¸€å®ä¾‹ï¼Œä½†æ˜¯å…¶å¾ˆå®¹æ˜“è¢«ä¿®æ”¹ï¼Œæ¯”å¦‚è¯´ä¸ºæ¯ä¸€æ¬¡è°ƒç”¨è¯¥æ–¹æ³•çš„çº¿ç¨‹è¿”å›ä¸€ä¸ªå”¯ä¸€çš„å®ä¾‹ã€‚ A second advantage is that you can write a generic singleton factory if your application requires it (Item 30). A final advantage of using a static factory is that a method reference can be used as a supplier, for example Elvis::instance is a Supplier. Unless one of these advantages is relevant, the public field approach is preferable ç¬¬äºŒä¸ªå¥½äº‹å°±æ˜¯ä½ å¯ä»¥å†™ä¸€ä¸ªæ³›å‹ç±»å‹çš„å•å®ä¾‹åŒ–ç±»ï¼Œå¦‚æœä½ çš„åº”ç”¨å°±æ­¤è¦æ±‚çš„è¯ã€‚å°±æ­¤çš„æ–¹æ³•å¯ä»¥æŠŠè¿™ä¸ªå•å®ä¾‹åŒ–å½“æˆä¸€ç§æä¾›è€…ã€‚ To make a singleton class that uses either of these approaches serializable (Chapter 12), it is not sufficient merely to add implements Serializable to its declaration. To maintain the singleton guarantee, declare all instance fields transient and provide a readResolve method (Item 89). Otherwise, each time a serialized instance is deserialized, a new instance will be created, leading, in the case of our example, to spurious Elvis sightings. ä¸ºäº†ä¿è¯æ¯ä¸€æ¬¡è®¿é—®åˆ°ç±»é‡Œé¢çš„ï¼Œå»è·å¾—ä¸€ä¸ªâ€åªè¯»å‡½æ•°â€œï¼Œè¿™æ ·å°±é˜²æ­¢æ¯ä¸€æ¬¡è®¿é—®åˆ°è¿™ä¸ªç±»çš„æ—¶å€™ä¸ä¼šå†ç”Ÿæˆä¸€ä¸ªæ–°çš„ç±»ï¼Œç¡®ç¡®å®å®çš„ä¿è¯äº†ç±»çš„å•ä¸€æ€§ã€‚ A third way to implement a singleton is to declare a single-element enum: ç¬¬ä¸‰ç§æ–¹æ³•å®ç°å•å®ä¾‹åŒ–æ˜¯ç”Ÿæˆä¸€ä¸ªå•ä¸ªå…ƒç´ çš„æšä¸¾ç±» This approach is similar to the public field approach, but it is more concise, provides the serialization machinery for free, and provides an ironclad guarantee against multiple instantiation, even in the face of sophisticated serialization or reflection attacks. This approach may feel a bit unnatural, but a single-element enum type is often the best way to implement a singleton. è¿™ç§ç±»å‹çš„æ–¹æ³•å°±æ˜¯ç±»ä¼¼äºç±»çš„å˜é‡æ–¹æ³•ï¼Œä½†æ˜¯è¿™ä¸ªæ›´ç²¾ç»†ï¼Œæä¾›çš„æœºå™¨å†…å­˜æ¶ˆè€—å‡ ä¹å°±æ˜¯å…è´¹çš„ï¼Œå¹¶ä¸”æä¾›ï¼ˆè¿™é‡Œåé¢çš„ä¸€å¥è¯ è‹±æ–‡æ²¡æ€ä¹ˆçœ‹æ‡‚ è‡ªåŠ¨æ ‡çº¢ï¼‰ã€‚ è¿™ç§æ–¹æ³•å¯èƒ½æœ‰ç‚¹ä¸è‡ªç„¶ï¼Œä½†æ˜¯è¿™ç§æ–¹æ³•å¾€å¾€æ˜¯å®ç°è¿™ç§å•å®ä¾‹åŒ–æœ€å¥½çš„æ–¹æ³•ã€‚ Note that you canâ€™t use this approach if your singleton must extend a superclass other than Enum (though you can declare an enum to implement interfaces). è®°ä½å¦‚æœä½ éœ€è¦ç”¨å•å®ä¾‹åŒ–ç±»å»ç»§æ‰¿ä¸€ä¸ªç±»çš„è¯ï¼Œé‚£ä¹ˆå°±ä¸èƒ½ä½¿ç”¨è¿™ç§å•æšä¸¾çš„æ–¹æ³•äº†ã€‚å…¶çš„æ ·ä¾‹ä»£ç å¦‚ä¸‹ï¼š1234567// Enum singleton - the preferred approach public enum Elvis &#123; INSTANCE; public void leaveTheBuilding() &#123; ... &#125; &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>effective_java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[effective java item 2]]></title>
    <url>%2F2019%2F03%2F14%2Feffective-java-item-2%2F</url>
    <content type="text"><![CDATA[Item 2: Consider a builder when faced with many constructor parametersæ¡æ¬¾äºŒ å½“é¢ä¸´è®¸å¤šæ„é€ å‚æ•°çš„æ—¶å€™ï¼Œå»ºè®®è€ƒè™‘ä¸€ä¸‹ä¸€ä¸ªæ„é€ å™¨(builder) What sort of constructors or static factories should you write for such a class? Traditionally, programmers have used the telescoping constructor pattern, in which you provide a constructor with only the required parameters, another with a single optional parameter, a third with two optional parameters, and so on, culmi- nating in a constructor with all the optional parameters. ç»å¸¸ä¼šé‡åˆ°æ„é€ å‡½æ•°ä¸­æœ‰å¤šä¸ªå‚æ•°ï¼Œè€Œè¿™äº›å‚æ•°ï¼Œå¦‚æœæŒ‰ç…§æ ‡å‡†çš„æ–¹æ³•æ¥å†™çš„è¯ï¼Œä¼šç‰¹åˆ«çš„éº»çƒ¦ï¼Œäºæ˜¯å°±é‡‡ç”¨C++ä¸­çš„å§”æ‰˜æ„é€ å‡½æ•°ï¼Œåˆ©ç”¨å…¶ä¸­ä¸€ä¸ªæ„é€ å‡½æ•°ï¼Œä¸ºå…¶ä»–æ‰€æœ‰çš„æ„é€ å‡½æ•°æ„é€ ï¼Œç›¸å½“äºèµ·åˆ°äº†ä¸€ä¸ªæ„é€ å™¨çš„ä½œç”¨(builder) Typically this constructor invocation will require many parameters that you donâ€™t want to set, but youâ€™re forced to pass a value for them anyway. In this case, we passed a value of 0 for fat. å¾ˆå¤šæ—¶å€™ä½ ä¸æƒ³è®¾ç½®é‚£ä¹ˆå¤šçš„å‚æ•°ï¼Œæœ€ç®€å•çš„ä¸€ä¸ªåŠæ³•æ˜¯ç»™è¿™ä¸ªæˆå‘˜ç›´æ¥è®¾ç½®0ã€‚ In short, the telescoping constructor pattern works, but it is hard to write client code when there are many parameters, and harder still to read it. The reader is left wondering what all those values mean and must carefully count parameters to find out. Long sequences of identically typed parameters can cause subtle bugs. If the client accidentally reverses two such parameters, the compiler wonâ€™t complain, but the program will misbehave at runtime (Item 51). ç®€è€Œè¨€ä¹‹ï¼Œè¿™ç§å§”æ‰˜æ„é€ å‡½æ•°è™½ç„¶å¯è¡Œï¼Œä½†æ˜¯å®¢æˆ·åœ¨å†™ä»£ç çš„æ—¶å€™å¾ˆå®¹æ˜“å†™é”™ï¼Œå°±ç®—å†™å¯¹äº†ï¼Œä¹Ÿå¾ˆéš¾è¯»å‡ºæ¥ï¼Œå¹¶ä¸”ä¹Ÿä¼šå‡ºç°ä¸€ç§æƒ…å†µå°±æ˜¯å½“å‚æ•°å¤Ÿå¤šçš„æ—¶å€™ï¼Œå†™é”™äº†å‚æ•°çš„é¡ºåºï¼Œè¿™æ ·é€ æˆçš„é”™è¯¯ï¼Œç¼–è¯‘å™¨æ˜¯ä¸ä¼šè½»æ˜“æŠ¥é”™çš„ã€‚æ‰€ä»¥è¿™é‡Œå°±å¾ˆéš¾è¢«æ‰¾å‡ºæ¥ã€‚ A second alternative when youâ€™re faced with many optional parameters in a constructor is the JavaBeans pattern, in which you call a parameterless construc- tor to create the object and then call setter methods to set each required parameter and each optional parameter of interest è¿˜æœ‰ç¬¬äºŒç§åŠæ³•å°±æ˜¯ ç»™æ¯ä¸€ä¸ªç§æœ‰æˆå‘˜è®¾ç½®ä¸€ä¸ªsetå‡½æ•°ï¼Œä¸€ä¸ªå¤–å›´çš„å‡½æ•°ç›´æ¥å¯ä»¥ä½œç”¨åˆ°å†…éƒ¨ç§æœ‰æˆå‘˜ï¼Œå¹¶ä¸”ç›´æ¥è®¾ç½®å…¶çš„å€¼ã€‚ Unfortunately, the JavaBeans pattern has serious disadvantages of its own.Because construction is split across multiple calls, a JavaBean may be in an inconsistent state partway through its construction. The class does not have the option of enforcing consistency merely by checking the validity of the constructor parameters. Attempting to use an object when itâ€™s in an inconsistent state may cause failures that are far removed from the code containing the bug and hence difficult to debug. ä¸å¹¸çš„æ˜¯ï¼Œè¿™ç§æ¨¡å¼çš„ä»£ç å†™æ³•ï¼Œå°†æ„é€ è¿‡ç¨‹ä¸èµ‹å€¼è¿‡ç¨‹åˆ†å¼€ï¼Œä¹Ÿå°±æ„å‘³ç€ï¼Œå½“æ„é€ å¯¹è±¡å¹¶æ²¡æœ‰èµ‹å€¼çš„æ—¶å€™ä¼šé€ æˆé”™è¯¯ï¼Œå¦å¤–ï¼Œå…¶è¿˜ä¼šåœ¨å†™ä¸€ä¸ªimmutableç±»çš„æ—¶å€™èŠ±è´¹é¢å¤–çš„å·¥ä½œä¿è¯çº¿ç¨‹å®‰å…¨ã€‚ Luckily, there is a third alternative that combines the safety of the telescoping constructor pattern with the readability of the JavaBeans pattern. It is a form of the Builder pattern [Gamma95]. Instead of making the desired object directly, the client calls a constructor (or static factory) with all of the required parameters and gets a builder object. Then the client calls setter-like methods on the builder object to set each optional parameter of interest. Finally, the client calls a parameterless build method to generate the object, which is typically immutable. å¹¸è¿çš„æ˜¯ è¿™é‡Œå­˜åœ¨ç¬¬ä¸‰ç§æ„é€ æ–¹å¼ï¼Œç»“åˆä¸Šè¿°ä¸¤ç§æ–¹æ³•çš„ä¼˜ç‚¹ï¼Œå¹¶ä¸”ä¿è¯äº†çº¿ç¨‹å®‰å…¨ï¼Œä¹Ÿä¸ä¼šæœ‰è¿‡å¤šçš„å‚æ•°çš„éº»çƒ¦ã€‚æŒ‰ç…§ä¸‹è¿°çš„ä¾‹å­ï¼Œç›´æ¥åœ¨å†…çš„å†…éƒ¨æ„é€ ä¸€ä¸ªé™æ€çš„builderçš„ç±»ï¼Œç”¨ä¸€ä¸ªå…¶ä»–çš„ç±»æ¥æ„é€ è¿™ä¸ªç±»ï¼Œç¬¬ä¸€è§£å†³äº†immutableçš„é—®é¢˜ï¼Œå…¶æ¬¡ä¹Ÿè§£å†³äº†å‚æ•°ä¸èƒ½ç‰¹æ„çš„é—®é¢˜ã€‚ This client code is easy to write and, more importantly, easy to read. The Builder pattern simulates named optional parameters as found in Python and Scala. NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8) .calories(100).sodium(35).carbohydrate(27).build();Check invariants involving multiple parameters in the constructor invoked by the build method. To ensure these invariants against attack, do the checks on object fields after copying parameters from the builder (Item 50). If a check fails, throw an IllegalArgumentException (Item 72) whose detail message indicates which parameters are invalid (Item 75). è¿™æ ·çš„åšæ³•ä¼šé€ æˆä»£ç æ¸…æ™°å¯è¯»ï¼Œå¹¶ä¸”æœ€é‡è¦çš„æ˜¯ï¼Œå¯ä»¥åœ¨æ„é€ å™¨è¿™ä¸ªç±»å‹é‡Œé¢è¿›è¡Œä¸€ä¸ªcheckå‡½æ•°è¿›è¡Œå¼‚å¸¸æ£€æŸ¥ã€‚ The Builder pattern is well suited to class hierarchies. Use a parallel hier- archy of builders, each nested in the corresponding class. Abstract classes have abstract builders; concrete classes have concrete builders. è¿™ç§æ„é€ æ¨¡å¼ï¼Œå…¶å®ç‰¹åˆ«æœ‰åˆ©äºç±»å‹ç»§æ‰¿ï¼Œåˆ©ç”¨ç›¸åº”çš„ç±»å†…çš„æ„é€ å™¨å¸®åŠ©è¿›è¡Œæ„é€ ã€‚ä¸€èˆ¬åˆ©ç”¨åƒå¦‚ä¸‹å½¢å¼çš„æ„é€ æ–¹æ³•å³å¯ï¼šè®°ä½è¿™ä¸ªåœ°æ–¹æ—¶ç›´æ¥ç”¨è¿‡build æ¥è¿”å›å¤–éƒ¨çš„é‚£ä¸ªç±»ã€‚ NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8) .calories(100).sodium(35).carbohydrate(27).build(); Here are two concrete subclasses of Pizza, one of which represents a standard New-York-style pizza, the other a calzone. åé¢çš„ä¸¤ç§æ¨¡å¼å±äºç»§æ‰¿è¿‡ç¨‹ä¸­å‡ºç°çš„æ„é€ ï¼Œæ³¨æ„æ„é€ çš„è¿™ä¸ªæ„é€ å™¨ ä¸€å®šè¦æ»¡è¶³å¦‚ä¸‹å½¢å¼ã€‚æœ€é‡è¦çš„æ˜¯ä¸‹é¢ç»§æ‰¿å¤„çš„å¤„ç†ï¼Œè°ƒç”¨åŸºç±»çš„æ„é€ å™¨ super(builder);12345678910111213141516171819202122232425262728293031323334353637public class NyPizza extends Pizza &#123; public enum Size &#123; SMALL, MEDIUM, LARGE &#125; private final Size size; public static class Builder extends Pizza.Builder&lt;Builder&gt; &#123; private final Size size; public Builder(Size size) &#123; this.size = Objects.requireNonNull(size); &#125; @Override public NyPizza build() &#123; return new NyPizza(this); &#125; @Override protected Builder self() &#123; return this; &#125; &#125; private NyPizza(Builder builder) &#123; super(builder); size = builder.size; &#125; &#125; public class Calzone extends Pizza &#123; private final boolean sauceInside; public static class Builder extends Pizza.Builder&lt;Builder&gt; &#123; private boolean sauceInside = false; // Default public Builder sauceInside() &#123; sauceInside = true; return this; &#125; @Override public Calzone build() &#123; return new Calzone(this); &#125; @Override protected Builder self() &#123; return this; &#125; &#125; private Calzone(Builder builder) &#123; super(builder); sauceInside = builder.sauceInside; &#125; &#125; This technique, wherein a subclass method is declared to return a subtype of the return type declared in the super- class, is known as covariant return typing. It allows clients to use these builders without the need for casting. è¿™é¡¹æŠ€æœ¯è¿”å›çš„ç±»éƒ½æ˜¯éš¶å±äºè¯¥ç±»çš„ï¼Œè¿™æ ·åšçš„å¥½å¤„å¯ä»¥å…è®¸å®¢æˆ·ä½¿ç”¨è¿™äº›ç±»è€Œä¸éœ€è¦ä½¿ç”¨è½¬å‹ã€‚ A single builder can be used repeatedly to build multiple objects. The parameters of the builder can be tweaked between invocations of the build method to vary the objects that are created. A builder can fill in some fields automatically upon object creation, such as a serial number that increases each time an object is created. ç”±äºæ˜¯é™æ€çš„ç±»ï¼Œæ‰€ä»¥åªéœ€è¦è¢«æ„é€ ä¸€æ¬¡ï¼Œå´å¯ä»¥é€ æˆå¤šæ¬¡ä½¿ç”¨ï¼Œè¿™é‡Œå°±æ˜¯å…¶çš„å¥½å¤„ï¼Œï¼Œè€Œè¿™ä¸ªæ„é€ å™¨å¯ä»¥åœ¨è¿™ä¸ªå¯¹è±¡è¢«åˆ›å»ºä¹‹åè‡ªåŠ¨èµ‹å€¼ã€‚ï¼Œæ¯”è¾ƒæ–¹ä¾¿ã€‚ The Builder pattern has disadvantages as well. In order to create an object, you must first create its builder. While the cost of creating this builder is unlikely to be noticeable in practice, it could be a problem in performance-critical situations. Also, the Builder pattern is more verbose than the telescoping constructor pattern å…¶å­˜åœ¨çš„åå¤„å°±åœ¨äºï¼Œå…¶å†™å‡ºæ¥çš„ä»£ç éå¸¸çš„å¤æ‚å’Œå†—æ‚ï¼Œå¯¹äºåªæœ‰ä¸€ç‚¹å‚æ•°çš„æ„é€ å™¨è€Œè¨€ï¼Œå®Œå…¨æ²¡æœ‰è¿™æ ·å†™çš„å¿…è¦ï¼Œä½†æ˜¯å¯¹äºå…ˆå¼€å§‹åªæœ‰ä¸€ç‚¹å‚æ•°ï¼Œä½†æ˜¯åé¢åˆ™å˜æˆå¾ˆå¤šå‚æ•°çš„å·¥ç¨‹æ¥è¯´ç¬¬ä¸€æ¬¡ä½¿ç”¨è¿™ç§æ„é€ å™¨æ–¹ä¾¿ä»¥åæ¥å†™ã€‚ In summary, the Builder pattern is a good choice when designing classes whose constructors or static factories would have more than a handful of parameters æ€»è€Œè¨€ä¹‹ï¼Œä½¿ç”¨è¿™ç§åŠæ³•çš„æ–¹ä¾¿åœ¨äºå¤§å·¥ç¨‹ï¼Œä¸”ä¸€ä¸ªç±»çš„æ„é€ å‚æ•°è¿‡å¤šçš„æƒ…å†µï¼Œå³è§£å†³äº†å‚æ•°å†—æ‚çš„é—®é¢˜ï¼Œåˆå†æ¬¡è§£å†³äº†ç±»ä¸èƒ½finalçš„é—®é¢˜ã€‚]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>effective_java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[effective java item 1]]></title>
    <url>%2F2019%2F03%2F13%2Feffective-java-item-1%2F</url>
    <content type="text"><![CDATA[Item 1: Consider static factory methods instead of constructorså‰é¢å‡ ä¸ªæ¡æ¬¾çš„å†…å®¹æ˜¯å…³äºåˆ›å»ºå’Œé”€æ¯å¯¹è±¡ã€‚ The traditional way for a class to allow a client to obtain an instance is to provide a public constructor. There is another technique that should be a part of every programmerâ€™s toolkit. A class can provide a public static factory method, which is simply a static method that returns an instance of the class. Hereâ€™s a simple example from Boolean (the boxed primitive class for boolean). This method translates a boolean primitive value into a Boolean object reference: è€ƒè™‘ç›´æ¥ç”¨ä¸€ä¸ªé™æ€çš„æ–¹æ³•æ¥å®Œæˆæ„é€ å‡½æ•°çš„åŠŸèƒ½ï¼Œæ¯”å¦‚æ¥å—ä¸€ä¸ªå¯¹è±¡ï¼Œç„¶åé€šè¿‡è¿™ä¸ªå¯¹è±¡æ¥æ„é€ ä¸€ä¸ªæ–°çš„å¯¹è±¡ã€‚ A class can provide its clients with static factory methods instead of, or in addition to, public constructors. Providing a static factory method instead of a public constructor has both advantages and disadvantages. æä¾›ä¸€ä¸ªé™æ€æ–¹æ³•ä½œä¸ºæ„é€ å‡½æ•°çš„æœ‰é¢å¤–ç›¸å¯¹äºæä¾›å…¬å¼€æ„é€ å‡½æ•°çš„å¥½å¤„ä»¥åŠåå¤„ã€‚ One advantage of static factory methods is that, unlike constructors, they have names. If the parameters to a constructor do not, in and of themselves, describe the object being returned, a static factory with a well-chosen name is easier to use and the resulting client code easier to read. ç¬¬ä¸€ä¸ªå¥½å¤„æ˜¯é™æ€çš„å‡½æ•°æœ‰ç‹¬ç‰¹çš„åå­—è€Œæ„é€ å‡½æ•°æ²¡æœ‰åå­—ï¼Œé€šè¿‡åå­—å°†æ„é€ å‡½æ•°çš„å‚æ•°è¿›è¡Œä¸€ä¸ªåˆ†ç±»æ˜¾ç¤ºçš„æ›´åŠ è€ç”¨ã€‚ the constructor BigInteger(int, int, Random), which returns a BigInteger that is probably prime, would have been better expressed as a static factory method named BigInteger.probablePrime. å°±åƒå¤§æ•´æ•°ç±»åœ¨é‡Œé¢å°±æœ‰ä¸€ä¸ªæ„é€ ä¸€ä¸ªè¶‹è¿‘äºè‡ªå·±å€¼çš„è´¨æ•°çš„å¤§æ•´æ•°ç±»ï¼Œç„¶åè¿™é‡Œç›´æ¥ç”¨åå­—å‘½åæ˜¾å¾—æ›´åŠ æ–¹ä¾¿ã€‚ Because they have names, static factory methods donâ€™t share the restriction discussed in the previous paragraph. In cases where a class seems to require multiple constructors with the same signature, replace the constructors with static factory methods and carefully chosen names to highlight their differences. æœ‰çš„æ—¶å€™ä¸€äº›å…¬å¼€æ„é€ å‡½æ•°çš„å‚æ•°ç±»å‹ï¼Œä»¥åŠå‚æ•°çš„é¡ºåºï¼Œä»£è¡¨ç€ä¸åŒçš„æ„é€ å‡½æ•°ï¼Œè¿™æ ·ä¼šå®¹æ˜“å¼„æ··æ·†ï¼Œäºæ˜¯è¿™ä¹Ÿæ˜¯ä½“ç°åå­—ç¬¬äºŒä¸ªå¥½çš„åœ°æ–¹ã€‚ A second advantage of static factory methods is that, unlike constructors, they are not required to create a new object each time theyâ€™re invoked. ç¬¬äºŒä¸ªå¥½å¤„å°±æ˜¯ç›¸æ¯”äºæ„é€ å‡½æ•°æ¯æ¬¡åœ¨è¢«callçš„æ—¶å€™ï¼Œä¼šæ„é€ ä¸€ä¸ªæ–°çš„å¯¹è±¡ï¼Œè€Œé™æ€æ–¹æ³•æœ‰çš„æ—¶å€™åˆ™ä¼šèŠ‚çœä¸‹è¿™ä¸€ç¬”å¼€é”€ã€‚å°±åƒä¹‹å‰ä¸¾äº†ä¸€ä¸ªä¾‹å­ï¼ŒBoolean.valueOf ä»æ¥æ²¡æœ‰æ„é€ ä¸€ä¸ªæ–°çš„å¯¹è±¡ã€‚ . Instance control allows a class to guarantee that it is a singleton (Item 3) or noninstantiable (Item 4). Also, it allows an immutable value class (Item 17) to make the guarantee that no two equal instances exist: a.equals(b) if and only if a == b. This is the basis of the Flyweight pattern . Enum types (Item 34) provide this guarantee. è¿™ç§å®ä¾‹åŒ–é‡å¤ä½¿ç”¨ä¸€ä¸ªå¯¹è±¡ï¼Œå¾—åˆ°çš„ä¸¤ä¸ªå¥½å¤„ï¼Œç¬¬ä¸€ä¸ªå¥½å¤„å°±æ˜¯ä¿è¯å…¶æ˜¯ä¸€ä¸ªsingleton,å¦ä¸€ä¸ªå¥½å¤„ï¼Œå°±æ˜¯ä¿è¯åœ¨è°ƒç”¨equalå‡½æ•°çš„æ—¶å€™åªèƒ½å…è®¸ç›¸ç­‰çš„æ¡ä»¶åªä¼šæœ‰ä¸€ä¸ªï¼Œé‚£ä¹ˆå°±å¯ä»¥ç›´æ¥ä½¿ç”¨==å·è¿›è¡Œæ“ä½œï¼Œä»è€Œè¿›è¡Œæ€§èƒ½ä¸Šé¢çš„æå‡ã€‚ A third advantage of static factory methods is that, unlike constructors, they can return an object of any subtype of their return type. This gives you great flexibility in choosing the class of the returned object. è€Œå…¶çš„ç¬¬ä¸‰ç‚¹å¥½å¤„å°±ä½“ç°åœ¨å…¶çš„è¿”å›å€¼å¯ä»¥ä¸ºä»»æ„è¯¥ç±»å‹çš„å­ç±»å‹å¯¹è±¡ï¼Œè¿™æ ·åœ¨ç±»å‹çš„è¿”å›çš„æ—¶å€™ä¼šæä¾›å¾ˆå¤§çš„çµæ´»æ€§ã€‚ One application of this flexibility is that an API can return objects without making their classes public. Hiding implementation classes in this fashion leads to a very compact API. è€Œå…¶ä¸­çš„ç¬¬ä¸€ç‚¹åº”ç”¨å°±åœ¨äºè¿”å›APIæ¥å£çš„æ—¶å€™å¯ä»¥ä¸éœ€è¦å°†è¿™ä¸ªç±»å¼„æˆå…¬å¼€çš„ï¼Œéšè—å…¶çš„å®ç°ã€‚ For example, the Java Collections Framework has forty-five utility implementations of its interfaces, providing unmodifiable collections, synchronized collections, and the like. Nearly all of these implemen- tations are exported via static factory methods in one noninstantiable class (java.util.Collections). The classes of the returned objects are all nonpublic. javaåœ¨å®ç°å…¶çš„æ¥å£çš„æ—¶å€™ï¼Œåœ¨æ¥å£é‡Œé¢é‡‡ç”¨é™æ€çš„æ–¹æ³•ï¼Œå¯¼å‡ºçš„ç±»å¾€å¾€éƒ½æ˜¯æ²¡æœ‰å…¬æœ‰åŒ–çš„ï¼Œè¿™æ ·å®ç°äº† ç±»çš„å®ç°è¿‡ç¨‹çš„éšè—ã€‚ one for each convenience implemen- tation. It is not just the bulk of the API that is reduced but the conceptual weight: the number and difficulty of the concepts that programmers must master in order to use the API. The programmer knows that the returned object has precisely the API specified by its interface, so there is no need to read additional class docu- mentation for the implementation class. Furthermore, using such a static factory method requires the client to refer to the returned object by interface rather than implementation class, which is generally good practice (Item 64). å¼€å‘è€…åœ¨æ¥å£çš„ä½¿ç”¨è¿‡ç¨‹ä¸­ï¼Œé€šè¿‡å…¶çš„è¿”å›ç±»å‹å¯ä»¥é€æ¸äº†è§£åˆ°å…¶APIçš„çœŸå®ç”¨é€”ï¼Œè¿™æ ·æ¥å°±ä¸éœ€è¦é˜…è¯»é¢å¤–çš„å¼€å‘è€…æ–‡æ¡£ã€‚ As of Java 8, the restriction that interfaces cannot contain static methods was eliminated, so there is typically little reason to provide a noninstantiable compan- ion class for an interface. Many public static members that would have been at home in such a class should instead be put in the interface itself. Note, however, that it may still be necessary to put the bulk of the implementation code behind these static methods in a separate package-private class. This is because Java 8 requires all static members of an interface to be public. Java 9 allows private static methods, but static fields and static member classes are still required to be public. java8çš„æ—¶å€™å°±åŒæ ·å°† æ¥å£é‡Œé¢ä¸èƒ½æ”¾é™æ€ç±»å‹çš„å‡½æ•°è§„å®šç»™æ¶ˆé™¤äº†ï¼Œæ‰€ä»¥è¿™ä¸ªæ—¶å€™å°±æ²¡æœ‰ç†ç”±å»æä¾›ä¸€ä¸ªä¸å¯å®ä¾‹åŒ–çš„ç±»ç»™ä¸€ä¸ªæ¥å£äº†ï¼Œè€Œè®¸å¤šé™æ€æˆå‘˜åº”è¯¥è¢«æ”¾åœ¨è¿™æ ·ä¸€ä¸ªæ¥å£æœ¬èº«é‡Œï¼Œè®°ä½ï¼Œç°åœ¨è¿˜æ˜¯æœ€é‡è¦çš„æ˜¯å°†å®ç°çš„ä»£ç æ”¾åœ¨è¿™äº›é™æ€å®ç°æ–¹æ³•ä¹‹åã€‚è¿™æ˜¯å› ä¸ºjava8 æ‰€æœ‰çš„é™æ€æˆå‘˜éƒ½å¿…é¡»å…¬å¼€ï¼Œè€Œjava9 åˆ™å…è®¸ç§æœ‰çš„é™æ€å‡½æ•°ï¼Œå…¶ä»–åˆ™æ˜¯å…¬å¼€çš„ã€‚ A fourth advantage of static factories is that the class of the returned object can vary from call to call as a function of the input parameters. Any sub- type of the declared return type is permissible. The class of the returned object can also vary from release to release. ç¬¬å››ä¸ªå¥½å¤„å°±åœ¨äºè¿”å›çš„å­ç±»å‹ä¸­å¯ä»¥æ ¹æ®å‚æ•°çš„å½¢å¼æ¥è¿›è¡Œæ”¹å˜ ä¸€ä¸€å¯¹åº”çš„å…³ç³»ï¼Œè¿™é‡Œä¸¾å‡ºäº†ä¸€ä¸ªenumsetçš„ä¾‹å­ ï¼ˆæˆ‘çœ‹çš„ä¸æ˜¯å¾ˆæ‡‚ æ‰€ä»¥è¿™é‡Œæ ‡çº¢ï¼Œä»¥åæœ‰æ—¶é—´å†æ¬¡æ¥äº†è§£ä¸€ä¸‹ã€‚ï¼‰ A fifth advantage of static factories is that the class of the returned object need not exist when the class containing the method is written. Such flexible static factory methods form the basis of service provider frameworks, like the Java Database Connectivity API (JDBC). A service provider framework is a system in which providers implement a service, and the system makes the implementations available to clients, decoupling the clients from the implementations. ç¬¬äº”ä¸ªå¥½å¤„å°±æ˜¯å½“ç±»ä¸­åŒ…å«çš„å‡½æ•°å·²ç»è¢«å†™äº†ï¼Œç„¶åè¿™è¿”å›å¯¹è±¡ä¸éœ€è¦å­˜åœ¨ï¼Œï¼ˆè¿™ä¸€ç‚¹ä¹Ÿæ²¡æœ‰çœ‹æ‡‚ï¼Œç­‰ä»¥åæ‹œè¯»äº†ä¸­æ–‡ç‰ˆå†æ¥è§£é‡Šï¼Œæ‰‹åŠ¨æ ‡çº¢ï¼‰ The main limitation of providing only static factory methods is that classes without public or protected constructors cannot be subclassed. For example, it is impossible to subclass any of the convenience implementation classes in the Collections Framework. Arguably this can be a blessing in disguise because it encourages programmers to use composition instead of inheritance (Item 18), and is required for immutable types (Item 17). å…¶å®è¿™ä¸ªåœ°æ–¹æœ€å¤§çš„ä¸€ä¸ªå±€é™çš„åœ°æ–¹å°±åœ¨äºï¼Œå¦‚æœä¸€ä¸ªç±»æ²¡æœ‰å…¬å¼€æˆ–è€…ä¿æŠ¤çš„æ„é€ å‡½æ•°çš„è¯ é‚£ä¹ˆè¿™ä¸ªç±»æ˜¯ä¸å…è®¸è¢«ç»§æ‰¿çš„ï¼Œæ„æ€å°±æ˜¯å¯¹äºè¢«é™æ€å‡½æ•°å¾—æ¥çš„ç±»ï¼Œå› ä¸ºä¸å…·æœ‰å…¬å¼€çš„æ„é€ å‡½æ•° æ‰€ä»¥ä¸èƒ½å¤Ÿè¢«å­ç±»åŒ–ã€‚ A second shortcoming of static factory methods is that they are hard for programmers to find. They do not stand out in API documentation in the way that constructors do, so it can be difficult to figure out how to instantiate a class that provides static factory methods instead of constructors. ç¬¬äºŒä¸ªç¼ºç‚¹å°±åœ¨äºå¯èƒ½å¼€å‘è€…ä¼šå¾ˆä¸å®¹æ˜“æ‰¾åˆ°è¿™äº›é™æ€æ–¹æ³•ï¼Œè€Œä¸”ä»–ä»¬ä¸ä¼šåƒå¹³å¸¸æ„é€ å‡½æ•°ä¸€æ ·ï¼Œæ‰€ä»¥å¾ˆéš¾ç†è§£å®ä¾‹åŒ–ä¸€ä¸ªç±»æä¾›çš„é™æ€å‡½æ•°è€Œä¸æ˜¯æ­¤æ„é€ å‡½æ•°ã€‚ ä¸è¿‡æœ‰ä¸€äº›é™æ€å‡½æ•°çš„æ ·ä¾‹ ç±»ä¼¼çš„æ¨¡æ¿ å¯ä»¥è‡ªå·±åœ¨ä¹¦ä¸­å»æŸ¥æ‰¾ã€‚ In summary, static factory methods and public constructors both have their uses, and it pays to understand their relative merits. Often static factories are preferable, so avoid the reflex to provide public constructors without first consid- ering static factories. æ€»ä¹‹ ä¸¤ç§æ„é€ å‡½æ•°éƒ½æœ‰ç›¸åº”çš„å¥½å¤„ä¸åå¤„ï¼Œå…·ä½“æ ·ä¾‹å…·ä½“åˆ†æã€‚]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>effective_java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¤§æ•°ä¸“é¢˜çš„javaæ–¹æ³•æ€»ç»“]]></title>
    <url>%2F2019%2F03%2F13%2F%E5%A4%A7%E6%95%B0%E4%B8%93%E9%A2%98%E7%9A%84java%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[å…¶å®è¿™é‡Œé¢˜ç›®ç±»å‹éƒ½å·®ä¸å¤šä»…ä»…åªè´´å‡ºå‡ é“é¢˜çš„ä»£ç ï¼Œå¹¶ä¸”å¯¹è¿™äº›é¢˜ç›®æ‰€ç”¨åˆ°çš„å‡½æ•°è¿›è¡Œä¸€ä¸ªæ€»ç»“ã€‚123456789101112131415161718192021222324import java.math.BigDecimal;import java.util.Scanner;import java.io.BufferedInputStream;public class E &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); while (in.hasNext()) &#123; BigDecimal r; int n; r = in.nextBigDecimal(); n = in.nextInt(); BigDecimal ans; ans = r.pow(n); ans = ans.stripTrailingZeros(); String res = ans.toPlainString(); while (res.startsWith("0")) &#123;res =res.substring(1);&#125; System.out.println(res); &#125; in.close(); &#125;&#125; stripTrailingZeros() è¿™ä¸ªå‡½æ•°çš„æ„æ€æ˜¯å»é™¤å¤šä½™çš„0ã€‚toPlainString() è¿™ä¸ªå‡½æ•°çš„æ„æ€æ˜¯å°†æŸäº›ç§‘å­¦è®¡æ•°æ³•ï¼Œç»™å…¨éƒ¨å±•å¼€ã€‚startsWith(&quot;0&quot;) è¿™ä¸ªå‡½æ•°çš„æ„æ€å°±æ˜¯ åˆ¤æ–­å­—ç¬¦ä¸²åˆ°åº•ä»¥ä»€ä¹ˆå‡½æ•°ä¸ºå‰æã€‚substring(1) è¿™ä¸ªå‡½æ•°çš„æ„æ€å°±æ˜¯å­—ç¬¦ä¸²è¿›è¡Œä¸€ä¸ªæœ‰æ•ˆçš„æ›¿æ¢ã€‚ å¦å¤– java é‡Œé¢å¤§æ•°çš„å¤§æ•°å¹‚æ¬¡æ–¹å¿…é¡»è¦è§„å®šä¸€ä¸ªmodå¯¹è±¡ å®ç°å‡½æ•°åˆ™ä¸ºmodpow() æœ€åå†ç´¯ç§¯ç‚¹ C++ çŸ¥è¯†ï¼š12345678910A*B % C = (A%C * B%C)%C(A+B)%C = (A%C + B%C)%Cå¦‚ 532 mod 7 =ï¼ˆ500%7+30%7+2%7)%7;å½“ç„¶è¿˜æœ‰a*b mod c=(a mod c+b mod c)mod c;å¦‚35 mod 3=((5%3)*(7%3))%3 è¿˜æœ‰ä¸€é“é¢˜ç›® å…·ä½“çœ‹ä»£ç è¿™é“é¢˜å±•ç°äº† javaåœ¨æ±‚ä½™æ•°æ–¹é¢çš„ç¼ºé™·ã€‚ é‡è¦çš„å°±æ˜¯è¿™ä¸€æ­¥ v = (v * 10 + s[i] - â€˜0â€™) % mod123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.Scanner;import java.math.BigInteger;public class H &#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); BigInteger a; String b,c; int Case = 1; while (cin.hasNext()) &#123; a = cin.nextBigInteger(); b = a.mod(new BigInteger("137")).toString(); c = a.mod(new BigInteger("73")).toString(); if (b.equals("0") &amp;&amp; c.equals("0") ) System.out.println("Case #" + Case++ + ": YES"); else System.out.println("Case #" + Case++ + ": NO"); &#125; &#125;&#125;/*å…³äºè¿™é“é¢˜ï¼Œä¸çŸ¥é“ä¸ºä»€ä¹ˆç”¨java æäº¤å°±æ˜¯æ²¡æœ‰åŠæ³•è¿‡ï¼Œå…¨éƒ¨éƒ½æ˜¯çˆ†å†…å­˜ï¼Œæˆ‘ä¸ªäººè§‰å¾—å¯èƒ½åœ¨å¤§æ•°ï¼Œæ±‚ä½™æ•°è¿™æ–¹é¢ï¼Œå¯èƒ½å­˜åœ¨ç¼ºé™·ã€‚ä¸‹é¢æä¾›å‡ ä¸ª ACçš„ C++ä»£ç #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 10000000 + 1;const int mod = 10001;char s[maxn];int main()&#123; int kase = 0; while(scanf("%s",s) == 1)&#123; int len = strlen(s); int v = 0; for (int i = 0; i &lt; len; ++i)&#123; v = (v*10 + s[i]-48) % mod; &#125; if (v == 0)printf("Case #%d: YES\n",++kase); else printf("Case #%d: NO\n",++kase); &#125; return 0;&#125;*/]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>java</tag>
        <tag>é¢˜è§£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å››é“å…³äºBFSçš„æƒ…å†µå˜æ¢é¢˜ç›®]]></title>
    <url>%2F2019%2F03%2F13%2F%E5%9B%9B%E9%81%93%E5%85%B3%E4%BA%8EBFS%E7%9A%84%E6%83%85%E5%86%B5%E5%8F%98%E6%8D%A2%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[è¿™ä¸ªä¸“é¢˜ åŒæ ·è¿˜æ˜¯æ€»ç»“ä¸€äº›BFSçš„é¢˜ç›®ï¼Œä½†æ˜¯è¿™äº›BFSçš„é¢˜ç›®éƒ½å­˜åœ¨ä¸€ä¸ªç‰¹å®šçš„ç‰¹ç‚¹ï¼Œä¹Ÿå°±æ˜¯ä½ çœŸçš„æ²¡æœ‰åŠæ³•çŒœåˆ°ï¼ŒåŸæ¥è¿™é“é¢˜ç›®æœ€åæ˜¯é€šè¿‡BFSçš„æ–¹æ³•åšçš„ã€‚ ç¬¬ä¸€é¢˜ FliptileFliptile è¿™é“é¢˜ ä¸ªäººæ˜¯è§‰å¾—å¾ˆæœ‰å¿…è¦æ¥åšä¸€éï¼Œè¿™é“é¢˜ä¸å¤ªå±äºä¸€ä¸ªä¸¥æ ¼çš„bfsï¼Œä½†æ˜¯è¿™é“é¢˜çš„é€’å½’è§£é¢˜æ€è·¯å¾ˆæœ‰æ„æ€ã€‚ é¢˜ç›®å¤§æ„å°±æ˜¯ä¸¤ç§é¢œè‰²çš„æ ¼å­ï¼Œç»™å®šä¸€ä¸ªåˆå§‹å›¾ï¼Œç¿»åŠ¨æœ€å°çš„æ­¥æ•°ï¼Œä½¿å¾—å…¨éƒ¨ä¸ºç™½è‰²ï¼Œå¹¶ä¸”æœ€åç»™å‡ºç¿»åŠ¨ä¸ä¸ç¿»åŠ¨çš„å›¾ç‰‡ è¿™é“é¢˜æœ€å¥½ç©çš„æ˜¯ æˆ‘ä»¬éœ€è¦æ˜ç™½ä¸€ä¸ªå‰æï¼Œç¬¬iè¡Œçš„æ ¼å­åœ¨ç«–æ’ä¸Šåªèƒ½è¢«ä¸Šé¢çš„é¢œè‰²æ”¹å˜ï¼Œæ„æ€æ˜¯ æœ€åä¸€æ’çš„åªèƒ½æ ¹æ®å€’æ•°ç¬¬äºŒæ’çš„ä½ç½®æ¥ç¡®å®šã€‚é‚£æˆ‘ä»¬é€šè¿‡é€’å½’ç¡®å®šç¬¬ä¸€æ’ä¾¿åˆ©ä¸‹å»çš„æ¯ä¸€ç§æ–¹æ³•ï¼Œç„¶ååˆ¤æ–­æ˜¯å¦ä¼šè¿›è¡Œæ”¹å˜ï¼Œæœ€åä¿è¯æœ€åä¸€æ’å…¨éƒ¨ä¸ºç™½è‰²ï¼Œä¹Ÿå°±è¾¾åˆ°äº†å…¨éƒ¨ä¸ºç™½è‰²çš„æ•ˆæœã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œé‡Œé¢æœ‰ä¸€ä¸ª&amp; 1çš„æ“ä½œï¼Œè¿™ä¸ªæ„æ€å°±æ˜¯å¯¹2æ±‚ä½™ï¼Œæœ€ç»ˆå¯¼è‡´çš„ç»“æœå°±æ˜¯å¯ä»¥åˆ¤æ–­è¯¥ä½ç½®çš„æ ¼å­è¯¥ä¸è¯¥é‡å¤ç¿»è½¬è¿‡æ¥ã€‚ ä»£ç å¦‚ä¸‹ï¼š1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 17;int cpy[maxn][maxn];int map[maxn][maxn];int res[maxn][maxn];int n,m;int Min;bool judge() &#123; for (int i = 1; i &lt;= m; i ++) &#123; int tmp = cpy[n][i] + cpy[n][i - 1] + cpy[n][i + 1] + cpy[n - 1][i]; if ((map[n][i] + tmp) &amp; 1) return false; &#125; return true;&#125;void dfs(int a,int num) &#123; if (num &gt; Min) return; if (a &gt; n) &#123; if (judge() &amp;&amp; Min &gt; num) &#123; Min = num; memcpy(res,cpy,sizeof (cpy)); return ; &#125; return; &#125; int _time = 0; for (int i = 1 ; i &lt;= m; i ++) &#123; int tmp = map[a - 1][i] + cpy[a - 1][i] + cpy[a - 2][i] + cpy[a - 1][i - 1] + cpy[a - 1][i + 1]; if (tmp &amp; 1) &#123; cpy[a][i] = 1; _time ++; &#125; else cpy[a][i] = 0; &#125; dfs(a + 1, num + _time);&#125;void solve(int a,int num) &#123; if (a &gt; m) &#123; dfs(2,num); return ; &#125; cpy[1][a] = 0; solve(a + 1,num); cpy[1][a] = 1; solve(a + 1,num + 1);&#125;void get()&#123; while( cin &gt;&gt; n &gt;&gt; m) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; Min = 0x3f3f3f3f; memset(cpy,0,sizeof(cpy)); solve(1,0); if (Min == 0x3f3f3f3f) cout &lt;&lt; "IMPOSSIBLE" &lt;&lt; endl; else &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cout &lt;&lt; res[i][j] &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; &#125; &#125;&#125;int main()&#123; get(); return 0;&#125; ç¬¬äºŒé¢˜ potspots è¿™é“é¢˜åˆšå¼€å§‹çœ‹çš„ç¬¬ä¸€çœ¼å®Œå…¨æƒ³è±¡ä¸åˆ°è¿™ç«Ÿç„¶æ˜¯ä¸€ä¸ªBFSçš„é¢˜ç›®ï¼Œå› ä¸ºç›¸äº’ä¹‹é—´å€’æ°´ï¼Œå½“æ—¶æ˜¯å®Œå…¨æ²¡æœ‰ä¸€ç‚¹æ€è·¯çš„ï¼Œä¸è¿‡åæ¥æ ¹æ®BFSå±‚åºæŸ¥æ‰¾çš„æ€§è´¨ï¼Œå¯ä»¥é€æ¸å‘ç°ï¼ŒåŸæ¥è¿™ä¸ªåœ°æ–¹çš„ä¸€å…±æœ‰å…­ç§æƒ…å†µï¼Œç„¶åå°†å·²ç»éå†è¿‡çš„å’Œä¸ç¬¦åˆæ¡ä»¶çš„å…¨éƒ¨å»é™¤ï¼Œç„¶åå°†è¿”å›åˆ°åŸæ¥çš„ä½ç½®çš„æƒ…å†µç›´æ¥å¤±è´¥ï¼Œå¾ˆå®¹æ˜“å°±å¯ä»¥ç”¨BFSç»™å¼„å‡ºæ¥ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;iterator&gt;using namespace std;int A,B,C;const int maxn = 1005;bool vis[maxn][maxn];const string s[6] = &#123;"FILL(1)", "FILL(2)", "DROP(1)", "DROP(2)", "POUR(1,2)", "POUR(2,1)"&#125;;struct Node&#123; int v_a,v_b; int step; vector&lt;string&gt; vs; Node() &#123;&#125;; Node (int a,int b,int c) : v_a(a), v_b(b), step(c) &#123; &#125;&#125;;bool bfs() &#123; queue&lt;Node&gt; q; Node now(0,0,0),next; vis[0][0] = true; q.push(now); vector&lt;string&gt; * tmp; while(!q.empty()) &#123; Node now = q.front(); q.pop(); if (now.v_a == C || now.v_b == C) &#123; cout &lt;&lt; now.step &lt;&lt; endl; for (int it = 0; it != now.vs.size(); it++) &#123; cout &lt;&lt; now.vs[it] &lt;&lt; endl; &#125; return true; &#125; if (now.v_a != A) &#123; next.v_a = A; next.v_b = now.v_b; next.step = now.step + 1; if (!vis[next.v_a][next.v_b])&#123; vis[next.v_a][next.v_b] = true; next.vs = now.vs; next.vs.push_back(s[0]); q.push(next); &#125; &#125; if (now.v_b != B) &#123; next.v_b = B; next.v_a = now.v_a; next.step = now.step + 1; if (!vis[next.v_a][next.v_b]) &#123; vis[next.v_a][next.v_b] = true; next.vs = now.vs; next.vs.push_back(s[1]); q.push(next); &#125; &#125; if (now.v_a != 0)&#123; next.v_a = 0; next.v_b = now.v_b; next.step = now.step + 1; if (!vis[next.v_a][next.v_b]) &#123; vis[next.v_a][next.v_b] = true; next.vs = now.vs; next.vs.push_back(s[2]); q.push(next); &#125; &#125; if (now.v_b != 0)&#123; next.v_b = 0; next.v_a = now.v_a; next.step = now.step + 1; if (!vis[next.v_a][next.v_b]) &#123; vis[next.v_a][next.v_b] = true; next.vs = now.vs; next.vs.push_back(s[3]); q.push(next); &#125; &#125; if (now.v_a != 0 &amp;&amp; now.v_b != B) &#123; next.v_a = now.v_a - (B - now.v_b); next.v_b = now.v_a + now.v_b; if (next.v_b &gt; B) next.v_b = B; if (next.v_a &lt; 0) next.v_a = 0; next.step = now.step + 1; if (!vis[next.v_a][next.v_b]) &#123; vis[next.v_a][next.v_b] = true; next.vs = now.vs; next.vs.push_back(s[4]); q.push(next); &#125; &#125; if (now.v_a != A &amp;&amp; now.v_b != 0)&#123; next.v_b = now.v_b - (A - now.v_a); next.v_a = now.v_a + now.v_b; if (next.v_a &gt; A) next.v_a = A; if (next.v_b &lt; 0) next.v_b = 0; next.step = now.step + 1; if (!vis[next.v_a][next.v_b]) &#123; vis[next.v_a][next.v_b] = true; next.vs = now.vs; next.vs.push_back(s[5]); q.push(next); &#125; &#125; &#125; return false;&#125;int main()&#123; while(cin &gt;&gt; A &gt;&gt; B &gt;&gt; C) &#123; memset(vis,false,sizeof vis); if (!bfs()) cout &lt;&lt; "impossible" &lt;&lt; endl; &#125; return 0;&#125; ç¬¬ä¸‰é¢˜ éå¸¸å¯ä¹éå¸¸å¯ä¹ è¿™ä¸€é“é¢˜ï¼Œå…¶å®ä¸ä¸Šé¢ä¸€é“é¢˜å¾ˆç±»ä¼¼çš„åœ°æ–¹å°±åœ¨äºï¼Œä¹Ÿæ˜¯å°†è¯¸å¤šæƒ…å†µè¿›è¡Œä¸€ä¸ªæ€»ç»“ä¸åˆ†å¸ƒï¼Œç¬¦åˆæ¡ä»¶çš„å…¥é˜Ÿåˆ—ï¼Œä¸ç¬¦åˆæ¡ä»¶çš„ç›´æ¥å‡ºé˜Ÿåˆ—ã€‚å…³é”®å°±æ˜¯è¿™é“é¢˜çš„æ¡ä»¶è®¾ç½®æ–¹é¢ä¸ä¸Šé¢ä¸€é¢˜æœ‰äº›ä¸åŒã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160import java.util.*;public class L_éå¸¸å¯ä¹ &#123; static Scanner in = new Scanner(System.in); static final int maxn = 105; // æ ‡å¿—æ•°ç»„æ¥æ ‡è®°è·¯å¾„ï¼Œä¸‰ä¸ªæ¯å­ä¸‰ç»´æ•°ç»„å³å¯ static int[][][] visited = new int[maxn][maxn][maxn]; static void init() &#123; for (int i = 0; i &lt; maxn; ++i) for (int j = 0; j &lt; maxn; ++j) for (int k = 0; k &lt; maxn; ++k) visited[i][j][k] = 0; &#125; // a b cä¸ºä¸‰ä¸ªå®¹å™¨çš„æœ€å¤§å®¹é‡ static void bfs(int a, int b, int c) &#123; if (a % 2 == 1) &#123; System.out.println("NO"); return; &#125; //è®°ä½è¿™é‡Œå¯ä»¥ç›´æ¥å†™queueçš„æ¥å£ æ¥å£°æ˜ç±»å‹ å¹¶ä¸”åœ¨åé¢ new çš„æ—¶å€™ ä»¥LinkedListæ¥å®ç° å…¶çš„æ¥å£ Queue&lt;Node&gt; que = new LinkedList&lt;Node&gt;(); // åˆå§‹ que.add(new Node(a, 0, 0, 0)); while (!que.isEmpty()) &#123; // å–é˜Ÿå¤´å¹¶å¼¹å‡º Node t = que.poll(); visited[t.a][t.b][t.c] = 1; // åˆ¤æ–­æ˜¯å¦ç¬¦åˆæ¡ä»¶ if (t.a == t.b &amp;&amp; t.c == 0 || t.a == t.c &amp;&amp; t.b == 0 || t.b == t.c &amp;&amp; t.a == 0) &#123; System.out.println(t.step); return; &#125; // å€’æ°´è¿‡ç¨‹ï¼Œæ³¨æ„å€’æ°´çš„å‰ææ˜¯æ¯å­é‡Œé¢æœ‰æ°´ // b -&gt; a if (t.b != 0) &#123; // å› ä¸ºæ²¡æœ‰åˆ»åº¦ï¼Œ æ‰€ä»¥æ¯æ¬¡å€’æ°´éƒ½æœ‰ä¸¤ç§æƒ…å†µ // ç¬¬ä¸€ç§æƒ…å†µæ˜¯æŠŠè‡ªå·±å€’å®Œ if (t.a + t.b &lt;= a) &#123; if (visited[t.a + t.b][0][t.c] == 0) &#123; que.add(new Node(t.a + t.b, 0, t.c, t.step + 1)); visited[t.a + t.b][0][t.c] = 1; &#125; &#125; // ç¬¬äºŒç§æƒ…å†µæ˜¯æŠŠå¯¹æ–¹å€’æ»¡ else if (t.a != a) &#123; if (visited[a][t.b - (a - t.a)][t.c] == 0) &#123; que.add(new Node(a, t.b - (a - t.a), t.c, t.step + 1)); visited[a][t.b - (a - t.a)][t.c] = 1; &#125; &#125; &#125; // c -&gt; a if (t.c != 0) &#123; if (t.a + t.c &lt;= a) &#123; if (visited[t.a + t.c][t.b][0] == 0) &#123; que.add(new Node(t.a + t.c, t.b, 0, t.step + 1)); visited[t.a + t.c][t.b][0] = 1; &#125; &#125; else if (t.a != a) &#123; if (visited[a][t.b][t.c - (a - t.a)] == 0) &#123; que.add(new Node(a, t.b, t.c - (a - t.a), t.step + 1)); visited[a][t.b][t.c - (a - t.a)] = 1; &#125; &#125; &#125; // b -&gt; c if (t.b != 0) &#123; if (t.b + t.c &lt;= c) &#123; if (visited[t.a][0][t.b + t.c] == 0) &#123; que.add(new Node(t.a, 0, t.b + t.c, t.step + 1)); visited[t.a][0][t.b + t.c] = 1; &#125; &#125; else if (t.c != c) &#123; if (visited[t.a][t.b - (c - t.c)][c] == 0) &#123; que.add(new Node(t.a, t.b - (c - t.c), c, t.step + 1)); visited[t.a][t.b - (c - t.c)][c] = 1; &#125; &#125; &#125; // c -&gt; b if (t.c != 0) &#123; if (t.c + t.b &lt;= b) &#123; if (visited[t.a][t.c + t.b][0] == 0) &#123; que.add(new Node(t.a, t.c + t.b, 0, t.step + 1)); visited[t.a][t.c + t.b][0] = 1; &#125; &#125; else if (t.b != b) &#123; if (visited[t.a][b][t.c - (b - t.b)] == 0) &#123; que.add(new Node(t.a, b, t.c - (b - t.b), t.step + 1)); visited[t.a][b][t.c - (b - t.b)] = 1; &#125; &#125; &#125; // a -&gt; b if (t.a != 0) &#123; if (t.a + t.b &lt;= b) &#123; if (visited[0][t.a + t.b][t.c] == 0) &#123; que.add(new Node(0, t.a + t.b, t.c, t.step + 1)); visited[0][t.a + t.b][t.c] = 1; &#125; &#125; else if (t.b != b) &#123; if (visited[t.a - (b - t.b)][b][t.c] == 0) &#123; que.add(new Node(t.a - (b - t.b), b, t.c, t.step + 1)); visited[t.a - (b - t.b)][b][t.c] = 1; &#125; &#125; &#125; // a -&gt; c if (t.a != 0) &#123; if (t.a + t.c &lt;= c) &#123; if (visited[0][t.b][t.a + t.c] == 0) &#123; que.add(new Node(0, t.b, t.a + t.c, t.step + 1)); visited[0][t.b][t.a + t.c] = 1; &#125; &#125; else if (t.c != c) &#123; if (visited[t.a - (c - t.c)][t.b][c] == 0) &#123; que.add(new Node(t.a - (c - t.c), t.b, c, t.step + 1)); visited[t.a - (c - t.c)][t.b][c] = 1; &#125; &#125; &#125; &#125; System.out.println("NO"); &#125; public static void main(String[] args) &#123; while (in.hasNext()) &#123; int a = in.nextInt(), b = in.nextInt(), c = in.nextInt(); if (a == 0 &amp;&amp; b == 0 &amp;&amp; c == 0) break; init(); bfs(a, b, c); &#125; &#125;&#125;class Node &#123; // a b c ä»£è¡¨å®é™…æ‹¥æœ‰æ°´çš„ä½“ç§¯ int a, b, c, step; Node(int a, int b, int c, int step) &#123; this.a = a; this.b = b; this.c = c; this.step = step; &#125;&#125; ç¬¬å››é¢˜ prime pathprime path è¿™é“é¢˜ åŒæ ·çœ‹é¢˜ç›®è¿™çš„æ²¡æœ‰åŠæ³•è§‚å¯Ÿåˆ°è¿™æ˜¯ä¸€ä¸ªBFSçš„é¢˜ç›®ï¼Œåªæœ‰çœ‹åˆ°åé¢æ‰é€æ¸å‘ç°è¿™é“é¢˜ç›® å…¶å®æ˜¯é€šè¿‡æœå¯»æ¯ä¸ªéƒ¨ä½çš„å˜åŒ–ï¼Œæœ€ç»ˆå¯¼è‡´è¾“å‡ºç»“æœä¸è¿‡è¿™é‡Œä¼šå€ŸåŠ©åˆ°ä¸€äº›ç­›é€‰è´¨æ•°çš„åŠæ³• æ¯”å¦‚æ¬§æ‹‰ç­› æ¯”å¦‚åŸƒå¼ç­› åªä¸è¿‡åé¢æ˜¯ç›´æ¥ç”¨æš´åŠ›æšä¸¾è¿™éƒ¨åˆ† æˆ‘æ˜¯çœŸçš„æ²¡æœ‰æƒ³åˆ°ï¼Œæš´åŠ›æšä¸¾äº†å››åç§æƒ…å†µã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;int T;int a,b;const int maxn = 10000;int prime[maxn];bool check[maxn];bool vis[maxn];int tot = 0;struct Node &#123; int x,step; Node()&#123;&#125;; Node(int a,int c):x(a),step(c)&#123;&#125;&#125;;void get_prime() &#123; memset(check,false,sizeof(check)); for (int i = 2; i &lt; maxn ; i++) &#123; if (!check[i]) prime[tot++] = i; for (int j = 0; j &lt; tot; j++) &#123; if (i * prime[j] &gt; maxn) break; check[i * prime[j]] = true; if (i % prime[j] == 0) break; &#125; &#125;&#125;int bfs(int a,int b) &#123; memset(vis,false,sizeof vis); queue&lt;Node&gt; q; Node o1(a,0),o2,o3; q.push(o1); vis[a] = false; while(!q.empty()) &#123; o2 = q.front(); q.pop(); if (o2.x == b) return o2.step; int num[4]; num[0] = o2.x / 1000; num[1] = o2.x / 100 % 10; num[2] = o2.x / 10 % 10; num[3] = o2.x % 10; for (int i = 0; i &lt; 4; i++) &#123; int tmp = num[i]; for (int j = 0; j &lt; 10; j++) &#123; num[i] = j; int yy = num[0] * 1000 + num[1] * 100 + num[2] *10 + num[3]; if (!vis[yy] &amp;&amp; !check[yy] &amp;&amp; yy &gt; 1000 &amp;&amp; yy &lt; 9999) &#123; vis[yy] = true; o3.x = yy; o3.step = o2.step + 1; q.push(o3); &#125; &#125; num[i] = tmp; &#125; &#125; return -1;&#125;int main()&#123; get_prime(); cin &gt;&gt; T; int ans = -1; while(T--) &#123; cin &gt;&gt; a &gt;&gt; b; ans = bfs(a,b); if (ans == -1) cout &lt;&lt; "Impossible" &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä¸¤é“ä¸fireæœ‰å…³çš„åŸºç¡€BFS]]></title>
    <url>%2F2019%2F03%2F13%2F%E4%B8%A4%E9%81%93%E4%B8%8Efire%E6%9C%89%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80BFS%2F</url>
    <content type="text"><![CDATA[ç¬¬ä¸€é“é¢˜fire game è¿™é“é¢˜ç›®å…¶å®å°±æ˜¯ä¸€ä¸ªç®€å•çš„bfsï¼Œä½†æ˜¯ä»¤æˆ‘ç‰¹åˆ«å›°æƒ‘çš„æ˜¯ï¼Œæˆ‘ä¸çŸ¥é“æ€ä¹ˆå»å–æ¯ä¸€ä¸ªç«è‹—å‘å››å‘¨æ‰©æ•£çš„æ—¶é—´ï¼Œç„¶åæœ€åæ‰çŸ¥é“ï¼ŒåŸæ¥æ˜¯ç›´æ¥è®¡ç®—é‚£ä¸ªæœ€é•¿çš„è·¯çº¿å°±è¡Œäº†ï¼Œè¿™é“é¢˜ç›®çš„æ„æ€å°±æ˜¯æ ¹æ®æ¯ä¸€ä¸ªç‚¹çš„éå†ï¼Œå»å¯»æ‰¾æœ€é•¿çš„é‚£ä¸€ä¸ªç‚¹ï¼Œå°†æ¯ä¸ªç‚¹æ”¾è¿›å»ï¼Œç„¶åæ‰¾è·ç¦»è¿™ä¸ªç‚¹æœ€é•¿çš„è·ç¦»å°±æ˜¯å…¶æ‰©æ•£çš„æœ€ç»ˆæ—¶é—´ï¼Œç„¶ååˆ°æœ€åä¾æ¬¡æšä¸¾ä¸¤ä¸ªç‚¹ï¼ŒæŒ‰ç…§å„è‡ªä¸¤ä¸ªç‚¹ä¹‹é—´çš„æœ€å¿«çš„æ—¶é—´æ¥å†³å®šæœ€ç»ˆçš„æ—¶é—´ã€‚ å…¶å®è¿™é“é¢˜ä¸éš¾ï¼Œä¸€é“bfsçš„æ¨¡æ‹Ÿé¢˜ç›®ï¼Œåªä¸è¿‡å°±æ˜¯åé¢å†³ç­–çš„é‚£ä¸ªåœ°æ–¹ä¸å¤ªå¥½ä¸‹ã€‚ ä»£ç å¦‚ä¸‹ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;#define inf 0x3f3f3f3fint n,m;const int maxn = 15;char map[maxn][maxn];int vis[maxn][maxn];struct point&#123; int x,y,pos; point ()&#123;&#125; point (int a,int b,int c) : x(a),y(b),pos(c) &#123;&#125; point move(int i) &#123; point tmp(x,y,pos); switch (i)&#123; case 0:&#123; tmp.x = x + 1; break; &#125; case 1: &#123; tmp.x = x - 1; break; &#125; case 2: &#123; tmp.y = y + 1; break; &#125; case 3: &#123; tmp.y = y - 1; break; &#125; &#125; tmp.pos++; return tmp; &#125;&#125;;int bfs(point a,point b) &#123; queue&lt;point&gt; q; point now,next; q.push(a); q.push(b); memset(vis,inf,sizeof vis); vis[a.x][a.y] = 0; vis[b.x][b.y] = 0; while (!q.empty()) &#123; now = q.front(); q.pop(); for (int i = 0; i &lt; 4; i++) &#123; next = now.move(i); if (next.x &gt;= 0 &amp;&amp; next.x &lt; n &amp;&amp; next.y &gt;= 0 &amp;&amp; next.y &lt; m &amp;&amp; map[next.x][next.y] == '#' &amp;&amp; vis[next.x][next.y] == inf) &#123; vis[next.x][next.y] = next.pos; q.push(next); &#125; &#125; &#125; int res = 0; for (int i = 0 ;i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (map[i][j] == '#') //è¿™é‡Œå°±æ˜¯æ‰¾åœ¨å±‚åºéå†ä¸­è·ç¦»resæœ€å¤§çš„æ¯ä¸€ä¸ªç‚¹ï¼Œå³æœ€åçš„æ—¶é—´ã€‚ res = max(res,vis[i][j]); &#125; &#125; return res;&#125;int main()&#123; int T; cin &gt;&gt; T; int Case = 1; while (T--) &#123; cin &gt;&gt; n &gt;&gt; m; int cnt = 0; getchar(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j ++) &#123; cin &gt;&gt; map[i][j]; if (map[i][j] == '#') &#123; cnt ++; &#125; &#125; getchar(); &#125; if (cnt &lt;= 2) &#123; cout &lt;&lt; "Case " &lt;&lt; Case++ &lt;&lt; ": " &lt;&lt; 0 &lt;&lt; endl; continue; &#125; int res = inf; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (map[i][j] == '#') &#123; for (int l = 0; l &lt; n; l++) &#123; for (int k = 0; k &lt; m; k++) &#123; if (l &lt;= i &amp;&amp; k &lt;= j) continue; if (map[l][k] == '#')&#123; point p1(i,j,0); point p2(l,k,0); //è¿™é‡Œå°±æ˜¯æ‰¾æ¯ä¸€ä¸ªè·ç¦»æœ€è¿œçš„ç‚¹ä¸­æœ€å°çš„é‚£ä¸ªå€¼ã€‚ int ans = bfs(p1,p2); res = min(ans,res); &#125; &#125; &#125; &#125; &#125; &#125; if (cnt == inf) cout &lt;&lt; "Case " &lt;&lt; Case++ &lt;&lt; ": " &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; "Case " &lt;&lt; Case++ &lt;&lt; ": " &lt;&lt; cnt &lt;&lt; endl; &#125;&#125; ç¬¬äºŒé“é¢˜Fire! å…¶å®å§ï¼Œè¿™é“é¢˜åˆšå‡ºæ¥çš„æ—¶å€™ï¼Œæˆ‘åœ¨æƒ³ï¼Œå› ä¸ºä¸¤ä¸ªBFSå˜›ï¼Œä¼šä¸ä¼šç”¨åˆ°å¹¶å‘ç¼–ç¨‹,(åŸè°…æˆ‘çš„å¤©çœŸçƒ‚æ¼«)ï¼Œåé¢æ˜¯ç›´æ¥ç”¨ä¸¤ä¸ªBFSåˆ†å¼€æ”¾ï¼Œç”¨ä¸€ä¸ªäºŒç»´æ•°ç»„æ¥è®°å½•ç«è”“å»¶çš„æ—¶é—´ï¼Œç„¶åå†ç”¨ä¸€ä¸ªBFSæ¥è®°å½•å…¶çš„èµ°å‘ä½ç½®ï¼Œã€‚ æœ¬è´¨ä¸Šï¼Œè¿˜æ˜¯å±äºä¸€ä¸ªbfsçš„æ¨¡æ¿é¢˜ç›®ã€‚ ä»£ç å¦‚ä¸‹ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;#define inf 0x3f3f3f3fstruct point &#123; int x,y,step; point() &#123;&#125; point (int a,int b,int c) : x(a),y(b), step(c) &#123;&#125; point move(int i) &#123; point tmp(x, y, step); switch (i) &#123; case 0: &#123; tmp.x = x + 1; break; &#125; case 1: &#123; tmp.x = x - 1; break; &#125; case 2: &#123; tmp.y = y + 1; break; &#125; case 3: &#123; tmp.y = y - 1; break; &#125; &#125; tmp.step++; return tmp; &#125;&#125;;const int maxn = 1010;int m,n;char map[maxn][maxn];bool vis[maxn][maxn];int _time[maxn][maxn];queue&lt;point&gt; q_fire;queue&lt;point&gt; q_joe;void bfs_fire() &#123; point now, next; while (!q_fire.empty()) &#123; now = q_fire.front(); q_fire.pop(); for (int i = 0; i &lt; 4 ; i++) &#123; next = now.move(i); if (next.x &gt;= 0 &amp;&amp; next.y &gt;= 0 &amp;&amp; next.x &lt; m &amp;&amp; next.y &lt; n &amp;&amp; _time[next.x][next.y] &gt; next.step &amp;&amp; (map[next.x][next.y] == '.' || map[next.x][next.y] == 'J')) &#123; q_fire.push(next); _time[next.x][next.y] = next.step; &#125; &#125; &#125;&#125;bool is_ok(int x,int y) &#123; return (x == 0 || y == 0 || x == m - 1 || y == n - 1);&#125;int bfs_joe() &#123; point now,next; while (!q_joe.empty()) &#123; now = q_joe.front(); q_joe.pop(); if (is_ok(now.x,now.y)) return now.step + 1; for (int i = 0; i &lt; 4; i ++) &#123; next = now.move(i); if (next.x &gt;= 0 &amp;&amp; next.y &gt;= 0 &amp;&amp; next.x &lt; m &amp;&amp; next.y &lt; n &amp;&amp; !vis[next.x][next.y] &amp;&amp; map[next.x][next.y] == '.' &amp;&amp; next.step &lt; _time[next.x][next.y])&#123; q_joe.push(next); vis[next.x][next.y] = true; &#125; &#125; &#125; return 0;&#125;void clear()&#123; memset(vis, false, sizeof(vis)); while (!q_fire.empty()) q_fire.pop(); while (!q_joe.empty()) q_joe.pop();&#125;int main()&#123; int T; cin &gt;&gt; T; while (T--) &#123; clear(); cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; map[i][j]; _time[i][j] = inf; if (map[i][j] == 'J') &#123; q_joe.push(point (i,j,0)); vis[i][j] = true; &#125; else if (map[i][j] == 'F') &#123; q_fire.push(point(i,j,0)); &#125; &#125; getchar(); &#125; bfs_fire(); int t = bfs_joe(); if (t) cout &lt;&lt; t &lt;&lt; endl; else cout &lt;&lt; "IMPOSSIBLE" &lt;&lt; endl; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[è´¨æ•°ç­›é€‰é—®é¢˜]]></title>
    <url>%2F2019%2F03%2F05%2F%E8%B4%A8%E6%95%B0%E7%AD%9B%E9%80%89%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[å…³äºè´¨æ•°çš„ç­›é€‰é—®é¢˜ï¼Œå°±åƒæœ€å…ˆå¼€å§‹å­¦ä¹ Cè¯­è¨€ä¸€æ ·ï¼Œæœ€å…ˆå¼€å§‹éƒ½æ˜¯ä»1éå†åˆ°æœ¬èº«ã€‚ åæ¥çš„ä¼˜åŒ–ç‰ˆæœ¬å°±ä½“ç°åœ¨éå†åˆ°æœ¬èº«çš„ æ ¹å·ä¸‹çš„å€æ•°å…³ç³»ã€‚ä½†æ˜¯ åæ¥åˆ™å‘ç°æœ‰å¤ªå¤šçš„é‡å¤å¾ªç¯æ¬¡æ•°ï¼Œè¿™é‡Œåè€Œæ˜¾å¾—ä¸æ˜¯ç‰¹åˆ«å¥½ï¼Œæ‰€ä»¥å°±å‡ºæ¥ä¸€ç§æ–°çš„ç­›é€‰æ–¹æ³•ã€‚ 12345678910111213141516//æœ€æ™®é€šçš„åŸƒå¼ç­›æ³•memset(check, 0, sizeof(check));int tot = 0;for (int i = 2; i &lt;= n; ++i)&#123; if (!check[i]) &#123; prime[tot++] = i; &#125; // ä¸‹é¢å…¶å®ç”¨ä¹˜æ³•å’Œç”¨åŠ æ³•éƒ½æ˜¯ä¸€æ ·çš„ï¼Œè€Œè¿™é‡Œå°±æ˜¯ä¹˜æ³•çš„åŸå› å°±åœ¨äºï¼Œå‡å°‘äº†å¾ªç¯æ¬¡æ•° // å”¯ä¸€æ²¡æœ‰è¢«ä¼˜åŒ–çš„åœ°æ–¹å°±åœ¨äº æ¯ä¸€ä¸ªæ•°å­—è¢«é‡å¤æ ‡è®°äº†å¾ˆå¤šæ¬¡ï¼Œè€Œåé¢çš„æ¬§æ‹‰ç­›å°±ä¼šé™åˆ¶æ ‡è®°æ¬¡æ•°ä¸ºä¸€æ¬¡ for (int j = i * i; j &lt;= n; j *= i) &#123; check[j] = 1; &#125;&#125; é‰´äºä¸Šé¢æ‰€è¯´çš„åœ¨è¿›è¡Œä¸€æ¬¡ä¼˜åŒ–ï¼Œåˆ™ä¼˜åŒ–ä½“ç°åœ¨äº†å‡å°‘é‡å¤æ¬¡æ•° 123456789101112131415161718192021222324252627282930//è¿›é˜¶ç‰ˆçš„çº¿æ€§ç­›æ³•//è´¨æ•°æ•°ç»„int prime[MAXN];//åˆ¤æ–­æ¯ä¸€ä¸ªæ•° æ•°ç»„int check[MAXL];int tot = 0;memset(check, 0, sizeof(check));for (int i = 2; i &lt; MAXL; ++i)&#123; if (!check[i]) &#123; prime[tot++] = i; &#125; for (int j = 0; j &lt; tot; ++j) &#123; //å¤§è‡´æ„æ€å°±åœ¨äº å°†æ¯ä¸€ä¸ªæ•°çš„ä¸è´¨æ•°æ•°ç»„é‡Œé¢çš„æ•°è¿›è¡Œç›¸ä¹˜ï¼Œæœ€åå¾—åˆ°çš„ç»“æœå­˜åœ¨checkä¸­å» //éœ€è¦æ³¨æ„çš„å°±æ˜¯ ä¸€æ—¦å½“å‰çš„æ•°èƒ½è¢«æ•´é™¤çš„æ—¶å€™ å°±ç«‹é©¬é€€å‡ºï¼Œè¿™æ ·ä»£è¡¨æ¯ä¸€ä¸ªæ•°å­—éƒ½ä¼šè¢«è‡ªå·±çš„æœ€å°è´¨å› æ•°ç»™æ•´é™¤å‡ºæ¥ã€‚ if (i * prime[j] &gt; MAXL) &#123; break; &#125; check[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; break; &#125; &#125;&#125; æ¥ä¸‹æ¥å°±æ˜¯åŒºé—´ç­›]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>è´¨æ•°ç­›é€‰</tag>
        <tag>æ¬§æ‹‰ç­›</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åˆ†äº«å‡ é“ç®€å•æœç´¢é¢˜ç›®]]></title>
    <url>%2F2019%2F03%2F05%2F%E5%88%86%E4%BA%AB%E5%87%A0%E9%81%93%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[ä¸å¤šåšåˆ†æï¼Œå…¶åŸºæœ¬ä¸Šéƒ½æ˜¯ä¸€äº› dfs ä¸ bfsä¸Šé¢çš„ç®€å•é¢˜ç›® 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/************************************************************************* &gt; File Name: æ£‹ç›˜é—®é¢˜.cpp &gt; Author: wangshuxiao &gt; Mail: wsx1128@outlook.com &gt; Created Time: Sun 3 Mar 15:05:54 2019 ************************************************************************/#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;int n,k;char board [10][10];int total;bool booked[10];int cnt;void dfs(int cur) &#123; if (cnt == k) &#123; total ++; return; &#125; if (cur &gt;= n) return ; for (int j = 0; j &lt; n; j ++) &#123; if (booked[j] == false &amp;&amp; board[cur][j] == '#') &#123; booked[j] = true; cnt ++; dfs(cur + 1); booked[j] = false; cnt --; &#125; &#125; //è¿™ç§æƒ…å†µæ˜¯é˜²èŒƒ æ²¡æœ‰åœ¨é¦–ç½®ä½ æœ‰æ»¡è¶³ç¬¦åˆæ¡ä»¶çš„æ•°æ® dfs(cur + 1);&#125;int main()&#123; while (cin &gt;&gt; n &gt;&gt; k) &#123; if (n == -1 &amp;&amp; k == -1) break; for (int i = 0; i &lt; n; i ++) &#123; booked[i] = false; for (int j = 0; j &lt; n; j ++) &#123; cin &gt;&gt; board[i][j]; &#125; &#125; total = 0,cnt = 0; dfs(0); cout &lt;&lt; total &lt;&lt; endl; &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/************************************************************************* &gt; File Name: DungeonMaster.cpp &gt; Author: wangshuxiao &gt; Mail: wsx1128@outlook.com &gt; Created Time: Sun 3 Mar 16:10:18 2019 ************************************************************************/#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;const int maxn = 35;int L,C,R;char map[maxn][maxn][maxn];int dis[maxn][maxn][maxn];struct position &#123; int x,y,z; int pos; position () = default; position(int x,int y,int z,int pos) : this.x(x), this.y(y),this.z(z),this.pos(pos) &#123;&#125;; position move (int i);&#125;;position position::move(int i)&#123; position tmp = *this; switch (i) &#123; case 1: tmp.x = x + 1; break; case 2: tmp.x = x - 1; break; case 3: tmp.y = y + 1; break; case 4: tmp.y = y - 1; break; case 5: tmp.z = z + 1; break; case 6: tmp.z = z - 1; break; &#125; return tmp;&#125;void bfs (int i,int j,int k) &#123; position beg (i,j,k,0); queue&lt;position&gt; q; q.push(beg); while (!q.empty()) &#123; position now = q.front(); q.pop(); dis[now.x][now.y][now.z] = now.pos; for (int i = 0; i &lt; 7; i++) &#123; position next = now.move(i); if (next.x &gt;= 0 &amp;&amp; next.x &lt; L &amp;&amp; next.y &gt;= 0 &amp;&amp; next.y &lt; R &amp;&amp; next.z &gt;= 0 &amp;&amp; next.z &lt; C &amp;&amp; dis[next.x][next.y][next.z] == -1 &amp;&amp; map[next.x][next.y][next.z] != '#') &#123; position empt (next.x,next.y,next.z,now.pos + 1); q.push(empt); &#125; &#125; &#125;&#125;int main()&#123; while (cin &gt;&gt; L &gt;&gt; R &gt;&gt; C) &#123; if (L == 0 &amp;&amp; R == 0 &amp;&amp; C == 0) &#123; break; int x1,y1,z1; int x2,y2,z2; for (int i = 0; i != L; i++) &#123; for (int j = 0; j != R; j++) &#123; for (int k = 0; k != C; k++) &#123; cin &gt;&gt; map[i][j][k]; dis[i][j][k] = -1; if (map[i][j][k] == 'S') &#123; x1 = i; y1 = j; z1 = k; &#125; if (map[i][j][k] == 'E') &#123; x2 = i; y2 = j; z2 = k; &#125; &#125; &#125; &#125; bfs(x1, y1, z1); if (dis[x2][y2][z2] == -1) cout &lt;&lt; "Trapped!" &lt;&lt; endl; else &#123; cout &lt;&lt; "Escaped in " &lt;&lt; dis[x2][y2][z2] &lt;&lt; " minute(s)." &lt;&lt; endl; &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;int m,n;const int maxn = 105;char map [maxn][maxn];int cnt;void dfs(int i,int j) &#123; if (i &lt; 0 &amp;&amp; i &gt;= m) return; if (j &lt; 0 &amp;&amp; j &gt;= n) return; if (map[i][j] == '@') &#123; map[i][j] = '.'; dfs(i-1,j); dfs(i+1,j); dfs(i,j-1); dfs(i,j+1); dfs(i-1,j-1); dfs(i-1,j+1); dfs(i+1,j-1); dfs(i+1,j+1); &#125;&#125;int main() &#123; while (cin &gt;&gt; m &amp;&amp; m != 0 &amp;&amp; cin &gt;&gt; n) &#123; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) cin &gt;&gt; map[i][j]; &#125; for (int i = 0; i &lt; m; i ++) &#123; for (int j = 0; j &lt; n ; j++) &#123; if (map[i][j] == '@')&#123; dfs(i,j); cnt++; &#125; &#125; &#125; cout &lt;&lt; cnt &lt;&lt; endl; cnt = 0; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stdio.h&gt;#include &lt;cstring&gt;using namespace std;int n, m;char map[201][201];int dis_Y[201][201];int dis_M[201][201];struct point&#123; int x, y, pos; point()&#123;&#125;; point(int a, int b, int c) : x(a), y(b), pos(c) &#123;&#125;&#125;;int _move[4][2] = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;void bfs(queue&lt;point&gt; *q, int x, int y, bool flag)&#123; point beg(x, y, 0); q-&gt;push(beg); point now, next; while (!q-&gt;empty()) &#123; now = q-&gt;front(); q-&gt;pop(); for (int i = 0; i &lt; 4; i++) &#123; next.x = now.x + _move[i][0]; next.y = now.y + _move[i][1]; if ( next.x &lt; n &amp;&amp; next.x &gt;= 0 &amp;&amp; next.y &lt; m &amp;&amp; next.y &gt;= 0 &amp;&amp; map[next.x][next.y] != '#') &#123; if (flag) &#123; if (dis_Y[next.x][next.y] == -1) &#123; next.pos = now.pos + 1; q -&gt; push(next); dis_Y[now.x][now.y] = now.pos + 1; &#125; &#125; else &#123; if (dis_M[next.x][next.y] == -1) &#123; next.pos = now.pos + 1; q -&gt; push(next); dis_M[now.x][now.y] = now.pos + 1; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; int yi_x, yi_y; int m_x, m_y; while (~scanf("%d %d", &amp;n, &amp;m)) &#123; pair&lt;int,int&gt; p; getchar(); vector&lt;pair&lt;int,int&gt; &gt;v; queue&lt;point&gt; qm; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; scanf("%c", &amp;map[i][j]); dis_M[i][j] = -1; dis_Y[i][j] = -1; if (map[i][j] == 'Y') &#123; yi_x = i; yi_y = j; &#125; else if (map[i][j] == 'M') &#123; m_x = i; m_y = j; &#125; else if (map[i][j] == '@') &#123; v.push_back(make_pair(i,j)); &#125; &#125; getchar(); &#125; dis_Y[yi_x][yi_y] = 0; dis_M[m_x][m_y] = 0; bfs(&amp;qm, yi_x, yi_y, true); bfs(&amp;qm, m_x, m_y, false); int Min = 9999999; int tmp = 0; for (auto it = v.begin(); it != v.end(); it++) &#123; tmp = dis_M[it-&gt;first][it-&gt;second] + dis_Y[it-&gt;first][it-&gt;second]; if (Min &gt; tmp) Min = tmp; &#125; printf("%d\n", Min * 11); &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;#include &lt;stack&gt;#include&lt;utility&gt;using namespace std;const int maxn = 6;int map [maxn][maxn];struct point&#123; int x , y , pos; pair&lt;int ,int &gt; p; point()&#123;&#125;; point(int a,int b,int c) : x(a),y(b),pos(c) &#123;&#125; point move(int i) &#123; point tmp = *this; switch (i) &#123; case 0: &#123; tmp.x += 1; break; &#125; case 1: &#123; tmp.x -= 1; break; &#125; case 2: &#123; tmp.y += 1; break; &#125; case 3: &#123; tmp.y -= 1; break; &#125; &#125; return tmp; &#125;&#125;;int main()&#123; point m[maxn][maxn]; for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0 ; j &lt; 5; j++) &#123; cin &gt;&gt; map[i][j]; m[i][j].x = i; m[i][j].y = j; m[i][j].pos = -1; &#125; &#125; queue&lt;point&gt;q; point beg(0,0,0); q.push(beg); while (!q.empty()) &#123; point now = q.front(); q.pop(); //m[now.x][now.y].pos = now.pos; for (int i = 0; i &lt; 4; i++) &#123; point next = now.move(i); if (next.x &lt; 5 &amp;&amp; next.x &gt;= 0 &amp;&amp; next.y &lt; 5 &amp;&amp; next.y &gt;= 0 &amp;&amp; map[next.x][next.y] != 1 &amp;&amp; m[next.x][next.y].pos == -1) &#123; m[next.x][next.y].pos = now.pos+1; m[next.x][next.y].p = make_pair(now.x,now.y); q.push(m[next.x][next.y]); &#125; &#125; &#125; stack&lt;pair&lt;int ,int&gt; &gt; s; s.push(make_pair(4,4)); pair&lt;int,int&gt;x = m[4][4].p; int y = m[4][4].pos; while (y --) &#123; s.push(x); x = m[x.first][x.second].p; &#125; while (!s.empty()) &#123; x = s.top(); s.pop(); cout &lt;&lt; "(" &lt;&lt; x.first &lt;&lt; ", " &lt;&lt; x.second &lt;&lt; ")" &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>bfs</tag>
        <tag>dfs</tag>
        <tag>æœç´¢</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8_pazzle]]></title>
    <url>%2F2019%2F02%2F26%2F8-pazzle%2F</url>
    <content type="text"><![CDATA[æ­¤ä¸ºç¬¬å››å‘¨æ™®æ—æ–¯é¡¿ç®—æ³•è¯¾å¤§ä½œä¸šï¼ŒåŸºæœ¬æ€è·¯æ˜¯åŸºäºä¼˜å…ˆé˜Ÿåˆ—çš„A*ç®—æ³•ã€‚æ‰€è°“A*ç®—æ³•ï¼Œå°±æ˜¯å¯å‘å¼ç®—æ³•ï¼Œäººå·¥æ™ºèƒ½åŸºç¡€ï¼Œå°±æ˜¯å°†æ¯ä¸€æ­¥å‘¨å›´çš„ä¸€æ­¥ä¹‹ç±»çš„æƒ…å†µå…¨éƒ¨å­˜å‚¨èµ·æ¥ï¼Œç„¶åæ”¾è¿›ä¼˜å…ˆé˜Ÿåˆ—é‡Œé¢è¿›è¡Œæ¯”è¾ƒï¼Œç„¶åä¾æ¬¡å‡ºé˜Ÿï¼Œç®—å‡ºæœ€ç»ˆçš„ç»“æœç›¸å½“äºä¸€ä¸ªå°åšå¼ˆã€‚ é¦–å…ˆï¼Œå…ˆçœ‹é¢˜ç›®ã€‚ ç›´æ¥è´´å‡ºä»£ç  Board.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148package Programming_Assignment_4;import edu.princeton.cs.algs4.StdRandom;import java.util.ArrayList;public class Board &#123; private int [][] blocks; private final int dimension; public Board(int[][] blocks) &#123; if (blocks == null) throw new NullPointerException("Null blocks"); dimension = blocks.length; this.blocks = new int[dimension][dimension]; for (int i = 0; i &lt; dimension; i++) &#123; this.blocks[i] = blocks[i].clone(); &#125; &#125; public int dimension() &#123; return dimension; &#125; public int hamming() &#123; int cnt = 0; for (int i = 0; i &lt; dimension; i++) &#123; for (int j = 0; j &lt; dimension; j++) &#123; if (blocks[i][j] == 0) continue; if (blocks[i][j] != i * dimension + j + 1) cnt ++; &#125; &#125; return cnt; &#125; public int manhattan() &#123; int cnt = 0; for (int i = 0; i &lt; dimension; i++) &#123; for (int j = 0; j &lt; dimension; j++) &#123; if (blocks[i][j] == 0) continue; if (blocks[i][j] != i * dimension + j + 1) &#123; int val = blocks[i][j]; int row = (val - 1) / dimension; int col = (val - 1) % dimension; int dif = Math.abs(row - i) + Math.abs(col - j); cnt += dif; &#125; &#125; &#125; return cnt; &#125; public boolean isGoal() &#123; return hamming() == 0; &#125; private void swap (int i1,int r1,int i2,int r2) &#123; int tmp = blocks[i1][r1]; blocks[i1][r1] = blocks[i2][r2]; blocks[i2][r2] = tmp; &#125; public Board twin() &#123; Board twinBoard = new Board(blocks); int row = 0,col = 0; if (blocks[row][col] == 0) col++; for (int i = 0; i &lt; dimension; i++) &#123; for (int j = 0; j &lt; dimension; j++) &#123; if (blocks[i][j] != 0 &amp;&amp; blocks[i][j] != blocks[row][col]) &#123; twinBoard.swap(i,j,row,col); return twinBoard; &#125; &#125; &#125; return twinBoard; &#125; public boolean equals(Object y) &#123; if (y == null) return false; if (y.getClass().isInstance(this)) &#123; Board tmp = (Board) y; if (tmp.dimension != this.dimension) return false; for (int i = 0; i &lt; dimension; i++) &#123; for (int j = 0; j &lt; dimension; j++) &#123; if (tmp.blocks[i][j] != this.blocks[i][j]) return false; &#125; &#125; return true; &#125; return false; &#125; public Iterable&lt;Board&gt; neighbors() &#123; ArrayList&lt;Board&gt; neighbors = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; dimension; i++) &#123; for (int j = 0; j &lt; dimension; j++) &#123; if (blocks[i][j] == 0) &#123; if (i &gt; 0) &#123; Board tmpUp = new Board(blocks); tmpUp.swap(i,j,i - 1,j); neighbors.add(tmpUp); &#125; if (i &lt; dimension - 1) &#123; Board tmpDown = new Board(blocks); tmpDown.swap(i,j,i + 1,j); neighbors.add(tmpDown); &#125; if (j &gt; 0) &#123; Board tmpLeft = new Board(blocks); tmpLeft.swap(i,j,i,j - 1); neighbors.add(tmpLeft); &#125; if (j &lt; dimension - 1) &#123; Board tmpRight = new Board(blocks); tmpRight.swap(i,j,i,j + 1); neighbors.add(tmpRight); &#125; break; &#125; &#125; &#125; return neighbors; &#125; public String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append(dimension + "\n"); for (int row = 0; row &lt; dimension; row++) &#123; for (int col = 0; col &lt; dimension; col++) &#123; sb.append(String.format("%2d ", blocks[row][col])); &#125; sb.append("\n"); &#125; return sb.toString(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package Programming_Assignment_4;import edu.princeton.cs.algs4.In;import edu.princeton.cs.algs4.MinPQ;import edu.princeton.cs.algs4.Stack;import edu.princeton.cs.algs4.StdOut;public class Solver &#123; private BoardNode current; private BoardNode twinCurrent; private class BoardNode implements Comparable&lt;BoardNode&gt; &#123; private Board item; private int priority; private int move; private BoardNode preBoard; public BoardNode (Board item,BoardNode preBoard) &#123; this.item = item; this.preBoard = preBoard; if (preBoard == null) this.move = 0; else this.move = preBoard.move + 1; this.priority = this.move + item.manhattan(); &#125; public int compareTo(BoardNode b) &#123; return Integer.compare(this.priority,b.priority); &#125; &#125; private void putNeighbors (BoardNode current,MinPQ&lt;BoardNode&gt;pq) &#123; Iterable&lt;Board&gt; neighbors = current.item.neighbors(); for (Board it : neighbors) &#123; if (current.preBoard == null || !it.equals(current.preBoard.item)) &#123; pq.insert(new BoardNode(it,current)); &#125; &#125; &#125; public Solver(Board initial) &#123; if (initial == null) &#123; throw new IllegalArgumentException("Constructor argument Board is null!"); &#125; current = new BoardNode(initial,null); twinCurrent = new BoardNode(initial.twin(),null); MinPQ&lt;BoardNode&gt; pq = new MinPQ&lt;BoardNode&gt;(); MinPQ&lt;BoardNode&gt; twinpq = new MinPQ&lt;BoardNode&gt;(); pq.insert(current); twinpq.insert(twinCurrent); while (true) &#123; current = pq.delMin(); if (current.item.isGoal()) break; putNeighbors(current,pq); twinCurrent = twinpq.delMin(); if (twinCurrent.item.isGoal()) break; putNeighbors(twinCurrent,twinpq); &#125; &#125; public boolean isSolvable() &#123; return current.item.isGoal(); &#125; public int moves() &#123; if (current.item.isGoal()) return current.move; return -1; &#125; public Iterable&lt;Board&gt; solution() &#123; if (isSolvable()) &#123; Stack&lt;Board&gt; stack = new Stack&lt;&gt;(); BoardNode node = current; while (node != null) &#123; stack.push(node.item); node = node.preBoard; &#125; return stack; &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>java</tag>
        <tag>æ™®æ—æ–¯é¡¿ç®—æ³•è¯¾</tag>
        <tag>A*ç®—æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åŸºäºjavaçš„ç¢°æ’ç‰©ç†å¼•æ“]]></title>
    <url>%2F2019%2F02%2F26%2F%E5%9F%BA%E4%BA%8Ejava%E7%9A%84%E7%A2%B0%E6%92%9E%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[é¦–å…ˆï¼Œè´´å‡ºæ•ˆæœå›¾ï¼ŒåŸºäºjavaçš„ç‰©ç†å¼•æ“ã€‚ å®Œæˆè¿™ä¸ªæ•ˆæœéœ€è¦è€ƒè™‘å‡ ä»¶äº‹æƒ…ã€‚ ç¬¬ä¸€æ­¥æ˜¾ç¤ºå®šä¹‰å‡ºæ¯ä¸€ä¸ªé¢—ç²’ï¼Œå…·ä½“çš„å½¢çŠ¶ï¼Œé¢œè‰²ï¼Œä½ç½®ï¼Œé€Ÿåº¦â€¦å…·ä½“APIå¦‚ä¸‹ï¼š å…¶å®è¿™é‡Œæœ€å…³é”®çš„æ˜¯ä¸Šé¢çš„é¢„æµ‹ç¢°æ’æ—¶é—´çš„ç®—æ³•ï¼Œåº”ç”¨äº†å¤§å­¦ç‰©ç†çš„ç›¸å…³çŸ¥è¯†ã€‚å°†ä¸‰ç§ç¢°æ’çš„é¢„æµ‹æ—¶é—´ç®—å‡ºæ¥ï¼Œå¦å¤–å¹¶ä¾æ¬¡èµ‹äºˆä¸‰ç§ç¢°æ’çš„æ•ˆæœã€‚ç„¶åå°†å…¶æ”¾å…¥ä¸€ä¸ªå¯æ¯”è¾ƒçš„äº‹ä»¶ä¸­ï¼Œé€šè¿‡éå†æ¯ä¸€ä¸ªçƒä¸å…¶ä»–çƒé¢„æµ‹ç¢°æ’æƒ…å†µï¼Œæ”¾å…¥ä¼˜å…ˆé˜Ÿåˆ—ä¸­å†ä¾æ¬¡å¤„ç†ã€‚ ç¬¬ä¸€ç§ ä¸¤çƒç›¸æ’1234567891011121314151617181920212223242526272829303132333435363738//æ—¶é—´//æ³¨æ„ä¸‹é¢å‡ ä¸ªåœ°æ–¹çš„å‰ªæpublic double timeToHitBall (Ball that) &#123; if (this == that) return INFINITY; double dx = that.pos_x - this.pos_x; double dy = that.pos_y - this.pos_y; double dvx = that.vec_x - this.vec_x; double dvy = that.vec_y - this.vec_y; double dvdr = dx * dvx + dy * dvy; if (dvdr &gt; 0) return INFINITY; double dvdv = dvx * dvx + dvy * dvy; if (dvdv == 0) return INFINITY; double drdr = dx * dx + dy * dy; double sigma = this.radius + that.radius; double d = (dvdr * dvdr) - dvdv * (drdr - sigma * sigma); if (d &lt; 0) return INFINITY; return -(dvdr + Math.sqrt(d)) / dvdv; &#125;//ç¢°æ’åçš„æ•ˆæœpublic void bounceOff (Ball that) &#123; double dx = that.pos_x - this.pos_x; double dy = that.pos_y - this.pos_y; double dvx = that.vec_x - this.vec_x; double dvy = that.vec_y - this.vec_y; double dvdr = dx * dvx + dy * dvy; double dist = this.radius + that.radius; double J = 2 * this.mass * that.mass * dvdr / ((this.mass + that.mass) * dist); double Jx = J * dx / dist; double Jy = J * dy / dist; this.vec_x += Jx / this.mass; this.vec_y += Jy / this.mass; that.vec_x -= Jx / that.mass; that.vec_y -= Jy / that.mass; this.cnt ++; that.cnt ++; &#125; ç¬¬äºŒç§ä¸å¢™ä½“å‘ç”Ÿç¢°æ’12345678910111213141516171819202122232425//ç¢°æ’å‚ç›´å¢™çš„æ—¶é—´public double timeToHitVerticalWall() &#123; if (vec_x &gt; 0) return (border - pos_x - radius) / vec_x; else if (vec_x &lt; 0) return (radius - pos_x) / vec_x; else return INFINITY;&#125;//ç¢°æ’æ°´å¹³å¢™çš„æ—¶é—´public double timeToHitHorizontalWall() &#123; if (vec_y &gt; 0) return (border - pos_y - radius) / vec_y; else if (vec_y &lt; 0) return (radius - pos_y) / vec_y; return INFINITY;&#125;//ç¢°æ’æ•ˆæœpublic void bounceOffVerticalWall () &#123; this.cnt ++; this.vec_x = - this.vec_x;&#125;public void bounceoffHorizontalWall () &#123; this.cnt ++; this.vec_y = - this.vec_y;&#125; ä»¥ä¸‹ä¾¿æ˜¯ç¬¬ä¸€ä¸ªçƒä½“ç±»å‹çš„å®Œæ•´ä»£ç Ball.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121import edu.princeton.cs.algs4.StdDraw;import edu.princeton.cs.algs4.StdRandom;import java.awt.*;public class Ball &#123; //çƒçš„æ¨ªçºµåæ ‡ private double pos_x; private double pos_y; //çƒçš„æ¨ªçºµæ–¹å‘ä¸Šé¢çš„é€Ÿåº¦ private double vec_x; private double vec_y; //çƒçš„åŠå¾„ private final double radius; //çƒçš„è´¨é‡ private final double mass; //è¾¹ç•Œé•¿åº¦ private final double border; //çƒçš„é¢œè‰² private final Color color; //ç¢°æ’æ¬¡æ•° private int cnt = 0; //é™å®šä¸€ä¸ªæœ€å¤§å€¼ private static final double INFINITY = Double.POSITIVE_INFINITY; public Ball () &#123; pos_x = StdRandom.uniform(0.0, 1.0); pos_y = StdRandom.uniform(0.0, 1.0); vec_x = StdRandom.uniform(-0.005, 0.005); vec_y = StdRandom.uniform(-0.005, 0.005); radius = 0.01; mass = 0.5; border = 1; color = Color.BLACK; &#125; public Ball (double px,double py,double vx,double vy,double radius,double mass,double border,Color color) &#123; this.pos_x = px; this.pos_y = py; this.vec_x = vx; this.vec_y = vy; this.radius = radius; this.mass = mass; this.border = border; this.color = color; &#125; public void draw() &#123; StdDraw.filledCircle(pos_x,pos_y,radius); StdDraw.setPenColor(color); &#125; public void move (double dt) &#123; pos_x = pos_x + vec_x * dt; pos_y = pos_y + vec_y * dt; &#125; public double timeToHitBall (Ball that) &#123; if (this == that) return INFINITY; double dx = that.pos_x - this.pos_x; double dy = that.pos_y - this.pos_y; double dvx = that.vec_x - this.vec_x; double dvy = that.vec_y - this.vec_y; double dvdr = dx * dvx + dy * dvy; if (dvdr &gt; 0) return INFINITY; double dvdv = dvx * dvx + dvy * dvy; if (dvdv == 0) return INFINITY; double drdr = dx * dx + dy * dy; double sigma = this.radius + that.radius; double d = (dvdr * dvdr) - dvdv * (drdr - sigma * sigma); if (d &lt; 0) return INFINITY; return -(dvdr + Math.sqrt(d)) / dvdv; &#125; public double timeToHitVerticalWall() &#123; if (vec_x &gt; 0) return (border - pos_x - radius) / vec_x; else if (vec_x &lt; 0) return (radius - pos_x) / vec_x; else return INFINITY; &#125; public double timeToHitHorizontalWall() &#123; if (vec_y &gt; 0) return (border - pos_y - radius) / vec_y; else if (vec_y &lt; 0) return (radius - pos_y) / vec_y; return INFINITY; &#125; public void bounceOff (Ball that) &#123; double dx = that.pos_x - this.pos_x; double dy = that.pos_y - this.pos_y; double dvx = that.vec_x - this.vec_x; double dvy = that.vec_y - this.vec_y; double dvdr = dx * dvx + dy * dvy; double dist = this.radius + that.radius; double J = 2 * this.mass * that.mass * dvdr / ((this.mass + that.mass) * dist); double Jx = J * dx / dist; double Jy = J * dy / dist; this.vec_x += Jx / this.mass; this.vec_y += Jy / this.mass; that.vec_x -= Jx / that.mass; that.vec_y -= Jy / that.mass; this.cnt ++; that.cnt ++; &#125; public int count() &#123; return cnt; &#125; public void bounceOffVerticalWall () &#123; this.cnt ++; this.vec_x = - this.vec_x; &#125; public void bounceoffHorizontalWall () &#123; this.cnt ++; this.vec_y = - this.vec_y; &#125;&#125; å…¶æ¬¡ï¼Œæˆ‘ä»¬éœ€è¦å¯¹ä»¥ä¸Šçƒä½“ç±»è¿›è¡Œä¸€ä¸ªåŒ…è£…ï¼Œå°†å…¶èµ‹äºˆå¯æ¯”è¾ƒçš„ç‰¹æ€§ã€‚å› ä¸ºä»å®è§‚ä¸Šæ¥çœ‹ï¼Œæˆ‘ä»¬éœ€è¦æ¯”è¾ƒçš„æ˜¯æ¯ä¸€ä¸ªçƒä½“çš„ç¢°æ’æƒ…å†µï¼Œæ‰€ä»¥ï¼Œç”¨ä¸€ä¸ªäº‹ä»¶åŒ…å«å…¶è¯¸å¤šç‰¹æ€§ 12345678910111213141516171819202122232425262728private static class Collison_Event implements Comparable&lt;Collison_Event&gt;&#123; private final Ball a,b; private final double time; private final int countA,countB; public Collison_Event (Ball a,Ball b,double time) &#123; this.time = time; this.a = a; this.b = b; if (a != null) countA = a.count(); else countA = -1; if (b != null) countB = b.count(); else countB = -1; &#125; public int compareTo(Collison_Event that) &#123; return Double.compare(this.time,that.time); &#125; public boolean isValid () &#123; if (this.time == Double.POSITIVE_INFINITY) return false; else &#123; if (a != null &amp;&amp; a.count() != countA) return false; if (b != null &amp;&amp; b.count() != countB) return false; return true; &#125; &#125; &#125; æœ€åå°±æ˜¯æ•´ä¸ªåŒ…å«ç±»ï¼Œå°±ç§°ä¸ºä¸€ä¸ªç³»ç»Ÿæ€è·¯å°±æ˜¯é¢„æµ‹ç¢°æ’çš„æ—¶é—´ï¼Œæ”¾å…¥ä¼˜å…ˆé˜Ÿåˆ—ä¸­ï¼Œå¦å¤–ï¼Œéœ€è¦æ³¨æ„çš„æ ¸å¿ƒçš„ä¸€ç‚¹å°±æ˜¯ï¼Œå…¶é‡‡ç”¨äº†æ—¶é—´é™åˆ¶ï¼Œå¤§äºæŸä¸ªæ—¶é—´çš„çƒä½“ç¢°æ’å³ä¸æ”¾è¿›é˜Ÿåˆ—ä¸­ï¼Œé¿å…å¼€é”€ã€‚è¿˜æœ‰ï¼Œä¸è¦å¿˜è®°é‡ç»˜çš„æ¡ä»¶ï¼Œåœ¨è¿™é‡ŒåŠ å…¥ä¸€ä¸ªHZå˜é‡æ§åˆ¶å¸§æ•°ã€‚ ä»¥ä¸‹æ˜¯ç¬¬äºŒä¸ªç±»çš„å…¨éƒ¨ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121import edu.princeton.cs.algs4.MinPQ;import edu.princeton.cs.algs4.StdDraw;import java.awt.Color;public class CollisionSystem &#123; protected MinPQ&lt;Collison_Event&gt; pq; //ç›¸å½“äºä¸€ä¸ªæ€»æ§æ—¶é—´çš„ä¸€ä¸ªå‚æ•°ï¼Œåé¢æ‰€æœ‰å…³äºæ—¶é—´çš„å‚æ•°éƒ½éœ€è¦åŠ ä¸Šä¸€ä¸ªè¿™ä¸ª protected double t = 0.0; protected Ball[] balls; //è¿™é‡Œå°±ç›¸å½“äºä¸€ä¸ªæ§åˆ¶æ¯ä¸€å¸§æ•°çš„é¢‘ç‡æ§åˆ¶ private static final double HZ = 0.5; public CollisionSystem(Ball[] balls) &#123; this.balls = balls.clone(); &#125; //è¿™é‡Œæ–°åŠ ä¸Šçš„ä¸€ä¸ªå‚æ•° limit æ˜¯æ§åˆ¶ä¸€äº›å®Œå…¨æ²¡å¿…è¦çš„äº‹ä»¶ //æ„æ€å°±æ˜¯å‰”é™¤é‚£äº›éœ€è¦å¤ªé•¿æ—¶é—´æ‰ä¼šç›¸æ’çš„çƒä½“ protected void pridict (Ball b,double limit) &#123; if (b == null) return; for (int i = 0;i &lt; balls.length;i++)&#123; double dt = b.timeToHitBall(balls[i]); if (t + dt &lt;= limit) pq.insert(new Collison_Event(b,balls[i],dt + t)); &#125; double dxt = b.timeToHitHorizontalWall() + t; double dyt = b.timeToHitVerticalWall() + t; if (dxt &lt;= limit) pq.insert(new Collison_Event(b,null,dxt)); if (dyt &lt;= limit) pq.insert(new Collison_Event(null,b,dyt)); &#125; protected void redrew(double limit) &#123; StdDraw.clear(); for (int i = 0;i &lt; balls.length;i++) &#123; balls[i].draw(); &#125; StdDraw.show(); StdDraw.pause(20); if (t &lt; limit) &#123; pq.insert(new Collison_Event(null,null,t + 1.0 / HZ)); &#125; &#125; protected void simulate (double limit) &#123; pq = new MinPQ&lt;Collison_Event&gt;(); for (int i = 0; i &lt; balls.length; i++) &#123; pridict(balls[i],limit); &#125; pq.insert(new Collison_Event(null,null,0)); while (!pq.isEmpty()) &#123; Collison_Event event = pq.delMin(); if (!event.isValid()) continue; //å°†å…¶ä»–çš„ç‚¹å…¨éƒ¨ç§»åŠ¨ for (int i = 0; i &lt; balls.length; i++) &#123; balls[i].move(event.time - t); &#125; t = event.time; if (event.a != null &amp;&amp; event.b != null) event.a.bounceOff(event.b); else if (event.a == null &amp;&amp; event.b != null) event.b.bounceOffVerticalWall(); else if (event.a != null &amp;&amp; event.b == null) event.a.bounceoffHorizontalWall(); else if (event.a == null &amp;&amp; event.b == null) redrew(limit); pridict(event.a,limit); pridict(event.b,limit); &#125; &#125; private static class Collison_Event implements Comparable&lt;Collison_Event&gt;&#123; private final Ball a,b; private final double time; private final int countA,countB; public Collison_Event (Ball a,Ball b,double time) &#123; this.time = time; this.a = a; this.b = b; if (a != null) countA = a.count(); else countA = -1; if (b != null) countB = b.count(); else countB = -1; &#125; public int compareTo(Collison_Event that) &#123; return Double.compare(this.time,that.time); &#125; public boolean isValid () &#123; if (this.time == Double.POSITIVE_INFINITY) return false; else &#123; if (a != null &amp;&amp; a.count() != countA) return false; if (b != null &amp;&amp; b.count() != countB) return false; return true; &#125; &#125; &#125; public static void main(String [] args)&#123; StdDraw.setCanvasSize(600,600); //è¿™ä¸ªæ˜¯æ¸…æ¥šç¼“å†² å¸®åŠ©æ”¹å–„è¿åŠ¨çš„ StdDraw.enableDoubleBuffering(); Ball[] balls = new Ball[100]; for (int i = 0;i &lt; 100; i++) &#123; balls[i] = new Ball(); &#125; CollisionSystem system = new CollisionSystem(balls); system.simulate(100000); &#125;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>java</tag>
        <tag>ç‰©ç†å¼•æ“</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ™®æ—æ–¯é¡¿ç®—æ³•è¯¾ç¬¬å››å‘¨å°ä½œä¸š]]></title>
    <url>%2F2019%2F02%2F24%2F%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%B0%8F%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[ç¬¬å››å‘¨çš„å°ä½œä¸šä¸»è¦å›´ç»•ä¼˜å…ˆé˜Ÿåˆ—ä»¥åŠåŸºäºä¼˜å…ˆé˜Ÿåˆ—çš„Taxicabnumberã€‚å…ˆè´´å‡ºå…³äºä¼˜å…ˆé˜Ÿåˆ—çš„ä»£ç MaxPQ.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149package Interview_Question_Week4.PQ;import edu.princeton.cs.algs4.StdIn;import edu.princeton.cs.algs4.StdOut;import java.util.Comparator;import java.util.Iterator;import java.util.NoSuchElementException;public class MaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt; implements Iterable&lt;Key&gt; &#123; protected Key[] key; protected int len; private Comparator&lt;Key&gt; comparator; public MaxPQ(int init)&#123; key = (Key[]) new Object[1 + init]; len = 0 + init; &#125; public MaxPQ (int init , Comparator&lt;Key&gt; rule)&#123; comparator = rule; key = (Key[]) new Object[1 + init]; len = 0 + init; &#125; private boolean less(int i,int j)&#123; if (comparator == null)&#123; return key[i].compareTo(key[j]) &lt; 0; &#125; return comparator.compare(key[i],key[j]) &lt; 0; &#125; protected void change(int i,int j) &#123; Key temp = key[i]; key[i] = key[j]; key[j] = temp; &#125; protected void sink(int k)&#123; while (k * 2 &lt;= len) &#123; int j = k * 2; if (j &lt; len &amp;&amp; less(j,j+1)) j++; if (!less(k,j)) break; change(k,j); k = j; &#125; &#125; protected void up(int k)&#123; while (k &gt; 1 &amp;&amp; less(k / 2,k)) &#123; change(k, k / 2); k = k / 2; &#125; &#125; private void resize(int n) &#123; Key[] temp = (Key[]) new Object[n]; for (int i = 1; i &lt;= len;i++) &#123; temp[i] = key[i]; &#125; key = temp; &#125; public boolean isEmpty()&#123; return len == 0; &#125; public Key get(int n) &#123; return key[n]; &#125; public int size() &#123; return len; &#125; public void insert(Key item) &#123; if (item == null) throw new IllegalArgumentException("wrong"); if (len + 1 == key.length) resize(2 * key.length); key[++len] = item; up(len); assert isMaxHeap(1); &#125; // è¿™é‡Œæ˜¯å¸®åŠ©åé¢å®Œæˆä¸€ä¸ªassertåˆ¤æ–­è€Œå­˜åœ¨çš„ private boolean isMaxHeap(int k) &#123; if (k &gt; len) return true; int left = 2*k; int right = 2*k + 1; if (left &lt;= len &amp;&amp; less(k, left)) return false; if (right &lt;= len &amp;&amp; less(k, right)) return false; return isMaxHeap(left) &amp;&amp; isMaxHeap(right); &#125; public Key delMax() &#123; if (isEmpty()) throw new NoSuchElementException(); Key item = key[1]; key[1] = null; change(1,len--); sink(1); if (len + 1 &lt;= key.length / 4 &amp;&amp; len &gt; 0 ) resize(key.length / 2); assert isMaxHeap(1); return item; &#125; public Iterator&lt;Key&gt; iterator ()&#123; return new heapIterator(); &#125; private class heapIterator implements Iterator&lt;Key&gt;&#123; private MaxPQ&lt;Key&gt; copy; public heapIterator() &#123; if (comparator == null) &#123; copy = new MaxPQ&lt;Key&gt;(len); &#125; else copy = new MaxPQ&lt;Key&gt;(len,comparator); for (int i = 0;i &lt; len;i++)&#123; copy.insert(key[i]); &#125; &#125; public boolean hasNext() &#123; if (!isEmpty()) return true; return false; &#125; public Key next() &#123; if (!hasNext()) throw new NoSuchElementException(); return copy.delMax(); &#125; @Override public void remove() &#123; throw new UnsupportedOperationException(); &#125; &#125; public static void main(String[] args) &#123; edu.princeton.cs.algs4.MaxPQ&lt;String&gt; pq = new edu.princeton.cs.algs4.MaxPQ&lt;String&gt;(); while (!StdIn.isEmpty()) &#123; String item = StdIn.readString(); if (!item.equals("-")) pq.insert(item); else if (!pq.isEmpty()) StdOut.print(pq.delMax() + " "); &#125; StdOut.println("(" + pq.size() + " left on pq)"); &#125;&#125; éšæœºä¼˜å…ˆé˜Ÿåˆ— RandomPQ.java 12345678910111213141516171819202122232425262728package Interview_Question_Week4;import Interview_Question_Week4.PQ.MaxPQ;import edu.princeton.cs.algs4.StdRandom;public class RandomPQ&lt;Key extends Comparable&lt;Key&gt;&gt; extends MaxPQ &#123; private int len; public RandomPQ (int n) &#123; super(n); this.len = super.len; &#125; public Comparable&lt;Key&gt; sample() &#123; int n = StdRandom.uniform(len + 1); return super.get(n); &#125; public Comparable&lt;Key&gt; randomRemove () &#123; int n = StdRandom.uniform(len + 1); Comparable&lt;Key&gt; item = key[n]; change(n,len--); key[len + 1] = null; sink(n); return item; &#125;&#125; ä¼˜å…ˆé˜Ÿåˆ—çš„ä¸€äº›åº”ç”¨PriorityQueue.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class PriorityQueue &#123; private MaxPQ&lt;Integer&gt; left; private MinPQ&lt;Integer&gt; right; public PriorityQueue() &#123; left = new MaxPQ&lt;Integer&gt;(); right = new MinPQ&lt;Integer&gt;(); &#125; public double findMedian() &#123; int L = left.size(); int R = right.size(); if (L == R) return (left.max() + right.min()) / 2; else if (L &gt; R) return left.max(); else return right.min(); &#125; public void insert(int key) &#123; double median = findMedian(); int L = left.size(); int R = right.size(); if (key &lt;= median) &#123; left.insert(key); if (L - R &gt; 1) &#123; right.insert(left.delMax()); &#125; &#125; else &#123; right.insert(key); if (R - L &gt; 1) &#123; left.insert(right.delMin()); &#125; &#125; &#125; public void removeMedian() &#123; int L = left.size(); int R = right.size(); if (L &gt; R) &#123; left.delMax(); &#125; else &#123; right.delMin(); &#125; &#125;&#125; æœ‰å››ä¸ªæ•° a,b,c,d æ»¡è¶³ a^3 + b^3 = c^3 +d^3ï¼Œç„¶åå†ç»™ä¸€ä¸ªæ•° nï¼Œæ±‚å‡º nä¹‹å†…æ‰€æœ‰æ»¡è¶³ä¸Šè¿°ç­‰å¼çš„å››ä¸ªæ•° æ€è·¯æ­¤å¤„å°±æ˜¯è¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ï¼Œå°†æ²¡ä¸¤ä¸ªæ•°çš„ç«‹æ–¹å’ŒåŠ èµ·æ¥ï¼Œç„¶åå†ä»¥ç«‹æ–¹å’Œçš„å¤§å°æ¥è¿›è¡Œæ’åºï¼Œä½œä¸ºæœ€åæ’åºçš„æ ‡å‡†ï¼Œæœ€åè¿›è¡Œæ¯”è¾ƒï¼Œå¯åšä¼˜åŒ–ã€‚ ä»£ç å¦‚ä¸‹ï¼š Taxicab 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package Interview_Question_Week4;import edu.princeton.cs.algs4.MinPQ;import edu.princeton.cs.algs4.StdOut;public class Taxicab implements Comparable&lt;Taxicab&gt; &#123; private final int a; private final int b; private final int cube; public Taxicab(int x,int y) &#123; this.a = x; this.b = y; this.cube = x * x * x + y * y * y; &#125; @Override public int compareTo(Taxicab a) &#123; if (this.cube &lt; a.cube) return -1; if (this.cube &gt; a.cube) return 1; if (this.a &lt; a.a) return -1; if (this.a &gt; a.a) return 1; return 0; &#125; @Override public String toString() &#123; return "number: " + cube + " (" + a + ", " + b + ")"; &#125; public void findTaxicabNumber(int N) &#123; MinPQ&lt;Taxicab&gt; candidate = new MinPQ&lt;Taxicab&gt;(); for (int i = 1;i &lt;= N;i++) &#123; candidate.insert(new Taxicab(i,i)); &#125; int cnt = 1; Taxicab pre = new Taxicab(0,0); while (!candidate.isEmpty()) &#123; Taxicab curr = candidate.delMin(); if (curr == pre) &#123; cnt ++; if (cnt == 2) &#123; StdOut.print(pre.cube + "=" + pre); &#125; StdOut.print(" = " + curr); &#125; else &#123; if (cnt &gt; 1) StdOut.println(); cnt = 1; &#125; pre = curr; if (curr.a &lt; N) candidate.insert(new Taxicab(curr.a,curr.b + 1)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>java</tag>
        <tag>æ™®æ—æ–¯é¡¿ç®—æ³•è¯¾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CollinearPoint]]></title>
    <url>%2F2019%2F02%2F24%2FCollinearPoint%2F</url>
    <content type="text"><![CDATA[CollinearPointâ€”â€”-æ™®æ—æ–¯é¡¿ç¬¬ä¸‰å‘¨å¤§ä½œä¸šç¬¬ä¸‰å‘¨çš„å¤§ä½œä¸š æœ‰ç‚¹æ„æ€ï¼ŒåŸºäºæ’åºçš„ä¸€æ¬¡ç®€å•ä¼˜åŒ–ï¼Œå…ˆçœ‹é¢˜ç›®ã€‚ ä¸€æ­¥ä¸€æ­¥æ¥ï¼Œæ ¹æ®é¢˜ç›®é¦–å…ˆå†™å‡ºä¸€ä¸ªç‚¹çš„ç±»ï¼Œè¿™ä¸ªç±»è¦åŒ…å«æ¯”è¾ƒï¼Œå¹¶ä¸”ï¼Œè¦åŒ…å«æ±‚å‡ºä¸¤ä¸ªç±»ä¹‹é—´æ–œç‡çš„æ–¹æ³•ã€‚Point.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package Programming_Assignment_3;import edu.princeton.cs.algs4.StdDraw;import edu.princeton.cs.algs4.StdRandom;import java.util.Arrays;import java.util.Comparator;public class Point implements Comparable&lt;Point&gt; &#123; private final int x; private final int y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; public void draw() &#123; StdDraw.point(x,y); &#125; public void drawTo(Point that) &#123; StdDraw.line(x,y,that.x,that.y); &#125; public String toString() &#123; return "(" + x + ", " + y + ")"; &#125; public int compareTo(Point that) &#123; if (y &gt; that.y) return 1; else if (y &lt; that.y) return -1; else if (x &gt; that.x) return 1; else if (x &lt; that.x) return -1; else return 0; &#125; public double slopeTo(Point that) &#123; if (x == that.x) &#123; if (y == that.y) return Double.NEGATIVE_INFINITY; else return Double.POSITIVE_INFINITY; &#125; if (y == that.y) return 0 / 1.0; return (y - that.y) * 1.0 / (x - that.x); &#125; private class SlopeOrder implements Comparator&lt;Point&gt;&#123; public int compare(Point p, Point q) &#123; if (slopeTo(p) &lt; slopeTo(q)) return -1; if (slopeTo(p) &gt; slopeTo(q)) return +1; return 0; &#125; &#125; public Comparator&lt;Point&gt; slopeOrder() &#123; return new SlopeOrder(); &#125; public static void main(String[] args) &#123; int x0 = Integer.parseInt(args[0]); int y0 = Integer.parseInt(args[1]); int n = Integer.parseInt(args[2]); StdDraw.setCanvasSize(800, 800); StdDraw.setXscale(0, 50); StdDraw.setYscale(0, 50); StdDraw.setPenRadius(0.005); StdDraw.enableDoubleBuffering(); Point[] points = new Point[n]; for (int i = 0; i &lt; n; i++) &#123; int x = StdRandom.uniform(50); int y = StdRandom.uniform(50); points[i] = new Point(x, y); points[i].draw(); &#125; // draw p = (x0, x1) in red Point p = new Point(x0, y0); StdDraw.setPenColor(StdDraw.RED); StdDraw.setPenRadius(0.02); p.draw(); // draw line segments from p to each point, one at a time, in polar order StdDraw.setPenRadius(); StdDraw.setPenColor(StdDraw.BLUE); Arrays.sort(points, p.slopeOrder()); for (int i = 0; i &lt; n; i++) &#123; p.drawTo(points[i]); StdDraw.show(); StdDraw.pause(100); &#125; &#125;&#125; æ¥ä¸‹æ¥å°±æ˜¯ç›´çº¿çš„ç±»ï¼Œè¿™ä¸¤ä¸ªç±»éƒ½æ¯”è¾ƒç®€å•ï¼Œè¿™é‡Œå°±ç›´æ¥è´´å‡ºä»£ç LineSegment.java123456789101112131415161718192021222324package Programming_Assignment_3;public class LineSegment &#123; private final Point a; private final Point b; public LineSegment(Point p, Point q) &#123; if (p == null || q == null) throw new java.lang.IllegalArgumentException(); a = p; b = q; &#125; public void draw() &#123; a.drawTo(b); &#125; public String toString() &#123; return a + " -&gt; " + b; &#125; public int hasCode() &#123; throw new UnsupportedOperationException(); &#125;&#125; æœ€åå°±æ˜¯é—®é¢˜çš„æ±‚è§£æ–¹æ³•ã€‚é—®é¢˜ éœ€è¦çŸ¥é“å¹³é¢ä¸Šçš„ç‚¹ï¼Œæœ‰å“ªäº›ç‚¹æ˜¯åœ¨ä¸€æ¡ç›´çº¿ä¸Šçš„ï¼Œç¬¬ä¸€ç§æ–¹æ³•ï¼Œæš´åŠ›æ³•ï¼Œç›´æ¥ç”¨å››ç§å¾ªç¯å†™å‡ºç­”æ¡ˆã€‚ BruteCollinearPoints.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package Programming_Assignment_3;import java.util.ArrayList;import java.util.Arrays;public class BruteCollinearPoints &#123; private Point[] copies; private ArrayList&lt;LineSegment&gt; lineSegments = new ArrayList&lt;LineSegment&gt;(); // finds all line segments containing 4 points public BruteCollinearPoints(final Point[] points) &#123; if (points == null) throw new java.lang.IllegalArgumentException(); copies = new Point[points.length]; for (int i = 0; i &lt; points.length; i++) &#123; copies[i] = points[i]; &#125; // sort by y-coordinate // the endpoints are the first and last points Arrays.sort(copies); // after sort then can check if duplicate for (int i = 0; i &lt; copies.length - 1; i++) if (copies[i].compareTo(copies[i+1]) == 0) throw new java.lang.IllegalArgumentException(); for (int ip = 0; ip &lt; copies.length-3; ip++) &#123; for (int iq = ip + 1; iq &lt; copies.length-2; iq++) &#123; double slopeP2Q = copies[ip].slopeTo(copies[iq]); for (int ir = iq + 1; ir &lt; copies.length-1; ir++) &#123; double slopeQ2R = copies[iq].slopeTo(copies[ir]); if (slopeP2Q != slopeQ2R) continue; for (int is = ir + 1; is &lt; copies.length; is++) &#123; double slopeR2S = copies[ir].slopeTo(copies[is]); // if 3 of 4's slopes are equal then 4 points are colllinear if (slopeP2Q == slopeR2S) lineSegments.add(new LineSegment(copies[ip], copies[is])); &#125; &#125; &#125; &#125; &#125; // the number of line segments public int numberOfSegments() &#123; return lineSegments.size(); &#125; // the line segments public LineSegment[] segments() &#123; LineSegment[] result = new LineSegment[lineSegments.size()]; for (int i = 0; i &lt; lineSegments.size(); i++) &#123; result[i] = lineSegments.get(i); &#125; return result; &#125; ä¼˜åŒ–çš„æ–¹æ³•å°±æ˜¯åŸºäºæ’åºï¼Œå°†æ¯ä¸€ä¸ªç‚¹éƒ½ä¸å·²ç»æ’å¥½åºçš„ç‚¹é›†è¿›è¡Œæ¯”è¾ƒï¼ŒæŒ‰ç…§ä¸€å®šçš„é¡ºåºè¿›è¡Œæ¯”è¾ƒå¯ä»¥çœç•¥å¾ˆå¤šã€‚FastCollinearPoints.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package Programming_Assignment_3;import java.util.ArrayList;import java.util.Arrays;public class FastCollinearPoints &#123; private Point[] copies; private ArrayList&lt;LineSegment&gt; lineSegments = new ArrayList&lt;LineSegment&gt;(); // finds all line segments containing 4 or more points public FastCollinearPoints(Point[] points) &#123; if (points == null) throw new java.lang.IllegalArgumentException(); copies = new Point[points.length]; for (int i = 0; i &lt; points.length; i++) &#123; copies[i] = points[i]; &#125; // sort by y-coordinate // the endpoints are the first and last points Arrays.sort(copies); // after sort then can check if duplicate for (int i = 0; i &lt; copies.length - 1; i++) if (copies[i].compareTo(copies[i+1]) == 0) throw new java.lang.IllegalArgumentException(); for (int i = 0; i &lt; copies.length - 1; i++) &#123; Point origin = copies[i]; // Think of p as the origin. double[] slopes = new double[copies.length - 1 - i]; Point[] others = new Point[copies.length - 1 - i]; for (int j = 0; j &lt; copies.length - 1 - i; j++) others[j] = copies[j + 1 + i]; // For each other point q, determine the slope it makes with p for (int j = 0; j &lt; others.length; j++) slopes[j] = origin.slopeTo(others[j]); // Sort the points according to the slopes they makes with p Arrays.sort(others, origin.slopeOrder()); Arrays.sort(slopes); // Check if any 3 (or more) adjacent points in the // sorted order have equal slopes with respect to p // If so, these points, together with p, are collinear for (int cnt_same = 0, j = 0; j &lt; slopes.length - 1; j++) &#123; if (slopes[j] == slopes[j+1]) &#123; cnt_same++; &#125; if (cnt_same &gt;= 2) &#123; lineSegments.add(new LineSegment(origin, others[j + 1])); break; &#125; &#125; &#125; &#125; // the number of line segments public int numberOfSegments() &#123; return lineSegments.size(); &#125; // the line segments public LineSegment[] segments() &#123; LineSegment[] result = new LineSegment[lineSegments.size()]; for (int i = 0; i &lt; lineSegments.size(); i++) &#123; result[i] = lineSegments.get(i); &#125; return result; &#125;&#125; æ€»ç»“ç”±äºæš´åŠ›åšæ³•è¿ç®—äº†å¾ˆå¤šåŸæœ¬ä¸éœ€è¦çš„å¾ªç¯ï¼Œç›¸å½“äºæ˜¯åšäº†å¾ˆå¤šé‡å¤åŠŸï¼Œæ‰€ä»¥ä¸æ‹›æ”¶å¾…è§ï¼Œè€ŒåŸºäºä¼˜åŒ–çš„ç‰ˆæœ¬è¿›è¡Œäº†ä¼˜åŒ–ï¼Œæ‰€ä»¥åœ¨å®é™…åº”ç”¨ä¸­æ˜¯å¯å–çš„ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>java</tag>
        <tag>æ™®æ—æ–¯é¡¿ç®—æ³•è¯¾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ™®æ—æ–¯é¡¿ç®—æ³•è¯¾ç¬¬ä¸‰å‘¨å°ä½œä¸š]]></title>
    <url>%2F2019%2F02%2F24%2F%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E4%B8%89%E5%91%A8%E5%B0%8F%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[ç¬¬ä¸‰å‘¨ä¸»è¦è®²çš„æ˜¯å½’å¹¶æ’åºå’Œå¿«é€Ÿæ’åºï¼Œè¿™é‡Œåœ¨C++é‡Œé¢å·²ç»æ€»ç»“è¿‡ï¼Œç›´æ¥è´´å‡ºä»£ç ã€‚CountInversions 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package Interview_Question_Week3;import java.util.Arrays;public class CountInversions &#123; private Comparable[] aux; private int inversion = 0; private boolean less (Comparable a,Comparable b)&#123; return a.compareTo(b) &lt; 0; &#125; public int get_num(Comparable[] a) &#123; aux = new Comparable[a.length]; sort(a,0,a.length - 1); return inversion; &#125; public void sort(Comparable[] a,int lo,int high)&#123; if (lo &gt;= high) return; int mid = (lo + high) / 2; sort(a,lo,mid); sort(a,mid+1,high); merge(a,lo,mid,high); &#125; public void merge(Comparable[] a,int lo,int mid,int high)&#123; int i = lo; int j = mid + 1; for (int k = lo; k &lt;= high;k++)&#123; aux[k] = a[k]; &#125; for (int k = lo;k &lt;= high;k++)&#123; if (i &gt; mid) a[k] = aux[j++]; else if (j &gt; high) a[k] = aux[i++]; else if (less (aux[i],aux[j]))&#123; // è¿™ä¸€æ­¥çš„ç›®çš„å°±åœ¨äºé€†åºå¯¹çš„ä¸ªæ•°ï¼Œå‰é¢æœ‰å¤šå°‘ä¸ªå¤§äºè‡ªå·±ä¸ªæ•°ï¼Œå°±æœ‰å¤šå°‘ä¸ªé€†åºå¯¹ inversion += mid + 1 - i; a[k] = aux[i++]; &#125; else a[k] = aux[j++]; &#125; &#125; public static void main(String [] args)&#123; Integer []a = &#123;1,5,3,7,2,8,6,4&#125;; System.out.println(new CountInversions().get_num(a)); System.out.println(Arrays.toString(a)); &#125;&#125; LinkedMergedArrays123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package Interview_Question_Week3;import java.util.Arrays;import java.util.Iterator;import java.util.ListIterator;public class LinkedMergedArrays &lt;T extends Comparable&lt;T&gt;&gt; implements Iterable&lt;T&gt;&#123; private Node first = null; private Node last = null; private int n = 0; private class Node &#123; Node next; T item; &#125; private boolean less (Comparable a,Comparable b) &#123; return a.compareTo(b) &lt; 0; &#125; public Iterator&lt;T&gt; iterator() &#123; return new ListIterator(); &#125; private class ListIterator implements Iterator&lt;T&gt;&#123; private Node current = first; public boolean hasNext() &#123; return current != null; &#125; public T next() &#123; // TODO Auto-generated method stub T t = current.item; current = current.next; return t; &#125; &#125; public void add(T t)&#123; Node node = new Node(); node.item = t; node.next = null; if(first == null &amp;&amp; last == null)&#123; first = node; last = node; &#125;else if(first != null &amp;&amp; first == last)&#123; first.next = node; last = node; &#125;else&#123; last.next = node; last = node; &#125; n++; &#125; public String toString()&#123; Iterator&lt;T&gt; iter = iterator(); String ret = iter.next().toString(); while(iter.hasNext())&#123; ret += ", "+ iter.next().toString() ; &#125; return ret; &#125; //ä»¥ä¸‹ä»£ç æ˜¯ç¬¬ä¸€ç§æ–¹å¼çš„å½’å¹¶ è¿˜æœ‰ç¬¬äºŒç§å½¢å¼çš„å½’å¹¶ æ˜å¤©å¯ä»¥å†™ä¸€ä¸‹ã€‚ public void mergeSort()&#123; first = sort(first); &#125; private Node sort(Node head)&#123; if(head == null || head.next == null) return head; Node slow = head; Node fast = head; //å–ä¸­é—´èŠ‚ç‚¹ while(fast.next != null &amp;&amp; fast.next.next != null)&#123; slow = slow.next; fast = fast.next.next; &#125; Node left = head; Node right = slow.next; slow.next = null; //å°†å·¦å³é“¾è¡¨åˆ†å¼€ left = sort(left); right = sort(right); return merge(left,right); &#125; private Node merge(Node left, Node right)&#123; //System.out.println("left="+left.element+",right="+right.element); Node aux = new Node(); //éœ€è¦è€—è´¹lognçš„é¢å¤–ç©ºé—´ Node l= left; Node r = right; Node current = aux; while(l != null &amp;&amp; r!=null)&#123; if(less(r.item,l.item)) &#123; current.next = r; current = current.next; r = r.next; &#125; else &#123; current.next = l; current = current.next; l= l.next; &#125; &#125; if(l!=null) current.next = l; // å¦‚æœå·¦ä¾§æ²¡éå†å®Œï¼Œå°†å…¶è¿æ¥è‡³currentå else if(r != null) current.next = r; //å¦‚æœå³ä¾§æ²¡éå†å®Œï¼Œå°†å…¶è¿æ¥è‡³currentå return aux.next; //è¿”å›å½’å¹¶å¥½çš„é“¾è¡¨ &#125;&#125; MergeSortedSubArray 12345678910111213141516171819202122232425262728package Interview_Question_Week3;import edu.princeton.cs.algs4.StdRandom;import java.util.Arrays;public class MergeSortedSubArray &#123; private static boolean less (Comparable a,Comparable b)&#123; return a.compareTo(b) &lt; 0; &#125; public static void merge(Comparable[] array)&#123; int n = array.length / 2; Comparable[] aux = new Comparable[n]; for (int i = 0;i &lt; n;i++)&#123; aux[i] = array[i]; &#125; System.out.println(Arrays.toString(aux)); int l = 0; int r = n; for(int k = 0; k&lt;2*n;k++)&#123; if(l &gt;= n) break;//è¾…åŠ©å…ƒç´ æ•°ç»„å…¨éƒ¨ç”¨å®Œï¼Œarrayå³ä¾§ä¸éœ€è¦æŒªåŠ¨ä½ç½®äº† else if(r&gt;=2*n) array[k]=aux[l++];//arrayåŸå³ä¾§å…ƒç´ å…¨éƒ¨æ”¾ç½®åˆé€‚ä½ç½®ï¼Œåé¢åªéœ€æŠŠè¾…åŠ©æ•°ç»„çš„å…ƒç´ æŒªåˆ°arrayå³ä¾§ else if(less(array[r],aux[l])) array[k] = array[r++]; else array[k] = aux[l++]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>java</tag>
        <tag>æ™®æ—æ–¯é¡¿ç®—æ³•è¯¾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ™®æ—æ–¯é¡¿ç¬¬äºŒå‘¨å°ä½œä¸š]]></title>
    <url>%2F2019%2F02%2F24%2F%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%B0%8F%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[ç¬¬äºŒå‘¨æ˜¯å…³äºé˜Ÿåˆ—ä¸æ ˆçš„ç›¸å…³å®ç°ï¼Œç”±äºC++é‡Œé¢æ—©å°±æ¶‰åŠåˆ°äº†ï¼Œè¿™é‡Œå¹¶ä¸å¤šè¯´ï¼Œç›´æ¥è´´ä»£ç Elementary_Sorts123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package Interview_Question_Week2.Elementary_Sorts;import edu.princeton.cs.algs4.StdRandom;enum Ball &#123; Red, Blue, White;&#125;public class Backets&#123; private Ball backets[]; private Ball color(int i)&#123; return backets[i]; &#125; private void swap (int i , int j)&#123; Ball tmp = backets[i]; backets[i] = backets[j]; backets[j] = tmp; &#125; public Backets(int n) &#123; backets = new Ball[n]; for (Ball i : backets)&#123; int x = StdRandom.uniform(3); switch (x)&#123; case 0: &#123;i = Ball.Blue;break;&#125; case 1: &#123; i = Ball.Red;break;&#125; case 2: &#123;i = Ball.White;break;&#125; &#125; &#125; &#125; public void sort() &#123; int low = 0; int cur = 0; int high = backets.length - 1; while (cur &lt;= high)&#123; switch (color(cur))&#123; case Red: &#123; if (cur != low) &#123; swap(cur, low); &#125; cur++; low++; break; &#125; case White: &#123; cur++; break; &#125; case Blue: &#123; swap (high,cur); high--; break; &#125; &#125; &#125; &#125; public static void main(String [] args)&#123; &#125;&#125;package Interview_Question_Week2.Elementary_Sorts;import java.awt.Point;import java.util.Arrays;import java.util.HashSet;import java.util.Random;import java.util.Set;public class Intersection_of_two_sets &#123; private Set&lt;Point&gt; same; private int sameTimes; public Intersection_of_two_sets(Point[]a , Point[]b,int times)&#123; same = new HashSet&lt;Point&gt;(); for (int i = 0;i &lt; times;i++)&#123; same.add(a[i]); same.add(b[i]); &#125; sameTimes = times * 2 - same.size(); &#125; public int get()&#123; return sameTimes; &#125; public static void main(String [] args)&#123; int n = 10; Random ra = new Random(); Point[] a = new Point[10]; Point[] b = new Point[10]; for (int i = 0;i &lt; n;i++)&#123; a[i] = new Point(); b[i] = new Point(); a[i].setLocation(ra.nextInt(10)+1,ra.nextInt(10)+1); b[i].setLocation(ra.nextInt(10)+1,ra.nextInt(10)+1); &#125; Intersection_of_two_sets i = new Intersection_of_two_sets(a,b,n); System.out.println(Arrays.toString(a)); System.out.println(Arrays.toString(b)); System.out.println(i.same); System.out.println(i.get()); &#125;&#125; MaxArrayStack1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package Interview_Question_Week2;import java.util.*;public class MaxArrayStack &#123; private int Max; private int sz; private int []a; public MaxArrayStack()&#123; Max = -999999999; a = new int [1]; sz = 0; &#125; public void resize(int capacity)&#123; int[] tmp = new int [capacity]; for (int i = 0;i != sz;i++)&#123; tmp[i] = a[i]; &#125; a = tmp; &#125; private void check()&#123; if (sz == a.length) resize(a.length * 2); &#125; public void push(int item)&#123; if (item &gt; Max) Max = item; check(); a[sz++] = item; &#125; public int pop()&#123; return a[--sz]; &#125; public int getMax()&#123; return Max; &#125; public String toString()&#123; return Arrays.toString(a); &#125; public static void main(String [] args)&#123; MaxArrayStack mStack = new MaxArrayStack(); mStack.push(4); mStack.push(5); mStack.push(6); mStack.push(2); mStack.push(1); mStack.push(10); mStack.push(7); mStack.push(7); System.out.println(mStack); System.out.println(mStack.getMax()); &#125;&#125; MaxLinkedStack123456789101112131415161718192021222324252627282930313233343536373839404142package Interview_Question_Week2;import java.util.*;class MaxLinkedStack &#123; private int N; private Node first; private Node max; private class Node &#123; private double item; private Node next; &#125; public MaxLinkedStack() &#123; N = 0; first = null; max = null; &#125; public double getMax() &#123; return max.item; &#125; public void push(double item) &#123; Node oldfirst = first; first = new Node(); first.item = item; first.next = oldfirst; N++; if (item &gt;= getMax()) &#123; Node oldmax = max; max = new Node(); max.next = oldmax; &#125; &#125; public double pop() &#123; double tmp = first.item; first = first.next; N--; if (tmp == getMax()) &#123; max = max.next; &#125; return tmp; &#125;&#125; StackQueue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package Interview_Question_Week2;import java.util.*;public class StackQueue&lt;Item&gt; &#123; private Stack&lt;Item&gt; input = new Stack &lt;Item&gt;(); private Stack&lt;Item&gt; output = new Stack &lt;Item&gt;(); public int size ()&#123; return input.size() + output.size(); &#125; public StackQueue() &#123; &#125; public boolean isEmpty() &#123; return size() == 0; &#125; public void enqueue(Item item) &#123; if (item == null) throw new IllegalArgumentException("wrong enquene"); input.push(item); &#125; public Item dequeue() &#123; if (isEmpty())&#123; throw new IndexOutOfBoundsException("out of range"); &#125; if (output.isEmpty())&#123; while (!input.isEmpty())&#123; output.push(input.pop()); &#125; &#125; return output.pop(); &#125; public static void main(String [] args)&#123; StackQueue&lt;Integer&gt; squeue = new StackQueue&lt;Integer&gt;(); int i = 0; int N = 100; System.out.println("Size: " + squeue.size()); squeue.enqueue(i); while (i &lt;= N) &#123; if (i % 3 == 0) &#123; System.out.println("Dequeue: " + squeue.dequeue()); &#125; else &#123; squeue.enqueue(i); System.out.println("Enqueue: " + i); &#125; ++i; &#125; System.out.println("Size: " + squeue.size()); while (!squeue.isEmpty()) &#123; System.out.println("Dequeue: " + squeue.dequeue()); &#125; System.out.println("Size: " + squeue.size()); &#125;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>java</tag>
        <tag>æ™®æ—æ–¯é¡¿ç®—æ³•è¯¾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Permutation]]></title>
    <url>%2F2019%2F02%2F24%2FPermutation%2F</url>
    <content type="text"><![CDATA[Permutationâ€”â€”â€”æ™®æ—æ–¯é¡¿ç®—æ³•å¤§ä½œä¸šç¬¬äºŒæ¬¡æ€»çš„æ¥è¯´ç¬¬äºŒæ¬¡ç®—æ³•å¤§ä½œä¸šæ¯”è¾ƒç®€å•ï¼Œå®ç°ä»¥ä¸‹åŒç«¯é˜Ÿåˆ—ï¼Œä»¥åŠéšæœºå‡ºé˜Ÿçš„é˜Ÿåˆ—ã€‚é‰´äºè¿™ä¸ªéš¾åº¦ç³»æ•°ï¼Œæˆ‘è¿™é‡Œç›´æ¥å†™äº†ä¸¤ç§ï¼ŒåŸºäºæ•°ç»„ä¸åŸºäºé“¾è¡¨ä¸¤ç§æ–¹å¼ï¼Œé¦–å…ˆå…ˆçœ‹é¢˜ç›®ã€‚ ç”±äºæ¯”è¾ƒç®€å• è¿™é‡Œä¸å¤šè¯´ ç›´æ¥å¼€å§‹è´´ä»£ç ã€‚ Deque123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131package Programming_Assignment_2;import java.util.Iterator;import java.util.NoSuchElementException;public class Deque&lt;Item&gt; implements Iterable&lt;Item&gt; &#123; private Node first,last; private int size; private class Node &#123; Item item; Node next; Node previous; Node (Item i)&#123; item = i; next = null; previous = null; &#125; &#125; public Deque() &#123; first = last = null; size = 0; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public int size() &#123; return size; &#125; public void addFirst(Item item) &#123; if (item == null)&#123; throw new IllegalArgumentException(); &#125; Node oldFirst = first; first = new Node(item); first.previous = null; if (isEmpty())&#123; last = first; first.next = null; &#125; else &#123; first.next = oldFirst; oldFirst.previous = first; &#125; size++; &#125; public void addLast(Item item) &#123; if (item == null)&#123; throw new IllegalArgumentException(); &#125; Node tmp = new Node(item); tmp.next = null; if (isEmpty())&#123; first = tmp; last = tmp; last.previous = null; &#125; else &#123; last.next = tmp; tmp.previous = last; last = tmp; &#125; size++; &#125; public Item removeFirst() &#123; if (isEmpty())&#123; throw new NoSuchElementException(); &#125; Item cnt = first.item; first = first.next; size--; if (isEmpty()) &#123; last = first =null; &#125; else &#123; first.previous = null; &#125; return cnt; &#125; public Item removeLast() &#123; if (isEmpty())&#123; throw new NoSuchElementException(); &#125; Item cnt = last.item; last = last.previous; size--; if (isEmpty())&#123; first = last = null; &#125; else &#123; last.next = null; &#125; return cnt; &#125; public Iterator&lt;Item&gt; iterator() &#123; return new DequeIterator(first); &#125; private class DequeIterator implements Iterator&lt;Item&gt;&#123; private Node current; public DequeIterator(Node first) &#123; current = first; &#125; public boolean hasNext()&#123; return current != null; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public Item next()&#123; if (!hasNext())&#123; throw new NoSuchElementException(); &#125; Item cnt = current.item; current = current.next; return cnt; &#125; &#125;&#125; RandomizedQueue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package Programming_Assignment_2;import java.util.Iterator;import java.util.NoSuchElementException;import java.lang.UnsupportedOperationException;import edu.princeton.cs.algs4.StdRandom;//åŸæœ¬æœ€åˆçš„æ‰“ç®—æ˜¯ç›´æ¥ç”¨é“¾è¡¨è¿›è¡Œå®ç°çš„ï¼Œ//ä½†æ˜¯åæ¥æ‰å‘ç°æ€§èƒ½è¦æ±‚è¿­ä»£å™¨çš„nextçš„æ–¹æ³•å¿…é¡»æ˜¯å¸¸æ•°æ—¶é—´ï¼Œ//è€Œç”¨é“¾è¡¨å®ç°ä¸äº†ï¼Œæ‰€ä»¥æ”¹ç”¨æ•°ç»„å®ç°ã€‚public class RandomizedQueue&lt;Item&gt; implements Iterable&lt;Item&gt; &#123; private Item[] array; private int size; public RandomizedQueue()&#123; size = 0; array = (Item[]) new Object[1]; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public int size() &#123; return size; &#125; private void check() &#123; if (size &gt;= array.length)&#123; resize(array.length * 2); &#125; else if (size &lt; array.length / 4)&#123; resize(array.length / 2); &#125; &#125; private void resize(int n) &#123; Item[] tmp = (Item[]) new Object[n]; for (int i = 0;i &lt; size;i++)&#123; tmp[i] = array[i]; &#125; array = tmp; &#125; public void enqueue(Item item) &#123; if (item == null) throw new IllegalArgumentException("wrong input"); check(); array[size++] = item; &#125; public Item dequeue() &#123; if (isEmpty()) throw new NoSuchElementException(); int random = StdRandom.uniform(size); Item cnt =array[random]; array[random] = array[size - 1]; array[--size] = null; check(); return cnt; &#125; public Item sample() &#123; if (isEmpty()) throw new NoSuchElementException(); return array[StdRandom.uniform(size)]; &#125; public Iterator&lt;Item&gt; iterator() &#123; return new RandomIterator(); &#125; private class RandomIterator implements Iterator&lt;Item&gt; &#123; private int rank; private Item[] iarray; public RandomIterator() &#123; rank = size; iarray = (Item[]) new Object[rank]; for (int i = 0;i &lt; rank;i++)&#123; iarray[i] = array[i]; &#125; &#125; public boolean hasNext() &#123; return rank &gt; 0; &#125; public void remove()&#123; throw new UnsupportedOperationException(); &#125; public Item next ()&#123; if (!hasNext()) throw new NoSuchElementException(); int random = StdRandom.uniform(rank); rank--; Item item = iarray[random]; iarray[random] = iarray[rank]; //è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ ä¸ä¸Šé¢ç›´æ¥åœ¨åŸæ•°ç»„ä¸Šé¢æ“ä½œçš„åŒºåˆ«å°±åœ¨äºä¸èƒ½ç›´æ¥ä»¤åé¢ç­‰äºnull //å¦‚ iarray[rank] = null è¿™æ ·é€ æˆçš„åæœæ˜¯å¤šç”¨å‡ æ¬¡è¿­ä»£å™¨ä½¿ç”¨ä¸äº†äº†ã€‚ iarray[rank] = null; return item; &#125; &#125;&#125; Permutation 123456789101112131415161718package Programming_Assignment_2;import edu.princeton.cs.algs4.StdIn;public class Permutation &#123; public static void main(String[] args) &#123; RandomizedQueue&lt;String&gt; rq = new RandomizedQueue&lt;String&gt;(); int k = Integer.parseInt(args[0]); while (!StdIn.isEmpty()) &#123; rq.enqueue(StdIn.readString()); // System.out.println(StdIn.readString()); &#125; while (k &gt; 0) &#123; System.out.println(rq.dequeue()); k--; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>java</tag>
        <tag>æ™®æ—æ–¯é¡¿ç®—æ³•è¯¾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Percolation]]></title>
    <url>%2F2019%2F02%2F08%2FPercolation%2F</url>
    <content type="text"><![CDATA[Programming Assignment 1: Percolationç¬¬ä¸€æ¬¡æäº¤è¿™æ ·çš„å…¨è‹±æ–‡å¤§ä½œä¸šï¼Œå…ˆå¼€å§‹å®Œå…¨çœ‹ä¸æ‡‚é¢˜ç›®ï¼Œç„¶ååœ¨ç½‘ä¸Šçœ‹æ‡‚é¢˜ç›®ä¹‹åï¼Œäºæ˜¯å†™ä»£ç çš„æ—¶å€™ä¹Ÿæ˜¯æ··ä¹±çš„ï¼Œå®Œå…¨ä¸çŸ¥é“è¯¥æ€ä¹ˆç”¨ï¼Œçœ‹äº†åˆ«äººæäº¤çš„å†™äº†ä¹‹åï¼Œè‡ªå·±ä¹Ÿæäº¤äº†å‡ æ¬¡ï¼Œéƒ½æ˜¯60åˆ†70åˆ†å·¦å³ï¼Œåˆ°æœ€åæ‰å‘ç°æ•°ç»„çš„æº¢å‡ºï¼Œä»¥åŠjavaè¾“å…¥è¾“å‡ºçš„ä¸€äº›é—®é¢˜ã€‚ æ¥ä¸‹æ¥çœ‹é¢˜ç›®é¦–å…ˆå…ˆçœ‹è‹±æ–‡ç‰ˆçš„é¢˜ç›® çœ‹æ‡‚çš„å¤§ç¥å¯ä»¥ä¸ç”¨çœ‹ä¸‹é¢çš„ä¸­æ–‡ç‰ˆçš„é¢˜ç›®äº†ï¼š é€šè¿‡è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿæ–¹æ³•æ¥ä¼°è®¡æ¸—æµé˜ˆå€¼ã€‚ Percolation. ç»™ä¸€ä¸ªæœ‰éšæœºåˆ†å¸ƒçš„ç»ç¼˜å’Œé‡‘å±ææ–™çš„ç»„æˆçš„å¤åˆç³»ç»Ÿã€‚ä¾‹å¦‚æˆ‘ä»¬æƒ³çŸ¥é“å“ªäº›éƒ¨åˆ†å¿…é¡»æ˜¯é‡‘å±ææ–™æ‰èƒ½è®©è¿™ä¸ªå¤åˆç³»ç»Ÿæ˜¯ä¸€ä¸ªç”µå¯¼ä½“ã€‚æˆ–è€…åœ¨ä¸€ä¸ªå¤šå­”çš„åœ°å½¢ï¼Œåœ¨è¡¨é¢æœ‰æ°´æˆ–è€…æ²¹ï¼Œåœ¨ä»€ä¹ˆæƒ…å†µä¸‹æ°´æˆ–è€…æ²¹èƒ½å¤Ÿä»æœ€è¡¨é¢æ¸—é€åˆ°æœ€åº•å±‚ã€‚ç§‘å­¦å®¶æŠŠè¿™ç§è¿‡ç¨‹çš„æ¨¡å‹å«åšPercolationã€‚ The model. åœ¨Assignmentä¸­ï¼Œç”¨ä¸€ä¸ªNxNçš„æ ¼å­è¡¨ç¤ºpercolationç³»ç»Ÿï¼Œæ¯ä¸€ä¸ªæ ¼å­æ˜¯æ‰“å¼€æˆ–è€…å…³é—­ï¼Œæ‰“å¼€æ˜¯ç™½è‰²å…³é—­æ˜¯é»‘è‰²ã€‚å¦‚æœä¸€ä¸ªæ ¼å­æ˜¯fullï¼Œé¦–å…ˆä»–å¿…é¡»æ˜¯æ‰“å¼€é¢ï¼Œç„¶åè¡¨ç¤ºä»æœ€é¡¶ä¸Šé€šè¿‡ç›¸è¿(4æ–¹å‘)çš„æ‰“å¼€çš„æ ¼å­å¯ä»¥æ¸—é€åˆ°è¿™ä¸ªä½ç½®ã€‚å½“ä¸€ä¸ªç³»ç»Ÿæ˜¯percolatesï¼Œè¡¨ç¤ºèƒ½ä»æœ€é¡¶å±‚æ¸—é€åˆ°æœ€åº•å±‚ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæœ€åº•å±‚å­˜åœ¨æ‰“å¼€çš„æ ¼å­æ˜¯fullã€‚ The Problem. ç ”ç©¶äººå‘˜å¯¹ä¸€ä¸‹çš„é—®é¢˜æ„Ÿå…´è¶£ï¼Œå¦‚æœæ¯ä¸€ä¸ªæ ¼å­æ˜¯ç‹¬ç«‹çš„ï¼Œå¹¶ä¸”è¢«æ‰“å¼€çš„æ¦‚ç‡ä¸ºpï¼Œé‚£ä¹ˆç³»ç»Ÿpercolatesçš„æ¦‚ç‡æ˜¯å¤šå°‘ï¼Ÿp=0ï¼Œpercolatesæ¦‚ç‡ä¸º0ï¼Œp=100ï¼Œpercolatesçš„æ¦‚ç‡ä¸º100ã€‚ä¸‹å›¾æ˜¯20x20å’Œ100x100æ ¼å­çš„æ¦‚ç‡pçš„åˆ†å¸ƒï¼š å½“Nè¶³å¤Ÿå¤§æ—¶, æœ‰ä¸€ä¸ªé˜ˆå€¼P, ä½¿å¾—å½“p &lt; pæ—¶å€™ï¼Œä»»æ„çš„NNç½‘æ ¼ï¼Œå‡ ä¹ä¸èƒ½è¢«æ¸—é€, å¹¶ä¸”å½“p &gt; p, åŸºæœ¬èƒ½å¤Ÿè¢«æ¸—é€ã€‚pæ²¡æœ‰å‡†ç¡®çš„æ•°å€¼è§£ã€‚ä»»åŠ¡æ˜¯å†™ä¸€ä¸ªè®¡ç®—ä¼°è®¡pçš„ç®—æ³•ã€‚ é¢˜ç›®ç»™å‡ºäº†ä¸¤ä¸ªæ ·ç‰ˆåˆ†åˆ«ä½œä¸ºé¢˜ç›®å¼€å§‹å†™çš„ä¸¤ä¸ªç±»ï¼š 1234567public class Percolation &#123; public Percolation(int N) // create N-by-N grid, with all sites blocked public void open(int i, int j) // open site (row i, column j) if it is not already public boolean isOpen(int i, int j) // is site (row i, column j) open? public boolean isFull(int i, int j) // is site (row i, column j) full? public boolean percolates() // does the system percolate?&#125; 123456789public class PercolationStats &#123; public PercolationStats(int n, int trials) // perform trials independent experiments on an n-by-n grid public double mean() // sample mean of percolation threshold public double stddev() // sample standard deviation of percolation threshold public double confidenceLo() // low endpoint of 95% confidence interval public double confidenceHi() // high endpoint of 95% confidence interval public static void main(String[] args) // test client (described below)&#125; ç¬¬ä¸€éƒ¨åˆ†å»ºç«‹èµ·ä¸€ä¸ªæ•°å­¦æ¨¡å‹æ¥æ¨¡æ‹Ÿè¿™ä¸ªç³»ç»Ÿclass Percolation123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import edu.princeton.cs.algs4.WeightedQuickUnionUF;public class Percolation &#123; //å»ºç«‹ä¸¤ä¸ªå¹¶æŸ¥é›† æ¥æ§åˆ¶ backwash çš„è™šæ‹ŸèŠ‚ç‚¹æ‰€äº§ç”Ÿçš„é—®é¢˜ private WeightedQuickUnionUF uf; private WeightedQuickUnionUF backwash; //æ‰“å¼€çš„æ•°ç›® private int num; //è¿™é‡Œç”¨ä¸€ç»´æ•°ç»„æ¥è¡¨ç¤ºæ•´å¼ å›¾ private boolean[] percolation; //æ€»æ•°ç›® private int len; public Percolation(int n) &#123; if (n &lt; 1) throw new IllegalArgumentException("Illeagal Argument"); len = n; percolation = new boolean[n * n + 2]; uf = new WeightedQuickUnionUF(n * n + 2); backwash = new WeightedQuickUnionUF(n * n + 1); num = 0; for (int i = 1;i &lt; n * n + 1; i++)&#123; percolation[i] = false; &#125; percolation[0] = percolation[n * n + 1] = true; &#125; private void check(int i,int j)&#123; if (i &lt; 1 || i &gt; len || j &lt; 1 || j &gt; len) throw new IllegalArgumentException("out of the range"); &#125; private int get_position(int i,int j) &#123; return (i - 1) * len + j; &#125; public void open(int row, int col) &#123; check(row,col); if (isOpen(row,col)) return; int index = get_position(row,col); percolation[index] = true; num++; //å¤„ç†è™šæ‹ŸèŠ‚ç‚¹ä¸å®é™…ä¸­çš„ç‚¹çš„å…³ç³» //å¹¶ä¸”åŒæ—¶å¤„ç†ä¸€ä¸‹å‰åå·¦å³ç‚¹ä¹‹é—´çš„å…³ç³» if (row == 1)&#123; uf.union(0,index); backwash.union(0,index); &#125; else if (isOpen(index - len))&#123; uf.union(index,index - len); backwash.union(index,index - len); &#125; if (row == len) uf.union(len * len + 1,index); else if (isOpen(index + len))&#123; uf.union(index,index + len); backwash.union(index,index + len); &#125; if (col != 1 &amp;&amp; isOpen(index - 1))&#123; uf.union(index,index - 1); backwash.union(index,index - 1); &#125; if (col != len &amp;&amp; isOpen(index + 1))&#123; uf.union(index,index + 1); backwash.union(index,index + 1); &#125; &#125; private boolean isOpen(int x)&#123; return percolation[x]; &#125; public boolean isOpen(int row, int col)&#123; check(row,col); return isOpen(get_position(row,col)); &#125; public boolean isFull(int row, int col)&#123; check(row,col); int index = get_position(row,col); if (backwash.connected(index,0)) return true; return false; &#125; public int numberOfOpenSites()&#123; return num; &#125; public boolean percolates()&#123; return uf.connected(0,len * len + 1); &#125;&#125; å…³äºä»¥ä¸Šè¿™ä¸ªç±» å…¶å®æœ€åˆæ€è€ƒä¹‹å¤„ï¼Œå®Œå…¨å°±æ˜¯å€Ÿé‰´å¹¶æŸ¥é›†çš„æ€æƒ³ï¼Œä½¿ç”¨ä¸€ä¸ªæ•°ç»„æ¥å­˜å‚¨å½“å‰çš„æ¨¡å—æœ‰æ²¡æœ‰è¢«æ‰“å¼€ï¼Œç„¶åæ ¹æ®è¿™ä¸ªæ¨¡å—è¿›è¡Œæ”¹å˜ï¼Œç„¶åå†ä½¿ç”¨å¹¶æŸ¥é›†å°†ç¬¬ä¸€ä¸ªä¸å½“å‰ä½ç½®ç›¸è¿æ¥ï¼Œå‰åå·¦å³éƒ½æ‰“å¼€å°±ç›¸å½“äºé“¾æ¥äº†ï¼Œç„¶åæ ¹æ®éå†å°±å¯ä»¥æ‰¾å‡ºæ˜¯å¦ä¼šéå†åˆ°æœ€åä¸€ä¸ªä½ç½®å»äº†ã€‚ ä¸Šé¢æ‰€è¯´çš„åŠæ³•æœ‰äº›éº»çƒ¦ï¼Œæœ‰ä¸€ç§æ–¹æ³•æ‰€äº§ç”Ÿçš„ä¸¤ä¸ªé—®é¢˜ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢æ‰€ä½¿ç”¨çš„æ–¹æ³•ä½¿ç”¨è™šæ‹ŸèŠ‚ç‚¹ï¼Œç›¸å½“äºé¢„è®¾ä¸€ä¸ªèµ·ç‚¹å’Œä¸€ä¸ªç»ˆç‚¹ï¼Œæœ€ååªéœ€è¦åˆ¤æ–­èµ·ç‚¹ä¸ç»ˆç‚¹æ˜¯å¦æ˜¯å¹¶æŸ¥é›†ç›¸è¿æ¥çš„å³å¯ å¹¶æŸ¥é›†çš„ä½¿ç”¨æ–¹æ³•ï¼Œå¯ä»¥ç›´æ¥å†™ä¸€ä¸ªç±»ä¹Ÿå¯ä»¥ä½¿ç”¨è‡ªå¸¦å¥½çš„ç±»å‹ã€‚ ä¼šäº§ç”Ÿç»ˆç‚¹å¤„çš„backwashé—®é¢˜ï¼Œæ„æ€å°±æ˜¯ç»ˆç‚¹ä½ç½®å¯èƒ½ä¼šä¸è®¸å¤šæ²¡æœ‰è¿æ¥åˆ°èµ·ç‚¹çš„æ”¯ç‚¹ç›¸è¿æ¥ï¼Œæ‰€ä»¥é‡‡ç”¨çš„è§£å†³åŠæ³•å°±æ˜¯ä½¿ç”¨ä¸¤ä¸ªå¹¶æŸ¥é›†ã€‚ ç¬¬äºŒéƒ¨åˆ†å°±æ˜¯ è§£å†³æ•°æ®çš„ä½ç½®ä¼°è®¡percolationçš„é˜ˆå€¼ï¼Œåˆå§‹åŒ–æ—¶å€™æ ¼å­éƒ½æ˜¯å…³é—­çš„ï¼Œéšæœºå¯»æ‰¾ä¸€ä¸ªå…³é—­çš„ä½ç½®æ‰“å¼€ï¼Œç›´åˆ°ç³»ç»Ÿå¯ä»¥æ¸—é€ä¸ºæ­¢ï¼Œæ‰“å¼€çš„æ ¼å­æ¯”ä¸Šæ€»æ ¼å­æ•°å°±æ˜¯é˜ˆå€¼ã€‚ è¿ç”¨ä¸€ä¸‹è¿™äº›å…¬å¼ï¼š è¿™ä¸ªé—®é¢˜ä»…ä»…å°±æ˜¯æ•°å­¦å¤„ç†çš„é—®é¢˜ï¼Œä»¥åŠæ§åˆ¶æ ¼å¼ä¸Šé¢çš„è¾“å…¥è¾“å‡ºã€‚ class PercolationStats12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import edu.princeton.cs.algs4.StdIn;import edu.princeton.cs.algs4.StdOut;import edu.princeton.cs.algs4.StdRandom;import edu.princeton.cs.algs4.StdStats;import edu.princeton.cs.algs4.Stopwatch;public class PercolationStats &#123; private double[] results; // estimated threshold for each trial private double avg; private double std; public PercolationStats(int n, int trials)&#123; if(n &lt;= 0 || trials &lt;= 0) throw new IllegalArgumentException(); results = new double[trials]; for(int i = 0; i &lt; trials; i++)&#123; int step = 0; Percolation pr = new Percolation(n); while(!pr.percolates())&#123; int row = StdRandom.uniform(n) + 1; int col = StdRandom.uniform(n) + 1; if(!pr.isOpen(row, col))&#123; pr.open(row, col); step++; &#125; &#125; results[i] = (double)step / (n * n); &#125; this.avg = StdStats.mean(results); this.std = StdStats.stddev(results); &#125; public static void main(String[] args)&#123; StdOut.printf("%-25s\n", "Please input 2 integers"); int N = StdIn.readInt(); int T = StdIn.readInt(); Stopwatch wt = new Stopwatch(); PercolationStats ps = new PercolationStats(N, T); // elapsed CPU time in seconds double elapsed = wt.elapsedTime(); StdOut.printf("%-25s= %.15f\n", "elapsed CPU time", elapsed); StdOut.printf("%-25s= %.7f\n", "mean", ps.mean()); StdOut.printf("%-25s= %.17f\n", "stddev", ps.stddev()); StdOut.printf("%-25s= [%.15f, %.15f]\n", "%95 confidence interval", ps.confidenceLo(), ps.confidenceHi()); &#125; public double mean()&#123; return this.avg; &#125; public double stddev()&#123; return this.std; &#125; public double confidenceLo()&#123; return mean() - 1.96 * stddev() / Math.sqrt(results.length); &#125; public double confidenceHi()&#123; return mean() + 1.96 * stddev() / Math.sqrt(results.length); &#125;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>æ™®æ—æ–¯é¡¿ç®—æ³•è¯¾</tag>
        <tag>æ•°æ®ç»“æ„</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ™®æ—æ–¯é¡¿ç®—æ³•è¯¾ä¹‹å¹¶æŸ¥é›†]]></title>
    <url>%2F2019%2F02%2F08%2F%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B9%8B%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[æ™®æ—æ–¯é¡¿ç®—æ³•ä¹‹å¹¶æŸ¥é›†ä¸ªäººç†è§£ å¹¶æŸ¥é›†å°±æ˜¯è¿ç”¨åœ¨è”é€šè·¯å¾„ä¸­ï¼Œéœ€è¦å‹ç¼©è·¯å¾„ï¼Œä»è€Œå¿«é€Ÿåˆ¤æ–­æ¥ä¸‹é‡Œçš„å‡ ä¸ªä½ç½®æ˜¯å¦ç›¸è¿. æ ¹æ®ä»¥ä¸Šçš„éœ€æ±‚å¯ä»¥å†™å‡ºç®€å•ç±»ä¼¼äºå¹¶æŸ¥é›†çš„æ“ä½œ å»ºç«‹æ•°å­¦æ¨¡å‹ï¼Œç”¨ä¸€ç»´ç”šè‡³æ˜¯å¤šç»´æ•°ç»„æ¥è¡¨ç¤ºä¸¤ä¸ªä½ç½®æ˜¯å¦ç›¸è¿ï¼Œç›¸è¿åˆ™ç”¨ç›¸åŒæ•°å­—æ¥è¿›è¡Œè¡¨ç¤ºï¼Œç„¶åç»è¿‡éå†æ¥ç­›æŸ¥ã€‚ ä»¥ä¸Šè¿™ç§åŠæ³•ç®€å•ç²—æš´ä¼šèŠ±è´¹å¾ˆå¤šæ— ç”¨åŠŸï¼Œæ‰€ä»¥è¿™æ‰äº§ç”Ÿäº†å¹¶æŸ¥é›†çš„å‰èº« ç®€å•æ¥è¯´å°±æ˜¯æ ¹æ®å åŠ æ•ˆåº”ï¼Œå¦‚è‹¥ä¸¤è€…ç›¸è¿ï¼Œå°±å°†å‰è€…ä½œä¸ºåè€…çš„å€¼ï¼Œç„¶åä¾æ¬¡ç´¯ç§¯ï¼Œå°±ä¼šäº§ç”Ÿç±»ä¼¼æ ‘å½¢ç»“æ„çš„æ ¹èŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯ä¸‹é¢å°†ä¼šæåˆ°çš„rootå‡½æ•°1234567private int root(int i)&#123; while (i != point[i]) &#123; i = point[i]; &#125; return i; &#125; ä»¥ä¸Šä»£ç åœ¨äºŒè€…æ²¡æœ‰ç›¸è¿æ¥çš„æ—¶å€™ï¼Œæ¯ä¸€ä¸ªäººçš„æ ¹èŠ‚ç‚¹éƒ½æ˜¯è‡ªå·±ï¼Œå½“ä½¿ç”¨unionæ“ä½œçš„æ—¶å€™ï¼Œå°±æ˜¯å°†å‰è€…æ¥åˆ°åè€…ä¸Šé¢å³åè€…å°±å˜æˆå‰è€…çš„èŠ‚ç‚¹ï¼Œè€Œè¿™é‡Œå°±è¿›è¡Œå¾ªç¯ï¼ŒçŸ¥é“æ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼ˆæ ¹èŠ‚ç‚¹çš„ç¥–å…ˆæ˜¯è‡ªå·±ï¼‰ æ¥ä¸‹æ¥å°±æ˜¯unionæ“ä½œ1234567public void union(int a,int b)&#123; int roota = root(a); int rootb = root(b); if (roota == rootb) return ; point[rootb] = roota; cnt--; &#125; æ‰¾åˆ°ä¸¤ä¸ªæ‰€ç»™ç‚¹çš„ç¥–å…ˆï¼Œå¹¶ä¸”æŠŠä»–ä»¬çš„ç¥–å…ˆåšä¸€ä¸ªè¿æ¥è¡Œä¸ºï¼Œè¿™æ ·å°±å®Œæˆäº†å¹¶æŸ¥é›†çš„æ ¸å¿ƒï¼Œè€Œå¾€å¾€æœ€å¤šçš„å˜å¼å°±äº§ç”Ÿåœ¨è¿™å…¶ä¸­ï¼Œä¸€èˆ¬æ¶‰åŠåˆ°ç¥–å…ˆçš„èµ‹å€¼æƒ…å†µï¼Œåé¢ä¼˜åŒ–çš„æ—¶å€™å†è¯´ã€‚ æœ€åä¸€ä¸ªå°±æ˜¯connectedçš„å‡½æ•°ï¼Œä¸»è¦ç”¨æ¥åˆ¤æ–­æ˜¯å¦ä¸¤ä¸ªç‚¹æ˜¯å¦è¿æ¥ï¼Œç›´æ¥åˆ¤æ–­ä»–ä»¬ä¸¤ä¸ªçš„ç¥–å…ˆç‚¹æ˜¯å¦ç›¸ç­‰å³å¯ã€‚123public boolean connected(int a,int b)&#123; return root(a)==root(b); &#125; ä¼˜åŒ–ä¼˜åŒ–ä¸»è¦åˆ†ä¸ºä¸¤ä¸ªæ–¹é¢è·¯å¾„å‹ç¼©å’Œè·¯å¾„æ ‘å¹³è¡¡ã€‚ è·¯å¾„å‹ç¼©12345678private int root(int i)&#123; while (i != point[i]) &#123; point[i] = point[point[i]]; i = point[i]; &#125; return i; &#125; æ­¤å¤„ä¸ä¸Šé¢ç›¸æ¯”ä»…ä»…åªæ˜¯å¤šäº†ä¸€è¡Œä»£ç ï¼Œä½†æ˜¯å´å¯ä»¥è®©ä»£ç æé«˜é€Ÿåº¦5å€ä»¥ä¸Šï¼Œè¿™é‡Œå°±æ˜¯å°†æœ¬æ¥è¦ä¸€ä¸ªä¸€ä¸ªå åŠ çš„èŠ‚ç‚¹ï¼Œå˜æˆäº†å¤šæ”¯å åŠ ï¼Œè¿™æ ·æ ‘çš„æ·±åº¦å°‘äº†å¾ˆå¤šï¼Œæ‰€å¸¦æ¥çš„ç»“æœå°±æ˜¯æ•ˆç‡çš„æé«˜ã€‚ è·¯å¾„æ ‘å¹³è¡¡1234567891011121314151617public void union(int a,int b)&#123; int roota = root(a); int rootb = root(b); if (roota == rootb) return ; if (sz[roota] &lt; sz[rootb])&#123; //ä¸‹é¢çš„æ„æ€å°±æ˜¯è®© roota æ¥åˆ° rootb ä¸Šé¢ point[roota] = rootb; sz[rootb] += sz[roota]; &#125; else &#123; point[rootb] = roota; //ä¸‹é¢è¿™ä¸ªæ„æ€å°±æ˜¯ç»§ç»­æ¥å¤´æ¥ä¸Šå» sz[roota] += sz[rootb]; if (Max[rootb] &gt; Max[roota]) Max[roota] = Max[rootb]; &#125; cnt--; &#125; è¿™é‡Œæ‰€å¸¦æ¥çš„æ”¹å˜å°±æ˜¯ ä½¿ç”¨äº†ä¸€ä¸ªszæ•°ç»„æ¥è®°å½•æ¯ä¸€ä¸ªç‚¹åœ¨è¿™ä¸ªä½ç½®çš„æ·±åº¦ï¼Œä»è€Œåœ¨æ¯ä¸€æ¬¡unionæ“ä½œçš„æ—¶å€™ï¼Œéƒ½ä¼šæœ‰ä¸€ä¸ªåˆ¤æ–­ï¼Œå°±æ˜¯æ ‘å±‚æ¬¡å°çš„å¾€æ ‘å±‚æ¬¡å¤§çš„èŠ‚ç‚¹ä¸Šé¢æ¥ï¼Œè¿™æ ·ä¸€æ¥ï¼ŒåŒæ ·å‡å°‘äº†æ ‘çš„å¼€é”€ï¼ŒåŠ å¿«æ•ˆç‡ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>æ™®æ—æ–¯é¡¿ç®—æ³•è¯¾</tag>
        <tag>æ•°æ®ç»“æ„</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javaä¸­thiså’Œsuperçš„ç”¨æ³•æ€»ç»“]]></title>
    <url>%2F2019%2F01%2F21%2FJava%E4%B8%ADthis%E5%92%8Csuper%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[thisthisæ˜¯è‡ªèº«çš„ä¸€ä¸ªå¯¹è±¡ï¼Œä»£è¡¨å¯¹è±¡æœ¬èº«ï¼Œå¯ä»¥ç†è§£ä¸ºï¼šæŒ‡å‘å¯¹è±¡æœ¬èº«çš„ä¸€ä¸ªæŒ‡é’ˆã€‚ thisçš„ç”¨æ³•åœ¨javaä¸­å¤§ä½“å¯ä»¥åˆ†ä¸º3ç§ï¼š 1. ç±»ä¼¼äºC++é‡Œé¢å¯¹äºè‡ªèº«æ™®é€šçš„å¼•ç”¨ï¼Œè¿™ç§æƒ…å†µå°±ä¸åœ¨å¤šè®²äº†2. å½¢å‚ä¸æˆå‘˜åå­—é‡åï¼Œç”¨thisæ¥åŒºåˆ†1234567891011121314151617class Person &#123; private int age = 10; public Person()&#123; System.out.println("åˆå§‹åŒ–å¹´é¾„ï¼š"+age);&#125; public int GetAge(int age)&#123; this.age = age; return this.age; &#125;&#125; public class test1 &#123; public static void main(String[] args) &#123; Person Harry = new Person(); System.out.println("Harry's age is "+Harry.GetAge(12)); &#125;&#125; è¿è¡Œç»“æœï¼šåˆå§‹åŒ–å¹´é¾„ï¼š10Harryâ€™s age is 12 å¯ä»¥çœ‹åˆ°ï¼Œè¿™é‡Œageæ˜¯GetAgeæˆå‘˜æ–¹æ³•çš„å½¢å‚ï¼Œthis.ageæ˜¯Personç±»çš„æˆå‘˜å˜é‡ã€‚ 3. å¼•ç”¨æ„é€ å‡½æ•°è¿™ä¸ªå°±æ”¾åœ¨ä¸‹é¢ä¸superä¸€èµ·è®²ã€‚ supersuperå¯ä»¥ç†è§£ä¸ºæ˜¯æŒ‡å‘è‡ªå·±è¶…ï¼ˆçˆ¶ï¼‰ç±»å¯¹è±¡çš„ä¸€ä¸ªæŒ‡é’ˆï¼Œè€Œè¿™ä¸ªè¶…ç±»æŒ‡çš„æ˜¯ç¦»è‡ªå·±æœ€è¿‘çš„ä¸€ä¸ªçˆ¶ç±»ã€‚ 1. ç±»ä¼¼äºC++çš„æ™®é€šå¯¹çˆ¶ç±»å¯¹è±¡çš„å¼•ç”¨ã€‚ï¼ˆè¿™é‡Œä¹Ÿä¸åœ¨å¤šè¯´ï¼‰2. å­ç±»ä¸­çš„æˆå‘˜å˜é‡æˆ–æ–¹æ³•ä¸çˆ¶ç±»ä¸­çš„æˆå‘˜å˜é‡æˆ–æ–¹æ³•åŒåï¼ˆå¯ä»¥ç”¨è¯¥åŠæ³•åŒºåˆ†ï¼‰123456789101112131415161718192021class Country &#123; String name; void value() &#123; name = "China"; &#125;&#125;class City extends Country &#123; String name; void value() &#123; name = "Shanghai"; super.value(); //è°ƒç”¨çˆ¶ç±»çš„æ–¹æ³• System.out.println(name); System.out.println(super.name); &#125; public static void main(String[] args) &#123; City c=new City(); c.value(); &#125;&#125; è¿è¡Œç»“æœ:ShanghaiChina å¯ä»¥çœ‹åˆ°ï¼Œè¿™é‡Œæ—¢è°ƒç”¨äº†çˆ¶ç±»çš„æ–¹æ³•ï¼Œä¹Ÿè°ƒç”¨äº†çˆ¶ç±»çš„å˜é‡ã€‚è‹¥ä¸è°ƒç”¨çˆ¶ç±»æ–¹æ³•value()ï¼Œåªè°ƒç”¨çˆ¶ç±»å˜é‡nameçš„è¯ï¼Œåˆ™çˆ¶ç±»nameå€¼ä¸ºé»˜è®¤å€¼nullã€‚ 3.å¼•ç”¨æ„é€ å‡½æ•°superï¼ˆå‚æ•°ï¼‰ï¼šè°ƒç”¨çˆ¶ç±»ä¸­çš„æŸä¸€ä¸ªæ„é€ å‡½æ•°ï¼ˆåº”è¯¥ä¸ºæ„é€ å‡½æ•°ä¸­çš„ç¬¬ä¸€æ¡è¯­å¥ï¼‰ã€‚thisï¼ˆå‚æ•°ï¼‰ï¼šè°ƒç”¨æœ¬ç±»ä¸­å¦ä¸€ç§å½¢å¼çš„æ„é€ å‡½æ•°ï¼ˆåº”è¯¥ä¸ºæ„é€ å‡½æ•°ä¸­çš„ç¬¬ä¸€æ¡è¯­å¥ï¼‰ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738class Person &#123; public static void prt(String s) &#123; System.out.println(s); &#125; Person() &#123; prt("çˆ¶ç±»Â·æ— å‚æ•°æ„é€ æ–¹æ³•ï¼š "+"A Person."); &#125;//æ„é€ æ–¹æ³•(1) Person(String name) &#123; prt("çˆ¶ç±»Â·å«ä¸€ä¸ªå‚æ•°çš„æ„é€ æ–¹æ³•ï¼š "+"A person's name is " + name); &#125;//æ„é€ æ–¹æ³•(2) &#125; public class Chinese extends Person &#123; Chinese() &#123; super(); // è°ƒç”¨çˆ¶ç±»æ„é€ æ–¹æ³•ï¼ˆ1ï¼‰ prt("å­ç±»Â·è°ƒç”¨çˆ¶ç±»â€æ— å‚æ•°æ„é€ æ–¹æ³•â€œï¼š "+"A chinese coder."); &#125; Chinese(String name) &#123; super(name);// è°ƒç”¨çˆ¶ç±»å…·æœ‰ç›¸åŒå½¢å‚çš„æ„é€ æ–¹æ³•ï¼ˆ2ï¼‰ prt("å­ç±»Â·è°ƒç”¨çˆ¶ç±»â€å«ä¸€ä¸ªå‚æ•°çš„æ„é€ æ–¹æ³•â€œï¼š "+"his name is " + name); &#125; Chinese(String name, int age) &#123; this(name);// è°ƒç”¨å…·æœ‰ç›¸åŒå½¢å‚çš„æ„é€ æ–¹æ³•ï¼ˆ3ï¼‰ prt("å­ç±»ï¼šè°ƒç”¨å­ç±»å…·æœ‰ç›¸åŒå½¢å‚çš„æ„é€ æ–¹æ³•ï¼šhis age is " + age); &#125; public static void main(String[] args) &#123; Chinese cn = new Chinese(); cn = new Chinese("codersai"); cn = new Chinese("codersai", 18); &#125; &#125;``` è¿è¡Œç»“æœ:çˆ¶ç±»Â·æ— å‚æ•°æ„é€ æ–¹æ³•ï¼š A Person.å­ç±»Â·è°ƒç”¨çˆ¶ç±»â€æ— å‚æ•°æ„é€ æ–¹æ³•â€œï¼š A chinese coder.çˆ¶ç±»Â·å«ä¸€ä¸ªå‚æ•°çš„æ„é€ æ–¹æ³•ï¼š A personâ€™s name is codersaiå­ç±»Â·è°ƒç”¨çˆ¶ç±»â€å«ä¸€ä¸ªå‚æ•°çš„æ„é€ æ–¹æ³•â€œï¼š his name is codersaiçˆ¶ç±»Â·å«ä¸€ä¸ªå‚æ•°çš„æ„é€ æ–¹æ³•ï¼š A personâ€™s name is codersaiå­ç±»Â·è°ƒç”¨çˆ¶ç±»â€å«ä¸€ä¸ªå‚æ•°çš„æ„é€ æ–¹æ³•â€œï¼š his name is codersaiå­ç±»ï¼šè°ƒç”¨å­ç±»å…·æœ‰ç›¸åŒå½¢å‚çš„æ„é€ æ–¹æ³•ï¼šhis age is 18 ä»æœ¬ä¾‹å¯ä»¥çœ‹åˆ°ï¼Œå¯ä»¥ç”¨superå’Œthisåˆ†åˆ«è°ƒç”¨çˆ¶ç±»çš„æ„é€ æ–¹æ³•å’Œæœ¬ç±»ä¸­å…¶ä»–å½¢å¼çš„æ„é€ æ–¹æ³•ã€‚ ä¾‹å­ä¸­Chineseç±»ç¬¬ä¸‰ç§æ„é€ æ–¹æ³•è°ƒç”¨çš„æ˜¯æœ¬ç±»ä¸­ç¬¬äºŒç§æ„é€ æ–¹æ³•ï¼Œè€Œç¬¬äºŒç§æ„é€ æ–¹æ³•æ˜¯è°ƒç”¨çˆ¶ç±»çš„ï¼Œå› æ­¤ä¹Ÿè¦å…ˆè°ƒç”¨çˆ¶ç±»çš„æ„é€ æ–¹æ³•ï¼Œå†è°ƒç”¨æœ¬ç±»ä¸­ç¬¬äºŒç§ï¼Œæœ€åæ˜¯é‡å†™ç¬¬ä¸‰ç§æ„é€ æ–¹æ³•ã€‚ superå’Œthisçš„å¼‚åŒï¼š superï¼ˆå‚æ•°ï¼‰ï¼šè°ƒç”¨åŸºç±»ä¸­çš„æŸä¸€ä¸ªæ„é€ å‡½æ•°ï¼ˆåº”è¯¥ä¸ºæ„é€ å‡½æ•°ä¸­çš„ç¬¬ä¸€æ¡è¯­å¥ï¼‰ thisï¼ˆå‚æ•°ï¼‰ï¼šè°ƒç”¨æœ¬ç±»ä¸­å¦ä¸€ç§å½¢æˆçš„æ„é€ å‡½æ•°ï¼ˆåº”è¯¥ä¸ºæ„é€ å‡½æ•°ä¸­çš„ç¬¬ä¸€æ¡è¯­å¥ï¼‰ super: å®ƒå¼•ç”¨å½“å‰å¯¹è±¡çš„ç›´æ¥çˆ¶ç±»ä¸­çš„æˆå‘˜ï¼ˆç”¨æ¥è®¿é—®ç›´æ¥çˆ¶ç±»ä¸­è¢«éšè—çš„çˆ¶ç±»ä¸­æˆå‘˜æ•°æ®æˆ–å‡½æ•°ï¼ŒåŸºç±»ä¸æ´¾ç”Ÿç±»ä¸­æœ‰ç›¸åŒæˆå‘˜å®šä¹‰æ—¶å¦‚ï¼šsuper.å˜é‡å super.æˆå‘˜å‡½æ•°æ®åï¼ˆå®å‚ï¼‰ thisï¼šå®ƒä»£è¡¨å½“å‰å¯¹è±¡åï¼ˆåœ¨ç¨‹åºä¸­æ˜“äº§ç”ŸäºŒä¹‰æ€§ä¹‹å¤„ï¼Œåº”ä½¿ç”¨thisæ¥æŒ‡æ˜å½“å‰å¯¹è±¡ï¼›å¦‚æœå‡½æ•°çš„å½¢å‚ä¸ç±»ä¸­çš„æˆå‘˜æ•°æ®åŒåï¼Œè¿™æ—¶éœ€ç”¨thisæ¥æŒ‡æ˜æˆå‘˜å˜é‡åï¼‰ è°ƒç”¨super()å¿…é¡»å†™åœ¨å­ç±»æ„é€ æ–¹æ³•çš„ç¬¬ä¸€è¡Œï¼Œå¦åˆ™ç¼–è¯‘ä¸é€šè¿‡ã€‚æ¯ä¸ªå­ç±»æ„é€ æ–¹æ³•çš„ç¬¬ä¸€æ¡è¯­å¥ï¼Œéƒ½æ˜¯éšå«åœ°è°ƒç”¨super()ï¼Œå¦‚æœçˆ¶ç±»æ²¡æœ‰è¿™ç§å½¢å¼çš„æ„é€ å‡½æ•°ï¼Œé‚£ä¹ˆåœ¨ç¼–è¯‘çš„æ—¶å€™å°±ä¼šæŠ¥é”™ã€‚ super()å’Œthis()ç±»ä¼¼,åŒºåˆ«æ˜¯ï¼Œsuper()ä»å­ç±»ä¸­è°ƒç”¨çˆ¶ç±»çš„æ„é€ æ–¹æ³•ï¼Œthis()åœ¨åŒä¸€ç±»å†…è°ƒç”¨å…¶å®ƒæ–¹æ³•ã€‚ super()å’Œthis()å‡éœ€æ”¾åœ¨æ„é€ æ–¹æ³•å†…ç¬¬ä¸€è¡Œã€‚ å°½ç®¡å¯ä»¥ç”¨thisè°ƒç”¨ä¸€ä¸ªæ„é€ å™¨ï¼Œä½†å´ä¸èƒ½è°ƒç”¨ä¸¤ä¸ªã€‚ thiså’Œsuperä¸èƒ½åŒæ—¶å‡ºç°åœ¨ä¸€ä¸ªæ„é€ å‡½æ•°é‡Œé¢ï¼Œå› ä¸ºthiså¿…ç„¶ä¼šè°ƒç”¨å…¶å®ƒçš„æ„é€ å‡½æ•°ï¼Œå…¶å®ƒçš„æ„é€ å‡½æ•°å¿…ç„¶ä¹Ÿä¼šæœ‰superè¯­å¥çš„å­˜åœ¨ï¼Œæ‰€ä»¥åœ¨åŒä¸€ä¸ªæ„é€ å‡½æ•°é‡Œé¢æœ‰ç›¸åŒçš„è¯­å¥ï¼Œå°±å¤±å»äº†è¯­å¥çš„æ„ä¹‰ï¼Œç¼–è¯‘å™¨ä¹Ÿä¸ä¼šé€šè¿‡ã€‚ this()å’Œsuper()éƒ½æŒ‡çš„æ˜¯å¯¹è±¡ï¼Œæ‰€ä»¥ï¼Œå‡ä¸å¯ä»¥åœ¨staticç¯å¢ƒä¸­ä½¿ç”¨ã€‚åŒ…æ‹¬ï¼šstaticå˜é‡,staticæ–¹æ³•ï¼Œstaticè¯­å¥å—ã€‚ ä»æœ¬è´¨ä¸Šè®²ï¼Œthisæ˜¯ä¸€ä¸ªæŒ‡å‘æœ¬å¯¹è±¡çš„æŒ‡é’ˆ, ç„¶è€Œsuperæ˜¯ä¸€ä¸ªJavaå…³é”®å­—ã€‚]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>java</tag>
        <tag>æ•°æ®ç»“æ„</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ•°æ®ç»“æ„ä¹‹æ’åºæ€»ç»“]]></title>
    <url>%2F2018%2F12%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[æ•°æ®ç»“æ„çš„æ’åºæ€»ç»“é¦–å…ˆå…ˆå±•ç¤ºä¸€å¼ å›¾ï¼Œæ¥è¯´æ˜æ¯ä¸€ä¸ªæ’åºä¹‹é—´çš„å¤æ‚åº¦å’Œç¨³å®šæ€§ å†’æ³¡æ’åºè¿™ç§æ’åºå¾€å¾€å±äºæœ€åŸºæœ¬çš„æ’åºäº†ï¼Œæ¯”è¾ƒç¨³å®šï¼Œè€Œä¸”ä»£ç ä¹Ÿæ¯”è¾ƒç®€å•ï¼Œè¿™é‡Œä¸åšå¤šè®²ï¼Œç›´æ¥è´´ä»£ç  123456789101112131415void maopao(int *p)&#123; for (int i=0;i!=maxn;i++) &#123; for (int j=i+1;j!=maxn;j++) &#123; if (*(p+i)&gt;*(p+j))&#123; int temp = *(p+i); *(p+i) = *(p+j); *(p+j) = temp; &#125; &#125; &#125; print(p);&#125; å¿«é€Ÿæ’åº è¿›é˜¶ç‰ˆçš„å†’æ³¡æ’åºï¼Œå³å¯¹å†’æ³¡æ’åºè¿›è¡Œç®—æ³•ä¼˜åŒ–è¿‡å¾—ç»“æœ å¿«é€Ÿæ’åºçš„åŸºæœ¬æ€æƒ³å°±æ˜¯ï¼Œé€šè¿‡æ‰¾åˆ°ä¸€ä¸ªä¸­é—´å€¼(æ¢çº½å€¼)ï¼Œç„¶åæ¯”æ¢çº½å€¼å°çš„æ”¾åˆ°æ¢çº½å€¼çš„å·¦è¾¹ï¼Œæ¯”æ¢çº½å€¼å¤§çš„æ”¾åœ¨æ¢çº½å€¼çš„å³è¾¹ï¼Œç„¶åé€šè¿‡æ¢çº½å€¼æ¥è¿›è¡Œåˆ’åˆ†ï¼Œä¸€æ¬¡å¾€ä¸‹é¢åˆ’åˆ†ï¼Œåˆ©ç”¨é€’å½’æˆ–è€…æ˜¯éé€’å½’çš„æ ˆæ¥å®ç°ï¼Œæœ€ç»ˆå®ç°ç›¸åº”çš„æ’åºã€‚ ç®—æ³•æ­¥éª¤ é¦–å…ˆæ‰¾åˆ°ä¸€ä¸ªæ¢çº½,ä¸€èˆ¬æ‰¾æœ€ä¸­é—´çš„ä¸€ä¸ªå€¼ï¼Œæˆ–è€…æ‰¾æœ€å·¦è¾¹çš„ä¸€ä¸ªå€¼ï¼Œæˆ–è€…æœ€å³è¾¹çš„å€¼ï¼Œä½†æ˜¯è¿™æ ·å°±ä¼šæœ‰ç¼ºé™·ï¼Œåœ¨æŸäº›ç‰¹æ®Šæƒ…å†µä¸‹ä¼šä¼šå­˜åœ¨å¾ˆå¤šä¸å¿…è¦çš„å¼€é”€ã€‚ å¦‚æœæœ€åè¿™ä¸ªå€¼åˆšå¥½æ˜¯æ•´æ®µåºåˆ—æœ€å¤§æˆ–è€…æœ€å°çš„å€¼ï¼Œé‚£ä¹ˆè¿™æ¬¡åˆ’åˆ†å°±æ˜¯æ²¡æ„ä¹‰çš„ã€‚ æ‰€ä»¥å½“åºåˆ—æ˜¯æ­£åºæˆ–è€…é€†åºæ—¶ï¼Œæ¯æ¬¡é€‰åˆ°çš„æ¢è½´éƒ½æ˜¯æ²¡æœ‰èµ·åˆ°åˆ’åˆ†çš„ä½œç”¨ã€‚å¿«æ’çš„æ•ˆç‡ä¼šæé€Ÿé€€åŒ–ã€‚æ‰€ä»¥å¯ä»¥æ¯æ¬¡åœ¨é€‰æ¢è½´æ—¶ï¼Œåœ¨åºåˆ—çš„ç¬¬ä¸€ï¼Œä¸­é—´ï¼Œæœ€åä¸‰ä¸ªå€¼é‡Œé¢é€‰ä¸€ä¸ªä¸­é—´å€¼å‡ºæ¥ä½œä¸ºæ¢è½´ï¼Œä¿è¯æ¯æ¬¡åˆ’åˆ†æ¥è¿‘å‡ç­‰ã€‚ æ‰€ä»¥é‡‡ç”¨çš„æ˜¯ä¸‰å€¼å–ä¸­æ³•ï¼š 12345678910111213141516int get_mid(int *a,int left,int right)&#123; int mid = (left + right) / 2; if (a[left] &lt;= a[right]) &#123; if (a[mid] &lt; a[left]) return left; else if (a[mid] &gt; a[right]) return right; else return mid; &#125; else &#123; if (a[mid] &lt; a[right]) return right; else if (a[mid] &gt; a[left]) return left; else return mid; &#125;&#125; å½“å–åˆ°ä¸­é—´çš„æ¢çº½å€¼ä¹‹åï¼Œæ¥ä¸‹æ¥éœ€è¦å®Œæˆçš„æ˜¯å°†æ¢çº½å€¼æ”¾åˆ°æœ€å³è¾¹ï¼Œå¹¶ä¸”ä¸€æ¬¡è¿›è¡Œæ¯”è¾ƒæ’åºï¼Œå°†æ¯”æ¢çº½å€¼å°çš„æ”¾åœ¨å·¦è¾¹ï¼Œæ¯”æ¢çº½å€¼å¤§çš„æ”¾åœ¨å³è¾¹ã€‚æœ€åè¿”å›æœ€ç»ˆæ¢çº½å€¼æ‰€åœ¨çš„ä½ç½®ï¼ŒæŒ‰ç…§æ­¤ä½ç½®è¿›è¡Œåˆ’åˆ†å­åŒºï¼Œä»è€Œå®Œæˆä¸€æ¬¡å¿«é€Ÿæ’åºï¼Œç„¶åå†åˆ°æ¯ä¸€ä¸ªå­åŒºè¿›è¡Œé‡å¤ä¸Šè¿°è¿‡ç¨‹ã€‚ ä»¥ä¸‹ä»‹ç»ä¸¤ç§æ–¹æ³•ï¼Œè€Œè¿™ä¸¤ç§æ–¹æ³•ä»£ç ç±»ä¼¼ï¼Œè€Œä¸¤è€…å”¯ä¸€çš„åŒºåˆ«ä¹Ÿå°±åœ¨äºå¯¹äºkeyçš„å¤„ç†äº†ï¼Œä¸€ä¸ªæ˜¯ç›´æ¥å°†keyå½“åšæ˜¯å¼•ç”¨ï¼Œè€Œå¦ä¸€ä¸ªåˆ™æ˜¯ç›´æ¥æ‹·è´ã€‚1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//å·¦å³æŒ‡é’ˆäº¤æ¢çš„åŠæ³•int part_sort1(int *a,int left,int right)&#123; int mid = get_mid(a,left,right); swap(a[mid],a[right]); int &amp;key = a[right]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; a[left] &lt;= key) ++left; while (left &lt; right &amp;&amp; a[right] &gt;= key) --right; //äº¤æ¢å·¦å³ä¸¤ä¸ªçš„å€¼ï¼Œåˆ†åˆ«æ ¹æ®keyå€¼è¿›è¡Œä¸€ä¸ªæœ‰æ•ˆçš„åˆ’åˆ† swap (a[left],a[right]); &#125; //ç”±äºè¿™é‡Œçš„keyæ˜¯ä¸€ä¸ªå¼•ç”¨ï¼Œç›´æ¥é™„åœ¨äº†æ¢çº½å€¼ä¸Šé¢ï¼Œæ— è®ºæ€ä¹ˆç§»åŠ¨ï¼Œéƒ½å¯ä»¥åœ¨è¿™ä¸ªåœ°æ–¹ç›´æ¥è¿›è¡Œäº¤æ¢ swap(a[right],key); //ç„¶è€Œè¿™é‡Œéœ€è¦æ³¨æ„å°±æ˜¯ï¼Œæ— è®ºè¿™é‡Œæ˜¯å†™rightè¿˜æ˜¯leftï¼Œåˆ°æœ€årightä¸leftä¸€å®šä¼šç›¸åŒçš„ï¼Œå› ä¸ºæ¯ä¸€æ¬¡åˆ’åˆ†æœ€ååˆ°ä¸èƒ½åˆ’åˆ†ä¹‹åï¼Œå·¦å³æŒ‡é’ˆå°±ä¼šè¿›è¡Œä¸€ä¸ªé‡å ã€‚ return right;&#125;//æŒ–å‘å¡«è¡¥æ³•int part_sort2(int *a,int left,int right)&#123; int mid = get_mid(a,left,right); swap (a[mid],a[right]); //è¿™é‡Œå®é™…ä¸Šå°±æ˜¯ç›´æ¥å°†æ¢çº½å€¼è¿›è¡Œæ‹·è´ç»™tempä¸Šé¢ int key = a[right]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; a[left] &lt;= key) ++left; a[right] = a[left]; //æ¯ä¸€æ­¥éª¤å°±è¿›è¡Œå ä½ while (left &lt; right &amp;&amp; a[right] &gt;= key) --right; //ç›¸å½“äºæ­¤å¤„è¿›è¡Œä¸€ä¸ªæœ‰æ•ˆçš„ä½ç½®äº’æ¢ a[left] = a[right]; &#125; a[right] = key; //ç„¶åè¿™é‡ŒrightæŒ‡å‘çš„å…ƒç´ å°±åº”è¯¥æ˜¯å¤šä½™ä¸”æœ¬åº”è¯¥å­˜æ”¾æ¢çº½å€¼çš„ä½ç½® return right;&#125; å½“æ¯ä¸€æ­¥ç»“æŸä¹‹åï¼Œå¯ä»¥åˆ©ç”¨é€’å½’ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨éé€’å½’çš„æ ˆæ¥å®ç°å¯¹æ¯ä¸€æ­¥çš„åˆ†åŒºè¿›è¡Œå¿«æ’çš„æ“ä½œã€‚ 123456789void quick_sort(int *a,int left,int right)&#123; if (left &lt; right) &#123; int index = part_sort1(a,left,right); quick_sort(a,left,index-1); quick_sort(a,index+1,right); &#125;&#125; é€‰æ‹©æ’åºç®€å•é€‰æ‹©æ’åºæ˜¯æœ€ç®€å•ç›´è§‚çš„ä¸€ç§ç®—æ³•ï¼ŒåŸºæœ¬æ€æƒ³ä¸ºæ¯ä¸€è¶Ÿä»å¾…æ’åºçš„æ•°æ®å…ƒç´ ä¸­é€‰æ‹©æœ€å°ï¼ˆæˆ–æœ€å¤§ï¼‰çš„ä¸€ä¸ªå…ƒç´ ä½œä¸ºé¦–å…ƒç´ ï¼Œç›´åˆ°æ‰€æœ‰å…ƒç´ æ’å®Œä¸ºæ­¢ï¼Œç®€å•é€‰æ‹©æ’åºæ˜¯ä¸ç¨³å®šæ’åºã€‚ ç®—æ³•æ€æƒ³ï¼šæ¯ä¸€è¶Ÿç¡®å®šæœ€å°å…ƒç´ çš„æ—¶å€™ä¼šé€šè¿‡ä¸æ–­åœ°æ¯”è¾ƒäº¤æ¢æ¥ä½¿å¾—é¦–ä½ç½®ä¸ºå½“å‰æœ€å°ï¼Œäº¤æ¢æ˜¯ä¸ªæ¯”è¾ƒè€—æ—¶çš„æ“ä½œã€‚é€šè¿‡è®¾ç½®ä¸€ä¸ªå˜é‡minï¼Œæ¯ä¸€æ¬¡æ¯”è¾ƒä»…å­˜å‚¨è¾ƒå°å…ƒç´ çš„æ•°ç»„ä¸‹æ ‡ï¼Œå½“è½®å¾ªç¯ç»“æŸä¹‹åï¼Œé‚£è¿™ä¸ªå˜é‡å­˜å‚¨çš„å°±æ˜¯å½“å‰æœ€å°å…ƒç´ çš„ä¸‹æ ‡ï¼Œæ­¤æ—¶å†æ‰§è¡Œäº¤æ¢æ“ä½œå³å¯ã€‚ï¼ˆè¿™é‡Œä¸åšè¿‡å¤šé˜è¿°ï¼‰ 12345678910111213141516171819void xuanze(int *p)&#123; for (int i=0;i!=maxn;i++) &#123; int Min = i; for (int j = i+1; j!=maxn ;j++) &#123; if (*(p+Min) &gt; *(p+j)) Min = j; &#125; if (Min != i) &#123; int temp = *(p + Min); *(p + Min) = * (p + i); *(p + i) = temp; &#125; &#125; print(p);&#125; å †æ’åºå †æ’åºæ˜¯åˆ©ç”¨å †è¿™ç§æ•°æ®ç»“æ„è€Œè®¾è®¡çš„ä¸€ç§æ’åºç®—æ³•ï¼Œå †æ’åºæ˜¯ä¸€ç§é€‰æ‹©æ’åºï¼Œï¼ˆå¯ä»¥ç†è§£æˆç‰¹æ®Šçš„é€‰æ‹©æ’åºï¼Œç›¸å½“äºå®Œå…¨äºŒå‰æ ‘å‹çš„é€‰æ‹©æ’åºï¼‰å®ƒçš„æœ€åï¼Œæœ€å¥½ï¼Œå¹³å‡æ—¶é—´å¤æ‚åº¦å‡ä¸ºO(nlogn)ï¼Œå®ƒä¹Ÿæ˜¯ä¸ç¨³å®šæ’åºã€‚ é¦–å…ˆç®€å•äº†è§£ä¸‹å †ç»“æ„ã€‚ å †å †æ˜¯å…·æœ‰ä»¥ä¸‹æ€§è´¨çš„å®Œå…¨äºŒå‰æ ‘ï¼šæ¯ä¸ªç»“ç‚¹çš„å€¼éƒ½å¤§äºæˆ–ç­‰äºå…¶å·¦å³å­©å­ç»“ç‚¹çš„å€¼ï¼Œç§°ä¸ºå¤§é¡¶å †ï¼›æˆ–è€…æ¯ä¸ªç»“ç‚¹çš„å€¼éƒ½å°äºæˆ–ç­‰äºå…¶å·¦å³å­©å­ç»“ç‚¹çš„å€¼ï¼Œç§°ä¸ºå°é¡¶å †ã€‚å¦‚ä¸‹å›¾ï¼š å †æ’åºçš„æ€æƒ³ï¼šé¦–å…ˆå…ˆå°†ç»™å‡ºçš„åºåˆ—è¿›è¡Œä¸€ä¸ªè°ƒæ•´ï¼Œè°ƒæ•´æˆä¸€ä¸ªå¤§é¡¶å †æˆ–è€…ä¸€ä¸ªå°é¡¶å †ï¼Œè°ƒæ•´ä¹‹åï¼Œå†æŠŠæ ˆé¡¶çš„å…ƒç´ ä¸æœ€åä¸€ä¸ªå…ƒç´ è¿›è¡Œäº¤æ¢ï¼Œäº¤æ¢å®Œæˆä¹‹ååœ¨è¿›è¡Œè°ƒæ•´ï¼Œæœ€åå®Œæˆå †æ’åºã€‚ å †æ’åºæ­¥éª¤: æ„é€ å¤§é¡¶å †æˆ–è€…å°é¡¶å †ï¼Œé€šè¿‡è°ƒæ•´çš„æ–¹å¼ æœ€åˆæ¨¡æ · ä»æœ€åä¸€ä¸ªéå¶å­èŠ‚ç‚¹å¼€å§‹ï¼Œä»å·¦åˆ°å³ï¼Œä»ä¸Šåˆ°ä¸‹è¿›è¡Œè°ƒæ•´ æ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œå·¦å­©å­ï¼Œå³å­©å­ï¼Œä¸­çš„æœ€å¤§çš„ä¸€ä¸ªï¼Œä½¿å…¶æ”¾åœ¨æ ¹èŠ‚ç‚¹çš„ä½ç½®ã€‚ ç»§ç»­å‘ä¸Šé¢è°ƒæ•´ï¼Œä¸€æ­¥ä¸€æ­¥çš„æ›´æ›¿åˆ°ä¸‹é¢ ä»£ç å¦‚ä¸‹ï¼š123456789101112131415161718void adjust(int *a,int root,int len)&#123; int temp = a[root]; //å †æ’åºè¿™é‡Œå¦‚æœæ˜¯æ•°ç»„æ˜¯ä»0å¼€å§‹è®¡æ•°çš„è¯ è¿™é‡Œå¿…é¡»åŠ ä¸Šä¸€ä¸ª1 //ä½†æ˜¯å¦‚æœæ˜¯ä»0å¼€å§‹è®¡æ•°çš„è¯ï¼Œé‚£ä¹ˆè¿™é‡Œå°±è¿™æ ·å†™ int child = 2 * root; while (child &lt; len) &#123; if (child + 1 &lt; len &amp;&amp; a[child] &lt; a[child + 1]) child ++; if (temp &gt;= a[child]) break; a[root] = a[child]; root = child; child = 2 * child; &#125; a[root] = temp;&#125; å°†æ ˆé¡¶å…ƒç´ ä¸æœ€åä¸€ä¸ªå…ƒç´ è¿›è¡Œäº¤æ¢ï¼Œä½¿æœ«å°¾å…ƒç´ æœ€å¤§ï¼Œç„¶åå†æ¥æ…¢æ…¢è°ƒæ•´ã€‚ ä»¥ä¸‹çš„å››å¼ å›¾å°±æ˜¯äº¤æ¢å…ƒç´ ï¼Œå¹¶ä¸”æ¯äº¤æ¢ä¸€æ¬¡éƒ½ä¼šè°ƒæ•´å…ƒç´ ä¸€æ¬¡ ä»£ç å¦‚ä¸‹12345678910111213void heap_sort(int *a)&#123; //æ³¨æ„è¿™é‡Œå¿…é¡»ä»åé¢å¼€å§‹å¾€å‰é¢é€’å½’çš„æ„æ€å°±åœ¨äºä¾¿äºæ”¹å˜ä¸Šé¢ä¹‹åå¯ä»¥æœ‰æ•ˆçš„æ¨è‡³ä¸‹é¢ï¼Œç›¸å½“äºä¸€ä¸ªå°å‹é€’å½’ for (int i = maxn / 2;i &gt;= 0;i--) adjust(a,i,maxn); for (int i = maxn - 1;i &gt; 0;i--)&#123; swap (a[0],a[i]); //è¿™é‡Œéœ€ä¸éœ€è¦å‡1 æ˜¯æ ¹æ®ä¸Šé¢çš„adjusté‡Œé¢å¯¹äºä¸Šé™å€¼çš„å¤„ç† å¦‚æœæ˜¯å¤§äºç­‰äºå°±éœ€è¦å‡å»1 å¦‚æœä»…ä»…åªæ˜¯å°äºï¼Œé‚£ä¹ˆå°±ä¸éœ€è¦å‡å»1 adjust(a,0,i); &#125; print (a);&#125; æ’å…¥æ’åºç®—æ³•æ€æƒ³ï¼š ä»åé¢å¾€å‰é¢é€’è¿›ï¼Œå°†æ¯ä¸€ä¸ªæ ‘ç›´æ¥æ’å…¥åˆ°å‰é¢å·²ç»æ’å¥½åºçš„åºåˆ—é‡Œé¢å»ã€‚(åé¢å†è¯¦ç»†é˜æ˜) 123456789101112131415161718void charu(int *p)&#123; for (int i=1;i!=maxn;i++) &#123; int temp = *(p+i); int j = i; while (j&gt;0 &amp;&amp; temp &lt; *(p+j-1) ) &#123; *(p+j) = *(p+j-1); j--; &#125; if (i != j) &#123; *(p+j) = temp; &#125; &#125; print(p);&#125; å¸Œå°”æ’åº å…¶å®å¸Œå°”æ’åºä¹Ÿå°±æ˜¯åŸºäºæ’å…¥æ’åºçš„ä¼˜åŒ–ç‰ˆæœ¬ï¼Œè€Œæ’å…¥æ’åºåˆ™å¯ä»¥çœ‹åšæ˜¯å¢å€¼ä¸º1çš„å¸Œå°”æ’åº ç®—æ³•æ€æƒ³å¸Œå°”æ’åºæ˜¯æŠŠè®°å½•æŒ‰ä¸‹æ ‡çš„ä¸€å®šå¢é‡åˆ†ç»„ï¼Œå¯¹æ¯ç»„ä½¿ç”¨ç›´æ¥æ’å…¥æ’åºç®—æ³•æ’åºï¼›éšç€å¢é‡é€æ¸å‡å°‘ï¼Œæ¯ç»„åŒ…å«çš„å…³é”®è¯è¶Šæ¥è¶Šå¤šï¼Œå½“å¢é‡å‡è‡³1æ—¶ï¼Œæ•´ä¸ªæ–‡ä»¶æ°è¢«åˆ†æˆä¸€ç»„ï¼Œç®—æ³•ä¾¿ç»ˆæ­¢ å¯ä»¥è§‚çœ‹ä¸‹é¢å›¾ç¤ºï¼š ç®—æ³•æ­¥éª¤ï¼šé¦–å…ˆæ‰¾å‡ºæ¯ä¸€ä¸ªgapå€¼ï¼ˆå¢å€¼ï¼‰ï¼Œç„¶åæ ¹æ®å¢å€¼è¿›è¡Œç›¸é™¤ï¼Œæ‰¾åˆ°æ¯ä¸€ä¸ªé—´éš”ä½ç½®çš„å…ƒç´ ï¼Œæ¥æ¯”è¾ƒå¤§å°ç„¶åæ’åºï¼Œè€Œgapå€¼æ‰€é€ æˆçš„é—´éš”ä¼šè¶Šæ¥è¶Šå°ï¼Œç›´åˆ°æœ€åå¢å€¼ä¸ºä¸€ï¼Œæˆä¸ºæœ€åçš„æ’å…¥æ’åºã€‚ ä¸€èˆ¬gapå€¼ä¸º2ï¼Œå³ç”¨2å»æ•´é™¤ï¼Œä½†æ˜¯æœ‰çš„ç®—æ³•è¡¨ç¤ºåŒæ ·ä¹Ÿå¯ä»¥ç”¨åˆ°3 ä»£ç å¦‚ä¸‹ï¼š12345678910111213141516171819202122void xier(int *a)&#123; for (int gap = maxn/2;gap&gt;0;gap=gap/2) &#123; //ä»åé¢å¾€å‰é¢è¿›è¡Œé€’å¢ï¼Œè·å–gapçš„å€¼ï¼Œç„¶åä¾æ¬¡é™¤ä»¥2. for (int i=gap;i&lt;maxn;i++) &#123; //ä¸‹é¢å°±ç±»ä¼¼äºæ’å…¥æ’åºäº†ï¼Œåªä¸è¿‡å¢å€¼è¦ä»1å˜æˆgapã€‚ int temp = a[i]; int j = i; //è¿™ä¸ªåœ°æ–¹éœ€è¦æ³¨æ„çš„æ˜¯å¯¹äºæ’å…¥æ’åº æœ€åä¸€ä¸ªå€¼æ˜¯éœ€è¦åˆ°j&gt;=1ï¼Œè€Œè¿™é‡Œè¦åˆ°gapï¼Œæ³¨æ„æ¸…æ¥šèŒƒå›´ã€‚ while (j&gt;gap-1 &amp;&amp; temp &lt; *(a+j-gap)) &#123; *(a+j) = *(a+j-gap); j -= gap; &#125; //ä¸Šä¸€æ­¥æ¯ä¸€ä¸ªéƒ½ä¼¦æ¢è¿‡åï¼Œå°†æœ€åˆè¿™é‡Œçš„å€¼æ¢åˆ°ç›¸åº”çš„ä½ç½®ä¸Šé¢ *(a+j) = temp; &#125; &#125; print(a);&#125; å½’å¹¶æ’åº å½’å¹¶æ’åºæ˜¯åˆ©ç”¨å½’å¹¶çš„æ€æƒ³å®ç°çš„æ’åºæ–¹æ³•ï¼Œè¯¥ç®—æ³•é‡‡ç”¨ç»å…¸çš„åˆ†æ²»ç­–ç•¥ï¼ˆåˆ†æ²»æ³•å°†é—®é¢˜åˆ†æˆä¸€äº›å°çš„é—®é¢˜ç„¶åé€’å½’æ±‚è§£ï¼Œè€Œæ²»çš„é˜¶æ®µåˆ™å°†åˆ†çš„é˜¶æ®µå¾—åˆ°çš„å„ç­”æ¡ˆâ€ä¿®è¡¥â€åœ¨ä¸€èµ·ï¼Œå³åˆ†è€Œæ²»ä¹‹)ã€‚ ç®—æ³•æ€æƒ³:å…¶å®æœ‰ç‚¹åƒå®Œå…¨äºŒå‰æ ‘çš„ç»“æ„ï¼Œä½†æ˜¯åˆæœ‰å¾ˆå¤§çš„ä¸åŒ,ä¸»è¦å°±æ˜¯å€ŸåŠ©å¦å¤–ä¸€ä¸ªåŒæ ·é•¿çš„æ•°ç»„æ¥å­˜å‚¨åˆå¹¶ä¹‹åçš„ç»“æœï¼Œåˆå¹¶çš„æ—¶å€™å¯ä»¥ä½¿ç”¨é€’å½’æˆ–è€…ä½¿ç”¨æ ˆæ¥å†³å®šåˆå¹¶éƒ¨ä½ã€‚ç„¶ååˆå¹¶çš„è¿‡ç¨‹ä¸­åˆ†æˆæ— æ•°ä¸ªå°éƒ¨åˆ†ï¼Œç„¶åä¸€ä¸€å¾€æ–°çš„æ•°ç»„ä¸Šé¢æ·»åŠ ï¼Œæœ€åæ‹·è´åˆ°åŸæ¥çš„æ•°ç»„ä¸Šé¢ã€‚ ç®—æ³•æ­¥éª¤ï¼š å†³å®šåˆå¹¶éƒ¨ä½ï¼Œè¿™é‡Œè´´å‡ºä¸¤ä¸ªï¼Œä¸€ä¸ªæ˜¯ç›´æ¥åˆ©ç”¨é€’å½’ï¼Œå¦ä¸€ä¸ªæ˜¯åˆ©ç”¨å¾ªç¯ï¼Œç”¨1ï¼Œ2ï¼Œ4ï¼Œ8â€¦ä¹˜æ•°æ‰©å¤§è¿›è¡Œæ“ä½œã€‚ é€’å½’ç‰ˆæœ¬ï¼š 12345678910void gui_sort(int *a,int left,int right,int *temp)&#123; if (left &lt; right) &#123; int mid = (left + right) / 2; gui_sort(a,left,mid,temp); gui_sort(a,mid+1,right,temp); merge(a,left,mid,right,temp); &#125;&#125; éé€’å½’ç‰ˆæœ¬ï¼š 12345678910111213141516171819202122void fei_gui_sort(int *a,int *temp)&#123; int size=1,low,mid,high; while(size&lt;=maxn-1) &#123; low=0; //è¿™ä¸ªæ­¥éª¤å°±ç›¸å½“äºä¸Šé¢é€’å½’å†…éƒ¨è¿›è¡Œçš„æ­¥éª¤äº†ï¼Œä»1åˆ°2åˆ°4åˆ°8åˆ°16ï¼Œä¾æ¬¡è¿›è¡Œã€‚ //ä½†æ˜¯è¿™ç§éé€’å½’çš„ç‰ˆæœ¬å¯ä»¥å¸¦æ¥èŠ‚çœå¾ˆå¤šç”±æ ˆå¸¦æ¥çš„é€’å½’å¼€é”€ã€‚ while(low+size&lt;=maxn-1) &#123; mid=low+size-1; high=mid+size; if(high&gt;maxn-1) high=maxn-1; merge(a,low,mid,high,temp); low=high+1; &#125; //è¿™é‡Œä¹˜ä»¥2ã€‚ size*=2; &#125;&#125; ç„¶åå°±æ˜¯åˆå¹¶æ“ä½œäº†ï¼Œè®¾ç½®å‡ ä¸ªæŒ‡é’ˆèŠ‚ç‚¹ï¼Œç„¶åä¾æ¬¡æ¯”è¾ƒå¤§å°ï¼ŒæŠŠå°çš„é‚£ä¸ªå…ˆæ”¾å…¥æ’åºä¸­ã€‚ 12345678910111213141516171819202122232425void merge(int *a,int left,int mid,int right,int *temp)&#123; int i =left; int j = mid +1; int t = 0; //å·¦è¾¹ä¸å³è¾¹å¼€å§‹è¿›è¡Œæ¯”è¾ƒ while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; if (a[i] &lt; a[j]) temp[t++] = a[i++]; else temp[t++] = a[j++]; &#125; //å·¦è¾¹å‰©ä¸‹çš„ while (i &lt;= mid) temp[t++] = a[i++]; //å³è¾¹å‰©ä¸‹çš„ while (j &lt;= right) temp[t++] = a[j++]; t = 0; //æ‹·è´åˆ°åŸæ•°ç»„ä¸­å» while (left &lt;= right) a[left++] = temp[t++];&#125; å…¨éƒ¨ä»£ç (å¯ç›´æ¥è¿è¡Œ)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330/************************************************************************* &gt; File Name: æ’åºä»£ç .cpp &gt; Author: wangshuxiao &gt; Mail: wsx1128@outlook.com &gt; Created Time: Mon 17 Dec 11:23:48 2018 ************************************************************************/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;const int maxn = 20;//è¿™é‡Œä½¿ç”¨STLç®—æ³•ä¸­çš„shuffleæ¥ä½¿æœ€åˆçš„æ’åºå…¨éƒ¨éšæœºvoid print(int *p)&#123; for (int i = 0; i != 20; i++) &#123; cout &lt;&lt; *p++ &lt;&lt;" "; &#125; cout &lt;&lt; endl &lt;&lt; endl;&#125;void random(int *p)&#123; random_shuffle(p,p+maxn); print(p);&#125;void maopao(int *p)&#123; for (int i=0;i!=maxn;i++) &#123; for (int j=i+1;j!=maxn;j++) &#123; if (*(p+i)&gt;*(p+j))&#123; int temp = *(p+i); *(p+i) = *(p+j); *(p+j) = temp; &#125; &#125; &#125; print(p);&#125;void xuanze(int *p)&#123; for (int i=0;i!=maxn;i++) &#123; int Min = i; for (int j = i+1; j!=maxn ;j++) &#123; if (*(p+Min) &gt; *(p+j)) Min = j; &#125; if (Min != i) &#123; int temp = *(p + Min); *(p + Min) = * (p + i); *(p + i) = temp; &#125; &#125; print(p);&#125;void charu(int *p)&#123; for (int i=1;i!=maxn;i++) &#123; int temp = *(p+i); int j = i; while (j&gt;0 &amp;&amp; temp &lt; *(p+j-1) ) &#123; *(p+j) = *(p+j-1); j--; &#125; if (i != j) &#123; *(p+j) = temp; &#125; &#125; print(p);&#125;void xier(int *a)&#123; for (int gap = maxn/2;gap&gt;0;gap=gap/2) &#123; for (int i=gap;i&lt;maxn;i++) &#123; int temp = a[i]; int j = i; while (j&gt;gap-1 &amp;&amp; temp &lt; *(a+j-gap)) &#123; *(a+j) = *(a+j-gap); j -= gap; &#125; *(a+j) = temp; &#125; &#125; print(a);&#125;void merge(int *a,int left,int mid,int right,int *temp)&#123; int i =left; int j = mid +1; int t = 0; while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; if (a[i] &lt; a[j]) temp[t++] = a[i++]; else temp[t++] = a[j++]; &#125; while (i &lt;= mid) temp[t++] = a[i++]; while (j &lt;= right) temp[t++] = a[j++]; t = 0; while (left &lt;= right) a[left++] = temp[t++];&#125;void gui_sort(int *a,int left,int right,int *temp)&#123; if (left &lt; right) &#123; int mid = (left + right) / 2; gui_sort(a,left,mid,temp); gui_sort(a,mid+1,right,temp); merge(a,left,mid,right,temp); &#125;&#125;void guibing(int *a)&#123; int *temp = new int [maxn]; gui_sort(a,0,maxn-1,temp); print(a); delete [] temp; return ;&#125;void fei_gui_sort(int *a,int *temp)&#123; int size=1,low,mid,high; while(size&lt;=maxn-1) &#123; low=0; while(low+size&lt;=maxn-1) &#123; mid=low+size-1; high=mid+size; if(high&gt;maxn-1) high=maxn-1; merge(a,low,mid,high,temp); low=high+1; &#125; size*=2; &#125;&#125;void fei_guibing(int *a)&#123; int *temp = new int [maxn]; fei_gui_sort(a,temp); print(a); if (temp != NULL) delete [] temp;&#125;int get_mid(int *a,int left,int right)&#123; int mid = (left + right) / 2; if (a[left] &lt;= a[right]) &#123; if (a[mid] &lt; a[left]) return left; else if (a[mid] &gt; a[right]) return right; else return mid; &#125; else &#123; if (a[mid] &lt; a[right]) return right; else if (a[mid] &gt; a[left]) return left; else return mid; &#125;&#125;//å·¦å³æŒ‡é’ˆäº¤æ¢çš„åŠæ³•int part_sort1(int *a,int left,int right)&#123; int mid = get_mid(a,left,right); swap(a[mid],a[right]); int &amp;key = a[right]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; a[left] &lt;= key) ++left; while (left &lt; right &amp;&amp; a[right] &gt;= key) --right; swap (a[left],a[right]); &#125; swap(a[right],key); return right;&#125;//æŒ–å‘å¡«è¡¥æ³•int part_sort2(int *a,int left,int right)&#123; int mid = get_mid(a,left,right); swap (a[mid],a[right]); int key = a[right]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; a[left] &lt;= key) ++left; a[right] = a[left]; while (left &lt; right &amp;&amp; a[right] &gt;= key) --right; a[left] = a[right]; &#125; a[right] = key; return right;&#125;void quick_sort(int *a,int left,int right)&#123; if (left &lt; right) &#123; int index = part_sort1(a,left,right); quick_sort(a,left,index-1); quick_sort(a,index+1,right); &#125;&#125;void kuaisu(int *a)&#123; quick_sort(a,0,maxn-1); print(a);&#125;void adjust(int *a,int root,int len)&#123; int temp = a[root]; int child = 2 * root + 1; while (child &lt; len) &#123; if (child + 1 &lt; len &amp;&amp; a[child] &lt; a[child + 1]) child ++; if (temp &gt;= a[child]) break; a[root] = a[child]; root = child; child = 2 * child; &#125; a[root] = temp;&#125;void heap_sort(int *a)&#123; for (int i = maxn / 2;i &gt;= 0;i--) adjust(a,i,maxn); for (int i = maxn - 1;i &gt; 0;i--)&#123; swap (a[0],a[i]); adjust(a,0,i); &#125; print (a);&#125;int main()&#123; int a[20] = &#123;1,2,3,4,5,6,7,8,9,10,11, 12,13,14,15,16,17,18,19,20&#125;; cout &lt;&lt; "æœ€åˆçš„é¡ºåºä¸º" &lt;&lt; endl; print(a); //ä»¥ä¸Šä¸ºåˆå§‹åŒ–è¿‡åï¼Œå¹¶ä¸”è¿›è¡Œæ‰“ä¹±é¡ºåºçš„æ’åˆ—é¡ºåº //å†’æ³¡æ’åº cout &lt;&lt; "å†’æ³¡æ’åº" &lt;&lt; endl; random(a); maopao(a); //é€‰æ‹©æ’åº cout &lt;&lt; "é€‰æ‹©æ’åº" &lt;&lt; endl; random(a); xuanze(a); //æ’å…¥æ’åº cout &lt;&lt; "æ’å…¥æ’åº" &lt;&lt; endl; random(a); charu(a); //å¸Œå°”æ’åº cout &lt;&lt; "å¸Œå°”æ’åº" &lt;&lt; endl; random(a); xier(a); //å½’å¹¶æ’åº cout &lt;&lt; "é€’å½’ç‰ˆæœ¬å½’å¹¶æ’åº" &lt;&lt; endl; random(a); guibing(a); cout &lt;&lt; "éé€’å½’ç‰ˆæœ¬çš„å½’å¹¶æ’åº" &lt;&lt; endl; random (a); fei_guibing(a); //å¿«é€Ÿæ’åº cout &lt;&lt; "å¿«é€Ÿæ’åº" &lt;&lt; endl; random(a); kuaisu(a); //å †æ’åº cout &lt;&lt; "å †æ’åº" &lt;&lt; endl; random(a); heap_sort(a); return 0;&#125; æ–‡ä¸­å›¾ç‰‡è½¬è½½è‡ªå¤šä¸ªåšå®¢ï¼Œè¿™é‡Œä¸è´´å‡ºæ¥æºäº†ï¼Œå¦‚è‹¥ä¾µæƒï¼Œå³åˆ»åˆ é™¤ï¼Œè°¢è°¢ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>æ’åº</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[äºŒå‰æ ‘æ€»ç»“]]></title>
    <url>%2F2018%2F12%2F04%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©èŠ±æ—¶é—´æ•´ç†ä¸€ä¸‹äºŒå‰æ ‘çš„ä¸€åˆ‡å†…å®¹ä¸‹é¢çš„éƒ¨åˆ†åŒ…æ‹¬ï¼š äºŒå‰æ ‘çš„åˆ›å»º äºŒå‰æ ‘çš„éå† äºŒå‰æ ‘çš„å±‚åºéå† äºŒå‰æ ‘çš„æ·±åº¦éå† äºŒå‰æ ‘é€’å½’å…ˆåºéå† äºŒå‰æ ‘é€’å½’ä¸­åºéå† äºŒå‰æ ‘é€’å½’ååºéå† äºŒå‰æ ‘éé€’å½’å…ˆåºéå† äºŒå‰æ ‘éé€’å½’ä¸­åºéå† äºŒå‰æ ‘éé€’å½’ååºéå† çº¿ç´¢æ ‘ ä¸‹é¢ç›´æ¥è´´ä»£ç ï¼ˆåœ¨ä»£ç å†…éƒ¨è¿›è¡Œæ³¨é‡Šï¼‰ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273/************************************************************************* &gt; File Name: tree.cpp &gt; Author: wangshuxiao &gt; Mail: wsx1128@outlook.com &gt; Created Time: äºŒ 11/20 18:51:16 2018 ************************************************************************/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;memory&gt;#include &lt;string&gt;using namespace std;class Node&#123;public: Node():left(0),right(0)&#123;&#125;; Node(char e): value(e)&#123;left = 0;right = 0;&#125;;public: char value; Node* left; Node* right;&#125;;class Bi_tree&#123;public: Bi_tree()=default; ~Bi_tree() &#123; clear(); &#125;//ç”±äºå»ºæ ‘ä¸ææ„éƒ½è¦ä½¿ç”¨åˆ°é€’å½’ï¼Œæ‰€ä»¥å¯¹äºç±»è€Œè¨€ï¼Œå¿…é¡»ä½¿ç”¨å¦å¤–ä¸€ä¸ªå‡½æ•°æ¥è¿›è¡Œé€’å½’ï¼Œæ‰ä¸ä¼šå½±å“ç§æœ‰æˆå‘˜ void bulid (); Node* _bulid (Node *); bool isEmpty () const &#123; return root == 0; &#125;; void breath_order() void preorder(Node *t); void inorder(Node *t); void postorder(Node *t); void iter_preorder(); void iter_inorder(); void iter_postorder(); Node * get_root() &#123;return root;&#125;private: void clear(); void clear(Node *); void print(Node *p); Node *root; &#125;;void Bi_tree::clear()&#123; clear(root); root = 0;&#125;void Bi_tree::clear(Node *n)&#123; if (n) &#123; if (n-&gt;left) clear(n-&gt;left); if (n-&gt;right) clear(n-&gt;right); delete n; &#125;&#125;void Bi_tree::print(Node *p)&#123; cout &lt;&lt; p-&gt;value &lt;&lt; " ";&#125;void Bi_tree::bulid()&#123; root = _bulid(root);&#125;//å¦å¤–è¿™é‡Œè¿˜æ˜¯éœ€è¦æ³¨æ„åˆ°çš„æ˜¯ï¼Œç”±äºç±»çš„é€»è¾‘ä¸Cè¯­è¨€çš„ä¸å¤ªç›¸åŒï¼Œæ‰€ä»¥å†å¾ªç¯çš„æ—¶å€™ä¸èƒ½ç›´æ¥è¿”å›ä¸ºç©ºï¼Œæ‰€ä»¥å¿…é¡»è¦è¿”å›ä¸€ä¸ª`Node*`ï¼Œè¿™æ ·æ‰å¯ä»¥æŠŠä¹‹å‰çš„ç»™è”ç³»åœ¨ä¸€èµ·ã€‚//æˆ–è€…è¿˜æœ‰ä¸€ç§åŠæ³•æ˜¯ï¼Œä½¿ç”¨æŒ‡é’ˆçš„å¼•ç”¨ï¼Œè¿™æ ·ä¹Ÿå°±æ˜¯æ‰€è°“çš„äºŒçº§æŒ‡é’ˆï¼Œæ‰èƒ½é€ æˆæ•ˆæœã€‚Node * Bi_tree::_bulid(Node *t)&#123; //creat the tree by preorder char ch; cin &gt;&gt; ch; if (ch =='#') t = nullptr ; else&#123; t = new Node; t-&gt;value = ch; t-&gt;left = _bulid(t-&gt;left); t-&gt;right = _bulid(t-&gt;right); &#125; return t;&#125;// å±‚åºéå†void Bi_tree::breath_order()&#123; queue&lt;Node*&gt; q_tree; Node *t = root; if ( t != 0 ) &#123; q_tree.push(t); while (!q_tree.empty()) &#123; t = q_tree.front(); q_tree.pop(); print(t); if (t-&gt;left != 0) q_tree.push(t-&gt;left); if (t-&gt;right != 0) q_tree.push(t-&gt;right); &#125; &#125;&#125;//é€’å½’ å…ˆåºéå†void Bi_tree::preorder(Node *t)&#123; if (t) &#123; print(t); preorder(t-&gt;left); preorder(t-&gt;right); &#125; return ;&#125;//é€’å½’ ä¸­åºéå†void Bi_tree::inorder(Node *t)&#123; if (t) &#123; inorder(t-&gt;left); print(t); inorder(t-&gt;right); &#125; return ;&#125;//é€’å½’ ååºéå†void Bi_tree::postorder(Node *t)&#123; if (t) &#123; postorder(t-&gt;left); postorder(t-&gt;right); print(t); &#125; return ;&#125;//éé€’å½’ å…ˆåºéå† ä½¿ç”¨æ ˆvoid Bi_tree::iter_preorder()&#123; stack&lt;Node*&gt; s_tree; Node *t = root; if (t != 0) &#123; s_tree.push(t); while (!s_tree.empty()) &#123; t = s_tree.top(); s_tree.pop(); print(t); if (t-&gt;right != 0) &#123; s_tree.push(t-&gt;right); &#125; if (t-&gt;left != 0) &#123; s_tree.push(t-&gt;left); &#125; &#125; &#125; return ;&#125;//éé€’å½’ ä¸­åºéå† ä½¿ç”¨æ ˆvoid Bi_tree::iter_postorder()&#123; stack&lt;Node*&gt; s_tree; Node *p = root , *q = root; while (p != 0) &#123; for ( ;p-&gt;left != 0;p = p-&gt;left) s_tree.push(p); while (p-&gt;right == 0 || p-&gt;right == q) &#123; print(p); q = p; if (s_tree.empty()) return ; p = s_tree.top(); s_tree.pop(); &#125; s_tree.push(p); p = p-&gt;right; &#125;&#125;// éé€’å½’ ååºéå† ä½¿ç”¨æ ˆvoid Bi_tree::iter_inorder()&#123; stack &lt;Node*&gt; s_tree; Node *p = root; while (p != 0) &#123; while (p != 0) &#123; if (p-&gt;right) s_tree.push(p-&gt;right); s_tree.push(p); p = p-&gt;left; &#125; p = s_tree.top(); s_tree.pop(); while (!s_tree.empty() &amp;&amp; p-&gt;right == 0) &#123; print (p); p = s_tree.top(); s_tree.pop(); &#125; print(p); if (!s_tree.empty()) &#123; p = s_tree.top(); s_tree.pop(); &#125; else p = 0; &#125; return ;&#125;int main()&#123; Bi_tree b; b.bulid(); if (b.isEmpty()) cout &lt;&lt; "ç©ºçš„" &lt;&lt; endl; cout &lt;&lt; "ä¸‹é¢æ˜¯é€’å½’å½¢å¼çš„éå†æ–¹å¼"&lt;&lt;endl; cout &lt;&lt; "é€’å½’å½¢å¼å…ˆåºéå†" &lt;&lt; endl; b.preorder(b.get_root()); cout &lt;&lt;endl; cout &lt;&lt; "é€’å½’å½¢å¼åç»­éå†" &lt;&lt;endl; b.postorder(b.get_root()); cout &lt;&lt; endl; cout &lt;&lt; " éé€’å½’å½¢å¼çš„ä¸­åºéå†"&lt;&lt; endl; b.iter_inorder(); cout &lt;&lt; endl; cout &lt;&lt; " éé€’å½’å½¢å¼çš„ååºéå†"&lt;&lt; endl; b.iter_postorder(); cout &lt;&lt; endl; return 0;&#125; çº¿ç´¢æ ‘çº¿ç´¢äºŒå‰æ ‘åŸç†é€šè¿‡è€ƒå¯Ÿå„ç§äºŒå‰é“¾è¡¨ï¼Œä¸ç®¡å„¿å‰æ ‘çš„å½¢æ€å¦‚ä½•ï¼Œç©ºé“¾åŸŸçš„ä¸ªæ•°æ€»æ˜¯å¤šè¿‡éç©ºé“¾åŸŸçš„ä¸ªæ•°ã€‚å‡†ç¡®çš„è¯´ï¼Œnå„ç»“ç‚¹çš„äºŒå‰é“¾è¡¨å…±æœ‰2nä¸ªé“¾åŸŸï¼Œéç©ºé“¾åŸŸä¸ºn-1ä¸ªï¼Œä½†å…¶ä¸­çš„ç©ºé“¾åŸŸå´æœ‰n+1ä¸ªã€‚å› æ­¤ï¼Œæå‡ºäº†ä¸€ç§æ–¹æ³•ï¼Œåˆ©ç”¨åŸæ¥çš„ç©ºé“¾åŸŸå­˜æ”¾æŒ‡é’ˆï¼ŒæŒ‡å‘æ ‘ä¸­å…¶ä»–ç»“ç‚¹ã€‚è¿™ç§æŒ‡é’ˆç§°ä¸ºçº¿ç´¢ã€‚ è®°ptræŒ‡å‘äºŒå‰é“¾è¡¨ä¸­çš„ä¸€ä¸ªç»“ç‚¹ï¼Œä»¥ä¸‹æ˜¯å»ºç«‹çº¿ç´¢çš„è§„åˆ™ï¼š å¦‚æœptr-&gt;lchildä¸ºç©ºï¼Œåˆ™å­˜æ”¾æŒ‡å‘ä¸­åºéå†åºåˆ—ä¸­è¯¥ç»“ç‚¹çš„å‰é©±ç»“ç‚¹ã€‚è¿™ä¸ªç»“ç‚¹ç§°ä¸ºptrçš„ä¸­åºå‰é©±ï¼› å¦‚æœptr-&gt;rchildä¸ºç©ºï¼Œåˆ™å­˜æ”¾æŒ‡å‘ä¸­åºéå†åºåˆ—ä¸­è¯¥ç»“ç‚¹çš„åç»§ç»“ç‚¹ã€‚è¿™ä¸ªç»“ç‚¹ç§°ä¸ºptrçš„ä¸­åºåç»§ï¼› æ˜¾ç„¶ï¼Œåœ¨å†³å®šlchildæ˜¯æŒ‡å‘å·¦å­©å­è¿˜æ˜¯å‰é©±ï¼Œrchildæ˜¯æŒ‡å‘å³å­©å­è¿˜æ˜¯åç»§ï¼Œéœ€è¦ä¸€ä¸ªåŒºåˆ†æ ‡å¿—çš„ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åœ¨æ¯ä¸ªç»“ç‚¹å†å¢è®¾ä¸¤ä¸ªæ ‡å¿—åŸŸltagå’Œrtagï¼Œæ³¨æ„ltagå’Œrtagåªæ˜¯åŒºåˆ†0æˆ–1æ•°å­—çš„å¸ƒå°”å‹å˜é‡ï¼Œå…¶å ç”¨å†…å­˜ç©ºé—´è¦å°äºåƒlchildå’Œrchildçš„æŒ‡é’ˆå˜é‡ã€‚ å…¶ä¸­ï¼š ltagä¸º0æ—¶æŒ‡å‘è¯¥ç»“ç‚¹çš„å·¦å­©å­ï¼Œä¸º1æ—¶æŒ‡å‘è¯¥ç»“ç‚¹çš„å‰é©±ï¼› rtagä¸º0æ—¶æŒ‡å‘è¯¥ç»“ç‚¹çš„å³å­©å­ï¼Œä¸º1æ—¶æŒ‡å‘è¯¥ç»“ç‚¹çš„åç»§ï¼› å› æ­¤å¯¹äºä¸Šå›¾çš„äºŒå‰é“¾è¡¨å›¾å¯ä»¥ä¿®æ”¹ä¸ºä¸‹å›¾çš„å…»å­ã€‚ çº¿ç´¢äºŒå‰æ ‘çš„ä»£ç å®ç°å¯¹æ¥ä¸‹æ¥çš„ä¾‹å­ä¸­ï¼Œçº¿ç´¢äºŒå‰æ ‘çš„ä¸­åºéå†ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>äºŒå‰æ ‘</tag>
        <tag>éå†</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æµ·è¾¹çš„å¡å¤«å¡çš„çŸ­ä¹¦è¯„]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B5%B7%E8%BE%B9%E7%9A%84%E5%8D%A1%E5%A4%AB%E5%8D%A1%E7%9A%84%E7%9F%AD%E4%B9%A6%E8%AF%84%2F</url>
    <content type="text"><![CDATA[ã€Šæµ·è¾¹çš„å¡å¤«å¡ã€‹è¿™æœ¬ä¹¦ä»¥ä¸€ä¸ªæ‚²å‰§æˆå‰§ä¸ºè“æœ¬ï¼Œè¿›è¡ŒåŒçº¿æ„é€ ï¼Œç›¸äº’äº¤ç»‡ï¼Œç›¸äº’è¿åˆï¼Œä»è€Œä½¿ä¸€ä¸ªåäº”å²çš„å°‘å¹´çš„æˆé•¿å†ç¨‹é€æ¸å®Œå–„ã€‚è™½ç„¶å–è‡ªäºä¿„ç‹„æµ¦æ–¯ç‹ä¸­æ€çˆ¶å¥¸æ¯çš„æ¡¥æ®µï¼Œä½†æ˜¯ç»“å±€å¯¼å‘ä»¥åŠä¼ è¾¾å‡ºæ¥çš„æ„ä¹‰ç»ä¸ä¸€æ ·ï¼Œå‰è€…æ˜¯æ‚²å‰§å¼çš„è‡ªæˆ‘æ¯ç­ä»¥åŠæ— å¸¸å‘½è¿çš„æ…¨å¹ï¼Œè€Œåè€…åˆ™æ˜¯å½»å½»åº•åº•çš„è‡ªæˆ‘æ•‘èµå¼çš„æˆé•¿ã€‚ä¸çŸ¥æœ‰å¤šå°‘äººæ›¾åœ¨é‚£é‡Œæµè¡€ï¼Œä½ æœ¬èº«ä¹Ÿä¼šæµè¡€ï¼Œæ¸©æš–è€Œåˆé²œçº¢çš„è¡€ã€‚ä½ çš„åŒæ‰‹å°†ä¼šæ¥ä½å®ƒä»¬ï¼Œé‚£æ—¢æ˜¯ä½ çš„è¡€ï¼Œåˆæ˜¯åˆ«äººçš„è¡€ï¼Œè€Œæ²™å°˜æš´åƒæ——æ¯é¼“çš„æ—¶å€™ï¼Œä½ ææ€•è¿˜ä¸èƒ½å®Œå…¨æ˜ç™½è‡ªå·±æ˜¯å¦‚åŒä»ä¸­ç©¿è¿‡è€Œå¾—ä»¥é€ƒç”Ÿçš„ã€‚ç”šè‡³å®ƒæ˜¯å¦è¿‡å»éƒ½æ— ä»åˆ¤æ–­ï¼Œä¸è¿‡æœ‰ä¸€ç‚¹æ˜¯ä½ ä¸€å®šæ˜¯éå¸¸æ¸…æ¥šçš„ï¼Œä»æ²™å°˜æš´ä¸­é€ƒç”Ÿçš„ä¸å†æ˜¯è·¨å…¥æ²™å°˜æš´çš„ä½ ã€‚æ¯ä¸€ä¸ªäººçš„æˆé•¿éƒ½æ˜¯è‡ªç”±çš„ï¼Œä½†åŒæ—¶å´ä¹Ÿæ˜¯ä¸å¯é¢„æµ‹çš„ã€‚æ‘ä¸Šå›ç”¨ä¸€ä¸ªåäº”å²å°‘å¹´çš„æˆé•¿å²å‘Šè¯‰æˆ‘ä»¬åœ¨å‘½è¿çš„å¦¥åä¸æŠ—äº‰ä¹‹é—´è¿˜å­˜åœ¨æ•‘èµå’Œæˆé•¿ã€‚ä½†æ˜¯å¦‚æœä»…ä»…å†™å‡ºå°‘å¹´çš„æˆé•¿å²çš„è¯åªèƒ½ç®—ä¸€èˆ¬å°è¯´ã€‚ä½†æ˜¯æ‘ä¸Šå›è‚¯å®šä¸ä¼šè¿™æ ·è½å…¥ä¿—å¥—ï¼Œäºæ˜¯ä»–å·§å¦™åˆ©ç”¨ç¬¬äºŒæ¡æ•…äº‹çº¿ï¼Œä¸€ä¸ªåäº”å²ä¹‹åä¸§å¤±ä¸€åˆ‡çš„è€çˆ·çˆ·çš„å¥‡é‡ï¼Œè¿™ä½è€çˆ·çˆ·æ‹¥æœ‰ç€è¯¸å¤šç¥å¥‡çš„èƒ½åŠ›ï¼Œä½†æ˜¯å°±æ˜¯æ— æ³•æ€è€ƒï¼Œè®°ä¸æ¸…æ¥šå‘ç”Ÿåœ¨è‡ªå·±èº«ä¸Šçš„ä¸€åˆ‡ï¼Œç”šè‡³æ˜¯ä¸æ•´ä¸ªä¸–ç•Œè„±è½¨ã€‚çœ‹ä¼¼ä¸ç¬¬ä¸€æ¡æ•…äº‹çº¿æ²¡æœ‰ä»»ä½•å…³è”ï¼Œå®åˆ™ä¸ä¸å…¥æ‰£ï¼Œä¸€ä¸ªåäº”å²ä¹‹åæ‹¥æœ‰æ— é™å¯èƒ½çš„äººç”Ÿç»å†å’Œä¸€ä¸ªåäº”å²ä¹‹åä¸€åˆ‡éƒ½æ˜¯ç©ºç™½çš„äººç”Ÿç»å†ç›¸å¯¹æ¯”ï¼Œæ›´åŠ æ·±äº†æœ¬æ–‡æˆé•¿ä¸æ•‘èµçš„ä¸»é¢˜ã€‚è¿™æœ¬ä¹¦å¦ä¸€ä¸ªå¼•äººæ³¨ç›®çš„åœ°æ–¹ä¹Ÿå°±æ˜¯ä½œè€…æ‘ä¸Šæ˜¥æ ‘å¯¹æˆé•¿ä¸­æœ€å¤§çš„æ•Œäººçš„å®šä¹‰ï¼šç¼ºä¹æƒ³è±¡åŠ›çš„ç‹­éš˜ï¼Œè‹›åˆ»ï¼Œè‡ªä»¥ä¸ºæ˜¯çš„å‘½é¢˜ï¼Œç©ºæ´çš„æœ¯è¯­ï¼Œè¢«ç¯¡å¤ºçš„ç†æƒ³ï¼ŒåƒµåŒ–çš„æ€æƒ³ä½“ç³»ï¼Œè¿™äº›æ‰æ˜¯æœ€å¯æ€•çš„ï¼Œä½†æ˜¯ä½•ä¸ºæ­£ç¡®ï¼Œä½•ä¸ºä¸æ­£ç¡®ï¼Œè¿™äº›éƒ½æ˜¯å€¼å¾—æ·±æ€çš„è¯é¢˜ï¼Œä½†æ˜¯æŸç§ä¸ªä½“çš„åˆ¤æ–­å¤±è¯¯ï¼Œåœ¨å¾ˆå¤šæƒ…å†µä¸‹äº‹åä¸æ˜¯ä¸å¯èƒ½æŒ½å›ï¼Œåªè¦æœ‰å‹‡æ°”ä¸»åŠ¨æ‰¿è®¤é”™è¯¯ï¼Œéƒ½æ˜¯å¯ä»¥è¡¥æ•‘ã€‚æ‘ä¸Šæ˜¥æ ‘è¿™æœ¬ä¹¦ä»¥ä¸€ä¸ªå…¨æ–°çš„è§†è§’è¯ é‡Šæˆ‘ä»¬åœ¨æˆé•¿ä¹‹è¡Œä¸Šå¿…å®šä¼šé‡åˆ°çš„å–„ä¸æ¶ï¼Œä»¥åŠä¸€æ­¥æ­¥èµ°å‘é¡½å¼ºçš„å¿ƒè·¯å†ç¨‹ï¼Œä¸è¦ç•æƒ§å‰æ–¹æœ‰æœªçŸ¥çš„é£æš´ï¼Œå› ä¸ºä½ æ˜¯ä¸–ç•Œä¸Šæœ€é¡½å¼ºçš„æ˜¯19å²çš„å°‘å¹´ã€‚]]></content>
      <tags>
        <tag>ä¹¦è¯„</tag>
        <tag>æ‘ä¸Šæ˜¥æ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä¸€é“STLçš„é¢˜è§£é¢˜ç›®ï¼Œéœ€è¦ä»¥åèŠ±æ—¶é—´ç†è§£é¢˜ç›®æ„æ€]]></title>
    <url>%2F2018%2F12%2F01%2F%E4%B8%80%E9%81%93STL%E7%9A%84%E9%A2%98%E8%A7%A3%E9%A2%98%E7%9B%AE%EF%BC%8C%E9%9C%80%E8%A6%81%E4%BB%A5%E5%90%8E%E8%8A%B1%E6%97%B6%E9%97%B4%E7%90%86%E8%A7%A3%E9%A2%98%E7%9B%AE%E6%84%8F%E6%80%9D%2F</url>
    <content type="text"><![CDATA[ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;//#include&lt;function&gt;#define ll long longusing namespace std;const int fort = 1314;ll a[6];//è¿™é“é¢˜ç›®å°±æ¢ä¸€ç§æ€è€ƒæ–¹å¼ï¼Œè®©åŸºæ•°åˆ†è´åŠ ä¸ŠåŠ æ•°ï¼Œè¿™æ ·ä¸€æ¥ï¼Œå°±ä¼šç®€åŒ–å¾ˆå¤šæ­¥éª¤int main()&#123; int t; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;a[0]&gt;&gt;a[1]&gt;&gt;a[2]; a[3] = 5; a[4] = 2; a[5] = 0; sort(a, a + 6, [](const ll &amp;a,const ll &amp;b)&#123;return a&gt;b;&#125;); priority_queue&lt;ll, vector&lt;ll&gt;, greater&lt;ll&gt; &gt; pq; set&lt;ll&gt;s; set&lt;ll&gt;ans; pq.push(1); s.insert(1); for(int i = 0;;i++)&#123; ll x = pq.top(); pq.pop(); if(i)&#123; for(int k = 3;k &lt; 6;k++)&#123; ans.insert(x - a[k]); if(ans.size()==fort) break; &#125; if(ans.size()==fort)&#123; /*int ttt = 1; for(set&lt;ll&gt;::iterator it = ans.begin();it!=ans.end();it++) cout&lt;&lt;ttt++&lt;&lt;' '&lt;&lt;*it&lt;&lt;endl;*/ auto it = ans.rbegin(); cout&lt;&lt;*it&lt;&lt;endl; break; &#125; &#125; for(int j = 0;j&lt;3;j++)&#123; ll x2=x*a[j]; if(!s.count(x2))&#123; s.insert(x2); pq.push(x2); &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡æ¬¾27ï¼šå°½é‡å°‘åšè½¬å‹åŠ¨ä½œ]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE27%EF%BC%9A%E5%B0%BD%E9%87%8F%E5%B0%91%E5%81%9A%E8%BD%AC%E5%9E%8B%E5%8A%A8%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[C++ è§„åˆ™çš„è®¾è®¡ç›®æ ‡ä¹‹ä¸€å°±æ˜¯ï¼Œä¿è¯â€œç±»å‹é”™è¯¯â€ ç»ä¸å¯èƒ½å‘ç”Ÿï¼Œä½†æ˜¯åœ¨ C++çš„æŸäº›ç‰¹æ®Šçš„æƒ…å½¢ä¸‹é¢ä¸å¾—ä¸å»ä½¿ç”¨è½¬å‹è¿™ä¸€ç‰¹æ€§ï¼Œè€Œ C è¯­è¨€çš„è½¬å‹è¯­å¥åˆ™ç±»ä¼¼äºä»¥ä¸‹ï¼š ç„¶è€Œ C++æä¾›å››ç§æ–°å¼çš„ç±»å‹è½¬æ¢ æ³¨æ„ åœ¨çœŸæ­£è¿›è¡Œç±»å‹è½¬æ¢çš„æ—¶å€™ï¼Œæˆ‘ä»¬ä¸èƒ½ä»…ä»…è®¤ä¸ºç¼–è¯‘å™¨åˆ°æœ€åä»…ä»…åªæ˜¯æ›´æ”¹ä¸€ä¸ªæ–‡ä»¶åå­—ï¼Œç¼–è¯‘å™¨æ”¹å˜çš„åº•å±‚çš„ç¼–ç ï¼Œæ¯”å¦‚ int è½¬å‹åˆ° double ä¹‹é—´åº•å±‚æè¿°æ˜¯ä¸ä¸€æ ·çš„ã€‚ å¦å¤– C++ä¸­çš„ä¸€ä¸ªç‰¹æ€§ä½¿å¾—å¤šé‡ç»§æ‰¿çš„æ—¶å€™ï¼Œä¸€ä¸ªå¯¹è±¡å«æœ‰å¤šä¸ªåœ°å€ã€‚ æ‰€ä»¥éœ€è¦æ³¨æ„çš„æ˜¯ä»¥ä¸‹å‡ ç‚¹ï¼Œå¦‚æœå¯ä»¥çš„è¯ï¼Œå°½é‡é¿å…è½¬å‹ï¼Œç‰¹åˆ«æ˜¯åœ¨æ³¨é‡ä»£ç ä¸­é¿å…dynamic_cast. å¦‚æœæœ‰è®¾è®¡éœ€è¦è½¬å‹åŠ¨ä½œçš„è¯ï¼Œå»è¯•è¯•æ— éœ€è½¬å‹çš„æ›¿ä»£è®¾è®¡ã€‚ å¦‚æœè½¬å‹æ˜¯å¿…è¦çš„ï¼Œé‚£ä¹ˆè¯•ç€å°†å…¶éšè—åœ¨æŸä¸ªå‡½æ•°èƒŒåã€‚å®¢æˆ·éšåå¯ä»¥è°ƒç”¨è¯¥å‡½æ•°ï¼Œè€Œä¸éœ€è¦è®²è½¬å‹æ”¾è¿›ä»–ä»¬è‡ªå·±çš„ä»£ç ä¸­ã€‚ å®å¯ä½¿ç”¨ C++æ–°å¼çš„è½¬å‹ï¼Œä¹Ÿä¸è¦ä½¿ç”¨æ—§å¼çš„è½¬å‹ï¼Œå‰è€…å¾ˆå®¹æ˜“è¯†åˆ«å‡ºæ¥ï¼Œè€Œä¸”ä¹Ÿæœ‰ç€ä¸å«åˆ†ä»¬åˆ«ç±»çš„èŒæŒã€‚]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä¸€é“è®¡ç®—æœºå‡ ä½•ç®—æ³•ç›¸å…³é¢˜ç›®]]></title>
    <url>%2F2018%2F12%2F01%2F%E4%B8%80%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%87%A0%E4%BD%95%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®ï¼š ä»£ç å¦‚ä¸‹ï¼š1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;using namespace std;double v,s,b;const double pi = acos(-1.0);int main()&#123; while(cin&gt;&gt;v&gt;&gt;s&gt;&gt;b)&#123; if (s&lt;b)&#123; cout&lt;&lt;-1&lt;&lt;endl; continue; &#125; double x = (v * v) / 9.8; if ( x &lt; s ) &#123; cout&lt;&lt;"move "&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;s-x&lt;&lt;endl; &#125; else &#123; double b = (s * 9.8) / (v * v); //æ³¨æ„åå‡½æ•°çš„è½¬æ¢ã€‚ double a = asin(b) * 90 / pi; //è¿™é‡Œæœ‰ä¸€ä¸ªè¿›ä¸€çš„æ“ä½œï¼Œå› ä¸ºæ­¤é¢˜ä¸å¤ªä¼šå»å››èˆäº”å…¥ã€‚ int a_ = a; if (a-a_ &gt;= 0.5) a_++; cout&lt;&lt;"a "&lt;&lt;a_&lt;&lt;endl; &#125; &#125; return 0;&#125; å…³äºè¿™é“é¢˜ç›®çš„ç›¸å…³è¦ç‚¹ åå‡½æ•°ç›¸å…³è¦ç‚¹ã€‚æ³¨æ„ åå‡½æ•°æœ€åè¾“å‡ºçš„æ˜¯ ä¸€ä¸ªå¼§åº¦å€¼ï¼Œæ ¹æ®ç›¸åº”æ•°å­¦çš„ç®—æ³•è€Œè¨€è®°ä½ ==å¼§åº¦å€¼=è§’åº¦*pi/180== å…³äºè¾“å‡ºä¸­è¿›1çš„ç›¸å…³æ“ä½œã€‚æŒ‰ç…§ç¬¬å‡ ä½ï¼Œå…ˆæ¢ç®—æˆç›¸åº”çš„æ•´å½¢æ•°ï¼Œæœ€åå†å¼ºè½¬æˆintå‹ æœ€ååœ¨åˆ¤æ–­æ˜¯å¦å¤§äº0.5æ¥è€ƒè™‘æ—¶å€™æ¥åŠ ä¸€ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è´ªå¿ƒç®—æ³•]]></title>
    <url>%2F2018%2F12%2F01%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[è´ªå¿ƒç®—æ³•å®šä¹‰è´ªå¿ƒç®—æ³•çš„æœ¬è´¨ç›®çš„ä¹Ÿå°±åœ¨äºå¯¹äºä¸€ä¸ªé—®é¢˜æ¥çœ‹ï¼Œæˆ‘å¯ä»¥ç”¨æœ€ç®€å•çš„åŠæ³•ç®—å‡ºå±€éƒ¨çš„è§£é›†ï¼Œå¹¶ä¸”æŒ‰ç…§è¿™ä¸ªæœ€ç®€å•çš„åŠæ³•åŒæ ·å¯ä»¥ç®—å‡ºè¯¥é—®é¢˜çš„æœ€ç»ˆè§£å†³åŠæ³•ï¼Œå³è´ªå¿ƒç®—æ³•ã€‚ ä¸‰ä¸ªç»å…¸çš„è´ªå¿ƒç®—æ³•é—®é¢˜ äº‹ä»¶çš„åºåˆ—é—®é¢˜ï¼š é‡åˆ°è¿™æ ·çš„é¢˜ç›®ï¼Œé¦–å…ˆå°±æ˜¯è¦æƒ³ç€èƒ½ä¸èƒ½æ‰¾åˆ°æœ€é•¿çš„å­åºåˆ—çš„å‰æï¼Œåˆ°åº•æ˜¯æŒ‰èŠ‚ç›®çš„å¼€å§‹æ—¶é—´è¿›è¡Œæ’åºï¼Œè¿˜æ˜¯æŒ‰ç…§èŠ‚ç›®çš„ç»“æŸæ—¶é—´è¿›è¡Œæ’åºã€‚ä¸‹é¢å°±æ˜¯æ ¸å¿ƒä»£ç 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 100+5;struct Show&#123; int beg; int en;&#125;show[maxn];int main()&#123; int n; while (cin&gt;&gt;n&amp;&amp;n!=0)&#123; for (int i=0;i!=n;i++)&#123; cin&gt;&gt;show[i].beg&gt;&gt;show[i].en; &#125; stable_sort(show,show+n, [](const Show &amp;a, const Show &amp;b)&#123;return a.en&lt;b.en;&#125;); int cnt=1; for (int i=1,j=0;i&lt;n;i++)&#123; if (show[i].beg&gt;=show[j].en)&#123; cnt++; j=i; &#125; &#125; cout&lt;&lt;cnt&lt;&lt;endl; &#125;&#125; æ­¤å¤„çš„å…³é”®å°±æ˜¯ä»ç¬¬ä¸€ä¸ªå¼€å§‹æŠŠç»“æŸæ—¶é—´æœ€æ—©çš„è¿›è¡Œä¸€ä¸ªç›¸å¯¹ä½ç½®çš„æ’åºï¼Œç„¶åæŠŠç¬¬ä¸€ä¸ªç»“æŸçš„ä¸åé¢å¼€å§‹çš„æ—¶é—´è¿›è¡ŒæŒ¨ä¸ªæŒ¨ä¸ªçš„æ¯”è¾ƒï¼Œæœ€ç»ˆå¾—å‡ºçš„ç»“æœå°±æ˜¯åœ¨è¿™é‡Œã€‚ åŒºé—´è¦†ç›–é—®é¢˜ä¸‹é¢å°±æ˜¯è¿™é“é¢˜ç›®çš„æ ¸å¿ƒä»£ç ï¼š123456789int greedy(vector&lt;int&gt; x,int k)&#123; int i,sum = 1,n=x.size(); sort(x.begin(),x.end()); int temp = x[0]; //åŒºé—´çš„èµ·å§‹ä½ç½® for(i=1;i &lt; n; ++i) if(x[i] - temp &gt; k) &#123;sum++,temp=x[i]&#125;; return sum;&#125; é¢˜ç›®è¿™é‡Œå°±æ˜¯åˆ†åˆ«è®¡æ•°ï¼Œç”¨ä¸€ä¸ªæœ€ç®€å•çš„æ€ç»´åšå‡ºä¸€æ•´é“é¢˜ç›®çš„æ€è·¯ã€‚ åŒºé—´ç›¸äº¤é—®é¢˜ï¼šå…¶å®å°±æ˜¯è·Ÿç¬¬ä¸€é“é¢˜ç›®ç±»ä¼¼ ç®—è¿ç»­çš„åºåˆ— å¹¶ä¸”æŠŠæ€»é•¿åº¦å‡å»è¿™äº›è¿ç»­çš„åºåˆ—ä¹‹åå¾—åˆ°çš„æ˜¯å‰©ä½™çš„åŒºé—´ï¼Œå³å¾—åˆ°é¢˜ç›®ç­”æ¡ˆã€‚ ==ä»¥åè‹¥è¿˜æœ‰å…³äºè´ªå¿ƒç±»å‹çš„é¢˜ç›®å¯ä»¥ç»§ç»­å¾€ä¸Šé¢åŠ == ä¸€ä¸‹å°±æ˜¯è´ªå¿ƒçš„ä¹ é¢˜]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>è´ªå¿ƒ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä¸€é“æœ‰è¶£çš„é¢˜ç›®â€”â€”é€†æ³¢å…°è®¡ç®—å™¨]]></title>
    <url>%2F2018%2F12%2F01%2F%E4%B8%80%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A2%98%E7%9B%AE%E2%80%94%E2%80%94%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[é¢˜è§£é¦–å…ˆè¿™é“é¢˜æ¯«æ— ç–‘é—®æ˜¯è¦ç”¨åˆ°stringstreamæµçš„ã€‚åˆ†åˆ«ä¾æ¬¡è¯»å–å­—ç¬¦ä¸²ï¼Œå¹¶ä¸”å°†å…¶å¯¼å…¥åˆ°charå‹çš„ä»£ç ä¸­å»ã€‚æ¯”å¦‚è¯´a+bå¯ä»¥å˜æˆab+ï¼Œè¿™é‡Œæœ€å¥½è¿ç”¨åˆ°æ ˆçš„çŸ¥è¯†ï¼Œæ¥æ§åˆ¶å‡ºæ ˆä¸è¿›æ ˆã€‚==æ³¨æ„ä»¥ä¸‹å‡ ä¸ªåœ°æ–¹== æ³¨æ„è¾“å…¥cin&gt;&gt;tä»¥åï¼Œéœ€è¦ç”¨getchar()æ¥æ¸…ç©ºä¸Šä¸€ä¸ªæ­¥éª¤ç•™ä¸‹æ¥çš„å›è½¦ç¬¦å· æ³¨æ„æ­¤å¤„éœ€è¦ä¸¥æ ¼è¿›è¡Œåˆ¤æ–­æ ˆå†…æ˜¯å¦ä¸ºç©ºã€‚ è¿™é‡Œæ˜¯å°†ä¹˜é™¤æ±‚æ¨¡çš„è¿ç®—æ”¾åœ¨æœ€å³è¾¹ï¼Œè¿™æ ·å°±å¯ä»¥æœ‰ä¼˜å…ˆçº§å­˜åœ¨äº† æ‹¬å·ä¼šæå‰è¿›è¡Œä¸€æ­¥è¿ç®—ï¼Œç„¶åæ¶ˆé™¤æ‰å·¦æ‹¬å·ï¼Œæˆ–è€…å·¦è¾¹çš„æ‰€æœ‰è¿ç®—å¼ï¼Œè¿›è¡Œä¸€ä¸ªç»“ç®—ã€‚ mapè¿™é‡Œå­˜åœ¨çš„æ„ä¹‰å°±åœ¨äº ä¸ºåˆ¤æ–­è¿›è¡Œæä¾›æ¡ä»¶ã€‚ æ­¤é“é¢˜ç›®æ¶‰åŠå­—ç¬¦ä¸²ï¼Œæ ˆï¼Œæ¨¡æ‹Ÿçš„ç›¸åº”ç®—æ³•ï¼Œéœ€è¦æœ‰ç©ºçš„æ—¶å€™å¯ä»¥å¤šçœ‹çœ‹ã€‚ ä»£ç å¦‚ä¸‹ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;sstream&gt;#include&lt;map&gt;using namespace std;stack&lt;char&gt;ope;stack&lt;int&gt;num;string str;map&lt;char,int&gt;m;void init()&#123; m['+']=m['-']=1; m['*']=m['/']=m['%']=m['(']=m[')']=2; while(!num.empty()) num.pop(); while(!ope.empty()) ope.pop();&#125;//æ­¤å¤„ä¸ºåŸºæœ¬çš„è¿ç®—è§„æ¨¡ã€‚void op1(int &amp;a,int &amp;b,const char &amp;c)&#123; if (c =='+') a += b; else if (c == '-') a=b-a; else if (c == '*') a*=b; else if (c == '/') a=b/a; else if (c == '%') a=b%a;&#125;//æ­¤å¤„å°±æ˜¯æ§åˆ¶å‡ºæ ˆçš„è¿ç®—ï¼Œä¸€èˆ¬å°±æ˜¯æ‹¬å·å†…éƒ¨çš„è®¡ç®—äº†ã€‚ç®—å‡ºæ¯ä¸€ä¸ªæ‹¬å·å†…éƒ¨çš„è¿ç®—å¼ã€‚void op2()&#123; char ch = ope.top(); while (ch != '('&amp;&amp;!ope.empty())&#123; ope.pop(); int a = num.top(); num.pop(); int b = num.top(); num.pop(); op1(a,b,ch); num.push(a); if (!ope.empty()) ch = ope.top(); &#125;//è¿™ä¸ªä¸‹é¢è¦æ³¨æ„çš„åˆ¤æ–­æ¡ä»¶ä¸­ä¸€å®šè¦åŠ ä¸Šåˆ¤æ–­æ˜¯å¦ä¸ºç©ºã€‚ if (!ope.empty()&amp;&amp;ope.top() =='(') ope.pop();&#125;int main()&#123; int t; cin&gt;&gt;t; getchar(); while (t--)&#123; getline(cin,str); stringstream s(str); init(); char tmp; while (s&gt;&gt;tmp)&#123; if(tmp&gt;='0'&amp;&amp;tmp&lt;='9')&#123; int x = 0; do&#123; if (m[tmp]) break; x *= 10; x += tmp - '0';//æ­¤å¤„æ˜¯å°†charè½¬æ¢æˆint &#125;while(s&gt;&gt;tmp); num.push(x); &#125; //æ³¨æ„è¿™ä¸ªåœ°æ–¹çš„é«˜æ˜ä¹‹å¤„å°±åœ¨äºç¢°è§â€˜ï¼‰â€™çš„è¿”å›ï¼Œä»¥åŠåˆ¤æ–­æœ‰æ²¡æœ‰â€˜ï¼ˆâ€™ï¼Œ æ¯”å¦‚è¿åŠ çš„æƒ…å†µå°±æŠŠåŠ å‡ä¹˜é™¤çš„ä¼˜å…ˆè¿ç®—çº§ç»™è¡¨ç¤ºå‡ºæ¥äº†ã€‚ //æœ€åç›¸å½“äºå°†è¿ç®—ä¼˜å…ˆçº§é«˜çš„å…¨éƒ¨æ”¾åˆ°äº†å³è¾¹ï¼Œç„¶åæœ‰æ‹¬å·çš„å°±å…ˆè§£å†³æ‹¬å·ï¼Œ åŠæ—¶å·¦æ‹¬å·è¢«æå‰å¼„æ²¡äº†ä¹Ÿä¸è¦ç´§ï¼Œå­˜åœ¨æœ‰å³æ‹¬å·å°±è¡Œï¼Œç„¶åä¹˜é™¤æ°¸è¿œæ”¾åœ¨åŠ å‡çš„å·¦è¾¹ã€‚ if (tmp==')') op2(); else if (m[tmp]==1)&#123; if (!ope.empty()&amp;&amp;ope.top()!='(') op2(); ope.push(tmp); &#125; else if (m[tmp]) ope.push(tmp); &#125; int ans = num.top(); num.pop(); while (!num.empty()&amp;&amp;!ope.empty())&#123; op1(ans,num.top(),ope.top()); ope.pop(); num.pop(); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[äºŒåˆ†æ³•æ€æƒ³]]></title>
    <url>%2F2018%2F12%2F01%2F%E4%BA%8C%E5%88%86%E6%B3%95%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[äºŒåˆ†æŸ¥æ‰¾å®ç°åœ¨å•è°ƒæœ‰åºçš„é›†åˆä¸­æŸ¥æ‰¾å…ƒç´ ï¼Œæ¯æ¬¡æ±Ÿé›†åˆåˆ†ä¸ºå·¦å³ä¸¤ä¸ªéƒ¨åˆ†ï¼Œå¹¶ä¸”é€šè¿‡åˆ¤æ–­é›†åˆåœ¨å“ªä¸ªéƒ¨åˆ†ä»è€Œè°ƒæ•´é›†åˆçš„ä¸Šä¸‹ç•Œï¼Œé‡å¤çŸ¥é“æ‰¾åˆ°ç›®æ ‡å…ƒç´ ä¸ºæ­¢ã€‚ ä¸¾ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œæˆ‘è¦åœ¨1åˆ°100é‡Œé¢æŸ¥æ‰¾62ï¼Œå…ˆæ‹¿62æ ¹è¿™ä¸ªå…¶æœ€ä¸­é—´çš„ä¸€ä¸ªæ•°è¿›è¡Œæ¯”è¾ƒã€‚ç„¶ååœ¨ä¸€æ­¥ä¸€æ­¥çš„ç¼©å°é›†åˆçš„ä¸Šä¸‹ç•Œï¼Œæœ€åå†æ¥ä¸€æ­¥ä¸€æ­¥å¾€é‡Œé¢ç¼© ä¸‹é¢æ˜¯C++STLé‡Œé¢äºŒåˆ†æŸ¥æ‰¾çš„å‡½æ•°ï¼š binary_search è¿”å›boolå€¼,æ˜¯å¦å­˜åœ¨lower_bound è¿”å›å¯æ’å…¥çš„æœ€å°ä½ç½®çš„è¿­ä»£å™¨ å³è¿”å›ç¬¬ä¸€ä¸ªç¬¦åˆæ¡ä»¶çš„å…ƒç´ ä½ç½®upper_bound è¿”å›å¯æ’å…¥çš„æœ€å¤§ä½ç½®çš„è¿­ä»£å™¨ å³è¿”å›æœ€åä¸€ä¸ªç¬¦åˆæ¡ä»¶çš„å…ƒç´ ä½ç½® åœ¨äºŒåˆ†æŸ¥æ‰¾é‡Œé¢æœ€å…¸å‹çš„é¢˜ç›®å°±æ˜¯äºŒåˆ†é€¼è¿‘æ±‚æ–¹ç¨‹å¼çš„æ ¹äº†ã€‚ ä»£ç å¦‚ä¸‹123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;iomanip&gt;using namespace std;const double pre =1e-4;double x,y;double f(double x)&#123; return 8*pow(x,4)+7*pow(x,3)+2*pow(x,2)+3*x+6-y;&#125;int main()&#123; int t; cin&gt;&gt;t; while (t--)&#123; cin&gt;&gt;y; double x1=0,x2=100;//å…ˆæŠŠä¸Šä¸‹ç•Œåœ¨è¿™é‡Œç¡®å®šå¥½ double mid=(x1+x2)/2; if (f(x1)*f(x2)&gt;0) cout&lt;&lt;"No solution!"&lt;&lt;endl; else &#123; while (x2-x1&gt;=pre)&#123;//è¿™é‡Œå¿…é¡»å†™çš„æ˜¯ä¸Šä¸‹ç•Œçº¿æ˜¯å¤šå°‘ï¼Œ ä¸èƒ½å†™çš„æ˜¯ç”¨äºåˆ¤æ–­midçš„æ¡ä»¶ã€‚ if (f(x1)*f(mid)&lt;0)&#123; x2=mid; mid=(x1+x2)/2; &#125; else &#123; x1=mid; mid=(x1+x2)/2; &#125; &#125; cout&lt;&lt;fixed&lt;&lt;setprecision(4)&lt;&lt;mid&lt;&lt;endl; &#125; &#125;&#125; ä¸Šé¢å°±æ˜¯æˆ‘ç¬¬äºŒæ¬¡å‡ºé”™çš„åœ°æ–¹ï¼Œåˆ¤æ–­äºŒåˆ†å¾ªç¯é€¼è¿‘çš„çš„æ¡ä»¶ä¸åº”è¯¥çœ‹midçš„å–å€¼ï¼Œè€Œæ˜¯åº”è¯¥çœ‹å¾—æ˜¯åŒºé—´ä¸Šç•Œå‡å»åŒºé—´ä¸‹ç•Œçš„èŒƒå›´ä»è€Œæ¥é™å®šã€‚ æ­¤å¤„å…³äºä¸‰åˆ†æ³•çš„æ±‚è§£ï¼šå½“éœ€è¦æ±‚æŸå‡¸æ€§æˆ–å‡¹å½¢å‡½æ•°çš„æå€¼ï¼Œé€šè¿‡å‡½æ•°æœ¬èº«è¡¨è¾¾å¼å¹¶ä¸å®¹æ˜“æ±‚è§£æ—¶ï¼Œå°±å¯ä»¥ç”¨ä¸‰åˆ†æ³•ä¸æ–­é€¼è¿‘æ±‚è§£ã€‚ ä¸‰åˆ†æ³•â€”â€”æ±‚è§£å‡¸æ€§å‡½æ•°çš„æå€¼é—®é¢˜http://hi.baidu.com/vfxupdpaipbcpuq/item/81b21d1910ea729c99ce33db ç»å…¸ä¾‹é¢˜ï¼šä¾µç•¥çš„å¥¶ç‰›ï¼š ä»£ç å¦‚ä¸‹ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 100005;int a[maxn],n,c;//æ­¤è¿‡ç¨‹å°±æ˜¯åœ¨åˆ¤æ–­å¥¶ç‰›ä¹‹é—´çš„é—´éš”ä¸ºè¿™ä¸ªå€¼åˆä¸åˆé€‚bool cc(int d)&#123; int t=a[0],cnt=1; for (int i=1;i!=n;i++)&#123; if (a[i]-t&gt;=d)&#123; cnt++; t=a[i]; if (cnt&gt;=c) return true; &#125; &#125; return false;&#125;//æ­¤è¿‡ç¨‹å°±æ˜¯åœ¨æ”¶å½•æ¯ä¸€ä¸ªå€¼ï¼Œç„¶åå†åˆ†åˆ«è¿›è¡Œåˆ¤æ–­int solve()&#123; int x=0,y=a[n-1]-a[0]; while (x&lt;=y)&#123; int mid=(x+y)/2; if (cc(mid)) x=mid+1; else y=mid-1; &#125; return x-1;&#125;//ä¸è¿‡è¿™ç§æœ€å¤§å€¼æœ€å°å€¼çš„é¢˜ç›®éœ€è¦å¤šèŠ±æ—¶é—´æƒ³æƒ³ã€‚int main()&#123; while (cin&gt;&gt;n&gt;&gt;c)&#123; for (int i=0;i!=n;i++) cin&gt;&gt;a[i]; sort(a,a+n); cout&lt;&lt;solve()&lt;&lt;endl; &#125;&#125; ==ä¸‹é¢åˆ™æ˜¯å…¶ä»–åœ°æ–¹å…³äºäºŒåˆ†çš„é¢˜ç›®==åŸºç¡€ç‰ˆ POJ 3122 Pie äºŒåˆ†æšä¸¾åŒºé—´æ˜¯å®æ•°POJ 1064 Cable master äºŒåˆ†æšä¸¾åŒºé—´æ˜¯å®æ•°,æ³¨æ„ç²¾åº¦POJ 3258 River Hopscotch æœ€å¤§åŒ–æœ€å°å€¼POJ 3273 Monthly Expense æœ€å°åŒ–æœ€å¤§å€¼LIGHTOJ 1076 Get the Containers æœ€å°åŒ–æœ€å¤§å€¼ï¼Œã€‚å’Œä¸Šä¸€ä¸ªå·®ä¸å¤šLIGHTOJ 1307 Counting Triangles è¿›é˜¶ç‰ˆ POJ 3579 äºŒåˆ†æœç´¢+äºŒåˆ†æŸ¥æ‰¾POJ 3685 äºŒåˆ†æœç´¢+äºŒåˆ†æŸ¥æ‰¾ZOJ 3278 ä¹Ÿæ˜¯ä¸¤ä¸ªäºŒåˆ†åµŒå¥—LIGHTOJ 1048å’ŒLightOJ 1076ä¸€æ ·ï¼Œä¸è¿‡è¦è¾“å‡ºä¸€ç»„è§£LIGHTOJ 1383 äºŒåˆ†åŠ è´ªå¿ƒï¼ˆåŒºé—´ï¼‰ZOJ 3665 æŸå¹´åŒºåŸŸèµ›é¢˜ã€‚ï¼ŒäºŒåˆ†æšä¸¾ZOJ 3726 å»å¹´åŒºåŸŸèµ›é¢˜ï¼ŒäºŒåˆ†æŸ¥æ‰¾codeforces 382B æœ‰æ„æ€çš„é¢˜codeforces 391D2 éš¾ï¼Œã€‚ã€‚ï¼Œï¼Œã€ ==ä¸‹é¢å°±æ˜¯å…³äºä¸‰åˆ†çš„é¢˜ç›®== poj3301hdu4454hdu3714hdu2438]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ•°æ®ç»“æ„ç›¸åº”æ€»ç»“]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%BA%94%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[æ ˆ æ ˆçš„æ¦‚å¿µæ­¤å¤„åªéœ€è¦è®°ä½æ ˆçš„æ€æƒ³æœ€é‡è¦çš„å°±æ˜¯å…ˆè¿›åå‡ºæ€æƒ³ï¼Œä¹Ÿå°±æ˜¯æœ€å…ˆè¿›å»çš„æœ€åå‡ºæ¥ã€‚ ä¸¤ç§æ–¹æ³•è¡¨ç¤ºè¿™ç§æ ˆçš„å®ç° ç¬¬ä¸€ç§åˆ™æ˜¯ ç›´æ¥ç”¨cè¯­è¨€å®ç°ï¼Œé‡‡ç”¨ä¸€ä¸ªä¸€ç»´æ•°ç»„æ¥å­˜å‚¨æ ˆï¼Œç”¨ä¸¤ä¸ªæŒ‡é’ˆä¸€ä¸ªæŒ‡å‘æ ˆé¡¶ï¼Œå¦ä¸€ä¸ªæŒ‡å‘æ ˆåº•ã€‚ç”¨top=bottomä½œä¸ºæ ˆç©ºçš„æ ‡è®°æˆ–è€…è¯´æ˜¯æ ˆéå†å®Œæ¯•çš„æ ‡è®°ã€‚ ç¬¬äºŒç§å°±æ˜¯ç›´æ¥ç”¨C++é‡Œé¢STLæ¨¡æ¿é¦–å…ˆå…ˆå®šä¹‰ä¸€ä¸ªstack&lt;int&gt; s ç„¶åä»¥ä¸‹å°±æ˜¯å…¶çš„æ“ä½œã€‚ æ³¨æ„å…¶ä¸èƒ½ä½¿ç”¨push_backåªèƒ½ä½¿ç”¨push 1234s.pop() åˆ é™¤æ ˆé¡¶å…ƒç´ ï¼Œä¹Ÿå°±æ˜¯å‡ºæ ˆçš„ä½œï¼ŒæŠŠåˆšåˆšè¿›æ¥çš„å…ƒç´ å‡ºæ ˆ,ä¸è¿”å›å…ƒç´ å€¼ã€‚s.push() åˆ›å»ºä¸€ä¸ªæ–°å…ƒç´ å‹å…¥æ ˆé¡¶ï¼Œå¯ä»¥é€šè¿‡æ‹·è´ï¼Œç§»åŠ¨ï¼Œç”šè‡³æ˜¯æ„é€ è€Œæ¥ã€‚s.top() è¿”å›æ ˆé¡¶çš„å…ƒç´ ï¼Œä¹Ÿå°±æ˜¯åˆšåˆšè¿›æ¥çš„å…ƒç´ ã€‚s.bottom() è¿”å›æ ˆåº•çš„å…ƒç´ ï¼Œä¹Ÿå°±æ˜¯æœ€åä¸€ä¸ªå…ƒç´  é˜Ÿåˆ—é€‚é…å™¨é˜Ÿåˆ—è¿™é‡Œåˆ†ä¸ºä¸¤ç§ä¸€ç§æ˜¯æ™®é€šé˜Ÿåˆ—ï¼Œè¿˜æœ‰ä¸€ç§æ˜¯ç‰¹æ®Šæ’åˆ—å¥½çš„ä¼˜å…ˆé˜Ÿåˆ—ï¼Œä½†æ˜¯è¿™äºŒè€…çš„åŒºåˆ«å°±åœ¨äºï¼Œè™½ç„¶éƒ½ç¬¦åˆå…ˆè¿›å…ˆå‡ºçš„æ€æƒ³ï¼Œä½†æ˜¯å‰è€…æ˜¯ä¸åŠ ä»»ä½•æ’åºçš„å…ˆè¿›å…ˆå‡ºï¼Œè€Œåè€…å°±æ˜¯è®©ä»£ç ç¼–è¾‘è€…è‡ªå·±å®šä¹‰ä¸€ç§æ’åºæ–¹å¼ï¼Œç„¶åé€šè¿‡è¿™ç§æ’åºæ–¹å¼ï¼Œå†æ¥å‡ºé˜Ÿæ“ä½œã€‚ ä¸ä¸Šé¢ä¸€æ ·ï¼Œå…ˆå®šä¹‰ä¸€ä¸ªqueue&lt;int&gt; qä¸priority_queue&lt;int&gt; qã€‚ 1234567q.pop() æŒ‰ç…§å…ˆè¿›å…ˆå‡ºçš„æ€æƒ³ï¼Œåˆ é™¤é¦–å…ƒç´ æˆ–è€…ä¼˜å…ˆçº§æœ€é«˜çš„å…ƒç´ q.front() è¿”å›é¦–å…ƒç´ ã€‚q.back() è¿”å›å°¾å…ƒç´ ã€‚ä»¥ä¸Šä¸¤ä¸ªæ˜¯åªé€‚ç”¨äºé˜Ÿåˆ—ã€‚q.top() è¿”å›ä¼˜å…ˆé˜Ÿåˆ—ä¸­ä¼˜å…ˆçº§æœ€é«˜çš„å…ƒç´ ã€‚q.push()q.emplace() åŠ å…¥å…ƒç´ åˆ°é˜Ÿå°¾ï¼Œæˆ–è€…ä¼˜å…ˆé˜Ÿåˆ—ä¸­ä¸€ä¸ªæ°å½“çš„ä½ç½®ï¼Œè¦ä¹ˆæ„é€ ï¼Œè¦ä¹ˆæ‹·è´ã€‚ è¿™é‡Œéœ€è¦æä¸€ä¸‹==ä¼˜å…ˆé˜Ÿåˆ—çš„æ„é€ æ–¹æ³•==ä»¥åŠ==ä¼˜å…ˆé˜Ÿåˆ—çš„ç‰¹æ®Šæ’åº==åº”è¯¥æ€ä¹ˆæ„é€  123456789ä¸‹é¢ä¸¤ç§ä¼˜å…ˆé˜Ÿåˆ—çš„å®šä¹‰æ˜¯ç­‰ä»·çš„priority_queue&lt;int&gt; q;priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;;//åé¢æœ‰ä¸€ä¸ªç©ºæ ¼é»˜è®¤éƒ½æ˜¯ä»å°åˆ°å¤§æ’åºæ¥å—ä¸‰ä¸ªå‚æ•°ï¼Œç¬¬ä¸€ä¸ªå‚æ•°ä¸ºæ•°æ®ç±»å‹ï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸ºæ‰¿è½½å®¹å™¨çš„ç±»å‹ï¼Œç¬¬ä¸‰ä¸ªå°±æ˜¯è‡ªå®šä¹‰çš„æ¯”è¾ƒå‡½æ•°äº†ã€‚å¯ä»¥ä½¿lamdaåŒ¿åå‡½æ•°ï¼Œä¹Ÿå¯ä»¥æ˜¯functionå¤´æ–‡ä»¶é‡Œé¢çš„å‡½æ•°æ¨¡æ¿ã€‚ é“¾è¡¨ç‰¹ç‚¹ï¼šè‡ªå®šä¹‰ï¼Œä¸è¿ç»­çš„ã€‚åŒæ—¶é“¾è¡¨ä¹Ÿæ˜¯åé¢ç›¸åº”æ ‘å½¢ç»“æ„çš„åŸºç¡€å®é™…ä¸Šå°±æ˜¯æŠŠæ¯ä¸€ä¸ªä¸è¿ç»­çš„å†…å­˜ç©ºé—´è¿åœ¨ä¸€èµ·ï¼Œå¯ä»¥è®¤ä¸ºçš„æ§åˆ¶è¿›ç¨‹è¿™ä¸ªéœ€è¦è‡ªå·±æ”¹å¤©æŠŠé“¾è¡¨çš„éå†ï¼Œåˆ é™¤ï¼Œå¢åŠ è‡ªå·±å†å†™ä¸€éï¼Œå› ä¸ºä¸æ˜¯ä»€ä¹ˆæ–°ä¸œè¥¿ï¼Œæ‰€ä»¥è¿™é‡Œå°±ä¸å¤šè¯´äº† åŠ¨æ€æ•°ç»„è¿™é‡Œå°±æ˜¯vector å­˜åœ¨çš„æ„ä¹‰äº† vectoré‡Œé¢é‡è¦çš„æ¦‚å¿µ å®¹é‡ï¼Œé•¿åº¦ã€‚ æ ‘ä¸äºŒå‰æ ‘ä¸€èˆ¬çš„æ ‘ ä»¥ä¸Šå°±æ˜¯ä¸€èˆ¬æ ‘çš„å½¢æ€ã€‚ä¸‹é¢åˆ™æ˜¯å…³äºæ ‘çš„åŸºæœ¬ç”¨è¯­ã€‚å…³äºä¸Šé¢é‡è¦çš„æ¦‚å¿µå°±æ˜¯ç»“ç‚¹å’Œç»“ç‚¹çš„åº¦äº†ã€‚ äºŒå‰æ ‘äºŒå‰æ ‘çš„å®šä¹‰: äºŒå‰æ ‘æœ‰äº”ç§åŸºæœ¬å½¢æ€ï¼š äºŒå‰æ ‘çš„æ€§è´¨:ä¸Šé¢æ‰€å†™åˆ°çš„==è‡³å¤š==éƒ½æ˜¯ç”±äºå°†å…¶å½“æˆäº†æ»¡äºŒå‰æ ‘æ¥è¿›è¡Œè®¡ç®—çš„ã€‚ æ»¡äºŒå‰æ ‘ä¸å®Œå…¨äºŒå‰æ ‘å‰è€…å…¨éƒ¨éƒ½æœ‰å­èŠ‚ç‚¹ï¼Œåè€…åŸºäºæ·±åº¦ä¸ºkçš„åŸºç¡€ä¸Šï¼Œç¼–å·ä»1åˆ°nçš„ç»“ç‚¹ä¸€ä¸€å¯¹åº”ã€‚å®Œå…¨äºŒå‰æ ‘æ˜¯æ»¡äºŒå‰æ ‘çš„ä¸€éƒ¨åˆ†ï¼Œè€Œæ»¡äºŒå‰æ ‘æ˜¯å®Œå…¨äºŒå‰æ ‘çš„ç‰¹ä¾‹ã€‚ äºŒå‰æ ‘çš„å­˜å‚¨ç»“æ„ï¼š æ•°ç»„å­˜å‚¨ï¼š äºŒå‰é“¾å¼å­˜å‚¨ï¼ˆåŸç†ç±»ä¼¼é“¾è¡¨ï¼‰ï¼šå°†é“¾è¡¨å†…éƒ¨çš„*nextï¼Œå˜æˆäº†æŒ‡å‘ä¸¤è¾¹çš„å­èŠ‚ç‚¹çš„æŒ‡é’ˆã€‚ ä¸‰å‰é“¾å¼å­˜å‚¨ï¼šæ¯”äºŒå‰é“¾å¼ç»“æ„å¤šäº†ä¸€ä¸ªå›æŒ‡å‘çˆ¶èŠ‚ç‚¹çš„æŒ‡é’ˆã€‚ éå†äºŒå‰æ ‘çš„æ–¹æ³• å…ˆåºéå†ï¼ˆæ ¹-&gt;å·¦-&gt;å³ï¼‰ï¼š ä»£ç : 12345678void PreOrderTraverse(BiTree *T)&#123; if(T != NULL)&#123; printf("%c", T-&gt;data); PreOrderTraverse(T-&gt;lchild); PreOrderTraverse(T-&gt;rchild); &#125;&#125; å›¾ç¤ºï¼š æœ€ç»ˆç»“æœå°±æ˜¯==ABDGHCEIF==ã€‚ ä¸­åºéå†ï¼ˆå·¦-&gt;æ ¹-&gt;å³)ï¼š è‹¥äºŒå‰æ ‘ä¸ºç©ºï¼Œåˆ™ç©ºæ“ä½œè¿”å›ï¼Œå¦åˆ™ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼ˆæ³¨æ„ä¸æ˜¯å…ˆè®¿é—®æ ¹èŠ‚ç‚¹ï¼‰ï¼Œä¸­åºéå†æ ¹èŠ‚ç‚¹çš„å·¦å­æ ‘ï¼Œç„¶åæ˜¯è®¿é—®æ ¹èŠ‚ç‚¹ï¼Œæœ€åä¸­åºéå†å³å­æ ‘ã€‚ ä»£ç ï¼š 12345678void InOrderTraverse(BiTree T)&#123; if(T != NULL)&#123; PreOrderTraverse(T-&gt;lchild); printf("%c", T-&gt;data); PreOrderTraverse(T-&gt;rchild); &#125;&#125; æœ€ç»ˆç»“æœä¸º==GDHBAEICF==ã€‚ ååºéå†ï¼ˆå·¦-&gt;å³-&gt;æ ¹ï¼‰ è‹¥äºŒå‰æ ‘ä¸ºç©ºï¼Œåˆ™ç©ºæ“ä½œè¿”å›ï¼Œå¦åˆ™ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼ˆæ³¨æ„ä¸æ˜¯å…ˆè®¿é—®æ ¹èŠ‚ç‚¹ï¼‰ï¼Œä¸­åºéå†æ ¹èŠ‚ç‚¹çš„å·¦å­æ ‘ï¼Œç„¶åæ˜¯è®¿é—®æ ¹èŠ‚ç‚¹ï¼Œæœ€åä¸­åºéå†å³å­æ ‘ã€‚ ä»£ç ï¼š 12345678void PostOrderTraverse(BiTree T)&#123; if(T != NULL)&#123; PreOrderTraverse(T-&gt;lchild); PreOrderTraverse(T-&gt;rchild); printf("%c", T-&gt;data); &#125;&#125; æœ€ç»ˆç»“æœä¸º==GHDBIEFCA==ã€‚ å…³äºäºŒå‰æ ‘çš„å»ºç«‹ä»£ç ï¼šä»£ç æˆ‘ç­‰ä¸‹è‡ªå·±å†™å‡ºæ¥ã€‚ å›¾å›¾çš„å®šä¹‰ å›¾ç»“æ„ï¼šæ˜¯ç ”ç©¶æ•°æ®å…ƒç´ ä¹‹é—´çš„å¤šå¯¹å¤šçš„å…³ç³»ã€‚åœ¨è¿™ç§ç»“æ„ä¸­ï¼Œä»»æ„ä¸¤ä¸ªå…ƒç´ ä¹‹é—´å¯èƒ½å­˜åœ¨å…³ç³»ã€‚å³ç»“ç‚¹ä¹‹é—´çš„å…³ç³»å¯ä»¥æ˜¯ä»»æ„çš„ï¼Œå›¾ä¸­ä»»æ„å…ƒç´ ä¹‹é—´éƒ½å¯èƒ½ç›¸å…³ã€‚ å›¾çš„ä¸“ä¸šæœ¯è¯­ï¼š å›¾-ç”Ÿæˆæ ‘ é‚»æ¥çŸ©é˜µçš„è¡¨ç¤ºæ–¹æ³•ï¼ˆæ•°ç»„ï¼‰ä¸å¸¦æƒå€¼çš„è¡¨ç¤ºæ–¹æ³• ä¸€èˆ¬å°±æ˜¯ç”¨äºŒç»´æ•°ç»„æ¥è¡¨ç¤ºæ¯ä¸€ä¸ªç»“ç‚¹ä¹‹é—´çš„å…³ç³» å…³äºå›¾çš„éå†å°±æœ€å¥½ç”¨ä¸€ä¸ªbool ç±»å‹çš„åŒäºŒç»´æ•°ç»„ ç„¶åé€šè¿‡è¿™ä¸ªæ¥æ ‡è®°å“ªäº›æ˜¯å¦å·²ç»è¢«éå†è¿‡å¾—ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>æ•°æ®ç»“æ„</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ•°è®ºåŸºç¡€ç¬¬ä¸€èŠ‚]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E8%8A%82%2F</url>
    <content type="text"><![CDATA[åˆç­‰æ•°è®ºæ˜¯ç”¨åˆç­‰æ–¹æ³•ç ”ç©¶çš„æ•°è®ºï¼Œå®ƒçš„ç ”ç©¶æ–¹æ³•æœ¬è´¨ä¸Šè¯´ï¼Œå°±æ˜¯åˆ©ç”¨æ•´æ•°ç¯çš„æ•´é™¤æ€§è´¨ï¼Œä¸»è¦åŒ…æ‹¬æ•´é™¤ç†è®ºã€åŒä½™ç†è®ºã€è¿åˆ†æ•°ç†è®ºã€‚ æ•´é™¤é—®é¢˜å¼•ç”³åˆ°åŒä½™é—®é¢˜ åŒä½™çš„æ€§è´¨ å¯ä»¥æ¢ç®—æˆä»¥ä¸‹å¼å­ï¼ša=c(modb) è¿™é‡Œcä¸ºä½™æ•°ï¼Œè€Œbä¸ºé™¤æ•° åŒä½™çš„æ€§è´¨ è‡ªåæ€§ a=a mod m å¯¹ç§°æ€§ a=b mod m ç­‰ä»·äº b=a mod m ä¼ é€’æ€§ a=b mod m ä¸ b=c mod m ç­‰ä»·äº a=c mod m çº¿æ€§åˆæˆ a=b mod m ä¸ c= mod m ç­‰ä»·äº aÂ±c=bÂ±d mod m ä¸ ac= bd mod m æ¶ˆå»å…¬å› å­ ac=bc mod m &amp;&amp; gcd(c,m)=1 ç­‰ä»·äº a=b mod m ç´ æ•°ç­› æœ´ç´ ç­› ä¸€èˆ¬å°±æ˜¯å¾ªç¯2~âˆšnæ¬¡ åŸƒæ‹‰æ‰˜æ–¯ç‰¹å°¼ç­› å¾ªç¯æ¬¡æ•° æ¬§æ‹‰ç­› ç›¸åº”ä»£ç å¦‚ä¸‹ï¼š12 æœ€å¤§å…¬çº¦æ•°ä»¥åŠæœ€å°å…¬å€æ•° æœ€å¤§å…¬çº¦æ•° å‡½æ•°_gcd(a,b)è€Œå¤šä¸ªæ•°çš„æœ€å¤§å…¬çº¦æ•° å°±æ˜¯ _gcd(a,b,c)=_gcd(gcd(a,b),c) æœ€å°å…¬å€æ•°_lcm(a,b)=ab/_gcd(a,b) æ‰©å±•æ¬§å‡ é‡Œå¾— å…³äºæ±‚è§£çº¿æ€§åŒä½™æ–¹ç¨‹ å…³äºæ±‚é€†å…ƒ å…³äºå¿«é€Ÿå¹‚ è´¹é©¬å°å®šç† å¦å¤– æ¬§æ‹‰å‡½æ•° æ¬§æ‹‰å‡½æ•°å®šä¹‰ æ¬§æ‹‰å‡½æ•°æ€§è´¨ æ±‚å€¼å…¬å¼ ä¸Šè¿°å…¬å¼ å¯ä»¥ç”¨æ¥ï¼š æ±‚é€†å…ƒ æ¬§æ‹‰é™å¹‚å…¬å¼ æ•°è®ºå‡½æ•° ä¸­å›½å‰©ä½™å®šç† è§£æ³•]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>acm</tag>
        <tag>æ•°è®º</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å…³äºç»„åˆæ•°å­¦ï¼Œä¸¤é“æ€ç»´é¢˜ç›®ï¼Œè¿™é‡Œè´´ä¸¤é“é¢˜ç›®]]></title>
    <url>%2F2018%2F12%2F01%2F%E5%85%B3%E4%BA%8E%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%8C%E4%B8%A4%E9%81%93%E6%80%9D%E7%BB%B4%E9%A2%98%E7%9B%AE%EF%BC%8C%E8%BF%99%E9%87%8C%E8%B4%B4%E4%B8%A4%E9%81%93%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[ç¬¬ä¸€é“ ç®€å•çš„æ’åˆ—ç»„åˆï¼š é¢˜è§£å¦‚ä¸‹ï¼š é¢˜ç›®å¤§è‡´å¯ä»¥ç†è§£ä¸º4å †ç‰Œa,b,c,dï¼Œæ¯æ¬¡ä»ä¸€å †ç‰Œé‡Œæ‹¿å‡ºç‰Œé¡¶çš„ä¸€å¼ ç‰Œï¼Œé—®å…±æœ‰å¤šå°‘ç§æ‹¿æ³•ã€‚å…¶å®æˆ‘ä»¬å¯ä»¥ä¸€å †ä¸€å †çš„åˆ†æï¼Œå‡è®¾åªæœ‰ä¸€å †aæ—¶åªæœ‰1ç§æ‹¿æ³•ï¼Œé‚£ä¸¤å †a,bæ—¶æˆ‘ä»¬å¯ä»¥è®¤ä¸ºæ˜¯ä»aä¸ªç‰Œä¸­æ’å…¥bå¼ ç‰Œï¼Œç”¨æ•°å­¦è¡¨è¾¾å¼å°±æ˜¯==C(b,a+b)==;é‚£ä¹ˆä¸‰å †çš„è¯æˆ‘ä»¬å¯ä»¥æŠŠå‰ä¸¤å †çœ‹æˆä¸€å †ï¼Œé‚£ä¹ˆè¡¨è¾¾å¼å°±æ˜¯==C(c,a+b+c)==ï¼Œè¿™æ˜¯æˆ‘ä»¬éœ€è¦ä¸å‰ä¸¤å †çš„ç»„æˆæ–¹æ³•ç›¸ä¹˜ï¼Œå°±æ˜¯==C(b,a+b)C(c,a+b+c)==ã€‚4å †çš„è¯å°±æ˜¯==C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)==ã€‚æ‰€ä»¥ç­”æ¡ˆå°±æ˜¯==C(a,a)C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)==ã€‚æ­¤å¤–ï¼Œæœ‰ä¸€å…¬å¼==C(a,b)=C(a,b-1)+C(a-1,b-1)==ï¼Œæ‰€ä»¥æˆ‘ä»¬ç”¨æ•°ç»„æ¥ä»£æ›¿C(m,n)æ“ä½œ ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 501;const long long mod = 1000000007;long long a[4],sum[4]=&#123;0&#125;;//æ­¤å¤„ç”¨åˆ°è®°å¿†åŒ–æœç´¢ï¼ŒåŠ¨æ€è§„åˆ’ã€‚long long dp[maxn*4][maxn*4];void init()&#123; dp[0][0]=0; for (int i=1;i!=4*maxn;i++)&#123; dp[i][0]=1; //æ ¹æ®è¡¨æ ¼æ¥çœ‹çš„ç¡®æ˜¯æ¯ä¸€è¡Œçš„ç¬¬ä¸€ä¸ªæ˜¯1 for (int j=1;j&lt;i;j++)&#123; //è¿™ä¸ªåœ°æ–¹å°±æ˜¯çŠ¶æ€è½¬ç§»æ–¹ç¨‹ //C(a,b)=C(a,b-1)+C(a-1,b-1)æ ¹æ®å…¬å¼æ¥åšçš„ dp[i][j]=dp[i-1][j]+dp[i-1][j-1]; //dp[i][j]=dp[i][j]%mod; &#125; dp[i][i]=1; &#125;&#125;int main()&#123; int t; cin&gt;&gt;t; while (t--)&#123; init();//è¿™ä¸ªåœ°æ–¹å°±å¼€å§‹åˆå§‹åŒ–è¡¨æ ¼äº†ã€‚ long long ans =1; for (int i = 0; i&lt;4;i++)&#123; if (!i) sum[i]=0; else sum[i]=sum[i-1]; cin&gt;&gt;a[i]; sum[i] += a[i]; if (a[i] &gt; sum[i]-a[i]) a[i]=sum[i]-a[i]; &#125; for (int i = 1 ; i != 4; i++)&#123; ans *= dp[sum[i]][a[i]]; //ans %=mod; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; ç¬¬äºŒé¢˜ ç¬¬ä¸€é¢˜çš„å˜å¼ï¼š é¢˜è§£å¦‚ä¸Šï¼Œä¸ä¸Šé¢ä¸€é¢˜æœ‰åŒºåˆ«çš„åœ°æ–¹å°±åœ¨äºè¦æœ‰ä¸€ä¸ªå–æ¨¡çš„æ“ä½œ ä»£ç å¦‚ä¸‹ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 501;const long long mod = 1000000007;long long a[4],sum[4]=&#123;0&#125;;//æ­¤å¤„ç”¨åˆ°è®°å¿†åŒ–æœç´¢ï¼ŒåŠ¨æ€è§„åˆ’ã€‚long long dp[maxn*4][maxn*4];void init()&#123; dp[0][0]=0; for (int i=1;i!=4*maxn;i++)&#123; dp[i][0]=1; //æ ¹æ®è¡¨æ ¼æ¥çœ‹çš„ç¡®æ˜¯æ¯ä¸€è¡Œçš„ç¬¬ä¸€ä¸ªæ˜¯1 for (int j=1;j&lt;i;j++)&#123; //è¿™ä¸ªåœ°æ–¹å°±æ˜¯çŠ¶æ€è½¬ç§»æ–¹ç¨‹ //C(a,b)=C(a,b-1)+C(a-1,b-1)æ ¹æ®å…¬å¼æ¥åšçš„ dp[i][j]=dp[i-1][j]+dp[i-1][j-1]; dp[i][j]=dp[i][j]%mod; &#125; dp[i][i]=1; &#125;&#125;int main()&#123; int t; cin&gt;&gt;t; while (t--)&#123; init();//è¿™ä¸ªåœ°æ–¹å°±å¼€å§‹åˆå§‹åŒ–è¡¨æ ¼äº†ã€‚ long long ans =1; for (int i = 0; i&lt;4;i++)&#123; if (!i) sum[i]=0; else sum[i]=sum[i-1]; cin&gt;&gt;a[i]; sum[i] += a[i]; if (a[i] &gt; sum[i]-a[i]) a[i]=sum[i]-a[i]; &#125; for (int i = 1 ; i != 4; i++)&#123; ans *= dp[sum[i]][a[i]]; ans %=mod; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; ==ä»¥åå­¦åˆ°åé¢å†èŠ±æ—¶é—´æ¥æ·±ç©¶==]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>ç»„åˆæ•°å­¦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ ‘ç›¸å…³é¢˜ç›®]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[å¤åŸäºŒå‰æ ‘ é¢˜è§£æ­¤é“é¢˜ç›®å°±æ˜¯è¦æ³¨æ„å…ˆåºæ’åºä¸ä¸­åºæ’åºï¼Œä¸€ä¸ªæ˜¯æ ¹å·¦å³ï¼Œä¸€ä¸ªæ˜¯å·¦æ ¹å³ï¼Œå…ˆåºæ’åºçš„ç¬¬ä¸€ä¸ªä¸ºæ ¹ï¼Œåˆ©ç”¨é€’æ¨å…³ç³»è¾“å‡ºæ¯ä¸€ä¸ªæ ¹ï¼ˆç”±äºå…¶çš„é€’æ¨å‡ºå£å¹¶æ²¡æœ‰ç­‰äºå·ï¼Œæ„æ€å°±æ˜¯è¯´è¿™é‡ŒåŒæ ·è¾“å‡ºå¶å­èŠ‚ç‚¹ï¼‰ ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;string pre;string in;void post(int root,int start,int end)&#123; //é€’å½’æ‰“å°è¿™æ£µæ ‘çš„ååºï¼Œé€’å½’å‡ºå£ä¸º start &gt; end //æ³¨æ„è¿™é‡Œä¸å¸¦ç­‰äºå·çš„åŸå› å°±æ˜¯è¦æŠŠå¶å­èŠ‚ç‚¹ä¸€æ ·ç»™è¾“å‡ºæ¥ if(start&gt;end) return; int i=start;//iä¸º rootæ‰€ä»£è¡¨çš„å€¼åœ¨ä¸­åºä¸­çš„ä¸‹æ ‡ while(i&lt;end&amp;&amp;in[i]!=pre[root]) i++; int cnt=i-start;//å·¦å­æ ‘ç»“ç‚¹ä¸ªæ•° //ç”±äºæ˜¯å…ˆåºæ’åºï¼Œé¡ºåºæ°¸è¿œéƒ½æ˜¯æ ¹å·¦å³ï¼Œ post(root+1,start,i-1); //å·¦èŠ‚ç‚¹ å› ä¸ºæ˜¯ååºæ’åºï¼Œå…ˆæŠŠå·¦èŠ‚ç‚¹å…ˆå¼„å‡ºé¡ºåºï¼Œåœ¨å·¦èŠ‚ç‚¹å†…éƒ¨åœ¨æ¥ååºæ’åºï¼Œç›´åˆ°ä¸¤è¾¹å·¦è¾¹èŠ‚ç‚¹å¤§äºå³è¾¹èŠ‚ç‚¹ post(root+1+cnt,i+1,end); cout&lt;&lt;pre[root];&#125;int main()&#123; while(cin&gt;&gt;pre&gt;&gt;in)&#123; int len=pre.length(); post(0,0,len-1); cout&lt;&lt;endl; &#125; return 0;&#125; å…³äºæ ‘çš„ä¸€ä¸ªç®€å•DFSè¿ç”¨ é¢˜è§£ ç®€å•çš„dfsè¿ç”¨ å¯ä»¥æ¨¡æ‹Ÿæ ‘çš„ç»„æˆï¼Œä½†æ˜¯ç‰¹åˆ«è€—æ—¶é—´ï¼Œåªç”¨ç”¨ç›¸åº”çš„æœç´¢æ–¹æ³•æ¥åšæ‰å®¹æ˜“ä¸€ç‚¹ï¼Œè¿™é“é¢˜æœ‰å¿…è¦å†åšä¸€éã€‚ ä»£ç å¦‚ä¸‹ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;const int maxn = 1e5+5;//æ­¤å¤„å®é™…ä¸Šæ˜¯å……åˆ†åˆ©ç”¨äº†vectorçš„ç‰¹æ€§//å¦‚æœæ­¤å¤„æ˜¯äºŒç»´æ•°ç»„çš„è¯ï¼Œé‚£ä¹ˆä¸€å®šä¼šæµªè´¹è®¸å¤šæ²¡å¿…è¦çš„ç©ºé—´å¼€æ”¯//æ‰€ä»¥ç”¨ä¸€ä¸ªvectorçš„æ•°ç»„ï¼Œæ¯ä¸ªvectorå­˜å‚¨å…¶å¯¹åº”çš„ç¥–å…ˆ//è€Œä¸€å…±æœ‰é¢˜ç›®ç»™å‡ºæ•°é‡çš„vectorvector&lt;int&gt;people[maxn];char sex[maxn*2];int ans;int top;int que[maxn];//è¿™é‡Œeçš„å€¼åªæ˜¯ç”¨æ¥åˆ¤æ–­åˆ°åº•æ˜¯è¯¥æ¤å…¥å€¼è¿˜æ˜¯è¯¥åˆ¤æ–­å€¼//æ¢ç®—åˆ°è¿™ä¸ªé¢˜ç›®ä¸­çš„æ„æ€å°±æ˜¯å‰é¢ä¸€ä¸ªäººä¸éœ€è¦çœ‹èµ·ç¥–å…ˆåªéœ€è¦è¾“å…¥å…¶ç¥–å…ˆå°±è¡Œäº†//åé¢ä¸€ä¸ªäººåˆ™éœ€è¦åšçš„æ˜¯æ ¹æ®å·²æœ‰çš„å¯¹æ–¹ç¥–å…ˆè¿›è¡Œåˆ¤æ–­void dfs(int x,int s,int e)&#123; if (s&gt;=5) return ; if (e==0)&#123; for (int i=0;i!=top;i++)&#123; if (x==que[i])&#123; ans=1; return; &#125; &#125; &#125; else que[top++]=x; for (int i=0;i!=people[x].size();i++) dfs(people[x][i],s+1,e); return;&#125;//ä¸Šé¢çš„é€’å½’æœç´¢å¯ä»¥ç”¨æ¥å› ä¸ºæ˜¯ä»åº•å±‚å‘ä¸Šé¢è¿›è¡Œæœç´¢//ç”±äºå­©å­ç¥–å…ˆæœ‰ä¸¤ä¸ªæ‰€ä»¥ä¸Šé¢æœç´¢æ–¹å¼æ¯ä¸€ä¸ªå­©å­çš„ç¥–å…ˆä½œä¸ºå•ç‹¬çš„èŠ‚ç‚¹å†æ¬¡è¿›è¡Œæœç´¢ï¼Œç›´åˆ°é€’æ¨å‡ºå£ä¸ºæ­¢int main()&#123; int n; cin&gt;&gt;n; char ch; int x,fa,ma; for (int i=0;i!=n;i++)&#123; cin&gt;&gt;x; getchar(); cin&gt;&gt;sex[x]; cin&gt;&gt;fa&gt;&gt;ma; if (fa!=-1) people[x].push_back(fa); if (ma!=-1) people[x].push_back(ma); sex[fa]='M'; sex[ma]='F'; &#125; int k; cin&gt;&gt;k; for (int i=0;i!=k;i++)&#123; cin&gt;&gt;fa&gt;&gt;ma; ans=0; if (sex[fa]==sex[ma]) cout&lt;&lt;"Never Mind"&lt;&lt;endl; else&#123; top=0; dfs(fa,0,1); dfs(ma,0,0); if (ans) cout&lt;&lt;"No"&lt;&lt;endl; else cout&lt;&lt;"Yes"&lt;&lt;endl; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>æ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡æ¬¾25ï¼šè€ƒè™‘å†™å‡ºä¸€ä¸ªä¸æŠ›å¼‚å¸¸çš„ swap å‡½æ•°]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE26%EF%BC%9A%E5%B0%BD%E9%87%8F%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E5%87%BA%E7%8E%B0%E7%9A%84%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[å…¶å®è¯¥æ¡æ¬¾æ€»ç»“ä¸‹æ¥å°±æ˜¯å†è®²ä¸€ä¸ªä¸œè¥¿ï¼Œè€Œè¿™ä¸ªä¸œè¥¿åˆ†æˆä¸¤ç‚¹ï¼š å¦‚æœç±»çš„èµ‹å€¼æˆæœ¬ä½äºä¸€ç»„æ„é€ å’Œææ„æˆæœ¬ï¼Œé‚£ä¹ˆå°†å¯¹è±¡çš„å®šä¹‰å®šä¹‰åˆ°å¾ªç¯ä½“å¤–éƒ¨å»ï¼Œå°¤å…¶æ˜¯åœ¨å¾ªç¯æ¬¡æ•°å¾ˆå¤šçš„æƒ…å†µä¸‹ã€‚å¦åˆ™å°±æ˜¯å°†å®šä¹‰å¾ªç¯ä½“å†…éƒ¨ä¸­å»ã€‚ å°½å¯èƒ½å»¶åå˜é‡å®šä¹‰å¼å‡ºç°çš„æ—¶é—´ï¼Œæœ€å¥½è¾¾åˆ°éœ€è¦ä»€ä¹ˆæ‰å»å®šä¹‰ä»€ä¹ˆï¼Œè¿™æ ·åšå¯ä»¥å¢åŠ ç¨‹åºçš„æ¸…æ™°åº¦å¹¶æ”¹å–„ç¨‹åºæ•ˆç‡ã€‚å¦å¤–æœ€å¥½åœ¨ç¨‹åºå®šä¹‰çš„æ—¶å€™å°±ç›´æ¥æ„é€ ï¼ˆåˆå§‹åŒ–ï¼‰ã€‚]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å…³äºæ¨¡æ‹Ÿä¸æœç´¢çš„ç›¸åº”ç®€å•é¢˜ç›®]]></title>
    <url>%2F2018%2F12%2F01%2F%E5%85%B3%E4%BA%8E%E6%A8%A1%E6%8B%9F%E4%B8%8E%E6%90%9C%E7%B4%A2%E7%9A%84%E7%9B%B8%E5%BA%94%E7%AE%80%E5%8D%95%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[é¢˜ç›® ä»£ç å¦‚ä¸‹ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; string w,v; int x,y,m; char ch; while(cin&gt;&gt;w&gt;&gt;v)&#123; string s; int flag=0; reverse(w.begin(),w.end()); reverse(v.begin(),v.end()); if (w.size()&gt;v.size())&#123; m=w.size()-v.size(); for (int i=0;i!=v.size();i++)&#123; x=w[i]-'0'; y=v[i]-'0'; x+=y; if (flag)&#123; flag=0; x++; &#125; if (x&gt;=10)&#123; flag=1; x=x-10; &#125; ch=x+'0'; s.push_back(ch); &#125; int i=v.size(); while (flag==1&amp;&amp;i&lt;=m)&#123; flag=0; x=w[i]-'0'; x++; if (x&gt;=10)&#123; flag=1; x=x-10; &#125; ch=x+'0'; s.push_back(ch); i++; &#125; if (flag&amp;&amp;i==w.size())&#123; s.push_back('1'); &#125; &#125; else &#123; m=v.size()-w.size(); for (int i=0;i!=w.size();i++)&#123; x=w[i]-'0'; y=v[i]-'0'; x+=y; if (flag)&#123; flag=0; x++; &#125; if (x&gt;=10)&#123; flag=1; x=x-10; &#125; ch=x+'0'; s.push_back(ch); &#125; int i=w.size(); while (flag&amp;&amp;i&lt;=m)&#123; flag=0; x=w[i]-'0'; x++; if (x&gt;=10)&#123; flag=1; x=x-10; &#125; ch=x+'0'; s.push_back(ch); i++; &#125; if (flag&amp;&amp;i==v.size())&#123; s.push_back('1'); &#125; &#125; reverse(s.begin(),s.end()); cout&lt;&lt;s&lt;&lt;endl; &#125;&#125; é¢˜è§£ï¼šå…¶å®è¿™é“é¢˜ç›®å±äºä¸€é“ç›¸åº”ç®€å•çš„é¢˜ç›®ï¼Œå°±æ˜¯è¦æ³¨æ„ç›¸åº”stringä¸charä¹‹é—´çš„åŒºåˆ«å°±è¡Œäº†ã€‚å¦å¤– intè½¬æ¢charæ˜¯åŠ ä¸Šâ€˜0â€™charè½¬æ¢intæ˜¯å‡å»â€˜0â€™ã€‚ ä¸€é“ç®€å•çš„dfsçš„é¢˜ç›® ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int maxn = 105;char h[maxn][maxn];int n,m,cnt=0;void dfs(int i,int j)&#123; if (i&lt;0||i&gt;=n||h[i][j]!='W') return ; if (j&lt;0||j&gt;=m||h[i][j]!='W') return ; if (h[i][j]=='W')&#123; h[i][j]='.'; dfs(i-1,j); dfs(i-1,j-1); dfs(i+1,j); dfs(i+1,j+1); dfs(i,j-1); dfs(i-1,j+1); dfs(i,j+1); dfs(i+1,j-1); &#125;&#125;int main()&#123; int ans=0; while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;(n!=0&amp;&amp;m!=0))&#123; for (int i=0;i!=n;i++) for (int j=0;j!=m;j++)&#123; cin&gt;&gt;h[i][j]; &#125; for (int i=0;i!=n;i++)&#123; for (int j=0;j!=m;j++)&#123; if (h[i][j]=='W')&#123; dfs(i,j); ans++; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; ans=0; &#125; return 0;&#125; é¢˜è§£ç®€å•çš„dfsæœç´¢å‡ºæ¯ä¸€ç§æƒ…å†µï¼Œç„¶åè®©å…¶è¿”å›å°±è¡Œäº†ã€‚ ä¸€é“ç»å…¸çš„BFSçš„é¢˜ç›®é¢˜ç›® ä»£ç å¦‚ä¸‹:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;stdio.h&gt;#include&lt;queue&gt;using namespace std;int fxy[4][2]=&#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;//æœç€å››ä¸ªæ–¹å‘char dis[101][101];int kp[101][101];//ä»¥ä¸‹çš„nodeå°±ä½œä¸ºæ¯ä¸€æ¬¡å‰è¿›çš„èŠ‚ç‚¹struct node&#123; int x,y,cnt; node(int a=0,int b=0,int c=0)&#123; x=a; y=b; cnt=c; &#125;&#125;;int main()&#123; int m,n,k,g,k1,g1; while(~scanf("%d %d",&amp;m,&amp;n)) &#123; for(int i=0;i&lt;m;i++) &#123; scanf("%s",dis[i]); &#125; // ç”¨é˜Ÿåˆ—æ•´åˆçš„æ€æƒ³æ¥å®Œæˆ queue&lt;struct node&gt;q; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++)&#123; kp[i][j]=-1; &#125; // ä¸¤ç§åˆå§‹åŒ–è¿‡ç¨‹ï¼Œå¹¶ä¸”æ‰¾åˆ°èµ·ç‚¹ä¸ç»ˆç‚¹çš„æ‰€åœ¨ä½ç½® for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++)&#123; if(dis[i][j]=='S')&#123; k=i; g=j; &#125; if(dis[i][j]=='E')&#123; k1=i; g1=j; &#125; &#125; // å°†èµ·ç‚¹å­˜è¿›å» node a(k,g,0); q.push(a); // ä¸‹é¢å°±æ˜¯ä¸ºbfsçš„ç›¸åº”æœç´¢ while(!q.empty())&#123; struct node now=q.front(); q.pop(); kp[now.x][now.y]=now.cnt; // å°†èµ·ç‚¹èµ°äº†å¤šå°‘æ­¥æ•°ä»¥åŠèµ·ç‚¹çš„åæ ‡ç‚¹å­˜å…¥åˆ°é¢˜ç›®ä¸­å» for(int i=0;i&lt;4;i++)&#123; node next; next.x=now.x+fxy[i][0]; next.y=now.y+fxy[i][1]; // åˆ¤æ–­èµ°çš„ä¸‹ä¸€æ­¥æœ‰æ²¡æœ‰å‡ºç•Œï¼Œæˆ–è€…ä½¿ä¸‹ä¸€æ­¥èµ°çš„ä¸ä¼šç¢°åˆ°è·¯éšœ if(next.x&gt;=0&amp;&amp;next.x&lt;m&amp;&amp;next.y&gt;=0&amp;&amp;next.y&lt;n&amp;&amp;dis[next.x][next.y]!='#'&amp;&amp;kp[next.x][next.y]==-1)&#123; node empt(next.x,next.y,now.cnt+1); q.push(empt); &#125; &#125; &#125; if(kp[k1][g1]==-1) printf("Trapped!\n"); else printf("Escaped in %d minute(s).\n",kp[k1][g1]); &#125; return 0;&#125; è®°ä½ä¸Šé¢ç›¸åº”çš„é˜Ÿåˆ—æ€æƒ³ã€‚ ä¸€é“DFSä¸BFSçš„ç»¼åˆé¢˜==éœ€è¦å¤šèŠ±æ—¶é—´æ¥æ¸©ä¹ ä¸€é== é¢˜ç›® ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;int n,m,k,cnt = 0;int x_begin,x_end,y_begin,y_end;const int maxn = 1005;int dis[maxn][maxn];char ch[maxn][maxn];class Position&#123;public: int x; int y; int distance; public: Position() = default; Position(int a, int b, int c):x(a),y(b),distance(c)&#123;&#125;; Position move(int i);&#125;;Position Position::move(int i)&#123; Position post = *this; if (i == 0) post.x = this -&gt; x + 1; else if (i == 1) post.x = this -&gt; x - 1; else if (i == 2) post.y = this -&gt; y + 1; else if (i == 3) post.y = this -&gt; y - 1; return post;&#125;void bfs()&#123; queue&lt;Position&gt;q_dis; Position p_begin (x_begin,y_begin,0); q_dis.push(p_begin); while(!q_dis.empty())&#123; Position now = q_dis.front(); q_dis.pop(); dis[now.x][now.y]=now.distance; for(int i = 0; i != 4; i++)&#123; Position next; next = now.move(i); if (next.x &gt;= 0 &amp;&amp; next.x &lt; n &amp;&amp; next.y &gt;= 0 &amp;&amp; next.y &lt; m &amp;&amp; dis[next.x][next.y] == -1 &amp;&amp; ch[next.x][next.y] != '#')&#123; Position empt (next.x,next.y,now.distance + 1); q_dis.push(empt); &#125; &#125; &#125;&#125;void dfs(int x,int y)&#123; if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m) return ; if (ch[x][y]=='L') &#123; cnt++; return; &#125; if (dis[x][y] == -1) return; // å‰é¢å·²ç»æœ‰diså¯ä»¥è¡¨ç¤ºæ¯ä¸€æ­¥èµ°çš„è·ç¦»ï¼Œæ‰€ä»¥åªéœ€è¦ä¸€æ­¥ä¸€æ­¥æ¥çœ‹ï¼Œè¿™æ ·çš„åšæ³•ä¾¿å¯ä»¥å®Œå…¨è§„é¿éšœç¢ç‰©ï¼Œå•å•ä»è·¯å¾„ä¸Šé¢è€ƒè™‘ã€‚ if (dis[x][y]==dis[x+1][y]+1) dfs(x+1,y); if (dis[x][y]==dis[x-1][y]+1) dfs(x-1,y); if (dis[x][y]==dis[x][y+1]+1) dfs(x,y+1); if (dis[x][y]==dis[x][y-1]+1) dfs(x,y-1);&#125;int main()&#123; int T,Case = 0; cin&gt;&gt;T; while(T--)&#123; Case++; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; bool f_begin = false,f_end = false; for (int i = 0; i != n; i++)&#123; for (int j = 0; j != m; j++)&#123; cin &gt;&gt; ch[i][j]; dis[i][j] = -1; &#125; &#125; for (int i = 0; i != n; i++)&#123; for (int j = 0; j != m; j++)&#123; if (f_end &amp;&amp; f_begin) break; if (ch[i][j] == 'L')&#123; x_begin = i; y_begin = j; f_begin = true; &#125; if (ch[i][j] == 'C')&#123; x_end = i; y_end = j; f_end = true; &#125; &#125; &#125; bfs(); if (dis[x_end][y_end] == -1 ||dis[x_end][y_end] &gt; k ) cout &lt;&lt; "Case #"&lt;&lt;Case&lt;&lt;": "&lt;&lt;-1&lt;&lt;endl; else&#123; dfs(x_end,y_end); cout&lt;&lt;"Case #"&lt;&lt;Case&lt;&lt;": "&lt;&lt;dis[x_end][y_end]&lt;&lt;" "&lt;&lt;cnt&lt;&lt;endl; cnt = 0; &#125; &#125; return 0;&#125; è¿™é‡Œæ³¨æ˜ä¸€ä¸‹å…³äº==é»˜è®¤å®å‚==çš„çŸ¥è¯†ç‚¹ï¼Œå› ä¸ºåœ¨è¿™ä¸ªåœ°æ–¹å¯ä»¥ç›´æ¥å¯¹ç±»çš„æ„é€ å‡½æ•°èµ‹å€¼ä¸€ä¸ªé»˜è®¤å®å‚ï¼Œå¯ä»¥é¿å…è¾“å…¥é»˜è®¤æ„é€ å‡½æ•°äº†ã€‚ ä¸‹é¢åˆ™æ˜¯ä¸€é“DFSçš„é¢˜ç›®ï¼Œè¿™é“é¢˜ç›®çœ‹ä¸Šå»å¯ä»¥ç”¨bfsæ¥åš ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int maxn = 100;int road[maxn][maxn];int dp[maxn][maxn];int n, m;int dfs (int i,int j)&#123; if (dp[i][j] != -1) return dp[i][j]; int Max = 0; if (i-1&gt;=0 &amp;&amp; road[i][j]&gt;road[i-1][j]&amp;&amp;Max&lt;dfs(i-1,j)) Max = dfs(i-1,j); if(i+1&lt;n &amp;&amp; road[i][j]&gt;road[i+1][j]&amp;&amp;Max&lt;dfs(i+1,j)) Max=dfs(i+1,j); if(j-1&gt;=0 &amp;&amp; road[i][j]&gt;road[i][j-1]&amp;&amp;Max&lt;dfs(i,j-1)) Max=dfs(i,j-1); if(j+1&lt;m &amp;&amp; road[i][j]&gt;road[i][j+1]&amp;&amp;Max&lt;dfs(i,j+1)) Max=dfs(i,j+1); return dp[i][j]=Max+1;&#125;int main()&#123; while (cin &gt;&gt; n &gt;&gt; m) &#123; for (int i = 0; i != n; i++) &#123; for (int j = 0; j != m; j++) &#123; cin &gt;&gt; road[i][j]; dp[i][j] = -1; &#125; &#125; int MAX = -1; for (int i = 0; i != n; i++) &#123; for (int j = 0; j != m; j++) &#123; MAX = max (dfs(i,j),MAX); &#125; &#125; cout &lt;&lt; MAX &lt;&lt; endl; &#125; return 0;&#125; é¢˜è§£ æ­¤é¢˜å…¶å®æœ€é‡è¦çš„å°±åœ¨äºè¿™ä¸ªé¢˜ç›®ä¸åŒäºå…¶ä»–é¢˜ç›®ï¼Œè¿™ä¸ªé¢˜ç›®æ‰¾çš„æ˜¯æœ€é•¿è·¯å¾„ï¼Œè¿˜ä¸æ˜¯æœ€çŸ­è·¯å¾„ï¼Œä¸€èˆ¬æ¥è¯´ï¼ŒBFSæ‰¾çš„æ˜¯æœ€çŸ­è·¯å¾„ï¼ŒDFSæ‰¾çš„æ˜¯æœ€çŸ­è·¯å¾„çš„æ¡æ•°ã€‚è€Œè¿™é‡Œå°±æ˜¯åˆ©ç”¨dfsçš„è¿”å›å€¼ï¼ˆæ¯èµ°ä¸€æ­¥çš„æœ€å¤§å€¼ï¼Œæ„æ€å°±æ˜¯ä»å„ä¸ªè§’åº¦ä¸Šï¼‰è®°å½•åœ¨dpä¸­ï¼Œå°†æ¯ä¸€ä¸ªä½ç½®éƒ½èµ°åˆ°ä¸èƒ½èµ°ä¸ºæ­¢ï¼Œç„¶åå­˜å‚¨åœ¨dpä¸­ï¼Œæœ€åæ‰¾æœ€å¤§å€¼çš„DPå³å¯ã€‚ä¸è¿‡è‡ªå·±å¯ä»¥è¯•è¯•éå†çš„å…¶ä»–æ–¹æ³•ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>æ¨¡æ‹Ÿä¸æœç´¢</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STLçš„ç®€å•æ€»ç»“]]></title>
    <url>%2F2018%2F12%2F01%2FSTL%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[è¡¥ä¸€ä¸ªåŠ å¿«C++è¾“å…¥è¾“å‡ºé€Ÿåº¦çš„æ–¹æ³•ï¼š èŠ±ä¸Šä¸€å¤©çš„æ—¶é—´æ¥æ€»ç»“ C++ primer é‡Œé¢çš„ç®—æ³•ä»¥åŠå®¹å™¨è¿™ä¸€ç« ï¼Œå¤šä½™çš„ç”¨æ³•å¯ä»¥ä¸Šç½‘å»æŸ¥æ‰¾å½“åšæ˜¯ç›¸åº”çš„æ‰©å±•ã€‚ å­—ç¬¦ä¸² stringä¸å­—ç¬¦æ•°ç»„ æ„é€ stringçš„æ–¹æ³• æ“ä½œstringçš„æ–¹æ³• ä¸Šé¢çš„æˆå‘˜å‡½æ•°æœ‰çš„è¯´è¦è¿”å›ï¼ŒåŒæ—¶ï¼Œæœ‰çš„ä¹Ÿå­˜åœ¨ä¸è¿”å›å€¼ã€‚ æœç´¢stringçš„æ–¹æ³• ä»¥ä¸Šå°±æ˜¯findå‡½æ•°çš„ä¸€äº›ç”¨æ³•ï¼Œåœ¨æ³›å‹ç®—æ³•ä¸€ç« ï¼Œè¿˜ä¼šç»§ç»­æ¶‰åŠåˆ°ã€‚é¢˜ç›®è¿”å›çš„æ˜¯ä¸‹æ ‡ è¡¥å……ä¸€ä¸‹å…³äºstringä¸­çš„æ¯”è¾ƒå‡½æ•°ä¸€èˆ¬åœ¨stringä¸­å¯ä»¥ç›´æ¥ç”¨è¿ç®—ç¬¦è¿›è¡Œæ¯”è¾ƒ intä¸stringä¹‹é—´çš„è½¬åŒ– getline()çš„ä¸¤ç§å†™æ³•æ³¨æ„åœ¨cin&gt;&gt;t;å¿…é¡»è¦ä¸€ä¸ªgetchar()æ¥åæ‰å…¶å‰é¢çš„å›è½¦ç¬¦å·ã€‚ä¹‹åæ‰èƒ½ç”¨getline()ã€‚ é¡ºåºå®¹å™¨ å®¹å™¨ç§ç±» vector&lt;vector&lt;int&gt; &gt;æ¥è¡¨ç¤ºäºŒç»´æ•°ç»„ã€‚ å®¹å™¨åŸºç¡€æ“ä½œè¡¥å……ä¸€ä¸ªassignçš„ç”¨æ³•ï¼šå…è®¸ä»ä¸€ä¸ªä¸åŒä½†ç›¸å®¹çš„ç±»å‹é‡Œé¢å»èµ‹å€¼ï¼Œæˆ–è€…ä»å®¹å™¨çš„ä¸€ä¸ªå­åºåˆ—èµ‹å€¼ã€‚ è¿˜æœ‰ç¬¬äºŒä¸ªç‰ˆæœ¬ï¼šæ¥å—ä¸€ä¸ªæ•´å‹å€¼å’Œä¸€ä¸ªå…ƒç´ å€¼ï¼Œç”¨æŒ‡å®šæ•°ç›®ä¸”å…·æœ‰ç›¸åŒç»™å®šå…ƒç´ æ›¿æ¢å®¹å™¨ä¸­åŸæœ‰çš„å…ƒç´ ï¼š å†è¡¥å……ä¸€ä¸ªresizeçš„ç”¨æ³•ï¼š éœ€è¦è®°ä½æœ‰ä¸€äº›ç±»å‹å£°æ˜å¯ä»¥ç›´æ¥ç”¨autoã€‚ åˆå§‹åŒ–æœ‰ä¸¤ç§ä¸€ç§ç›´æ¥åˆå§‹åŒ–å’Œæ‹·è´åˆå§‹åŒ–ã€‚ é¡ºåºå®¹å™¨æ·»åŠ å…ƒç´ ä¸Šé¢å·²ç»åˆ—å‡ºäº†å„ç§å½¢å¼çš„æ’å…¥ã€‚æ’å…¥æ˜¯åœ¨è¿­ä»£å™¨æŒ‡å‘çš„å…ƒç´ ä¹‹å‰æ’å…¥ã€‚æ’å…¥æƒ³è¦æ’å…¥çš„å…ƒç´ å‰é¢ï¼Œæ¯”å¦‚è¯´push_backæ˜¯æ’å…¥åˆ°äº†å°¾åè¿­ä»£å™¨çš„å‰é¢ã€‚è€Œè¿”å›çš„æ˜¯æ–°æ·»åŠ çš„ç¬¬ä¸€ä¸ªå…ƒç´ çš„è¿­ä»£å™¨ï¼ŒåŒæ ·ä¹Ÿå¯ä¹Ÿ==ä¸è¿”å›==ã€‚ è¿™é‡Œè¦æ³¨æ„çš„æ˜¯push_frontä¼šæ”¹å˜æ•´ä¸ªå®¹å™¨çš„è¿­ä»£å™¨æŒ‡å‘ï¼Œè€Œpush_backä¸ä¼šã€‚ è®¿é—®å…ƒç´  é“¾è¡¨ï¼Œå•å‘é“¾è¡¨ï¼Œæ ˆï¼Œé˜Ÿåˆ—éƒ½ä¸æ”¯æŒéšæœºè®¿é—®ï¼Œä¹Ÿå°±ä¸æ”¯æŒä¸‹æ ‡è®¿é—®äº†ã€‚ åˆ é™¤å…ƒç´  åˆ é™¤çš„æ˜¯è¿­ä»£å™¨æŒ‡å‘çš„å…ƒç´ ï¼Œè¿”å›çš„æ˜¯åˆ é™¤å…ƒç´ çš„åè¿­ä»£å™¨ä¹Ÿå°±æ˜¯è¢«åˆ é™¤çš„å…ƒç´ ä¸‹ä¸€ä¸ªå…ƒç´ çš„å‰é¢çš„è¿­ä»£å™¨ï¼ŒåŒæ ·ä¹Ÿå¯ä»¥ä¸è¿”å›ã€‚ è¿™é‡Œéœ€è¦æ³¨æ„çš„å°±æ˜¯åˆ é™¤ä¸€ä¸ªå…ƒç´ ä¹‹åï¼Œå¿…å®šä¼šæ”¹å˜åŸå®¹å™¨ä¸­è¿­ä»£å™¨çš„æŒ‡å‘ï¼Œæ‰€ä»¥åŠ¡å¿…å°å¿ƒï¼ˆé™¤äº†pop_backï¼‰ æ”¹å˜å®¹å™¨å¤§å°çš„æ“ä½œ ç‰¹æ®Šçš„forward_listï¼ˆå•å‘é“¾è¡¨ï¼‰ ç”±äºè¿­ä»£å™¨çš„æ·»åŠ åˆ é™¤æ“ä½œéƒ½æ¶‰åŠåˆ°äº†é¦–å‰å’Œå°¾åï¼Œæ‰€ä»¥å¯¹äºå•å‘é“¾è¡¨æ¥è¯´è¿™é‡Œæ·»åŠ äº†ä¸€ä¸ªé¦–å‰è¿­ä»£å™¨before_beginè€Œå¯¹äºå•å‘é“¾è¡¨çš„æ’å…¥è€Œè¨€ æ˜¯åœ¨å…ƒç´ çš„åé¢è¿›è¡Œæ’å…¥ï¼Œåˆ é™¤ä¹Ÿæ˜¯ä¸€æ ·ï¼ŒæŒ‡å‘éƒ½æ˜¯è¿­ä»£å™¨æŒ‡å‘å…ƒç´ ä¹‹åçš„å…ƒç´ ã€‚ å…³è”å®¹å™¨ **å…³è”å®¹å™¨é‡Œé¢çš„pair å…³è”å®¹å™¨çš„æ“ä½œ å…³è”å®¹å™¨çš„æ·»åŠ æ“ä½œ ä¸€èˆ¬éƒ½æ˜¯ç›´æ¥ç”¨ä¸‹æ ‡æ“ä½œæ·»åŠ mapé‡Œé¢çš„æ“ä½œã€‚atæ“ä½œåªèƒ½åˆ¤æ–­å­˜ä¸å­˜åœ¨ å…³è”å®¹å™¨çš„åˆ é™¤æ“ä½œ å…³è”å®¹å™¨çš„è®¿é—®æ“ä½œ ä¸Šé¢å…³äºæ’åºçš„æ“ä½œä¸é€‚ç”¨äºæ— åºçš„å…³è”å®¹å™¨ã€‚ å½“å…è®¸å…³é”®è¯é‡å¤çš„multimapä¸­æŸ¥æ‰¾å…ƒç´ æ—¶ï¼Œä¸€èˆ¬ä½¿ç”¨findå‡½æ•°ä¸countå‡½æ•°åŒæ—¶è¿›è¡Œã€‚ ç®—æ³•å¤§éƒ¨åˆ†å‡½æ•°ç®—æ³•éƒ½æ”¾åœ¨&lt;algorithm&gt;çš„å¤´æ–‡ä»¶é‡Œé¢äº†ã€‚è¿˜æœ‰ä¸€äº›æ•°å€¼ç®—æ³•æ˜¯æ”¾åœ¨äº†&lt;numeric&gt;çš„å¤´æ–‡ä»¶é‡Œé¢ã€‚ åªè¯»ç®—æ³• accumulate æ±‚å’Œç®—æ³•ï¼Œæ¥å—ä¸‰ä¸ªå‚æ•°ï¼Œå‰é¢ä¸¤ä¸ªå‚æ•°æ˜¯ç´¯åŠ èŒƒå›´ï¼Œç¬¬ä¸‰ä¸ªæ˜¯å’Œçš„åˆå€¼ã€‚equal åˆ¤æ–­ä¸¤ä¸ªåºåˆ—é‡Œé¢æ˜¯å¦æ‰€æœ‰çš„å€¼éƒ½ç›¸åŒã€‚åé¢ç½‘ä¸ŠæŸ¥æ‰¾ æœ‰çš„å†è¡¥å……ã€‚findç®—æ³•binary_search()äºŒåˆ†æŸ¥æ‰¾å‡½æ•°find_end()æœ€åä¸€æ¬¡å‡ºç°ç®—æ³•find_first_of()ç¬¬ä¸€æ¬¡å‡ºç°çš„ç®—æ³•find_if ()ç¬¬ä¸‰ä¸ªå‚æ•°å°±ä¸ºè‡ªå®šä¹‰å‡½æ•°æœç´¢lower_bound()ç¬¬ä¸€ä¸ªä¸å°äºçš„å…ƒç´ upper_bound()ç¬¬ä¸€ä¸ªå¤§äºçš„å…ƒç´ countï¼ˆï¼‰ç®—æ³• è®¡ç®—å‡ºç°æ¬¡æ•°count_ifï¼ˆï¼‰å‡½æ•°è‡ªå®šä¹‰è®¡æ•° å†™å®¹å™¨çš„ç®—æ³• fill å¡«å……ç®—æ³• ç±»ä¼¼äºmemsetå‡½æ•°å‰è€…åœ¨äºå¯ä»¥èµ‹å€¼èµ‹ä»»ä½•å€¼ï¼Œè€Œåè€…ç†è®ºä¸Šåªèƒ½èµ‹å€¼0æˆ–è€…1æˆ–è€…0x3f3f3f3fã€‚fill_nä¹Ÿæ˜¯ä¸‰ä¸ªå‚æ•°ï¼Œç¬¬ä¸€ä¸ªæ˜¯å¼€å§‹ç‚¹ï¼Œç¬¬äºŒä¸ªæ˜¯èµ‹å€¼æ•°ç›®ï¼Œç¬¬ä¸‰ä¸ªä¸ºèµ‹å€¼åˆå§‹åŒ–ã€‚copy æ‹·è´ç®—æ³•ï¼Œæ¥æ”¶ä¸‰ä¸ªè¿­ä»£å™¨ï¼Œå‰é¢ä¸¤ä¸ªè¡¨ç¤ºè¾“å…¥èŒƒå›´ï¼Œç¬¬ä¸‰ä¸ªä¸ºæ‹·è´ç›®æ ‡åºåˆ—çš„èµ·ç‚¹ã€‚replace æ›¿æ¢ç®—æ³•ï¼Œå°†ç›®æ ‡åºåˆ—é‡Œé¢çš„æŸäº›å€¼æ›´æ”¹æˆæŸäº›å€¼ï¼Œæ¥å—å››ä¸ªå‚æ•°ï¼Œå‰é¢ä¸¤ä¸ªæ˜¯ç›®æ ‡åºåˆ—çš„èŒƒå›´ï¼Œç¬¬ä¸‰ä¸ªæ˜¯è¦æœç´¢çš„å€¼ï¼Œç¬¬å››ä¸ªæ˜¯è¦å°†æœç´¢åˆ°çš„ç¬¬ä¸‰ä¸ªçš„å€¼æ›´æ”¹åçš„å€¼ã€‚remove å»é™¤æ‰å‡½æ•°é‡Œé¢åŒ…æ‹¬çš„å‚æ•°çš„å…ƒç´ ã€‚remove_if è‡ªå®šä¹‰ã€‚remove_copy æ‹·è´ç»“æœã€‚swapï¼ˆï¼‰äº¤æ¢ä¸¤ä¸ªå¯¹è±¡çš„å€¼ã€‚swap_range()äº¤æ¢ä¸¤ä¸ªåºåˆ—çš„å€¼ã€‚ é‡æ’å®¹å™¨çš„ç®—æ³• å…¶æ’åºçš„ç®—æ³•ä¸­ï¼Œå®šä¹‰çš„æ’åºæ–¹å¼å°±åœ¨äºè‡ªå®šä¹‰å‡½æ•°ä¼ å…¥ç®—æ³•ä¸­ã€‚æœ‰ä¸‰ç§è‡ªå®šä¹‰å‡½æ•°ï¼š æ™®é€šboolå‹è‡ªå®šä¹‰å‡½æ•°ï¼Œæ¯”è¾ƒæ’åˆ—é¡ºåºã€‚ lambda åŒ¿åå°å‡½æ•°ã€‚ bind å‡½æ•° ç»‘å®šè°“è¯ã€‚çµæ´»çš„åº”ç”¨è‡ªå®šä¹‰å‡½æ•°ã€‚ unique å°†å®¹å™¨ä¸­æ‰€æœ‰é‡å¤çš„å€¼å…¨éƒ¨æ’åˆ—åˆ°åé¢å»ï¼Œæ¥å—ç›®æ ‡åºåˆ—çš„è¿­ä»£å™¨èŒƒå›´ï¼Œè¿”å›æŒ‡å‘ç¬¬ä¸€ä¸ªé‡å¤å…ƒç´ çš„è¿­ä»£å™¨ã€‚sort æ’åº æœ¬è´¨ä¸Šè¿ç”¨çš„æ˜¯å¿«é€Ÿæ’åºã€‚stable_sort æœ¬è´¨ä¸Šè¿åŠ¨çš„æ˜¯å½’å¹¶æ’åºã€‚stable_partition å‰é¢è¿›è¡Œæ’åºåï¼ŒæŠŠè‡ªå®šä¹‰æ’åˆ—çš„åˆ†å‰²å¼€æ¥ã€‚reverse å€’æ’å‡½æ•°ã€‚reverse_copy å€’æ’å‡½æ•°ã€‚rotate æ¥å—ä¸‰ä¸ªå‚æ•°ï¼Œå‰é¢ä¸¤ä¸ªæ˜¯è¦å¾€åé¢æ’çš„èŒƒå›´ã€‚ è¿­ä»£å™¨ æ’å…¥è¿­ä»£å™¨back_inserter ç±»ä¼¼äºpush_backçš„è¿­ä»£å™¨ï¼Œåˆ›å»ºå¹¶ä¸”ä½¿ç”¨front_inserter åˆ›å»ºå¹¶ä¸”ä½¿ç”¨ä¸€ä¸ªpush_frontçš„è¿­ä»£å™¨inserter åˆ›å»ºä¸€ä¸ªæ™®é€šæ’å…¥çš„è¿­ä»£å™¨ æµè¿­ä»£å™¨istream_iterator è¾“å…¥è¿­ä»£å™¨ ostream_iterator è¾“å‡ºè¿­ä»£å™¨ åå‘è¿­ä»£å™¨reverse_iterator ç§»åŠ¨è¿­ä»£å™¨åé¢å¤ä¹ åˆ°åœ¨æ€»ç»“ ç§»åŠ¨ã€æ‹·è´ã€å³å€¼å¼•ç”¨ã€‚]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡æ¬¾03ï¼šå°½å¯èƒ½ä½¿ç”¨ const]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE03%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8%20const%2F</url>
    <content type="text"><![CDATA[é¦–å…ˆä½¿ç”¨ const å¯ä»¥é˜²æ­¢åæœŸè«åå…¶å¦™çš„è¿›è¡Œæ”¹å˜åŸæœ‰çš„æ„æ€ï¼Œç›¸å½“äºä¸€ä¸ªçº¦æŸè¯­ä¹‰ï¼Œå¦å¤–ç¼–è¯‘å™¨ä¸è®ºä»€ä¹ˆæ—¶å€™éƒ½ä¼šå¼ºåˆ¶æ–½è¡Œè¿™é¡¹çº¦æŸã€‚ const åœ¨ C++ 11 ä¸­æœ‰åº•å±‚å’Œé¡¶å±‚ä¹‹åˆ†ï¼Œå‰è€…æ˜¯ä½œç”¨äºæŒ‡é’ˆæœ¬èº«ï¼ŒæŒ‡é’ˆä¸å†æ”¹å˜æŒ‡å‘å¯¹è±¡ï¼Œè€Œé¡¶å±‚ const åˆ™æ˜¯æŒ‡é’ˆæ‰€æŒ‡å‘çš„å¯¹è±¡åˆ™ä¸èƒ½å‘ç”Ÿæ”¹å˜ã€‚ const æœ€å…·å¨åŠ›çš„ç”¨æ³•å®åœ¨é¢å¯¹å‡½æ•°å£°æ˜æ—¶çš„ç”¨æ³•ï¼Œåœ¨ä¸€ä¸ªå‡½æ•°çš„å£°æ˜å¼é‡Œï¼Œconst å¯ä»¥å’Œå‡½æ•°çš„è¿”å›å€¼ï¼Œå„è‡ªçš„å‚æ•°ä»¥åŠå‡½æ•°è‡ªèº«äº§ç”Ÿå…³è”ã€‚ å°†å¼•ç”¨å‚æ•°è®¾ç½®æˆ const å¥½å¤„æ˜¯åœ¨åé¢å†™ä»£ç çš„è¿‡ç¨‹ä¸­å¦‚æœæŠŠ==å†™æˆ=ï¼Œå¯ä»¥ç«‹é©¬ç”„åˆ«å‡ºæ¥ã€‚ const æˆå‘˜å‡½æ•°å­˜åœ¨çš„ä¸¤ä¸ªç†ç”±ï¼Œä¸€ä¸ªä½¿ class çš„æ¥å£ä¸€ç›®äº†ç„¶ï¼Œå› ä¸ºçŸ¥é“äº†å“ªäº›å¯ä»¥è¢«æ”¹åŠ¨å¯¹è±¡è€Œå“ªäº›ä¸å¯ä»¥è¢«æ”¹åŠ¨å¯¹è±¡ï¼Œç¬¬äºŒåˆ™æ˜¯åŸºäºä»£ç ç¼–å†™çš„é«˜æ•ˆæ€§è€Œè¨€ï¼Œæ“ä½œ const å¯¹è±¡æˆä¸ºå¯èƒ½ï¼Œå› ä¸ºå¯ä»¥é€šè¿‡ const æˆå‘˜å‡½æ•°è¿”å› const å¯¹è±¡ã€‚ å­˜åœ¨ä¸€ç§ç‰¹æ®Šæƒ…å†µï¼Œé‡è½½[ ]è¿ç®—ç¬¦çš„æ—¶å€™ï¼Œå¦‚æœæˆå‘˜å‡½æ•°æ˜¯ const é‚£ä¹ˆå…¶çš„è¿”å›å€¼ä¹Ÿå¿…é¡»æ˜¯ const&amp;ç±»å‹çš„ã€‚ å¦‚æœå¯¹äºconst æˆå‘˜å‡½æ•°ï¼Œæƒ³è¦æ”¹å˜è¯¥å¯¹è±¡çš„å†…éƒ¨æˆå‘˜çš„è¯ï¼Œä½†æ˜¯åˆä¸æƒ³å…¨éƒ¨æ”¹å˜çš„è¯ï¼Œå¯ä»¥åœ¨ç±»ä¸­çš„æ•°æ®æˆå‘˜å®šä¹‰ä¸­åŠ ä¸Š mutableï¼Œæ¥ä¿è¯å¯ä»¥æ”¹å˜è¯¥å‡½æ•°ï¼Œå…¶å­˜åœ¨çš„æ„ä¹‰å°±åœ¨äºä¿è¯äº†å…¶ä»–æ•°æ®æˆå‘˜ä¸èƒ½è¢« const æˆå‘˜å‡½æ•°æ”¹å˜ï¼Œä½†æ˜¯è¯¥æ•°æ®æˆå‘˜å´å¯ä»¥ã€‚ 7.å½“ const å’Œ non-const æˆå‘˜å‡½æ•°æœ‰å®è´¨ç­‰ä»·çš„å®ç°æ—¶ï¼Œä»¤ non-const ç‰ˆæœ¬è°ƒç”¨ const ç‰ˆæœ¬å¯é¿å…ä»£ç é‡å¤ã€‚ è¿™ä¸€ç‚¹è¿˜ä¸æ˜¯ç‰¹åˆ«äº†è§£ï¼Œéœ€è¦çœ‹åˆ°åé¢ä¹‹åèŠ±ç‚¹æ—¶é—´æ¥çœ‹çœ‹è¿™ä¸€ç‚¹çš„å†…å®¹ã€‚]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡æ¬¾05ï¼šäº†è§£ C++é»˜é»˜ç¼–å†™å¹¶è°ƒç”¨äº†å“ªäº›å‡½æ•°]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE05%EF%BC%9A%E4%BA%86%E8%A7%A3%20C%2B%2B%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[å‡ ä¹æ¯ä¸€ä¸ª class éƒ½ä¼šç”¨ä¸€ä¸ªæˆ–å¤šä¸ªæ„é€ å‡½æ•°ï¼Œä¸€ä¸ªææ„å‡½æ•°ï¼Œä¸€ä¸ªæ‹·è´é‡è½½è¿ç®—ç¬¦ï¼Œæœ‰äº›æ˜¯ç³»ç»Ÿè‡ªåŠ¨ç”Ÿæˆçš„åˆæˆç‰ˆæœ¬ï¼Œæœ‰äº›æ˜¯éœ€è¦è‡ªå®šä¹‰çš„ç‰ˆæœ¬ï¼Œæ‰€ä»¥è¿™ä¸€æ¡æ¬¾çš„ç›®çš„æ˜¯ä¸ºäº†æ¢å¯»å“ªäº›æ˜¯éœ€è¦è‡ªå·±å»å†™ï¼Œå“ªä¸€äº›æ˜¯éœ€è¦ç³»ç»Ÿè‡ªèº«åˆæˆçš„ã€‚ åƒä¸‡ä¸è¦å†™å®Œæ„é€ å‡½æ•°æˆ–è€…æ‹·è´æ„é€ å‡½æ•°æˆ–è€…æ˜¯ææ„å‡½æ•°ä¹‹åä¸å»å®šä¹‰ï¼Œé‚£ä¹ˆä¼šé€ æˆé—®é¢˜ï¼Œè€Œä¸”æ­¤ç±»é—®é¢˜ä¼šé€ æˆå¾ˆå¤šæ–¹é¢ä¸Šçš„æ— æ³•é€‚åº”é—®é¢˜ã€‚ å¦å¤–è¿™é‡Œé¢å¤–éœ€è¦æ³¨æ„çš„æ˜¯ C++11ä¸Šå¢åŠ çš„ç§»åŠ¨è¯­ä¹‰ï¼Œåªæœ‰åœ¨æ‹¥æœ‰äº†æ‹·è´æ„é€ å‡½æ•°å’Œæ‹·è´èµ‹å€¼è¿ç®—ç¬¦ä¹‹åï¼Œç¼–è¯‘å™¨æ‰ä¼šè‡ªåŠ¨ç”Ÿæˆç§»åŠ¨æ„é€ å‡½æ•°ï¼Œå’Œç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦ã€‚ æœ€åè¿™ä¸ªæ¡æ¬¾éœ€è¦æ³¨æ„çš„å°±æ˜¯ç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆçš„å‡½æ•°å…·æœ‰æ™®éæ€§ï¼Œæ‰€ä»¥å°±ä¸å…·æœ‰ç‰¹å¼‚æ€§ï¼Œä¸€äº›ç‰¹æ®Šçš„æ“ä½œåœ¨åˆæˆç‰ˆæœ¬ä¸Šé¢å¯èƒ½ä¼šå‡ºç°å¤§é—®é¢˜ã€‚]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡æ¬¾01ï¼šè§† C++ ä¸ºä¸€ä¸ªè¯­è¨€è”é‚¦]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE01%EF%BC%9A%E8%A7%86%20C%2B%2B%20%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6%2F</url>
    <content type="text"><![CDATA[ç°åœ¨å‘å±•çš„C++å·²ç»æ˜¯ä¸€ä¸ªå¤šé‡æ³›å‹ç¼–ç¨‹è¯­è¨€ã€‚ ä¸€ä¸ªåŒæ—¶æ”¯æŒè¿‡ç¨‹å½¢å¼ã€æ”¯æŒé¢å‘å¯¹è±¡å½¢å¼ã€å‡½æ•°å½¢å¼ã€æ³›å‹å½¢å¼ã€å…ƒç¼–ç¨‹å½¢å¼çš„è¯­è¨€ï¼Œè¿™äº›èƒ½åŠ›å’Œå¼¹æ€§ä½¿ C++æˆä¸ºäº†ä¸€ä¸ªæ— å¯åŒ¹æ•Œçš„å·¥å…·ã€‚å¯¹å¾…å…¶çš„æ–¹å¼æœ€ç®€å•çš„æ–¹æ³•æ˜¯å°†å…¶çœ‹åšæ˜¯ä¸€ä¸ªç”±ç›¸å…³è¯­è¨€ç»„æˆçš„ä¸€ä¸ªè”é‚¦è€Œä¸æ˜¯æŸä¸ªæ¬¡è¯­è¨€ã€‚ C è¯´åˆ°åº• C++ ä»ç„¶æ˜¯ C çš„ä¸€ä¸ªå»¶ä¼¸ï¼Œé¢å¯¹è¿‡ç¨‹çš„ç¼–ç¨‹æ€æƒ³ä»ç„¶åœ¨æŸäº›æ—¶å€™å¾ˆå—ç”¨ï¼Œè€ŒæŸäº›æ—¶åˆ» C++ çš„è§£æ³•åªä¸è¿‡å°±æ˜¯æ¯” C é«˜çº§äº†ä¸€ç‚¹ç‚¹ï¼Œä½†æ˜¯å½“ä½ ä»¥ C++çš„å†… C æˆåˆ†çš„å·¥ä½œçš„æ—¶å€™ï¼Œé«˜æ•ˆç¼–ç¨‹åˆ™æ˜ ç…§å‡ºäº† C è¯­è¨€çš„å±€é™ï¼Œæ²¡æœ‰æ¨¡æ¿ï¼Œæ²¡æœ‰å¼‚å¸¸ï¼Œæ²¡æœ‰é‡è½½ã€‚ Object-Oriented C++ è¿™éƒ¨åˆ†ä¹Ÿå°±æ˜¯ C++ ä¸­é¢å¯¹å¯¹è±¡ç¼–ç¨‹æ€æƒ³çš„ç›´æ¥ä½“ç°ï¼Œç®€å•æ¥è¯´å°±æ˜¯ C with class æ¯”å¦‚ ç±»ï¼Œå°è£…ï¼Œç»§æ‰¿ï¼Œå¤šæ€ï¼Œè™šå‡½æ•°çš„åŠ¨æ€ç»‘å®šã€‚ Template C++ è¿™æ˜¯ C++ä¸­çš„æ³›å‹ç¼–ç¨‹éƒ¨åˆ†ï¼Œtemplate çš„ç›¸å…³è€ƒè™‘ä¸è®¾è®¡å·²ç»å¼¥æ¼«äº†æ•´ä¸ª C++ è€Œè¿™ç§ç¼–ç¨‹æ€æƒ³çš„å¼ºå¤§ï¼Œç›´æ¥å¸¦æ¥äº†å…¨æ–°çš„åå­— æ¨¡æ¿å…ƒç¼–ç¨‹ï¼Œåé¢å¾—èŠ±ä¸Šå¤§éƒ¨åˆ†æ—¶é—´å»ä¸“ç ”è¿™ä¸ªã€‚ STL åŸºæœ¬ä¸ŠåŒ…æ‹¬ å®¹å™¨ï¼Œè¿­ä»£å™¨ï¼Œç®—æ³•ä»¥åŠç›¸åº”çš„å‡½æ•°å¯¹è±¡ï¼Œä¸€èˆ¬ç«èµ›å¯èƒ½ä¼šç›´æ¥ç”¨åˆ°é‡Œé¢çš„ç›¸å…³å®¹å™¨ä»¥åŠç›¸å…³ç®—æ³•ï¼Œç†Ÿç»ƒä½¿ç”¨ STL ä¹Ÿæ˜¯ä¸€å C++ ç¨‹åºå‘˜åº”è¯¥å¿…å¤‡çš„ç´ è´¨ã€‚]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡æ¬¾06ï¼šè‹¥ä¸æƒ³ä½¿ç”¨ç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆçš„å‡½æ•°ï¼Œå°±åº”è¯¥æ˜ç¡®æ‹’ç»]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE06%EF%BC%9A%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E5%BA%94%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D%2F</url>
    <content type="text"><![CDATA[æœ‰çš„æ—¶å€™é‰´äºæŸäº›æƒ…å†µï¼Œæ¯”å¦‚æ™ºèƒ½æŒ‡é’ˆä¸­ unique_str å’Œ io åº“å¯¹è±¡æ— æ³•å‘ç”Ÿæ‹·è´å’Œèµ‹å€¼ï¼Œæ˜¯å› ä¸ºæ˜ç¡®åœ¨ç±»çš„å†…éƒ¨è¿›è¡Œäº†æ‹’ç»æ“ä½œï¼Œæ‰€ä»¥æ— æ³•æ‹·è´ä¸èµ‹å€¼ï¼Œè¿™ä¸€ä¸ªæ¡æ¬¾å°±æ¥è®²è§£æœ‰å“ªäº›æ–¹æ³•å¯ä»¥ç”¨æ¥æ‹’ç»ã€‚ æŠŠè‡ªå·±ä¸æƒ³è¦çš„å‡½æ•°ï¼Œä½†æ˜¯ç³»ç»Ÿé»˜è®¤åˆä¼šç”Ÿæˆçš„å‡½æ•°æ”¾åˆ°ç§æœ‰æˆå‘˜ä¸­ï¼Œè¿™ç§æ–¹æ³•å¾ˆç®€ä¾¿ï¼Œä½†æ˜¯æœ‰ä¸€ä¸ªç¼ºç‚¹å°±æ˜¯åœ¨ç±»çš„å†…éƒ¨å®šä¹‰ä¸­ä»ç„¶æ˜¯å¯ä»¥ä½¿ç”¨æ‹·è´ä¸èµ‹å€¼åŠŸèƒ½çš„ã€‚ ç»§æ‰¿ä¸€ä¸ªåŸºç±»ï¼Œä½¿ç”¨ private ç»§æ‰¿æ–¹æ³•ï¼Œç„¶åå°†è¿™ä¸ªåŸºç±»çš„å‡½æ•°æ”¾å…¥ç§æœ‰æˆå‘˜ä¸­ï¼Œè¿™æ ·å°±å¯ä»¥ä¿è¯ä¸‡æ— ä¸€å¤±çš„æ–¹æ³•ï¼Œä½†æ˜¯ç¼ºç‚¹å°±æ˜¯å¤ªå¤æ‚ï¼Œè¿˜éœ€è¦å®šä¸€ä¸ªåŸºç±»ã€‚ C++11 æå‡ºçš„æ–°åŠæ³•å°†å‡½æ•°å£°æ˜å‡ºæ¥ï¼Œä¸ä»…ä¸å»å®šä¹‰ï¼Œè€Œä¸”ç›´æ¥å£°æ˜æˆ deleteã€‚è¿™æ ·æ›´ä¾¿æ·ã€‚]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡æ¬¾02ï¼šå°½é‡ä»¥const,enum,inline æ›¿æ¢æ‰#define]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE02%EF%BC%9A%E5%B0%BD%E9%87%8F%E4%BB%A5const%2Cenum%2Cinline%20%E6%9B%BF%E6%8D%A2%E6%8E%89%23define%2F</url>
    <content type="text"><![CDATA[è¿™ä¸ªæ¡æ¬¾å…¶å®ä¹Ÿå°±ç›¸å½“äºå®å¯ç¼–è¯‘å™¨æ›¿æ¢é¢„å¤„ç†å™¨æ¯”è¾ƒå¥½ 1. å¯¹äºå•çº¯å¸¸é‡è€Œè¨€ï¼Œä½¿ç”¨ const å¯¹è±¡æˆ–è€…æ˜¯ enums æ¯” #define æ›´åŠ çœæ—¶é—´ æ—¶é—´ä¸Šæ›´ä¸ºèŠ‚çœ ä½œä¸ºä¸€ä¸ªè¯­è¨€å¸¸é‡è€Œä¸æ˜¯åç§°è®°å·ï¼Œç”±äºåœ¨å‡½æ•°ä½“ä¸­åˆ†é…äº†å†…å­˜ï¼Œè¿½å¯»èµ·æ¥æ¶ˆè€—çš„æ—¶é—´æ¯”åœ¨å‡½æ•°ä¸­ä½¿ç”¨åç§°è®°å·æ‰€èŠ±çš„æ—¶é—´æ›´å°‘ï¼Œå› ä¸ºæœ‰å®å¤„æ›´å®¹æ˜“å¯»æ‰¾ï¼Œä¸åƒåç§°è®°å·ï¼Œå¯èƒ½æœ‰çš„æ—¶å€™å¹¶æ²¡æœ‰è¿›å…¥åˆ°è®°å·è¡¨ä¸­ã€‚ è¿˜æœ‰ä¸€äº›å…¶ä»–çš„åªèƒ½ä½¿ç”¨ const æƒ…å†µ å®šä¹‰å¸¸é‡æŒ‡é’ˆå’Œç±»çš„ä¸“å±å¸¸é‡]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡æ¬¾07ï¼šä¸ºå¤šæ€åŸºç±»å£°æ˜ virtual ææ„å‡½æ•°]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE07%EF%BC%9A%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8E%20virtual%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[åœ¨è¿›è¡ŒåŸºç±»ä¸æ´¾ç”Ÿç±»ä¹‹é—´åŠ¨æ€ç»‘å®šçš„æ—¶å€™ï¼Œå¦‚æœå‘ç”Ÿå¯¹è±¡é”€æ¯è°ƒç”¨çš„ææ„å‡½æ•°ä¸æ˜¯è™šå‡½æ•°çš„è¯ï¼Œé‚£ä¹ˆå°±ä¼šé€ æˆææ„é”€æ¯éƒ¨åˆ†çš„ç°è±¡ã€‚ C++æ˜ç¡®æŒ‡å‡ºï¼Œå½“ derived class å¯¹è±¡ç»ç”±ä¸€ä¸ª base classæŒ‡é’ˆè¢«åˆ é™¤ï¼Œè€Œè¯¥ base class å¸¦ç€ä¸€ä¸ªä¸æ˜¯è™šå‡½æ•°çš„ææ„å‡½æ•°çš„è¯ï¼Œå…¶ç»“æœå¾€å¾€éƒ½æ˜¯è‡ªå®šä¹‰çš„ï¼Œå°±åƒä¸Šè¿°çš„è¯´æ³•è€Œè¨€ï¼Œå¾€å¾€æ˜¯å¯¹è±¡çš„ derived æˆåˆ†æ²¡æœ‰è¢«é”€æ¯ï¼Œè€Œä¸”æ¶ˆé™¤è¿™ä¸ªé—®é¢˜æœ€ç®€å•çš„åŠæ³•æ˜¯åœ¨åŸºç±»çš„ææ„å‡½æ•°ä¸Šé¢åŠ ä¸Šè™šå‡½æ•°çš„å£°æ˜ã€‚ ä¸è¦éšä¾¿ç»§æ‰¿æ ‡å‡†åº“é‡Œé¢çš„ä¸œè¥¿ï¼Œå› ä¸ºé‡Œé¢å¤§éƒ¨åˆ†ä¸œè¥¿éƒ½ä¸å­˜åœ¨è™šå‡½æ•°çš„ææ„å‡½æ•°ï¼Œè¿™æ ·ä¸€æ¥ï¼Œå¦‚æœä½¿ç”¨åŠ¨æ€ç»‘å®šçš„è¯ï¼Œé‚£ä¹ˆåœ¨é”€æ¯å¯¹è±¡çš„è¿‡ç¨‹ä¸­å°±æ²¡æœ‰åŠæ³•å…¨éƒ¨é”€æ¯äº†ã€‚ è€Œä¸”ä¸ä¸€å®šæ˜¯åŸºç±»çš„ææ„å‡½æ•°è®¾ç½®æˆè™šå‡½æ•°ï¼Œåªè¦ç±»é‡Œé¢æœ‰ä¸€ä¸ªå‡½æ•°æ˜¯è™šå‡½æ•°çš„è¯ï¼Œé‚£ä¹ˆå°±éœ€è¦å°†ææ„å‡½æ•°å®šä¹‰æˆè™šå‡½æ•°ã€‚ ç±»çš„ç”¨é€”ä¸æ˜¯ä½œä¸ºå¤šæ€çš„ç”¨é€”çš„è¯ï¼Œé‚£ä¹ˆè¯·ä¸è¦å°†ææ„å‡½æ•°å£°æ˜æˆè™šå‡½æ•°ï¼Œå› ä¸ºé‚£æ ·æ²¡æœ‰ä½œç”¨ã€‚ å¯¹äºä¸€ä¸ªçº¯è™šå‡½æ•°è€Œè¨€ï¼Œè¿™ä¸ªç±»å°±æ˜¯ä¸€ä¸ªæŠ½è±¡ç±»ï¼Œä½†æ˜¯ç”±äºå­˜åœ¨ä¸€ä¸ªææ„å‡½æ•°ï¼Œæ‰€ä»¥ä¸€èˆ¬è¦ä¸ºè¿™ä¸ªçº¯è™šå‡½æ•°æä¾›å®šä¹‰ï¼Œå…¶çš„è¿ä½œæ–¹å¼æ˜¯æœ€æ·±å±‚æ´¾ç”Ÿçš„é‚£ä¸ªç±»çš„ææ„å‡½æ•°æœ€å…ˆè¢«è°ƒç”¨ï¼Œç„¶åå°±æ˜¯æ¯ä¸€ä¸ªåŸºç±»çš„ææ„å‡½æ•°è¢«è°ƒç”¨ï¼Œæ‰€ä»¥ç¼–è¯‘å™¨ä¼šåœ¨æ´¾ç”Ÿç±»çš„ææ„å‡½æ•°ä¸­å®šä¸€ä¸ªå¯¹åŸºç±»çº¯è™šææ„å‡½æ•°çš„è°ƒç”¨åŠ¨ä½œï¼Œå› æ­¤ï¼Œä¸€èˆ¬éƒ½å¾—è¿›è¡Œè°ƒç”¨ã€‚]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡æ¬¾04ï¼šç¡®å®šå¯¹è±¡è¢«ä½¿ç”¨å‰å·²å…ˆè¢«åˆå§‹åŒ–]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE04%EF%BC%9A%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[åœ¨ C è¯­è¨€ä¸­å¯¹è±¡çš„åˆå§‹åŒ–å¯èƒ½ä¼šå˜å¾—å¼‚å¸¸å®¹æ˜“ï¼Œä½†æ˜¯åœ¨ C++ä¸­æŸäº›è¯­å¢ƒä¸‹è¿›è¡Œå¯¹è±¡å¯èƒ½ä¸ä¼šå­˜åœ¨è‡ªåŠ¨çš„åˆå§‹åŒ–è¿‡ç¨‹ï¼Œä¹Ÿè®¸ä¼šåœ¨ä½¿ç”¨ C part of C++ ä¼šè‡ªåŠ¨æœ‰ä¸€ä¸ªåˆå§‹åŒ–è¿‡ç¨‹ï¼Œä½†æ˜¯åœ¨å…¶ä»–éƒ¨åˆ†ä¸‹é¢çš„ C++å°±ä¸èƒ½ä¿è¯åˆå§‹åŒ–è¿‡ç¨‹äº†ã€‚ ç‰¹åˆ«æ˜¯åœ¨ç±»çš„è¿‡ç¨‹ä¸­ï¼Œåˆå§‹åŒ–çš„è¿‡ç¨‹ä¸€èˆ¬ç›´æ¥äº¤ç»™æ„é€ å‡½æ•°ï¼Œåˆå§‹åŒ–çš„è¿‡ç¨‹å¹¶ä¸ç­‰åŒäºèµ‹å€¼ï¼Œæ‰€ä»¥åœ¨å†™ç±»çš„æ„é€ å‡½æ•°çš„æ—¶å€™ï¼Œå°½é‡ä¸è¦åœ¨å‡½æ•°ä½“é‡Œé¢å†™èµ‹å€¼ç»™ç§æœ‰æˆå‘˜çš„è¯­å¥ï¼Œå¯ä»¥ç›´æ¥åœ¨åˆ—è¡¨ä¸Šé¢ç›´æ¥å†™åˆå§‹åŒ–çš„ã€‚ å¯¹äºæ‹¥æœ‰å¤šä¸ªæ„é€ å‡½æ•°ï¼Œä¸”æ¯ä¸ªæ„é€ å‡½æ•°å…·æœ‰è‡ªå·±çš„æˆå‘˜åˆå€¼åˆ—ï¼Œå¦‚æœè¿™äº›ç±»å­˜åœ¨è®¸å¤šæˆå‘˜å˜é‡æˆ–è€…åŸºç±»çš„è¯ï¼Œå¤šç§æˆå‘˜åˆå§‹åˆ—è¡¨å°±ä¼šå¯¼è‡´ä¸å—æ¬¢è¿çš„é‡å¤ï¼Œé‚£ä¹ˆè¿™ä¸ªæ—¶å€™å¯ä»¥é—æ¼ä¸€äº›â€œèµ‹å€¼è·Ÿåˆå§‹åŒ–è¿‡ç¨‹å·®ä¸è¯»çš„æˆå‘˜å˜é‡â€ï¼Œæ”¹ç”¨ä»–ä»¬çš„èµ‹å€¼æ“ä½œï¼Œå¹¶ä¸”æŠŠè¿™äº›æ“ä½œæ”¾ç½®åœ¨ private ä¸­ã€‚ C++æœ‰ç€ååˆ†å›ºå®šçš„æˆå‘˜åˆå§‹åŒ–è¿‡ç¨‹ï¼ŒåŸºç±»çš„åˆå§‹åŒ–ä¼šæ—©äºæ´¾ç”Ÿç±»ï¼Œè€Œç±»çš„æˆå‘˜å˜é‡æ€»æ˜¯ä»¥å…¶å£°æ˜çš„æ¬¡åºè¢«åˆå§‹åŒ–ã€‚ å…³äºç±»çš„é™æ€æˆå‘˜çš„åˆå§‹åŒ– ä¸€èˆ¬åœ¨ç±»å†…éƒ¨è¿›è¡Œå£°æ˜ï¼Œç„¶åå†ç±»çš„å¤–éƒ¨è¿›è¡Œå®šä¹‰ï¼Œèµ‹å€¼ï¼Œå…¶çš„å£°æ˜å‘¨æœŸä¸€èˆ¬æ˜¯ä»ç¨‹åºå¼€å§‹åˆ°ç¨‹åºç»“æŸã€‚ æ„é€ å‡½æ•°åˆå§‹åŒ–çš„æ¬¡åºéå¸¸é‡è¦ï¼Œä¸¾ä¸ªä¾‹å­å°±æ˜¯åˆå§‹åŒ–çš„æ—¶å€™å¿…é¡»è¦ä¸ºæ•°ç»„æŒ‡å®šå¤§å°ï¼Œæ‰€ä»¥æŒ‡å®šå¤§å°çš„å˜é‡å¿…é¡»å…·æœ‰å…ˆå€¼ å¯¹äºä¸åŒäººåœ¨ä¸åŒæ—¶é—´ä¸‹ä¸åŒçš„æºç æ–‡ä»¶å»ºç«‹èµ·æ¥ï¼Œå…¶çš„åˆå§‹åŒ–ç›¸å¯¹æ¬¡åºå¹¶æ²¡æœ‰æ˜ç¡®å®šä¹‰ï¼Œæ‰€ä»¥è§£å†³åŠæ³•å°±æ˜¯å°†ä¸€ä¸ªå¯¹è±¡æ¬åˆ°è‡ªå·±çš„ä¸“å±å‡½æ•°é‡Œé¢å»ï¼Œç„¶åå£°æ˜æˆé™æ€æˆå‘˜ï¼Œå¹¶ä¸”è¿”å›ä¸€ä¸ªå¼•ç”¨å³å¯ï¼Œåé¢ç”¨æˆ·ç›´æ¥è°ƒç”¨è¿™äº›å‡½æ•°ï¼Œå°±å¯ä»¥æ— è§†åˆå§‹åŒ–çš„æ¬¡åºé—®é¢˜äº†ã€‚å…·ä½“å¯ä»¥çœ‹ä¹¦é‡Œé¢P32é¢çš„ç›¸å…³ä»£ç ã€‚ æœ€åæ€»ç»“ä¸€å¥ä¸ºäº†å…é™¤â€œè·¨ç¼–è¯‘å•å…ƒä¹‹åˆå§‹åŒ–æ¬¡åºâ€é—®é¢˜ï¼Œä¸€èˆ¬ç”¨ local static å¯¹è±¡æ›¿æ¢ non-local static å¯¹è±¡ã€‚]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡æ¬¾08ï¼šåˆ«è®©å¼‚å¸¸é€ƒç¦»ææ„å‡½æ•°]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE08%EF%BC%9A%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[å…¶å®è¿™ä¸€é¡¹æ¡æ¬¾æ²¡æœ‰é¢†æ‚Ÿçš„å¾ˆæ·±åˆ»ï¼Œå¯ä»¥ç†è§£æˆä¸è¦å†ææ„å‡½æ•°é‡Œé¢å†™æ•è·å¼‚å¸¸ä¹‹ç±»çš„ä»£ç ã€‚å› ä¸ºæŸäº›æ—¶å€™ï¼Œå¦‚æœåœ¨ææ„å‡½æ•°é‡Œé¢æŠ“è·å¼‚å¸¸å¯¼è‡´ç¨‹åºç»ˆæ­¢çš„è¯ï¼Œé‚£ä¹ˆå°±å¯èƒ½é€ æˆå¯¹è±¡ä¸èƒ½å®Œå…¨è¢«é”€æ¯ ææ„å‡½æ•°ç»å¯¹ä¸è¦åå‡ºå¼‚å¸¸ï¼Œå¦‚æœä¸€ä¸ªè¢«ææ„å‡½æ•°è°ƒç”¨çš„å‡½æ•°å¯èƒ½æŠ›å‡ºå¼‚å¸¸çš„è¯ï¼Œææ„å‡½æ•°åº”è¯¥åšçš„åº”è¯¥æ˜¯æ•æ‰ä»»ä½•å¼‚å¸¸ï¼Œç„¶ååä¸‹ä»–ä»¬ï¼ˆä¸ä¼ æ’­ï¼‰æˆ–è€…ç»“æŸç¨‹åºã€‚ å¦‚æœå¯¹è±¡éœ€è¦å¯¹æ‘¸ä¸ªæ“ä½œå‡½æ•°è¿è¡ŒæœŸé—´æŠ›å‡ºçš„å¼‚å¸¸åšå‡ºååº”ï¼Œé‚£ä¹ˆ class åº”è¯¥æä¾›ä¸€ä¸ªæ™®é€šå‡½æ•°ï¼ˆä¸åº”è¯¥åœ¨ææ„å‡½æ•°é‡Œé¢ï¼‰æ‰§è¡Œè¯¥ä»»åŠ¡ã€‚ä½†æ˜¯è¯¥ææ„å‡½æ•°é‡Œé¢ä»ç„¶è¦è¿›è¡ŒåŒä¿é™©çš„ææ„è¿‡ç¨‹ï¼Œå¯ä»¥åœ¨ç±»çš„å†…éƒ¨å®šä¹‰é‡Œé¢åŠ ä¸Šä¸€ä¸ª bool å˜é‡æ¥åˆ¤æ–­åˆ°åº•æœ‰æ²¡æœ‰è¿è¡Œææ„è¡Œä¸ºï¼Œç›¸å½“äºä¸€èˆ¬å†™ç¨‹åºçš„ä¸€ä¸ª flagã€‚]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡æ¬¾10ï¼šä»¤ operator= è¿”å›ä¸€ä¸ª è‡ªèº«çš„è¿”å›]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE10%EF%BC%9A%E4%BB%A4%20operator%3D%20%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%20%E8%87%AA%E8%BA%AB%E7%9A%84%E8%BF%94%E5%9B%9E%2F</url>
    <content type="text"><![CDATA[ä¸€èˆ¬é‡è½½èµ‹å€¼è¿ç®—ç¬¦å·çš„æ—¶å€™ä¸€èˆ¬éƒ½ä¼šè¿”å›ä¸€ä¸ªè‡ªèº«çš„å¼•ç”¨ï¼Œè¿™æ ·å¯ä»¥æ›´æ–¹é¢æ“ä½œè‡ªèº«ï¼Œå¦‚æœä»…ä»…åªæ˜¯è¿”å›ä¸€ä¸ªæ‹·è´çš„å¯¹è±¡çš„è¯ï¼Œé‚£ä¹ˆå°†ä¼šåœ¨è¿ç»­ä½¿ç”¨è¿ç®—ç¬¦çš„æ—¶å€™å‘ç”Ÿé”™è¯¯ï¼Œè€Œä¸”åœ¨ä¸€äº›è¾ƒå¤§çš„ç±»å‹çš„è¯ï¼Œå¯èƒ½é€Ÿåº¦ä¼šæ…¢äº›ï¼Œæ‰€ä»¥ä¸€èˆ¬è¿”å›è‡ªèº«çš„å¼•ç”¨ã€‚]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡æ¬¾09ï¼šç»ä¸åœ¨æ„é€ å’Œææ„çš„è¿‡ç¨‹ä¸­è°ƒç”¨ virtual å‡½æ•°]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE09%EF%BC%9A%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8%20virtual%20%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[ç»å¯¹ä¸è¦åœ¨æ„é€ å‡½æ•°å’Œææ„å‡½æ•°æœŸé—´è°ƒç”¨è™šå‡½æ•°ï¼Œå› ä¸ºè¿™æ ·è°ƒç”¨çš„ç»“æœä¸ä¼šå¸¦æ¥é¢„æƒ³çš„ç»“æœã€‚ åŸºç±»æ„é€ å‡½æ•°çš„æ—¶å€™ï¼Œè™šå‡½æ•°æ˜¯ä¸ä¼šä¸‹é™åˆ°æ´¾ç”Ÿç±»ä¸­ï¼ŒåŸå› å°±æ˜¯åœ¨åŸºç±»å¼€å§‹æ„é€ å‡½æ•°çš„æ—¶å€™ï¼Œè¯¥ç±»çš„ç±»å‹æ˜¯åŸºç±»ï¼Œè€Œä¸æ˜¯æ´¾ç”Ÿç±»ï¼Œç®€å•æ¥è¯´ï¼Œå¦‚æœæƒ³åœ¨æ„é€ å‡½æ•°çš„è¿‡ç¨‹ä¸­ï¼Œç›´æ¥ä½¿ç”¨åŸºç±»çš„è™šå‡½æ•°æ¥æŠ˜å°„åˆ°æ´¾ç”Ÿç±»ï¼Œä»è€Œå¸®åŠ©æ´¾ç”Ÿç±»å®Œæˆæ„é€ çš„è¯ï¼Œé‚£ä¹ˆè¿™ç§åŠæ³•ä¸€å®šè¡Œä¸é€šã€‚ ç›¸åŒçš„é“ç†åŒä¸Šï¼Œåœ¨åŸºç±»ææ„å‡½æ•°å‘ç”Ÿçš„è¿‡ç¨‹ä¸­ï¼ŒåŒæ ·å°†å…¶ä»–çš„æ´¾ç”Ÿç±»è§†ä½œæœªå®šä¹‰ã€‚ å¦‚æœå°†æ„é€ å‡½æ•°æˆ–è€…ææ„å‡½æ•°è°ƒç”¨çš„å‡½æ•°è®¾ç«‹æˆçº¯è™šå‡½æ•°çš„è¯ï¼Œé‚£ä¹ˆå½“çº¯è™šå‡½æ•°è¢«è°ƒç”¨çš„æ—¶å€™ï¼Œå¤§å¤šæ•°æ‰§è¡Œç³»ç»Ÿä¼šç›´æ¥ç»ˆæ­¢ç¨‹åºï¼Œå”¯ä¸€é¿å…çš„æ­¤é—®é¢˜çš„åšæ³•å°±æ˜¯ç¡®å®šæ„é€ å’Œææ„æœŸé—´æ²¡æœ‰è°ƒç”¨è™šå‡½æ•°ã€‚ å”¯ä¸€çš„æ›¿ä»£æ–¹æ¡ˆæ˜¯ä¸è®¾ç½®è™šå‡½æ•°ï¼Œæ¯”å¦‚åœ¨æ„é€ ä¸€ä¸ªæ´¾ç”Ÿç±»å¯¹è±¡çš„æ—¶å€™ï¼Œéœ€è¦ç›´æ¥è°ƒç”¨åŸºç±»å‡½æ•°çš„æ„é€ å‡½æ•°ï¼Œç„¶åå†å®Œæˆæ´¾ç”Ÿç±»çš„æ„é€ ï¼Œè€Œæ­¤æ—¶æœ€å¥½æ˜¯å°†æ´¾ç”Ÿç±»é‡Œé¢ä¸€ä¸ªä½œç”¨äºæ„é€ å‡½æ•°çš„ä¸€ä¸ªæˆå‘˜å‡½æ•°å®šä¹‰æˆé™æ€å‡½æ•°ï¼Œè¿™æ ·çš„è¯å°±èƒ½åœ¨ç¨‹åºåˆšå¼€å§‹å°±å­˜åœ¨è¯¥å‡½æ•°äº†ã€‚ ç”±ç¬¬å››ç‚¹æ¢å¥è¯è¯´ï¼Œä½ æ— æ³•ä½¿ç”¨è™šå‡½æ•°ç›´æ¥ä»åŸºå‡½æ•°å‘ä¸‹è°ƒç”¨ï¼Œä½†æ˜¯åœ¨åŸºç±»å‡½æ•°ä¸­å¯ä»¥ç”±æ´¾ç”Ÿç±»å°†ä¿¡æ¯ä¼ é€’åˆ°åŸºç±»ä»è€Œè¿›è¡Œæœ‰æ•ˆè°ƒç”¨ã€‚]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡æ¬¾11ï¼šåœ¨ operator ä¸­å¤„ç†è‡ªæˆ‘èµ‹å€¼çš„æƒ…å†µ]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE11%EF%BC%9A%E5%9C%A8operator%E4%B8%AD%E5%A4%84%E7%90%86%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E7%9A%84%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[æœ¬æ¥æ˜¯å¯ä»¥ä¸ç”¨æ‹…å¿ƒæ‹·è´è¿‡ç¨‹ä¸­å‘ç”Ÿè‡ªæˆ‘èµ‹å€¼çš„æƒ…å†µï¼Œä½†æ˜¯å°±æ˜¯ä¸ºäº†é˜²æ­¢ç”¨æˆ·ï¼Œæˆ–è€…å¯¹è±¡è‡ªèº«çš„è¿™ç§æƒ…å†µï¼Œæ‰€ä»¥éœ€è¦å®Œæˆé¿å…è‡ªèµ‹å€¼çš„æƒ…å†µ æ¯”å¦‚ä¸¤ä¸ªæŒ‡é’ˆå¯¹è±¡è¿›è¡Œè‡ªèµ‹å€¼çš„æ—¶å€™ï¼Œä¸ºäº†é˜²æ­¢å¤šæ¬¡åˆ é™¤ï¼Œéœ€è¦æ£€æŸ¥ä¸€ä¸‹è‡ªèµ‹å€¼çš„æƒ…å†µã€‚ åŒæ—¶ä¸ä»…è¦è€ƒè™‘çš„æ˜¯è‡ªæˆ‘èµ‹å€¼çš„å®‰å…¨æ€§ï¼Œä»ç„¶éœ€è¦è€ƒè™‘çš„æ˜¯å¼‚å¸¸çš„å®‰å…¨ï¼Œä¹Ÿå°±æ˜¯å‰è€…æ˜¯éœ€è¦åˆ¤æ–­å¦‚æœå‰è€…çš„åœ°å€ç­‰äºåè€…çš„åœ°å€è¯ å°±ç›´æ¥è¿”å›ä¸ä½œä¸ºï¼Œå¹¶ä¸”å…ˆåˆ é™¤åŸæœ¬çš„ï¼Œå†èµ‹å€¼æ–°çš„ï¼Œè€Œåè€…åˆ™æ˜¯å…ˆæ„é€ ä¸€ä¸ªå¯¹è±¡èµ‹å€¼ç»™å¦å¤–ä¸€ä¸ªï¼Œç„¶åå…ˆèµ‹å€¼ï¼Œå†åˆ é™¤ã€‚ å°±ç±»ä¼¼äºè¿™æ ·ï¼Œè¿™æ ·æ—¢èƒ½ä¿è¯è‡ªèµ‹å€¼çš„æƒ…å†µï¼Œä½†æ˜¯åˆèƒ½ä¿è¯å¼‚å¸¸å®‰å…¨ï¼Œä¸ä¼šåœ¨newå¯¹è±¡çš„æ—¶å€™å‘ç”Ÿé”™è¯¯ã€‚ è¿˜è¦è®°ä½çš„æ˜¯ä¸€èˆ¬åœ¨ç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦çš„æ—¶å€™ä¹Ÿåº”è¯¥æ³¨æ„ä¸€ä¸‹è‡ªèµ‹å€¼çš„æƒ…å†µï¼Œä¸è¿‡ä¸Šé¢çš„å¼‚å¸¸å®‰å…¨å¾ˆå°‘æ¶‰åŠåˆ°ï¼Œå› ä¸ºä¸Šé¢çš„ç›¸æ¯”äºå‰è€…æ›´è´¹ç‚¹æ—¶é—´ã€‚ æˆ–è€…æ˜¯ç›´æ¥ä½¿ç”¨è‡ªå®šä¹‰çš„ swap åŠŸèƒ½ï¼Œè¿™æ ·çš„è¯å¯¹äºè‡ªèµ‹å€¼çš„æƒ…å†µä»¥åŠå¼‚å¸¸å®‰å…¨çš„æƒ…å†µæ¥æ¯”ï¼Œæ›´åŠ çœäº‹å’Œé«˜æ•ˆã€‚]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡æ¬¾12ï¼šå¤åˆ¶å¯¹è±¡æ—¶å‹¿å¿˜å…¶æ¯ä¸€ä¸ªæˆåˆ†]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE12%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%8B%BF%E5%BF%98%E5%85%B6%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%88%90%E5%88%86%2F</url>
    <content type="text"><![CDATA[è¿™ä¸ªæ¡æ¬¾è€Œè¨€ï¼Œæ˜¯æ— è®ºç±»å‘ç”Ÿä»€ä¹ˆæ ·çš„å†…éƒ¨å˜åŒ–ï¼Œéƒ½å¿…é¡»é‡å†™ç±»çš„ç®¡ç†è¡Œä¸ºã€‚ä¸‹é¢ç›´æ¥åˆ†ä¸ºä¸¤ä¸ªæ–¹é¢è¿›è¡Œè¯ é‡Šï¼š ç±»çš„å†…éƒ¨å¢åŠ æˆ–è€…å‡å°‘æ•°æ®æˆå‘˜ï¼Œå¦‚æœæœªé‡æ–°ç¼–å†™æ„é€ å‡½æ•°çš„è¯ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨ä¹Ÿä¸ä¼šæé†’ï¼Œè¿™æ ·å°±ä¼šé€ æˆä¸å¤ªè¢«éœ€è¦çš„å±€éƒ¨æ‹·è´ã€‚ ä¸€æ—¦å‘ç”Ÿç»§æ‰¿ï¼Œå¦‚æœè¿˜æ˜¯æŒ‰ç…§ä»¥å‰çš„æ–¹æ³•ä»…ä»…æ˜¯å¯¹å‡½æ•°å†…éƒ¨çš„æ‰€æœ‰æ•°æ®æˆå‘˜è¿›è¡Œæ‹·è´çš„æ˜¯ä¸å¯¹çš„ï¼Œå› ä¸ºæ´¾ç”Ÿç±»ä¸ä»…ä»…æ˜¯åŒ…å«ç€æ´¾ç”Ÿç±»çš„éƒ¨åˆ†ï¼Œè¿˜ä»ç„¶åŒ…å«ç€åŸºç±»çš„éƒ¨åˆ†ï¼Œæ‰€ä»¥éœ€è¦è°ƒç”¨åŸºç±»çš„æ‹·è´è¡Œä¸ºï¼Œå¦‚ä¸‹å›¾ï¼š å¦å¤–æ‹·è´æ„é€ å‡½æ•°å®šä¹‰å†…éƒ¨æ˜¯ä¸èƒ½ç›´æ¥è°ƒç”¨èµ‹å€¼è¿ç®—ç¬¦ï¼Œåä¹‹äº¦ç„¶ï¼Œå‰è€…å°±ç›¸å½“äºå¯¹ä¸€ä¸ªå°šæœªæ„é€ å¥½çš„å¯¹è±¡è¿›è¡Œèµ‹å€¼ï¼Œè€Œåè€…å°±ç›¸å½“äºå¯¹ä¸€ä¸ªå·²ç»æ„é€ å¯¹è±¡å†è¿›è¡Œé‡æ–°æ„é€ ã€‚æ‰€ä»¥åƒä¸‡ä¸è¦è¿™ä¹ˆåšã€‚ å¦‚æœå‘ç°ä¸¤ä¸ªæ‹·è´è¡Œä¸ºæœ‰ç±»ä¼¼çš„ä»£ç æ—¶ï¼Œåº”è¯¥æŠŠè¿™ä¸ªç›¸åŒçš„ä»£ç æ”¾åˆ°ä¸€ä¸ªå‡½æ•°ä¸­åŒºï¼Œç„¶åç”±ä¸¤ä¸ªæ‹·è´è¡Œä¸ºå…±åŒè°ƒç”¨ã€‚]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡æ¬¾16ï¼šæˆå¯¹ä½¿ç”¨newå’Œdeleteæ—¶éœ€è¦é‡‡å–ç›¸åŒçš„å½¢å¼]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE16%EF%BC%9A%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8new%E5%92%8Cdelete%E6%97%B6%E9%9C%80%E8%A6%81%E9%87%87%E5%8F%96%E7%9B%B8%E5%90%8C%E7%9A%84%E5%BD%A2%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[å…¶å®æˆ‘æ ¹æœ¬ä¸çŸ¥é“è¿™ä¸ªä¸ºä»€ä¹ˆä¼šæˆä¸ºä¸€ä¸ªå•ç‹¬çš„æ¡æ¬¾é‰´äºæ­¤ï¼Œæ‰€ä»¥å°±ç®€å•çš„è®²ä¸¤å¥è¯ï¼š new ä¸€ä¸ªæ•°ç»„ï¼Œé‚£ä¹ˆä¸€å®šè¦ delete ä¸€ä¸ªæ•°ç»„ æ™ºèƒ½æŒ‡é’ˆé»˜è®¤æ²¡æœ‰ delete æ•°ç»„ï¼Œæ‰€ä»¥éœ€è¦è‡ªå®šä¹‰åˆ é™¤å™¨ã€‚]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡æ¬¾13ï¼šä»¥å¯¹è±¡ç®¡ç†èµ„æº]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE13%EF%BC%9A%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[ç³»ç»Ÿèµ„æºçš„ç®¡ç†è§„åˆ™å°±æ˜¯ï¼Œä¸€æ—¦ä½¿ç”¨å®Œæ¯•ï¼Œé‚£ä¹ˆå°±ä¸€å®šè¦å½’è¿˜ç»™ç³»ç»Ÿï¼Œå…å¾—é€ æˆå†…å­˜æ³„æ¼çš„é—®é¢˜ï¼Œè€Œ C++ä¸­éœ€è¦è‡ªå·±å»ç®¡ç†å†…å­˜ï¼Œé‚£ä¹ˆä¸ºäº†é˜²æ­¢åœ¨å¯¹è±¡é”€æ¯ä»¥åŠå†…å­˜é‡Šæ”¾ä¹‹é—´å‘ç”Ÿå¼‚å¸¸ï¼Œä»¥åŠæŸäº›å…¶ä»–åŸå› ï¼Œä¸€ç§æ–°çš„åŸºäºå¯¹è±¡çš„èµ„æºç®¡ç†åŠæ³•å°±åº”è¿è€Œç”Ÿã€‚ ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆï¼Œ C++11ä¹‹åæ™ºèƒ½æŒ‡é’ˆåˆ†ä¸ºä¸‰ç§ä¸€ç§æ˜¯ share_ptr æŒ‡é’ˆ æ™ºèƒ½å‹çš„åº”ç”¨è®¡æ•°ï¼Œå…±äº«åº•å±‚æ•°æ®ã€‚weak_ptr ä¾é™„äº share_ptr ä½œä¸ºä¸€ç§æ ¸æŸ¥ç±»æŒ‡é’ˆå­˜åœ¨ï¼Œæœ€åå°±æ˜¯ unique_ptr æŒ‡é’ˆï¼Œä»…ä»…åªæ˜¯ä¸ºäº†å¯¹è±¡çš„ææ„å‡½æ•°è‡ªåŠ¨é”€æ¯ï¼Œä¸Šè¿°ä¸¤ç§ä¸»è¦çš„æ™ºèƒ½æŒ‡é’ˆå¯ä»¥å®šä¹‰è‡ªå·±çš„åˆ é™¤å™¨ï¼ˆææ„å‡½æ•°ï¼‰ è·å¾—èµ„æºåç«‹åˆ»æ”¾åˆ°ç®¡ç†å¯¹è±¡ä¸­ï¼Œå…¶æ‰€ä»£è¡¨çš„è§‚å¿µå°±æ˜¯ â€œèµ„æºå–å¾—çš„æ—¶æœºï¼Œå°±æ˜¯ç›´æ¥åˆå§‹åŒ–çš„æ—¶æœºâ€ã€‚ éœ€è¦æ³¨æ„çš„å°±æ˜¯æ™ºèƒ½æŒ‡é’ˆé»˜è®¤çš„åˆ é™¤å™¨æ˜¯ä¸èƒ½åˆ é™¤å›ºå®šçš„è¿ç»­å†…å­˜ç©ºé—´ï¼Œæ„æ€å°±æ˜¯è¯´ï¼Œéœ€è¦è‡ªå®šä¹‰çš„åˆ é™¤å™¨æ‰èƒ½å®Œæˆ delete[]ã€‚]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡æ¬¾14ï¼šåœ¨èµ„æºç®¡ç†ç±»ä¸­å°å¿ƒæ‹·è´è¡Œä¸º]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE14%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83%E6%8B%B7%E8%B4%9D%E8%A1%8C%E4%B8%BA%2F</url>
    <content type="text"><![CDATA[ä¸€èˆ¬åœ¨è‡ªå®šä¹‰ç±»ä¸­ä¼šé‡åˆ°å¤šç§å¤šæ ·çš„æ‹·è´è¡Œä¸ºï¼Œæ‰€ä»¥ä¸€èˆ¬ä¼šé‡‡å–ä¸‹é¢çš„ä¸€äº›ç­–ç•¥ ç¦æ­¢å¤åˆ¶ å‘å‰é¢æ¡æ¬¾06ä¸€æ ·ï¼Œæœ‰å¤šç§åŠæ³•ï¼Œä¸€èˆ¬å¯¹äºé‚£äº›é€»è¾‘ä¸Šæ‹·è´ä¸åˆç†çš„å‡½æ•°ã€‚ å¯¹åº•å±‚æ•°æ®çš„å…±äº«æ§åˆ¶ é‚£ä¹ˆæ­¤å¤„è¿™å°±éœ€è¦ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆ share_ptrï¼Œæˆ–è€…è‡ªå®šä¹‰å¼•ç”¨è®¡æ•°ã€‚å¹¶ä¸”æ‹¥æœ‰è‡ªå®šä¹‰çš„åˆ é™¤å™¨ï¼Œå› ä¸ºæŸäº›ç±»çš„åˆ é™¤æ“ä½œå¹¶ä¸ä¸€å®šæ˜¯é‡Šæ”¾å†…å­˜ã€é”€æ¯å¯¹è±¡ã€‚ è½¬ç§»åº•éƒ¨èµ„æºçš„æ‹¥æœ‰æƒ ç§»åŠ¨æ“ä½œï¼ŒC++11 å³å€¼å¼•ç”¨çš„ç§»åŠ¨è¿‡ç¨‹ã€‚ å¤åˆ¶åˆ†ä¸ºæµ…å±‚å¤åˆ¶ä»¥åŠæ·±å±‚å¤åˆ¶ å‰è€…æ˜¯å¤åˆ¶å…¶çš„æŒ‡é’ˆæˆ–è€…å¼•ç”¨ï¼Œè¾¾åˆ°å…±äº«èµ„æºçš„ç›®çš„ï¼Œè¿™ä¸ªæ—¶å€™ä½¿ç”¨ share_ptr æ¥è¿›è¡Œæ§åˆ¶ï¼Œåè€…èµ‹å€¼çš„æ˜¯å…¨éƒ¨å†…å­˜ï¼Œæœ€å¥½æ˜¯ç”¨ unique_ptr æ¥ä¿ç®¡ï¼Œä½†æ˜¯å¤åˆ¶æ“ä½œå¾—æŠŠæ¯ä¸€ä¸ªå¯¹è±¡æ‰€æŒ‡å‘çš„å¯¹è±¡è¿›è¡Œæ‹·è´ä¹‹åï¼Œæ”¾è¿› unique_ptr ä¸­è¿›è¡Œç®¡ç†ã€‚]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡æ¬¾15ï¼šåœ¨èµ„æºç®¡ç†ç±»ä¸­æä¾›å¯¹åŸå§‹èµ„æºçš„è®¿é—®]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE15%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[ä¸€èˆ¬ä½¿ç”¨äº†æ™ºèƒ½æŒ‡é’ˆä¹‹åå°±ä¸ä¼šåœ¨å»ºè®®ä½¿ç”¨å†…ç½®æŒ‡é’ˆï¼Œä»¥å…å‘ç”Ÿé”™ä¹±ï¼Œä½†æ˜¯å°±æ˜¯æœ‰ä¸€äº›ç±»éœ€è¦åœ¨ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆçš„è¿‡ç¨‹ä¸­éœ€è¦è¿”å›å†…ç½®æŒ‡é’ˆæ¥å®ŒæˆæŸäº›å‡½æ•°çš„å‚æ•°ä¼ é€’è¿‡ç¨‹ï¼Œä½†æ˜¯éœ€è¦æ³¨æ„çš„ä¸€ç‚¹å°±æ˜¯ åœ¨ä½¿ç”¨å†…ç½®æŒ‡é’ˆçš„è¿‡ç¨‹ä¸­ åƒä¸‡ä¸éœ€è¦ deleteï¼Œç›´æ¥è®©æ™ºèƒ½æŒ‡é’ˆè¿›è¡Œåˆ é™¤æ“ä½œã€‚ å¦å¤–é™¤äº†è¿”å›å†…ç½®æŒ‡é’ˆè¿™ç§æ–¹å¼æ¥è¿›è¡Œå¯¹åŸå§‹èµ„æºçš„è®¿é—®ï¼Œè¿˜æœ‰ä¸€ç§æ–¹æ³•å°±æ˜¯é‡è½½éšå¼è½¬æ¢è¿ç®—ç¬¦ï¼Œæ¥å®Œæˆç±»åˆ°èµ„æºçš„è½¬æ¢ï¼Œä½†æ˜¯è¿™æ ·åšä¼šåŠ å¤§é”™è¯¯çš„å¯èƒ½æ€§ï¼Œå› ä¸ºæŸäº›ä¸å¯æ§çš„éšå¼ç±»å‹å‘ç”Ÿè½¬æ¢ã€‚ ä¸Šè¿°çš„ç¬¬ä¸€ç§åŠæ³•å±äºæ˜¾ç¤ºè½¬æ¢ï¼Œç›´æ¥ä½¿ç”¨ get è·å¾—èµ„æºï¼Œè€Œä¸‹é¢çš„é‚£ç§æ˜¯éšå¼è½¬æ¢ç±»å‹ï¼Œå‰è€…æ¯”è¾ƒå®‰å…¨ï¼Œåè€…æ¯”è¾ƒæ–¹ä¾¿ã€‚]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡æ¬¾17ï¼šä»¥ç‹¬ç«‹è¯­å¥å°†newè¿‡å¾—å¯¹è±¡æ”¾å…¥æ™ºèƒ½æŒ‡é’ˆä¸­]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE17%EF%BC%9A%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86-new-%E8%BF%87%E5%BE%97%E5%AF%B9%E8%B1%A1%E6%94%BE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[ç¼–è¯‘å™¨çš„ç¼–è¯‘æ¬¡åºæ˜¯è¯´ä¸å®šçš„ï¼Œå°±æƒ³ä¸‹å›¾çš„ ä¸Šè¿°çš„ä¸‰ä¸ªæ¬¡åºä¸€æ—¦é¡ºåºä¸å¯¹å°±ä¼šå‘ç”Ÿé”™è¯¯ï¼Œæ‰€ä»¥ä¸€ä¸ªæœ€å¥½é¿å…çš„åŠæ³•å°±æ˜¯æƒ³å¦‚å›¾æ‰€ç¤ºï¼š å…ˆå°†å¯¹è±¡å­˜å‚¨åœ¨æ™ºèƒ½æŒ‡é’ˆä¸­ï¼ˆå…ˆå®Œæˆæ™ºèƒ½æŒ‡é’ˆçš„æ„é€ ï¼‰ï¼Œåœ¨å®Œæˆå¯¹æ™ºèƒ½æŒ‡é’ˆçš„è°ƒç”¨ã€‚ ä¸Šè¿°ä¸¾çš„ä¾‹å­è¯´æ˜çš„é—®é¢˜æ˜¯ä¸€å®šè¦æŠŠå¯¹è±¡å­˜å…¥æ™ºèƒ½æŒ‡é’ˆçš„è¿‡ç¨‹ç‹¬ç«‹æˆä¸€ä¸ªè¯­å¥]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡æ¬¾18ï¼šè®©æ¥å£å®¹æ˜“è¢«æ­£ç¡®ä½¿ç”¨ï¼Œä¸æ˜“è¢«è¯¯ç”¨]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE18%EF%BC%9A%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%AE%B9%E6%98%93%E8%A2%AB%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8D%E6%98%93%E8%A2%AB%E8%AF%AF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[æ³¨æ„ç±»çš„éšå¼è½¬æ¢ï¼Œå¹¶ä¸”æ™ºèƒ½æŒ‡é’ˆä¸å†…ç½®æŒ‡é’ˆçš„åŒºåˆ«ï¼Œä»¥åŠä»¥å¯¹è±¡ç®¡ç†çš„æ€æƒ³æ¥ç®¡ç†èµ„æºã€‚ å¥½çš„æ¥å£å¾ˆå®¹æ˜“è¢«æ­£ç¡®ä½¿ç”¨ï¼Œä¸å®¹æ˜“è¢«è¯¯ç”¨ï¼Œåº”è¯¥åœ¨æ¥å£é‡Œé¢åŠªåŠ›è¾¾æˆè¿™äº›æ€§è´¨ã€‚ ä¿ƒè¿›æ­£ç¡®ä½¿ç”¨çš„åŠæ³• åŒ…æ‹¬æ¥å£çš„ä¸€è‡´æ€§ï¼Œä¸å…¶å†…ç½®ç±»å‹çš„è¡Œä¸ºä¸€è‡´ã€‚ é˜»æ­¢è¯¯ç”¨çš„åŠæ³•åŒ…æ‹¬å»ºç«‹æ–°ç±»å‹ï¼Œé™åˆ¶ç±»å‹ä¸Šé¢çš„æ“ä½œï¼Œä»¥åŠæŸç¼šå¯¹è±¡å€¼ï¼Œä»¥åŠæ¶ˆé™¤å®¢æˆ·çš„èµ„æºç®¡ç†è´£ä»» æ™ºèƒ½æŒ‡é’ˆæ”¯æŒå®šåˆ¶åˆ é™¤å™¨ï¼Œè¿™æ ·å¯ä»¥é˜²èŒƒåŠ¨æ€é“¾æ¥ç¨‹åºåº“çš„é—®é¢˜]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡æ¬¾20ï¼šå®ä»¥ä¼  const å¼•ç”¨ä¹Ÿä¸è¦ä¼ å€¼]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE20%EF%BC%9A%E5%AE%81%E4%BB%A5%E4%BC%A0%20const%20%E5%BC%95%E7%94%A8%E4%B9%9F%E4%B8%8D%E8%A6%81%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[è¿™ä¸ªä¼ å€¼è¡Œä¸ºæ˜¯ç»§æ‰¿ä¸ C è¯­è¨€çš„ï¼ŒåŸºæœ¬ä¸Šä¼ å¼•ç”¨æ›´åŠ æ–¹ä¾¿ï¼Œä¸”ä»˜å‡ºçš„ä»£ä»·æ›´å°ï¼Œä¸è¿‡éœ€è¦æ³¨æ„ä¸‹é¢äº†ä¸¤ç‚¹ã€‚ ä¼ å¼•ç”¨æœ‰çš„æ—¶å€™ä¼šç¢°åˆ°åˆ‡å‰²é—®é¢˜ï¼Œæ¯”å¦‚ä¼ å‚çš„æ—¶å€™ï¼Œæœ¬æ¥åº”è¯¥ä¼ å…¥ä¸€ä¸ªåŸºç±»å¯¹è±¡ï¼Œä½†æ˜¯å®é™…ä¸Šä¼ å…¥äº†ä¸€ä¸ªæ´¾ç”Ÿç±»å¯¹è±¡ï¼Œè¿™ä¸ªæ—¶å€™å°±ä¼šæŠŠæ´¾ç”Ÿç±»åŸºç±»çš„éƒ¨åˆ†åˆ‡å‰²å‡ºå»ï¼Œå…¶ä»–éƒ¨åˆ†å°±ç›´æ¥ä¸¢äº† ä»¥ä¸Šè§„åˆ™ä¸é€‚åˆæŸäº›ç‰¹æ®Šè§„åˆ™ï¼Œæ¯”å¦‚å†…ç½®ç±»å‹ä»¥åŠ STL çš„è¿­ä»£å™¨ï¼Œå¯¹å®ƒä»¬è€Œè¨€ ï¼Œä¼ å€¼å¾€å¾€æ˜¯æœ€æ°å½“çš„ã€‚]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡æ¬¾19ï¼šè®¾è®¡ class çŠ¹å¦‚è®¾è®¡ type]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE19%EF%BC%9A%E8%AE%BE%E8%AE%A1%20class%20%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1%20type%2F</url>
    <content type="text"><![CDATA[ä¸€èˆ¬è®¾è®¡ä¸€ä¸ªä¼˜ç§€çš„ç±»ï¼Œå®é™…ä¸Šä¹Ÿå°±æ˜¯è®¾è®¡ä¸€ä¸ªä¼˜ç§€çš„ç±»å‹ï¼Œè€Œå¾€å¾€éœ€è¦æ»¡è¶³ä¸‹é¢è¿™äº›ç–‘é—®ã€‚ æ–° type å¯¹è±¡åº”è¯¥å¦‚ä½•åˆ›å»ºå’Œé”€æ¯ å…³ç³»åˆ°ç±»çš„æ„é€ å‡½æ•°ä¸ææ„å‡½æ•°å¦‚ä½•å»ºç«‹ å¯¹è±¡çš„åˆå§‹åŒ–å’Œå¯¹è±¡çš„èµ‹å€¼ä¹‹é—´çš„å·®åˆ« ä¸»è¦æ˜¯ä¸ºäº†åŒºåˆ†æ„é€ å‡½æ•°ä¸èµ‹å€¼è¿ç®—ç¬¦ä¹‹é—´çš„åŒºåˆ« è¯¥ç±»å‚æ•°ä¼ é€’ä¸­æœ‰ä¼ å€¼ä¹Ÿæœ‰ä¼ å¼•ç”¨ ä¼ å¼•ç”¨ä¸ä¼ å€¼ä¹‹é—´çš„åŒºåˆ«ï¼Œä»¥åŠå¦‚ä½•å®ç°ï¼Œä»¥åŠç©¶ç«Ÿä½•æ—¶ä¼šå»è°ƒç”¨è¿™ä¸€ç±»çš„å‡½æ•°ã€‚ æ–° type çš„å’Œæ³•åˆ¶ æ„é€ è¿™ä¸ªç±»çš„æ—¶å€™ä¸€äº›åˆæ³•å€¼ï¼Œè¦ä¸è¦å¯¹åº”è‡ªå·±çš„ç§æœ‰æ•°æ®æˆå‘˜ï¼Œæˆ–è€…æ˜¯ç±»å‹è½¬æ¢ï¼Œé€šå¸¸å…¶éƒ½ä¼šå½±å“æ„é€ å‡½æ•°ã€èµ‹å€¼æ“ä½œï¼Œä»¥åŠ setter å‡½æ•°ï¼Œç”šè‡³è¿˜ä¼šå½±å“åˆ°å‡½æ•°æŠ›å‡ºçš„å¼‚å¸¸ã€‚ æ˜¯å¦éœ€è¦é…åˆæŸä¸€ä¸ªç»§æ‰¿ä½“ç³» éœ€è¦è®°ä½çš„æ˜¯ç»§æ‰¿ä½“ç³»çš„æ„æˆä¸€å®šè¦æ»¡è¶³çš„æ˜¯ is - a çš„æ¡ä»¶ï¼Œå¦å¤–è™šå‡½æ•°ä¸éè™šå‡½æ•°ä¹‹é—´çš„å½±å“ï¼Œå¹¶ä¸”è¿˜è¦è€ƒè™‘çš„æ—¶å€™ æ˜¯å¦åº”è¯¥æŠŠè‡ªå·±çš„ææ„å‡½æ•°ä¹Ÿè®¾è®¡æˆè™šå‡½æ•°ã€‚ æ˜¯å¦éœ€è¦ç±»å‹è½¬æ¢ ç±»å‹è½¬æ¢ä¸€èˆ¬ä¼šåˆ†ä¸ºæ˜¾å¼è½¬æ¢å’Œéšå¼è½¬æ¢ï¼Œå®ç°æ–¹å¼ä¸€èˆ¬æœ‰ç›´æ¥åœ¨å…¶ä¸­ä¸€ä¸ªå‡½æ•°å†…äº›ç±»å‹è½¬æ¢çš„é‡è½½è¿ç®—ç¬¦å‡½æ•°ï¼Œå’Œæ²¡æœ‰å£°æ˜ explicit çš„å•ä¸€å‚æ•°çš„æ„é€ å‡½æ•°ã€‚ é‡è½½çš„æ“ä½œç¬¦ä»¥åŠå…¶ä»–ç›¸åº”çš„å‡½æ•°ï¼Œæ˜¯å¦åˆç† è¿™é‡Œçœ‹é‡è½½çš„å‡½æ•°æ˜¯å¦ç¬¦åˆé€»è¾‘æ¡ä»¶ï¼Œä¸ä»…ä»…æ˜¯ä»£ç ä¹‹é—´çš„ä¸¥ç¦æ€§è´¨ï¼Œè¿˜éœ€è¦è€ƒè™‘çš„å°±æ˜¯ç”Ÿæ´»å±‚é¢çš„å®ç”¨æ€§ã€‚ å“ªäº›æˆå‘˜åº”è¯¥å°è£…ï¼Ÿ è¿™é‡Œå°±è®¾è®¡åˆ°å“ªäº›æˆå‘˜åº”è¯¥è®¾ç½®æˆç§æœ‰ï¼Œè€Œå“ªä¸€äº›å‡½æ•°åº”è¯¥è®¾ç½®æˆå…¬æœ‰å‡½æ•°ï¼Œå¹¶ä¸”ä¸€äº›ä¸æƒ³ç¼–è¯‘å™¨ç”Ÿæˆçš„å‡½æ•°åº”è¯¥å®šä¹‰æˆåˆ é™¤ã€‚ ç±»å‹çš„æœªå£°æ˜æ¥å£ å®ƒå¯¹æ•ˆç‡ã€å¼‚å¸¸å®‰å…¨æ€§ä»¥åŠèµ„æºè¿ç”¨æä¾›ä»€ä¹ˆæ ·ä¿è¯ï¼Œä»¥åŠä¸ºç±»çš„å®ç°ä»£ç åº”è¯¥æä¾›ä»€ä¹ˆçš„çº¦æŸæ¡ä»¶ã€‚ æ˜¯å¦åº”è¯¥å®šä¹‰æˆæ¨¡æ¿ è¿™é‡Œå°±çœ‹ç±»çš„ä¸€èˆ¬æ€§ç©¶ç«Ÿæœ‰å¤šå¤§ï¼Œæ˜¯å¦å…·æœ‰æ™®éä»·å€¼ã€‚ è€ƒè™‘æ˜¯å¦ä¼šç»§æ‰¿ä¸å…¶ä»–çš„ç±» æœ‰çš„æ—¶å€™è€ƒè™‘è¿‡åï¼Œä¹Ÿè®¸è¿™ä¸ªç±»å°±ä¸éœ€è¦å‡­ç©ºåˆ›é€ å‡ºï¼Œä»…ä»…åªæ˜¯éœ€è¦ä»å…¶ä»–ç±»ä¸Šé¢æ´¾ç”Ÿå‡ºæ¥å³å¯ã€‚]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡æ¬¾21ï¼šå¿…é¡»è¿”å›å¯¹è±¡çš„æ—¶å€™ï¼Œä¸è¦å¦„æƒ³è¿”å›å…¶çš„å¼•ç”¨]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE21%EF%BC%9A%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%B8%8D%E8%A6%81%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6%E7%9A%84%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[è¯¥æ¡æ¬¾ä¸€èˆ¬é€‚ç”¨äºæŸäº›ç‰¹æ®Šæƒ…å†µä¸‹å¿…é¡»è¿”å›å€¼çš„æƒ…å†µ å…³äºè¿™ä¸ªæ¡æ¬¾åªéœ€è¦æ³¨æ„ä¸€ç‚¹ï¼Œç»ä¸è¦è¿”å› pointer æˆ– reference æˆ–è€…è¿”å›å¼•ç”¨æŒ‡å‘ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œæˆ–è€…è¿”å›æŒ‡é’ˆå¼•ç”¨æŒ‡å‘ä¸€ä¸ªé™æ€æˆå‘˜ï¼Œä½†æ˜¯åŒæ—¶åˆéœ€è¦å¤šä¸ªè¿™æ ·çš„é™æ€æˆå‘˜ã€‚åœ¨æ¡æ¬¾4ä¸­å·²ç»æä¾›äº†ä¸€ä»½è®¾è®¡å®ä¾‹ã€‚]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡æ¬¾24ï¼šè‹¥æ‰€æœ‰å‚æ•°éœ€è¦ç±»å‹è½¬æ¢çš„æ—¶å€™ï¼Œè¯·è®¾ç½®éæˆå‘˜å‡½æ•°]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE24%EF%BC%9A%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E8%AF%B7%E8%AE%BE%E7%BD%AE%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[è¯¥æ¡æ¬¾å°±æ˜¯éœ€è¦æ³¨æ„ä¸€ç‚¹ å¦‚æœéœ€è¦ä¸ºæŸä¸ªå‡½æ•°çš„æ‰€æœ‰å‚æ•°ï¼ŒåŒ…æ‹¬this æŒ‡é’ˆæ‰€æŒ‡çš„éšå–»å‚æ•°ï¼Œè¿›è¡Œç±»å‹è½¬æ¢çš„æ—¶å€™ï¼Œé‚£ä¹ˆè¿™ä¸ªå‡½æ•°å°±å¿…é¡»æ˜¯éæˆå‘˜å‡½æ•°]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡æ¬¾22ï¼šå°†æˆå‘˜å˜é‡å£°æ˜ä¸º private]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE22%EF%BC%9A%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BA%20private%2F</url>
    <content type="text"><![CDATA[è¿™é‡Œå°±æ˜¯è¦è®°ä½å°è£…çš„å¥½å¤„ åˆ‡è®°è¦å°†æˆå‘˜å˜é‡å£°æ˜ä¸º private ã€‚è¿™æ ·å¯ä»¥å‡å°‘æ”¹åŠ¨æˆå‘˜ä¹‹åçš„ç ´åæ€§ï¼Œå¯ç»†å¾®åˆ’åˆ†è®¿é—®æ§åˆ¶ã€å…è¯ºçº¦æŸæ¡ä»¶è·å¾—ä¿è¯ï¼Œå¹¶ä¸”æä¾› class ä½œè€…ä»¥å……åˆ†å®ç°å¼¹æ€§ã€‚ protected å¹¶ä¸æ¯” public æ›´å…·æœ‰å°è£…æ€§]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡æ¬¾23ï¼šå®ä»¥éæˆå‘˜å‹å…ƒå‡½æ•°ä»£æ›¿æˆå‘˜å‡½æ•°]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE23%EF%BC%9A%E5%AE%81%E4%BB%A5%E9%9D%9E%E6%88%90%E5%91%98%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E4%BB%A3%E6%9B%BF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[åŒæ ·è¿˜æ˜¯ä¸ºäº†å°è£… å®å¯æ‹¿éæˆå‘˜éå‹å…ƒå‡½æ•°æ¥ä»£æ›¿æˆå‘˜å‡½æ•°ï¼Œè¿™æ ·åšå¯ä»¥å¢åŠ å°è£…æ€§ï¼Œå’ŒåŒ…è£¹å¼¹æ€§ï¼Œä»¥åŠæœºèƒ½æ‰©å……æ€§ã€‚]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡æ¬¾25ï¼šè€ƒè™‘å†™å‡ºä¸€ä¸ªä¸æŠ›å¼‚å¸¸çš„swapå‡½æ•°]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%A1%E6%AC%BE25%EF%BC%9A%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[æ‰€è°“ swap ä¸¤å¯¹è±¡å€¼ï¼Œæ„æ€å°±æ˜¯å°†ä¸¤ä¸ªå¯¹è±¡çš„å€¼å½¼æ­¤èµ‹äºˆå¯¹æ–¹ï¼Œç¼ºçœçš„æƒ…å†µä¸‹ swap çš„åŠ¨ä½œå¯ä»¥ç”±æ ‡å‡†åº“ç¨‹åºæä¾›çš„ swapæ¥å®Œæˆã€‚ å…¶ä¸­æœ‰ä¸€ä¸ªæœ€ä¸»è¦çš„æ–¹æ³•å°±æ˜¯ï¼Œä»¥æŒ‡é’ˆæŒ‡å‘ä¸€ä¸ªå¯¹è±¡ï¼Œå†…å«çœŸæ­£çš„æ•°æ®â€œ å³â€pimpl æ‰‹æ³•â€æ‰€ä»¥ä¸€èˆ¬å¯¹äºä¸€ä¸ªå¯¹è±¡è€Œè¨€ï¼Œç›´æ¥äº¤æ¢é‡Œé¢çš„æŒ‡é’ˆå¯¹è±¡å³å¯ã€‚å°±å¦‚åŒä»¥ä¸‹çš„å†™æ³•ï¼š ä»¥ä¸Šå°±æ˜¯è¯¥å¯¹è±¡çš„ç‰¹åŒ–ç‰ˆæœ¬ã€‚è¿™åŒæ—¶ä¹Ÿæ˜¯ä¸€ä¸ªæ¨¡æ¿ç±»çš„åç‰¹åŒ–çš„ä¾‹å­ã€‚ å¦‚æœæƒ³ç‰¹åŒ–ä¸€ä¸ªå‡½æ•°æ¨¡æ¿çš„è¯ï¼Œé€šå¸¸çš„åšæ³•å°±æ˜¯æ·»åŠ ä¸€ä¸ªé‡è½½ç‰ˆæœ¬ã€‚ ä½†æ˜¯è¿™ç§ç‰¹åŒ–å­˜åœ¨é—®é¢˜ï¼š æˆ‘ä»¬å¯ä»¥å…¨ç‰¹åŒ– std å†…çš„æ¨¡æ¿ï¼Œä½†æ˜¯ä¸å¯ä»¥æ·»åŠ æ–°çš„æ¨¡æ¿åˆ° std é‡Œé¢å»ï¼Œå› ä¸º std çš„å†…å®¹å®Œå…¨ç”± C++æ ‡å‡†å§”å‘˜ä¼šå†³å®šçš„ã€‚ æœ‰çš„æ—¶å€™ä¸èƒ½ç›´æ¥è®¿é—®ç§æœ‰æˆå‘˜ï¼Œå› ä¸ºå°è£…å±‚é¢çš„ç›¸å…³æƒé™ç¼ºå¤±ã€‚ è§£å†³çš„åŠæ³•å¾ˆç®€å•ï¼Œå£°æ˜ä¸€ä¸ªéæˆå‘˜ç‰ˆæœ¬çš„ swap å‡½æ•°ï¼Œç„¶åè®©ä»–è°ƒç”¨å…¶çš„æˆå‘˜å‡½æ•°ï¼Œè€Œä¸æ˜¯å°†é‚£ä¸ªä¸æ˜¯æˆå‘˜å‡½æ•°çš„ swap å£°æ˜ä¸º stdï¼šï¼šä¸­çš„ç‰¹åŒ–ç‰ˆæœ¬æˆ–è€…æ˜¯é‡è½½ç‰ˆæœ¬ã€‚ä¸‹é¢å°±æ˜¯ç›¸å…³æ­¥éª¤ï¼š æä¾›ä¸€ä¸ª public swap æˆå‘˜å‡½æ•°ï¼Œè®©å®ƒé«˜æ•ˆåœ°ç½®æ¢ä½ çš„ç±»å‹çš„ä¸¤ä¸ªå¯¹è±¡ï¼ˆæ³¨æ„è¿™ä¸ªåœ°æ–¹æ—¶é«˜æ•ˆçš„ç½®æ¢ï¼‰ï¼Œä½†æ˜¯è¿™ä¸ªå‡½æ•°ä¸åº”è¯¥æŠ›å‡ºå¼‚å¸¸ã€‚ åœ¨ä½ çš„ç±»æˆ–è€…æ¨¡æ¿æ‰€åœ¨çš„å‘½åç©ºé—´å†…ï¼Œæä¾›ä¸€ä¸ªéæˆå‘˜å‡½æ•°çš„ swapï¼Œå¹¶ä¸”å¦å…¶è°ƒç”¨ swap æˆå‘˜å‡½æ•°ã€‚ å¦‚æœä½ æ­£åœ¨ç¼–å†™ä¸€ä¸ª class è€Œä¸æ˜¯ä¸€ä¸ªæ¨¡æ¿ç±»çš„æ—¶å€™ï¼Œä¸ºä½ çš„ç±»ç‰¹åŒ–stdï¼šï¼šswapã€‚å¹¶ä»¤å…¶è°ƒç”¨ä½ çš„ swap æˆå‘˜å‡½æ•°ã€‚ æœ€åï¼Œåœ¨è°ƒç”¨å¥‡å‡½æ•°çš„æ—¶å€™ï¼Œè¯·ç¡®å®šåŒ…å«ä¸€ä¸ª using ç”Ÿå‘½æ˜¯ï¼Œä»¥ä¾¿äºè®© stdï¼šï¼šswap åœ¨ä½ çš„å‡½æ•°å†…æ›å…‰å¯è§ï¼Œç›´æ¥èµ¤è£¸è£¸çš„è°ƒç”¨ swapã€‚]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å…³äºSTLé‡Œé¢å‡½æ•°ç®€å•çš„åº”ç”¨]]></title>
    <url>%2F2018%2F12%2F01%2F%E5%85%B3%E4%BA%8ESTL%E9%87%8C%E9%9D%A2%E5%87%BD%E6%95%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[ä»£ç å¦‚ä¸‹ï¼š1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;int main()&#123; int n,t; cin&gt;&gt;n; set&lt;int&gt;s; s.insert(0); for (int i =0;i!=n;i++)&#123; cin&gt;&gt;t; //è¿™é“é¢˜ç›®çš„ä¸»è¦åšæ³•æ˜¯è®°ä½å‡ ä¸ªupper_bound çš„STLå‡½æ•° if(t &lt; *s.rbegin()) &#123; s.erase(*(s.upper_bound(t))); &#125; s.insert(t); &#125; cout &lt;&lt; s.size() - 1; return 0;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACMé›†è®­ç›¸å…³çŸ¥è¯†]]></title>
    <url>%2F2018%2F12%2F01%2FACM%E9%9B%86%E8%AE%AD%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[åŸºæœ¬çš„æ•°æ®ç»“æ„ æ‰©å……é¡ºåºè¡¨ ï¼ˆæˆ‘çš„ç†è§£å°±æ˜¯è¿ç»­çš„é¡ºåºå®¹å™¨ï¼‰å­˜å‚¨æ–¹æ³•å°±æ˜¯åœ¨å†…å­˜ä¸­å¼€è¾Ÿä¸€æ®µè¿ç»­çš„ç©ºé—´ã€‚ è€Œæ•°æ®å…ƒç´ çš„ä½ç½®ç¡®è®¤ï¼š å¸¸è§çš„çº¿æ€§è¡¨è¿ç®—ï¼š æ­¤å¤„ä¸€èˆ¬éƒ½æ˜¯ç”¨æ•°ç»„æ¥å®ç°ï¼Œå…¶çš„æ’å…¥è¿ç®—å’Œåˆ é™¤è¿ç®—éƒ½æ˜¯åŸºäºè¿ç»­å†…å­˜ç©ºé—´ä¸Šé¢æ‰€å®ç°çš„ã€‚ å•é“¾è¡¨å®šä¹‰ï¼šé“¾è¡¨çš„å­˜å‚¨æ–¹å¼ï¼š åŒå‘é“¾è¡¨ å¾ªç¯é“¾è¡¨ç®€å•æ¥è¯´å°±æ˜¯é¦–å°¾ç›¸è¿æ¥çš„å•å‘é“¾è¡¨ã€‚ ä»¥ä¸Šæœ‰æ—¶é—´å†æ¥è¿›è¡Œè¯¦ç»†çš„å…¨é¢æ€»ç»“ã€‚ æ ˆ å¦‚æœç”¨Cè¯­è¨€æ¥è¡¨ç¤ºæ ˆçš„è¯ï¼Œå¾—ä»¥æ•°ç»„ä½œä¸ºåŸºç¡€ï¼Œç§‰æŒå…ˆè¿›åå‡ºçš„æ€æƒ³å°±è¡Œäº†ã€‚å¯ä»¥ç”¨intå€¼ä½œä¸ºä¸‹æ ‡å€¼ä½œä¸ºå½“æ—¶å­˜å‚¨çš„æ ˆçš„ä½ç½®ã€‚ä¹Ÿå¯ä»¥ç”¨ä¸¤ä¸ªæŒ‡é’ˆæ¥æŒ‡ç¤ºå½“å‰ä¸‹æ ‡å€¼ã€‚å¯ä»¥å€Ÿç”¨æ ˆçš„æ€æƒ³æ¥åšé¢˜ç›®ã€‚ é˜Ÿåˆ— é˜Ÿåˆ—çš„åŸºæœ¬é€»è¾‘è¿ç®—ï¼š è¿™é‡Œä¹Ÿæ˜¯è¿ç”¨ä¸¤ä¸ªintå‹çš„å€¼å½“åšæ˜¯å˜é‡ï¼Œåˆ†åˆ«æŒ‡å‘å¤´æŒ‡é’ˆä»¥åŠå°¾æŒ‡é’ˆï¼Œç„¶åæ‰§è¡Œæ·»åŠ å‡å°‘çš„æ“ä½œã€‚ä¸€èˆ¬åˆ°æœ€åå…¨éƒ¨ç”¨åšåˆ°ä¸‹æ ‡ä¸Šé¢ã€‚ è€Œå¾ªç¯é˜Ÿåˆ—ä¹Ÿæ˜¯å»ºç«‹ä¸¤ä¸ªæŒ‡é’ˆï¼Œä½†æ˜¯ä¸åŒçš„æ˜¯å…¶æ˜¯å°†é¦–å°¾è¿›è¡Œè¿æ¥ä¹‹åï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå…¶ç›´æ¥å°†æ¯æ¬¡å¾—åˆ°çš„æ–°ç»“æœå¯¹é˜Ÿåˆ—çš„æ€»é•¿åº¦è¿›è¡Œä¸€ä¸ªæ±‚ä½™æ•°ï¼ˆæ±‚modï¼‰ã€‚ ä¸‹å­¦æœŸä¸Šè¯¾çš„æ—¶å€™å¯ä»¥ç”¨Cè¯­è¨€ä»£ç å®ç°ä»¥ä¸‹ã€‚ å¾ªç¯é˜Ÿåˆ—å…¶å®å¯ä»¥å¹²å’Œå¾ªç¯é“¾è¡¨ä¸€æ ·çš„äº‹æƒ…ã€‚æ¯”å¦‚ä¸€é“ä¾‹é¢˜ï¼š ä»£ç å¦‚ä¸‹ï¼š1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt; #include&lt;queue&gt;#include&lt;string&gt; #include&lt;stdio.h&gt; using namespace std; int main()&#123; int n; while(cin&gt;&gt;n)&#123; queue&lt;string&gt; a; for(int i=0;i&lt;n;i++)&#123; string name; cin&gt;&gt;name; a.push(name); &#125; int w,s; scanf(&quot;%d,%d&quot;,&amp;w,&amp;s); for(int i=0;i&lt;w-1;i++)&#123; string temp = a.front(); a.pop(); a.push(temp); &#125; while(a.size())&#123; for(int i=0;i&lt;s-1;i++)&#123; string temp = a.front(); a.pop() a.push(temp); &#125; cout&lt;&lt;a.front()&lt;&lt;endl; a.pop(); &#125; &#125; &#125; ä¸²ä¸²çš„å®šä¹‰ï¼š æ­¤å¤„åˆ™å¯ä»¥ç†è§£æˆæ˜¯å­—ç¬¦ä¸²ã€‚ äºŒå‰æ ‘æ ‘çš„å®šä¹‰ï¼š äºŒå‰æ ‘çš„æ€§è´¨ï¼š æ’åºç®€å•çš„å†’æ³¡æ’åº]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
        <tag>æ•°æ®ç»“æ„</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018å¹´ç”Ÿæ—¥é‡åº†ä¹‹æ—…]]></title>
    <url>%2F2018%2F11%2F30%2F2018%E5%B9%B4%E7%94%9F%E6%97%A5%E9%87%8D%E5%BA%86%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[è¯´å¥å®è¯ï¼Œè‡ªå·±ä¹Ÿä¸çŸ¥é“åº”è¯¥å†™äº›ä»€ä¹ˆä¸œè¥¿ï¼Œè½¬çœ¼ä¹‹é—´ä¼¼ä¹å·²ç»21å²äº†ï¼ŒçŸ¥é“è‡ªå·±å†…å¿ƒä¸ç”˜å¿ƒçš„åœ°æ–¹ï¼Œä½†æ˜¯å”¯ä¸€ä¸å¤ªçŸ¥é“çš„æ˜¯å¦‚ä½•å»æ”¹å–„è¿™äº›ä¸ç”˜å¿ƒçš„åœ°æ–¹ã€‚é—®é—®è‡ªå·±çš„å†…å¿ƒï¼Œå…¶å®è‡ªå·±ä¸€ç›´æƒ³è¦çš„å°±æ˜¯åˆ«äººçš„å…³æ³¨ã€‚æˆ‘è§‰å¾—æˆ‘ä¸ªäººçš„å¿ƒè·¯æˆé•¿åˆ†æˆäº†å‡ ä¸ªé˜¶æ®µã€‚ ç¬¬ä¸€ä¸ªé˜¶æ®µå°±æ˜¯æ‹¼å‘½çš„å±•ç°è‡ªæˆ‘ï¼Œè¿½æ±‚å…¶ä»–äººçš„è®¤å¯ä¸å…³çˆ±ã€‚ å¦‚æœåœ¨è¿™ä¸ªé˜¶æ®µé‡Œé¢è·å–äº†è¶³å¤Ÿçš„è®¤å¯ï¼Œä¹Ÿè®¸å°±ä¼šä¸€ç›´åœ¨è¿™ä¸ªé˜¶æ®µé‡Œé¢ä¸æ–­ï¼Œè¦æ±‚æ»¡è¶³ï¼Œç„¶åè¢«æ»¡è¶³çš„è¿‡ç¨‹ä¸­è¿›è¡Œæ²‰æ²¦ã€‚æˆ‘ä¸ªäººçš„æƒ³æ³•å°±æ˜¯ï¼Œå¦‚æœæ²¡æœ‰è¿›å…¥åˆ°ä¸‹ä¸€ä¸ªé˜¶æ®µï¼Œé‚£ä¹ˆæ°¸è¿œå¾—ä¸åˆ°æˆé•¿ã€‚ ç¬¬äºŒä¸ªé˜¶æ®µå°±æ˜¯çŸ¥é“äº†è¿™ä¸ªä¸–ç•Œä¸Šä¸ä¼šè½»æ˜“çš„ç»™è‡ªå·±æ»¡è¶³çš„ï¼ŒçŸ¥é“äº†åŸæ¥è‡ªå·±æ˜¯ä¼šè¢«æ‹’ç»çš„ã€‚ è¿™ä¸ªæ—¶æœŸå¦‚æœæ²¡æœ‰å¤„ç†å¥½çš„è¯ï¼Œé‚£ä¹ˆç‰¹åˆ«å®¹æ˜“èµ°å‘ä¸€ä¸ªæç«¯ï¼Œèµ°å‘ä¸€ä¸ªâ€œä½›ç³»â€çš„ä¸€ä¸ªæç«¯ï¼Œå‡æ„æˆä¸ºä¸€ä¸ªæ— æ¬²æ— æ±‚çš„äººï¼Œè¿™ä¸ªæ—¶æœŸçš„æˆ‘ä»¬å°±ä¼šåŒæ¶ä¸€åˆ‡â€œäº‰å® â€çš„è¡Œä¸ºï¼Œåè€Œè¿˜ä¼šå°†é‚£äº›äº‰å–ä¼˜ç§€çš„äººçœ‹ä½œæ˜¯ç‰¹åˆ«ä½çº§çš„äººç±»ï¼Œä»è€ŒåŒæ¶ä¸€åˆ‡ä¼˜ç§€ï¼Œä½†åŒæ—¶è‡ªå·±ä¼šåœ¨æš—ä¸­åšå‡ºå¾ˆå¤šè‡ªè®¤ä¸ºç‹¬ä¸€æ— äºŒçš„äº‹æƒ…ï¼Œæ¥å½°æ˜¾è‡ªå·±ä¸åˆ«äººä¸ä¸€æ ·çš„åœ°æ–¹ã€‚ ç¬¬ä¸‰ä¸ªé˜¶æ®µå¾€å¾€æ˜¯åœ¨ç»å†äº†å¾ˆé•¿é˜¶æ®µçš„ç¬¬äºŒé˜¶æ®µï¼Œç»å†è¿‡æ‰“å‡»ï¼Œé‡æ–°å¹¶ä¸”æ·±åˆ»çš„è®¤çŸ¥åˆ°è¿™ä¸ªä¸–ç•Œå¹¶ä¸æ˜¯å›´ç»•ç€è‡ªå·±è½¬åŠ¨ï¼Œä¸€ä¸ªäººçœŸçš„æ²¡åŠæ³•è·å–å‘¨å›´æ¯ä¸ªäººçš„å…³æ³¨ã€‚ ä¹Ÿè®¸ç”šè‡³è‡ªå·±æ²¡åŠæ³•è·å–å‘¨å›´ä¸€ä¸ªæœ‹å‹çš„å…¨éƒ¨çš„å…³æ³¨ï¼Œå…¶å®æ¢ä½æ€è€ƒä¸€ä¸‹ï¼Œè‡ªå·±ä¹Ÿæ²¡æœ‰å…¨èº«å¿ƒçš„æŠ•å…¥è‡ªå·±å»å…³æ³¨åˆ«äººï¼Œå…¶å®åˆ°æœ€åè‡ªå·±è¿˜æ˜¯ä»¥ä¸€ä¸ªè‡ªå·±éƒ½è¾¾ä¸åˆ°çš„æ ‡å‡†å…¨éƒ¨è¦æ±‚åˆ«äººï¼Œæœ‰ç‚¹è‡ªæ¬ºæ¬ºäººçš„æ„Ÿè§‰ã€‚ å…¶å®è‡ªå·±å°±åœ¨ä¸Šé¢æ‰€è¯´çš„ç¬¬äºŒé˜¶æ®µä¸­æ— åŠ›ç¿»è…¾ç€ã€‚è™½ç„¶è‡ªå·±æ²¡æœ‰å»è”‘è§†åŠªåŠ›ï¼ŒçŸ¥é“è‡ªå·±ä¸€åˆ‡æ”¹å˜éƒ½æ˜¯åŠªåŠ›çš„ç»“æœï¼Œè¿™æ˜¯å¥½çš„ï¼Œä½†æ˜¯ä»è¿›å…¥å¤§å­¦çš„ä¸€å¹´å¤šæ¥ï¼Œè‡ªå·±è§‰å¾—è‡ªå·±å¾ˆç´¯ï¼Œæ¯å¤©è¿‡å¾—ä¹Ÿå¾ˆå……å®ï¼Œä¹Ÿæœ‰ä¸€ä¸ªå›ºå®šçš„ç›®æ ‡ï¼Œä½†æ˜¯è‡ªå·±å´å¥½åƒä»æ¥ä¸èƒ½å¾—åˆ°æ»¡è¶³ã€‚ å…¶å®æœ€è¿‘å‘ç”Ÿçš„ä¸€åˆ‡ä¸å®‰ï¼Œä¸€åˆ‡å›°æƒ‘ï¼Œé—®é—®è‡ªå·±ï¼Œå…¶å®å…¨éƒ¨æ¥æºäºè‡ªæˆ‘è®¤çŸ¥çš„åå·®ã€‚çœŸçš„ä»¥ä¸ºè‡ªå·±æ˜¯æ— æ‰€ä¸èƒ½çš„è¶…äººï¼Œè®¤ä¸ºæ‰€æœ‰äº‹æƒ…ï¼Œåªè¦è‡ªå·±è®¤çœŸå»åšï¼Œé‚£ä¹ˆå°±ä¸€å®šå¯ä»¥å®ç°ï¼Œä½†æ˜¯å´å¿˜è®°äº†ä¸€ä¸ªå¾ˆé‡è¦çš„å‰æï¼Œäººçš„ç²¾åŠ›æ˜¯æœ‰é™çš„ï¼ŒçœŸçš„æ²¡æœ‰åŠæ³•åšåˆ°é¢é¢ä¿±åˆ°ã€‚ ä»æœ€å…ˆå¼€å§‹çš„é€‰æ‹©ç¨‹åºå‘˜è¿™æ¡è·¯ï¼Œåˆ°åé¢ç¼–ç¨‹è¯­è¨€çš„é€‰æ‹©ï¼Œç„¶ååˆåˆ°äº†å·¥å…·ï¼Œå¼€å‘ç¯å¢ƒï¼Œä»¥åŠç¼–ç¨‹ä¹‹è·¯æ–¹å‘ä¸Šé¢çš„é€‰æ‹©ï¼Œæˆ‘æœ€è¿‘åšå‡ºäº†å¾ˆå¤šå¾ˆå¤šçš„é€‰æ‹©ã€‚å¾ˆé«˜å…´è‡ªå·±åšå‡ºäº†å¾ˆå¤šçš„é€‰æ‹©ï¼Œä½†æ˜¯åŒæ ·åˆå¾ˆæ‚²ä¼¤è‡ªå·±åšå‡ºçš„é€‰æ‹©ã€‚ å¤–å›  æ¯ä¸ªäººçš„äººç”Ÿåªæœ‰ä¸€æ¬¡ï¼Œå¯¹äºä¸ªäººè€Œè¨€ï¼Œå‘ç”Ÿçš„ä¸€åˆ‡ï¼Œå…¶å®éƒ½æ˜¯ä¸€ä¸ªå…¨æ–°çš„ä½“éªŒï¼Œæ‰€ä»¥ä¸çŸ¥é“è¯¥æ€ä¹ˆåšï¼Œäº§ç”Ÿè¿·èŒ«çš„æƒ…ç»ªæ˜¯ä¸€ä»¶å¾ˆæ­£å¸¸çš„äº‹æƒ…ï¼Œå¦å¤–å¯¹äºè‡ªå·±è€Œè¨€ï¼Œå‘¨å›´ä¹Ÿæ²¡æœ‰é™ªä¼´è‡ªå·±æˆé•¿çš„é•¿è€…ï¼Œæ²¡æœ‰äººå¯ä»¥ä½“ä¼šåˆ°è‡ªå·±ç”Ÿå‘½ä¸­æ¯ä¸€ä¸ªæŠ‰æ‹©èƒŒåæ‰€è¦æ‰¿æ‹…çš„ä¸œè¥¿ã€‚å†åŠ ä¸Šæœ¬ç€æƒ³æŠŠä¸€åˆ‡åšå¥½çš„ç›®çš„ï¼Œè¿™ä¸ªæ—¶å€™å°±ä¼šäº§ç”Ÿå³ä½¿åšå‡ºé€‰æ‹©ä¹Ÿä¼šäº§ç”Ÿåæ‚”çš„ä¸ç¡®å®šæ„Ÿã€‚ å†…å›  æˆ‘è§‰å¾—å½’æ ¹åˆ°å†…å¿ƒçš„è¯ï¼Œè¿˜æ˜¯æœ‰å¯¹è‡ªå·±ä¸å¤Ÿè‡ªä¿¡è¿™ä¸ªå¿ƒæ€å­˜åœ¨çš„ï¼Œè¿˜è®°å¾—ä¸Šæ¬¡åœ¨ç»å¼€ä¸€ä¸­ä¸€ä¸ªç§‘æŠ€å±•è§ˆä¼šçš„æ—¶å€™ï¼Œè¢«ä¸€ä¸ªå­¦å¦¹è¯´ä¸è‡ªä¿¡çš„æ—¶å€™ï¼Œå½“æ—¶éœ‡æƒŠçš„åŒæ—¶ï¼Œå…¶å®æ›´å¤šçš„è¿˜æ˜¯è®¤å¯ï¼Œæˆ‘çš„ç¡®å¯¹è‡ªå·±ä¸æ˜¯ç‰¹åˆ«çš„è‡ªä¿¡ã€‚ä¸åšé€‰æ‹©çš„æ—¶å€™ï¼Œæ€€ç–‘è‡ªå·±æ˜¯ä¸æ˜¯åšä¸äº†é€‰æ‹©äº†ï¼Œå½“è‡ªå·±åšå‡ºé€‰æ‹©ä¹‹åï¼Œåˆåœ¨æ€€ç–‘è‡ªå·±æ˜¯ä¸æ˜¯åšå‡ºäº†ä¸€ä¸ªé”™è¯¯çš„é€‰æ‹©ï¼Œæˆ‘è§‰å¾—è¿™éƒ½æ˜¯è‡ªå·±å†…å¿ƒä¸­éœ€è¦å…‹æœçš„åœ°æ–¹ã€‚ ä¸Šé¢ç»¼åˆèµ·æ¥å¸¦æ¥äº† ç„¦è™‘ã€‚ ç„¦è™‘ï¼Œä¸€éä¸€éçš„æ€€ç–‘è‡ªå·±ï¼Œä¸€éä¸€éçš„è‹›åˆ»å®Œç¾çš„æ ‡å‡†ï¼Œä¸€éä¸€éå¤¸å¤§å…¶ä»–äººçš„æˆå°±è€Œè´¬ä½è‡ªå·±çš„æˆå°±ã€‚ä»¥è‡³äºæ²¡æœ‰åŠ¨åŠ›ï¼Œæ²¡æœ‰è€å¿ƒï¼Œæ²¡æœ‰æ¯…åŠ›ï¼Œä»¥è‡³äºæœ€åä»»æ¬²æœ›ä¾µè¢­ï¼Œå •è½ã€‚ å…¶å®è‡ªå·±çš„åˆå¿ƒæ˜¯å¥½çš„ï¼Œä½†æ˜¯ä¸ºä»€ä¹ˆåœ¨åˆå¿ƒä¹‹åçš„å‰è¡Œé“è·¯ä¸Šä¼šæœ‰å¦‚æ­¤å¤§çš„é˜»ç¢å‘¢ï¼Œæˆ‘è§‰å¾—å°±æ˜¯æ€¥åŠŸè¿‘åˆ©çš„å¿ƒæ€ï¼Œå¿ƒæ€¥åƒä¸äº†çƒ­è±†è…ï¼Œè¿™å¥è¯é€‚ç”¨äºäººç”Ÿé“è·¯ä¸Šé¢çš„æ¯ä¸€å¯¸ã€‚ ä¸è¦å› ä¸ºèµ°çš„å¤ªè¿œï¼Œè€Œå¿˜è®°ä¸ºä»€ä¹ˆå‡ºå‘ æœ¬æ¥åªæ˜¯ä¸€ä¸ªç”Ÿæ—¥çš„å°æ€»ç»“ï¼Œä¸çŸ¥ä¸è§‰å°±è¯´äº†è¿™ä¹ˆå¤šï¼Œæœ¬æ¥åªæ˜¯æƒ³å†™å†™åœ¨é‡åº†é‡åˆ°äº†ä»€ä¹ˆäººï¼Œé‡åˆ°äº†ä»€ä¹ˆæ ·çš„äº‹æƒ…ï¼Œä½†æ˜¯è¿˜æ˜¯æŠµå¾¡ä¸ä½æ¬²æœ›çš„è¯±æƒ‘ï¼Œä¸»è¦è¿˜æ˜¯ç„¦è™‘ï¼Œæ€¥åŠŸè¿‘åˆ©çš„å¿ƒæ€æ¯äº†è‡ªå·±ï¼Œè‡ªå·±åœ¨é‡åº†å¾—åˆ°çš„æœ€å¤§çš„æ”¶è·ä¾¿æ˜¯åœ¨çƒ­é—¹çš„å¤–ç•Œç¯å¢ƒä¸‹ï¼Œä¿æŒä¸€ä»½é™è°§ï¼Œå°±åƒç«é”…é…æ–™ä¸Šé¢çš„è€—æ²¹ï¼Œè™½ç„¶èµ·ä¸åˆ°ä»»ä½•å¥½åƒçš„ä½œç”¨ï¼Œä½†æ˜¯å´èƒ½åœ¨è‡ªå·±æœ€è¾£çš„æ—¶å€™ï¼Œç»™è‡ªå·±ä¸€ç‚¹é™è°§ã€‚ è¿™æ¬¡çš„é‡åº†ä¹‹æ—…ï¼Œæœ‰é—æ†¾ï¼Œæœ‰å¯æƒœï¼Œæœ‰æ²¡æœ‰å®Œæˆçš„å¿ƒæ„¿ï¼Œä¹Ÿæœ‰æ²¡æœ‰å°½å…´çš„åœ°æ–¹ï¼Œä½†æ˜¯è¶Šé•¿å¤§è¶Šå‘ç°ï¼Œæˆ‘ä»¬æ€»æ˜¯å¸Œæœ›äººç”Ÿä¸­æ²¡æœ‰é—æ†¾ï¼Œå¯æ˜¯åˆ°åæ¥æ‰å‘ç°ï¼Œäººç”Ÿçš„é—æ†¾æ‰æ˜¯äººç”Ÿä¸­æœ€æœ‰é­…åŠ›çš„åœ°æ–¹ï¼Œå› ä¸ºæœ‰é—æ†¾ï¼Œæ‰ä¼šæœ‰æ‰€å‘å¾€ã€‚æ‰€æœ‰å®Œç¾çš„ä¸œè¥¿æœ€è‡´å‘½çš„å¼±ç‚¹å°±æ˜¯æ²¡æœ‰é—æ†¾ï¼Œä»è€Œä¹Ÿå°±æ²¡æœ‰äº†å‘å¾€ã€‚ ç°åœ¨æ˜¯å‡Œæ™¨çš„ä¸€ç‚¹é’Ÿï¼Œè‡ªå·±è¿˜ååœ¨ç«è½¦ä¸Šé¢é¢ ç°¸ï¼Œä½†æ˜¯è‡ªå·±å´æœ‰ç‚¹äº«å—è¿™ä¸ªæ—¶å€™çš„æ°›å›´ï¼Œè¿‡é“é‡Œæ—¶ä¸æ—¶æœ‰äººèµ°è¿‡ï¼Œæœ‰äººä¸Šè½¦ï¼Œæœ‰äººä¸‹è½¦ï¼Œæ—è¾¹å‘¼å‘¼æ‰“é¼¾å£°éŸ³ï¼Œè¿˜æœ‰æ—¶ä¸æ—¶é£˜æ¥çš„é¦™çƒŸå‘³ï¼Œæé†’æˆ‘ åŸæ¥ä¸€ç›´ä»¥æ¥è¿½æ±‚çš„ç”Ÿæ´»å°±åœ¨å‘¨å›´ã€‚ å¸Œæœ›è‡ªå·±å›å»ä»¥åå¯ä»¥å¥½å¥½çš„å®‰æ’è‡ªå·±çš„äººç”Ÿï¼Œä¸è¦ç„¦è™‘ï¼Œä¸è¦æ€¥åŠŸè¿‘åˆ©ï¼Œå¥èº«è®¡åˆ’ï¼Œè‹±è¯­å…­çº§ï¼Œç¼–ç¨‹ä¹‹è·¯ï¼Œæˆé•¿ä¹‹è·¯ï¼Œå¤ªè¿‡äºè¿½æ±‚ç»“æœå°±ä¼šå¯¼è‡´å¤±å»è‡ªå·±æƒ³è¦çš„ç»“æœã€‚ ç”Ÿæ´»é‡Œæœ€å¦™çš„æ°¸è¿œä¸æ˜¯æŒ‰éƒ¨å°±ç­ï¼Œè§„åˆ’å¥½çš„ç»“æœï¼Œè€Œæ˜¯è½¬è§’é‡Œä¸ç»æ„çš„æƒŠå–œ ç¥è‡ªå·±21å²ç”Ÿæ—¥å¿«ä¹ã€‚]]></content>
      <categories>
        <category>æˆé•¿</category>
      </categories>
      <tags>
        <tag>ä¸ªäººç»å†</tag>
        <tag>æ—…è¡Œ</tag>
        <tag>é‡åº†</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017~2018.5.1ä¸ªäººå°ç»“]]></title>
    <url>%2F2018%2F05%2F01%2F2017-2018-5-1%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[å…¶å®å¿ƒçŸ¥è‚šæ˜è‡ªå·±çš„æ‹–å»¶ç—‡æ˜¯éå¸¸å¼ºå¤§çš„ï¼Œæ€»æ˜¯åœ¨æœ‰æ„æ— æ„çš„æ‹–å»¶ç€ï¼Œæœ¬æ¥æœ€å…ˆå¼€å§‹çš„é¢„è®¡æ˜¯æ¯ä¸€å¹´éƒ½ä¼šå†™ä¸€ä¸ªå¹´ç»ˆæ€»ç»“ï¼Œç„¶å2017å¹´çš„å¹´ç»ˆæ€»ç»“ç›´åˆ°ç°åœ¨æ‰å¼€å§‹ä¸‹ç¬”ï¼Œæ¯æ¬¡éƒ½æœ‰ç†ç”±æ˜¯æœ€è¿‘çš„è‡ªå·±å¾ˆå¿™å¾ˆç´¯ï¼Œæ²¡æœ‰åŠæ³•é™ä¸‹å¿ƒæ¥è®¤çœŸçš„å†™ä¸€å†™è‡ªå·±çš„æ€»ç»“ï¼ŒåŒæ—¶ä¹Ÿç§‰æŒç€â€œä¸‹ä¸€æ¬¡ä¸€å®šæœ‰æ—¶é—´ï¼Œå…¶å®åé¢çš„æ—¶é—´è¿˜å¤šäº›å‘¢ï¼Ÿâ€ç„¶åå°±æ˜¯è¿™ä¸€äº›æƒ³æ³•ä½¿è‡ªå·±æ‹–å»¶ä¹ æƒ¯å˜å¾—è¶Šæ¥è¶Šä¸¥é‡ã€‚ä¹Ÿå°±æœ‰äº†ä»Šå¤©â€æ’é™¤ä¸‡éš¾â€œåœ¨äº”ä¸€å‡æœŸçš„ç¬¬ä¸€å¤©ï¼Œåœ¨å¤§å®¶éƒ½å‡ºå»éƒŠæ¸¸çš„æƒ…å†µä¸‹é€‰æ‹©è‡ªå·±åœ¨å®¿èˆé‡Œé¢å¥½å¥½æ•´ç†ã€‚ ä»å½“åˆä¸Šå¤§å­¦ä¸€ç›´åˆ°ç°åœ¨ï¼Œè¯´å®è¯è‡ªå·±è¿˜æ˜¯æœ‰ç‚¹è‡ªå‘½æ¸…é«˜ï¼Œä¹Ÿå°±æ˜¯ä¸å¤ªå–œæ¬¢ç°åœ¨çš„ç¯å¢ƒï¼Œä¸è¿‡è¿™ç§å¿ƒæ€å‘å±•åˆ°ç°åœ¨ï¼Œå·²ç»å‰”é™¤äº†è¿™ç§å¿ƒæ€é‡Œé¢ä¸å¤ªå¥½çš„ä¸€é¢ã€‚è¿™ç§æƒ³è¶…è„±ç¯å¢ƒçš„å¿ƒæ€ï¼Œæˆ‘ä¸çŸ¥é“è¯¥ä¸è¯¥è¯„ä»·å…¶çš„å¥½ä¸ä¸å¥½ï¼Œä½†æ˜¯æˆ‘åªçŸ¥é“çš„æ˜¯ï¼Œå¦‚æœè¦è¶…è„±åˆ°ç°åœ¨åŸæœ‰çš„ç¯å¢ƒçš„è¯ï¼Œå¾—æ¯”å‘¨å›´çš„äººä»˜å‡º200%çš„åŠªåŠ›ã€‚ ä½†æ˜¯é‰´äºè‡ªå·±çš„è¡¨ç°ï¼ŒçœŸçš„è¾¾åˆ°äº†200%çš„è¡¨ç°å—ï¼Ÿæˆ‘ä¸çŸ¥é“ï¼Œå› ä¸ºä¸çŸ¥é“è‡ªå·±åŠªåŠ›çš„æ–¹å‘åœ¨å“ªï¼Œä»€ä¹ˆéƒ½æƒ³å­¦ï¼Œä»€ä¹ˆéƒ½æƒ³å‡ºäººå¤´åœ°ï¼Œä½†æ˜¯å´åˆä»€ä¹ˆéƒ½åšä¸å¥½ï¼Œå…¶å®æˆ‘ç°åœ¨è¶Šæ¥è¶Šè§‰å¾—äººç”Ÿæœ€éš¾çš„å°±æ˜¯å†æ§åˆ¶å¥½å¹¿åº¦çš„åŒæ—¶é’»ç ”å¥½æ·±åº¦ã€‚æˆ‘è§‰å¾—è¿™æ‰æ˜¯éš¾ä»¥æ§åˆ¶çš„ã€‚è½å®åˆ°æˆ‘ç°åœ¨çš„ç”Ÿæ´»é‡Œé¢æ¥çœ‹ã€‚ä¸Šä¸ªå­¦æœŸçš„äº‹æƒ…ä¸å»è°ˆè®ºè¿‡å¤šï¼Œæ¯•ç«Ÿä¸Šä¸ªå­¦æœŸæ˜¯æ¥åˆ°å­¦æ ¡çš„ç¬¬ä¸€ä¸ªå­¦æœŸï¼Œä»€ä¹ˆéƒ½å¾ˆæ–°é²œï¼Œç”±äºå¥½å¥‡å¿ƒçš„ç›¸äº’æ¢ç´¢ï¼Œè‡ªå·±æ‰¾åˆ°äº†å¾ˆå¤šæœ‰è¶£çš„æœ‹å‹ï¼Œå¹¶ä¸”æ¥è§¦åˆ°äº†è¾©è®ºï¼Œç„¶åä¸Šä¸ªå­¦æœŸåœ¨ä¿æŒå­¦ä¹ è¿›åº¦çš„åŒæ—¶ï¼Œåœ¨è¾©è®ºä¸Šé¢è¿›è¡Œäº†å‘å±•ã€‚ä¸Šä¸ªå­¦æœŸå°±å¤§å­¦ç¬¬ä¸€ä¸ªå­¦æœŸè€Œè¨€ï¼Œå°±ç®—æœ‰å¤ªå¤šçš„ç›®æ ‡æ²¡æœ‰å®Œæˆï¼Œä½†æ˜¯è¿™ä¹Ÿéƒ½æ˜¯å¯ä»¥å€¼å¾—åŸè°…çš„ã€‚ ç°åœ¨æˆ‘å°±è¦è¯´çš„æ˜¯å¤§å­¦çš„ç¬¬äºŒä¸ªå­¦æœŸï¼Œå¤§é“ç†æ¯ä¸ªäººéƒ½æ‡‚ï¼Œæ¯ä¸ªäººéƒ½ä¸æ˜¯ç‰¹åˆ«å–œæ¬¢å¯¹è‡ªå·±è¯´æ•™çš„äººï¼Œå°¤å…¶æ˜¯é‚£ä¸ªå¯¹ä½ è¯´æ•™çš„äººè¿˜æ˜¯ä½ çš„åŒçº§çš„æ—¶å€™ï¼Œå°±æ›´ä¸å®¹æ˜“æ¥å—ï¼Œç‰¹åˆ«æ˜¯è‡ªå·±åšäº†ä¸€ä»¶äº‹æƒ…ï¼Œæ¸´æ±‚è‚¯å®šçš„æ—¶å€™ï¼Œè¿™ä¸ªæ—¶å€™åˆ«äººçš„â€å–„æ„æ€§è´¨çš„æ‰¹è¯„â€œæˆ‘è§‰å¾—ä¸€å®šæ˜¯å¬ä¸ä¸‹å»çš„ï¼Œä½†æ˜¯å¯¹äºè‡ªå·±è€Œè¨€ï¼Œä¹Ÿè®¸åˆ«äººä¸ä¼šæ¥è¯´è‡ªå·±è¿™ä¸€æ–¹é¢çš„äº‹æƒ…ï¼Œä½†æ˜¯è‡ªå·±å¿ƒé‡Œä¸€å®šè¿˜æ˜¯è¦æœ‰ä¸€äº›è‡ªçŸ¥è‡ªæ˜çš„ï¼Œæˆ‘çŸ¥é“å¯¹äºè‡ªå·±è¿™åŠä¸ªå­¦æœŸè€Œæ¥ï¼Œå¾ˆä¸æ»¡æ„ï¼Œåˆ†å‡ ä¸ªå—æ¥è¯´ï¼Œç”±äºè‡ªå·±æ¯ä¸€æ–¹é¢éƒ½æƒ³è¦é¡¾åˆ°ï¼Œç„¶ååˆ°æœ€åè‡ªå·±æ¯ä¸€æ–¹é¢éƒ½æ²¡æœ‰é¡¾åˆ°ã€‚å¥èº«ï¼Œè¾©è®ºï¼Œç¼–ç¨‹ï¼Œç»©ç‚¹å­¦ä¹ å¥–å­¦é‡‘ï¼Œå¿—æ„¿è€…ï¼Œæ—…æ¸¸ï¼Œè‡ªåª’ä½“å†™ä½œï¼Œä¸ªäººæ„Ÿè§‰è¿™æ¯ä¸€å—éƒ½æ²¡æœ‰åšå¥½ï¼Œå› ä¸ºæ¯ä¸€ä»¶äº‹æƒ…éƒ½æƒ³åšå¥½ï¼Œä½†æ˜¯æ¯ä¸€ä»¶äº‹éƒ½éœ€è¦å¤§é‡çš„æ—¶é—´åŸºç¡€å¾ˆæ²‰æ·€ï¼Œäºæ˜¯æˆ‘è§‰å¾—ç›®å‰æœ€å¥½çš„è§£å†³åŠæ³•å°±æ˜¯è¿›è¡Œæ—¶é—´ä¸Šé¢çš„ä¼˜å…ˆçº§æ’åºï¼ŒæŠŠç°é˜¶æ®µæœ€é‡è¦çš„äº‹æƒ…æ‹¿å‡ºæ¥æ’åˆ°å‰é¢ï¼Œè‡ªå·±æƒ³åšï¼Œä½†æ˜¯åˆä¸æ˜¯å¿…é¡»åšçš„äº‹æƒ…æ”¾åˆ°åé¢ã€‚äºæ˜¯æˆ‘å°±åšäº†ä¸€ä¸‹è¿™å¼ æ€ç»´å¯¼å›¾ã€‚ æˆ‘ç›®å‰çš„æƒ³æ³•æ˜¯æƒ³æŠŠè®¡ç®—æœºä¸“ä¸šå±‚é¢çš„å­¦ä¹ æ”¾åœ¨ç¬¬ä¸€ä½ç„¶åå°±æ˜¯è‹±è¯­æ–¹é¢çš„å­¦ä¹ ï¼Œç„¶åå°±æ˜¯å¤§å­¦è¯¾ç¨‹ä¸Šé¢çš„å­¦ä¹ ã€‚ç„¶åå°±æ˜¯ä¹‹åçš„å…´è¶£å‘å±•ã€‚ä½†æ˜¯å‘å±•åˆ°ç°åœ¨ï¼Œè®²çœŸçš„è‡ªå·±è¿˜æ˜¯æœ‰ç‚¹æ¾æ‡ˆäº†ï¼Œæ²¡æœ‰ä»¥å‰çš„é‚£è‚¡åŠ²ï¼Œä½†æ˜¯å°±æ˜¯ç¾¡æ…•é‚£äº›æœ‰æœ¬äº‹ï¼Œæœ‰èƒ½åŠ›çš„äººã€‚ä¹‹å‰çš„ç”Ÿæ´»å°±æ˜¯æ¯å¤©ç¼–ç‚¹ç¨‹åºï¼Œå­¦è®¡ç®—æœºæ–¹é¢çš„ä¸œè¥¿ï¼Œç„¶åä¹Ÿå°±æ˜¯å› ä¸ºè¿™äº›å¯¼è‡´äº†ç¿˜è¯¾ï¼Œå¯¼è‡´äº†æ¾æ‡ˆï¼Œå¯¼è‡´äº†ç°åœ¨ä¼šåœ¨å®¿èˆé‡Œé¢å‘å‘†ä¹Ÿä¸å»æ•™å®¤ä¸Šè¯¾ï¼Œè¿™äº›ç»Ÿç»Ÿæ˜¯å¯¼è‡´çš„ã€‚æˆ‘è§‰å¾—è¿™ä»æ—§æ˜¯è‡ªå·±å¼€å§‹æ¾æ‡ˆçš„æ ‡å¿—ï¼Œä½†æ˜¯æ›´æ˜¯ç”±äºè¿™äº›ï¼Œæˆ‘çš„ç”Ÿæ´»ä¹Ÿå˜å¾—ä¸å¤ªè§„å¾‹ï¼Œä¹‹å‰ä¸€ä¸ªæ˜ŸæœŸæ¯å¤©ä¼°è®¡ä¸€ä¸¤ç‚¹ç¡è§‰ï¼Œè€Œä¸”æ—©ä¸Šä¸ä¼šå†åƒä»¥å‰ä¸€æ ·å»æ•™å®¤è‡ªä¹ ã€‚æˆ‘è§‰å¾—æˆ‘ä¹Ÿä¸ä¼šåƒä»¥å‰ä¸€æ ·æš—ç¤ºè‡ªå·±è¿™éƒ½ä¸æ˜¯ä¸ªäº‹ï¼Œå› ä¸ºå¤©ç„¶é»˜è®¤æœªæ¥ä¸€åˆ‡éƒ½æ˜¯å¥½çš„ã€‚ç„¶åå°±è«åå…¶å¦™çš„ç»™è‡ªå·±å‘ä¸€å¤§æ®µä¸€å¤§æ®µçš„é¸¡æ±¤ ã€‚è¿™æ¬¡çš„æ€»ç»“ æˆ‘ä¸æƒ³ç»™è‡ªå·±è®²å¤§é“ç†ï¼Œå› ä¸ºå…¨éƒ¨éƒ½æ‡‚ï¼Œæˆ‘åªæƒ³æ‰¹è¯„è‡ªå·±ï¼Œåªæƒ³åçœã€‚è‡ªå·±åšçš„ä¸å¯¹çš„åœ°æ–¹å°±åº”è¯¥å»æ”¹æ­£ã€‚ æœªæ¥è¿˜æœ‰ä¸€å—æ˜¯å…³äºè¾©è®ºé˜Ÿæ˜¯å»æ˜¯ç•™çš„é—®é¢˜ï¼Œç”±äºæ—¶é—´ä»¥åŠè‡ªå·±æŒ‰ç…§æ’åºæƒ³åšçš„äº‹æƒ…å†²çªï¼Œä¸å¾—ä¸é€€äº†æ ¡é˜Ÿï¼Œå¹¶ä¸”æåŠ›å‡å°‘è‡ªå·±å†é™¢é˜Ÿé‡Œé¢çš„æ¯”èµ›ï¼Œä½†æ˜¯è‡ªå·±è¿˜æ˜¯æ¯”è¾ƒå–œæ¬¢è¿™æ–¹é¢ã€‚ä½†æ˜¯æ²¡æœ‰åŠæ³•ï¼Œå› ä¸ºåªè¦æ‰“ä¹±äº†é‚£ä¸ªä¼˜å…ˆçº§æ’åçš„è¯ï¼Œé‚£ä¹ˆè‡ªå·±æ‰€æœ‰çš„äº‹æƒ…éƒ½ä¼šä¹±ã€‚å¹¶ä¸”æˆ‘å–œæ¬¢è‡ªå·±åšäº‹æƒ…èƒ½å¤Ÿä¸“ä¸€ï¼Œæœ€è¿‘å‘ç°è‡ªå·±åœ¨ä¸“ä¸€åº¦ä¸Šé¢æ²¡æœ‰å¾ˆç”¨åŠŸï¼Œåé¢å¯èƒ½ä¼šè€ƒè™‘å°è¯•ä¸€ä¸‹ç•ªèŒ„æ—¶é—´ã€‚æ€»ä¹‹å¯¹äºè¾©è®ºé˜Ÿçš„è¯¸å¤šäº‹å®œï¼Œæˆ‘æœ€ç»ˆå†³å®šè¿˜æ˜¯ä»…ä»…æ˜¯å½“ä½œä¸€ä¸ªçˆ±å¥½ï¼Œä¸ºè‡ªå·±çš„æœ¬å‘½å­¦ç§‘è®©è·¯ã€‚ ä¸‹ä¸€ä¸ªé—®é¢˜æ˜¯å…³äºåšæŒï¼Œæœ¬æ¥æˆ‘è§‰å¾—åœ¨è¿™ä¸ªå±‚é¢æ˜¯ä¸å­˜åœ¨çš„é—®é¢˜çš„ï¼Œä½†æ˜¯æœ€è¿‘æ„Ÿè§‰çš„è‡ªå·±çš„è‡ªåˆ¶åŠ›è¶Šæ¥è¶Šå·®ï¼Œå…¶å®æ¯…åŠ›ä¹Ÿå°±åƒè‚Œè‚‰ï¼Œä½ åªæœ‰å¤šç»ƒç»ƒï¼Œæ‰èƒ½ä½¿æ¯…åŠ›è¿™å—è‚Œè‚‰è¶Šæ¥è¶Šç¡¬ã€‚æ‰€ä»¥ä»¥åè·‘æ­¥å¥èº«éƒ½è¦å‹¤å¿«ç‚¹ï¼Œå»é”»ç‚¼æ¯…åŠ›è¿™å—è‚Œè‚‰ã€‚ æœ€åæ˜¯å…³äºäººé™…äº¤å¾€ï¼Œæœ‰å®¤å‹å±‚é¢çš„ï¼Œä¹Ÿæœ‰æœ‹å‹å±‚é¢çš„ï¼Œäº¤å¾€ä¸€å®šè¦æ‡‚å¾—åº¦ï¼Œè¿™ä¸ªåº¦çš„æŠŠæ¡ï¼Œä¸ä»…è¦ä½“ç°åœ¨è‡ªå·±èº«ä¸Šï¼Œè¿˜è¦ä½“ç°åœ¨åˆ«äººèº«ä¸Šã€‚å¯¹äºæŸäº›è‡ªä»¥ä¸ºæ˜¯ï¼Œåªä¼šåæ¿€å¹¶ä¸”ç‰‡é¢è¯„ä»·åˆ«äººçš„äººï¼Œæˆ‘è§‰å¾—è¿˜æ˜¯æŠŠä»–ä»¬å½“ä½œå¤§ç¥ä¾›èµ·æ¥å§ã€‚ è´±äººè‡ªæœ‰è´±äººæ”¶ï¼Œæˆ‘æ²¡åŠæ³•å¼„ä»–ä»¬ï¼Œå› ä¸ºæˆ‘ä¸æ˜¯è´±äººã€‚ æœ€åçš„æœ€åå¸Œæœ›ä»è¿™ä¸ªäº”ä¸€å‡æœŸå¼€å§‹å°±å¸¦æ¥æ”¹å˜ï¼Œè®°ä½è‡ªå·±çš„ä¼˜å…ˆçº§å®‰æ’è¡¨ï¼ŒåŒæ—¶ä¹Ÿè®°ä½åšæŒå’ŒåŠªåŠ›ï¼Œæ°¸è¿œä¸è‡ªå·±çš„æ‡’æƒ°å’Œæ¾æ‡ˆæˆ˜æ–—ä¸‹å»ã€‚ æ€»ä¹‹å¯¹äºç°åœ¨è€Œè¨€â€‹â€‹ï¼Œä»5æœˆ1æ—¥åˆ°æ¥ä¸‹æ¥æ”¾å‡çš„æ—¶é—´é‡Œï¼Œéœ€è¦å®Œæˆçš„ç›®æ ‡æœ‰ï¼š 1ã€è®¡ç®—æœºç¼–ç¨‹è¯­è¨€C++çš„ç›¸å…³è¡¥å……ï¼ˆå°½é‡æ¥çœ‹ï¼Œè¿˜æœ‰æš‘å‡å¯ä»¥ç”¨æ¥çœ‹ï¼‰ã€‚ 2ã€è‹±è¯­å››çº§å¿…é¡»å¾—è¿‡ï¼Œæ¥ä¸‹æ¥æ—¶é—´æŠŠè‹±è¯­å¬åŠ›å¼„å¥½ï¼Œæ¯å¤©å°½åŠ›å®Œæˆä¸€å¥—è‹±è¯­å·å­ã€‚ 3ã€ä½“è‚²é”»ç‚¼ è¿åŠ¨ï¼Œé©¬ä¸Šå¤å¤©äº†ï¼Œå¦‚æœä¸æƒ³æ˜¾ç¤ºå‡ºè‡ªå·±çš„è‚¥è‚‰çš„è¯ï¼Œå¾—å¥½å¥½åŠªåŠ›äº†ã€‚ â€‹4ã€ä¿è¯æ¥ä¸‹æ¥ä¸æŒ‚ç§‘ã€‚å…è®¸ä¸å†ä»¥æ‹¿å¥–å­¦é‡‘ä¸ºä¸»è¦ç›®çš„ã€‚ 5â€‹ã€é—²æš‡æ—¶é—´éƒ½çœ‹ç‚¹è‡ªå·±æ„Ÿå…´è¶£çš„ä¹¦ç±ï¼Œä¸è¦å†åˆ·ç”µè§†å‰§äº†ã€‚ï¼ˆè¿™ä¸€ç‚¹å°½é‡æ§åˆ¶ï¼‰]]></content>
      <categories>
        <category>æˆé•¿</category>
      </categories>
      <tags>
        <tag>æˆé•¿</tag>
        <tag>æ€»ç»“</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017å¹´ä¸­ç§‹èŠ‚æ„Ÿæ…¨]]></title>
    <url>%2F2017%2F10%2F05%2F2017%E5%B9%B4%E4%B8%AD%E7%A7%8B%E8%8A%82%E6%84%9F%E6%85%A8%2F</url>
    <content type="text"><![CDATA[æˆ‘ä¸€ç›´ä»¥æ¥è§‰å¾—ç”Ÿæ´»çš„æ„ä¹‰å°±æ˜¯ä¸Šè¿›ï¼Œå°±æ˜¯æ¯«æ— ç†ç”±çš„æå‡è‡ªå·±ï¼Œè®©è‡ªå·±å˜çš„æ›´æœ‰ä»·å€¼ï¼Œæ›´æœ‰æ„ä¹‰ã€‚è¿™ç§æ€æƒ³äº§ç”Ÿäºå°æ—¶å€™å—åˆ°çš„å¥½å¥½å­¦ä¹ ï¼ŒåŠªåŠ›è€ƒä¸Šå¤§å­¦çš„åŠŸåˆ©æ€æƒ³å§ã€‚ä½†æ˜¯ä¹Ÿå°±æ˜¯è¿™ç§æ€æƒ³ä¿ƒä½¿æˆ‘ä¸€æ­¥ä¸€æ­¥èµ°åˆ°ç°åœ¨ï¼Œè™½ç„¶æ²¡æœ‰å¤ªå¤§çš„æˆå°±ï¼Œä½†æ˜¯ä¹Ÿä¸å‘¨å›´çš„äººæ‹‰å¼€äº†è·ç¦»ã€‚å¾ˆä¹…ä»¥å‰è‡ªå·±çš„è¿™ç§æ€æƒ³ä¹Ÿç»å¸¸å»¶ç”³å‡ºå¦å¤–ä¸€ç§è¡¨ç°æ–¹å¼ã€‚é‚£å°±æ˜¯æ¯”è¾ƒã€‚æˆ‘è§‰å¾—ç°é˜¶æ®µåœ¨æˆ‘ç”Ÿæ´»é‡Œçš„æ‰€æœ‰ä¸Šè¿›ï¼Œæ‰€æœ‰å¿«ä¹å’Œæ‰€æœ‰æˆå°±æ„Ÿå…¨éƒ¨éƒ½æ¥è‡ªäºæ¯”è¾ƒã€‚æˆ‘çš„å¤§å­¦æ¯”æŸäº›äººå¥½ï¼Œæˆ‘æŸäº›ä¼˜ç‚¹æ¯”æŸäº›äººå¥½ï¼Œæˆ‘æ¯”æŸäº›äººæ›´æ‡‚å¾—ç”Ÿæ´»ï¼Œè¿™äº›éƒ½ä¼šè®©æˆ‘æ„Ÿåˆ°ä¸€ç§ä¼˜è¶Šæ€§è´¨çš„å¿«ä¹ï¼Œå°±æ˜¯æˆ‘æ¯”åˆ«äººè¡Œï¼Œæˆ‘æ¯”åˆ«äººå‰å®³çš„å¿«ä¹ã€‚ä½†æ˜¯åè§‚è¿™ç§å¿«ä¹çš„æ¥æºï¼Œè™½ç„¶ä»ä¸€å®šçš„è§’åº¦ä¸Šï¼Œä»–å¯èƒ½ä¿ƒè¿›äº†æˆ‘å¯¹ä¸Šè¿›æ„ä¹‰çš„æ¢ç´¢ï¼Œä½†æ˜¯ä¹Ÿé™åˆ¶äº†æˆ‘å¯¹æœªæ¥æ„ä¹‰ä¸Šçš„è¿½é€ã€‚æ¯”å¦‚è¯´ï¼Œæˆ‘ä»Šå¤©çœ‹åˆ°ä¸€ä¸ªä»¥æˆ‘æ‰€è°“çš„è¯„åˆ¤æ ‡å‡†æ¯”æˆ‘å·®åŠ²çš„ä¸€ä¸ªäººï¼Œæˆ‘ä¼šå¼€å¿ƒã€‚ä½†æ˜¯å½“æˆ‘çœ‹åˆ°ä¸€ä¸ªæ¯”æˆ‘å‰å®³ï¼Œæˆ–è€…è¯´æ˜¯æˆ‘è®¤ä¸ºæ²¡æœ‰æˆ‘å‰å®³ä½†æ˜¯å´åšäº†ä¸€ä»¶æˆ‘è§‰å¾—å¾ˆäº†ä¸èµ·çš„ä¸€ä»¶äº‹æƒ…ï¼Œè¿™ä¸ªæ—¶å€™æˆ‘ä¼šéš¾è¿‡ï¼Œå› ä¸ºæˆ‘ä¸çŸ¥é“è‡ªå·±èƒ½ä¸èƒ½åšçš„è·Ÿä»–ä¸€æ ·å¥½ï¼Œæˆ–è€…è¯´æ˜¯æ¯”ä»–è¿˜è¦å¥½ã€‚æˆ‘ä¹‹å‰è§‰å¾—è¿™æ˜¯ä¸€ç§å«‰å¦’å¿ƒé‡Œï¼Œç¾¡æ…•å¦’å¿Œåˆ«äººæ¯”æˆ‘å¥½çš„ï¼Œå´æ®Šä¸çŸ¥åˆ«äººæ˜¯ä»˜å‡ºäº†å¤šå¤§çš„ä»£ä»·è¾¾åˆ°è¿™ä¸€æ­¥çš„ã€‚æˆ‘çŸ¥é“æœ‰çš„æ—¶å€™å¦’å¿Œå¿ƒçœŸçš„æ²¡æœ‰åŠæ³•é¿å…ï¼Œè‡³å°‘æˆ‘æ˜¯æ²¡æœ‰åŠæ³•å»é¿å…è¿™ç§ä¸å¥½çš„å¿ƒé‡Œï¼Œä½†æ˜¯å°†è¿™ä¸€ç‚¹å¾€æ·±å±‚æ¬¡å»è€ƒè™‘ï¼Œè¿™ä½•å°ä¸æ˜¯ä¸€ç§è‡ªå‘å¿ƒé‡Œå‘¢ï¼Ÿæ›¾ç»çš„æˆ‘æåº¦é„™è§†å«‰å¦’å¿ƒé‡Œï¼Œæ‰€ä»¥è®¤ä¸ºä¸€åˆ‡æ¯”è¾ƒéƒ½æ˜¯æ²¡æœ‰å¿…è¦çš„ï¼Œä¸€åˆ‡æ¯”è¾ƒéƒ½æ˜¯æ»¡è¶³è‡ªå·±è™šæ— çš„è™šè£å¿ƒï¼Œä½†æ˜¯è¿™æ ·åšçš„åæœåˆæ˜¯ä»€ä¹ˆæ ·çš„å‘¢ï¼Ÿè¿™æ ·åšçš„åæœæ˜¯å®³æ€•æ¯”è¾ƒï¼ŒåŒæ¶ä¸Šè¿›ï¼Œéš¾é“è¿™ä¸€åˆ‡çœŸçš„åªæ˜¯æ¯”è¾ƒé”™äº†å—ï¼Œè¿˜æ˜¯è¯´é‚£ç§è™šæ— çš„å¦’å¿Œå¿ƒçœŸçš„æ¯ç­ä¸€åˆ‡çš„æ ¹æºå—ï¼Ÿæˆ‘è§‰å¾—å¯èƒ½è¿˜æ˜¯å†…å¿ƒæ·±å¤„å¼±ç‚¹ï¼Œæˆ‘è§‰å¾—è¿™å¯èƒ½éœ€è¦æˆ‘æ¥ä¸‹æ¥å‡ åå¹´çš„ç»å†å’Œå†ç»ƒå»å®Œå–„çš„é—®é¢˜ï¼Œè‡ªå‘ã€‚è¿™é‡Œè¯´çš„è‡ªå‘å¯èƒ½ä¸æ˜¯é‚£ç§å£å¤´ä¸Šçš„ä»€ä¹ˆæˆ‘ä¸è¡Œï¼Œæˆ‘çœŸçš„ä¸è¡Œã€‚æˆ‘è§‰å¾—è¿™ä¸å«åšè‡ªå‘ï¼Œé‚£å«åšè‡ªæš´è‡ªå¼ƒã€‚è‡ªå‘çš„å¿ƒç†æˆ‘è§‰å¾—çº¯ç²¹æ˜¯æ¥è‡ªäºä»·å€¼è§‚ä¸­çš„æ‚²è§‚ä½“ç³»ï¼Œå’Œæ€§æ ¼ä¸­æ— æ³•é¿å…çš„è½¯å¼±ä»¥åŠæ‡¦å¼±ã€‚å¯èƒ½è¿™ä¸€ç³»åˆ—çš„è¯´æ³•ç‰¹åˆ«å®½æ³›å’ŒæŠ½è±¡ï¼Œé‚£æˆ‘ä¸¾ä¸ªä¾‹å­ã€‚æ¯”å¦‚è¯´æˆ‘ç°åœ¨çƒ­è¡·äºå”±æ­Œï¼Œå¦‚æœæˆ‘å‘ç°ä¸€ä¸ªä¸æ˜¯é‚£ç§å¤©èµ‹æµï¼Œä»…ä»…æ˜¯é€šè¿‡åŠªåŠ›æå‡ä¸Šå»çš„äººï¼Œå”±æ­Œçªç„¶å˜å¾—å¾ˆå‰å®³äº†ï¼ŒæŒ‰ç…§æ­£å¸¸äººçš„æƒ³æ³•ï¼Œç¬¬ä¸€ä¹Ÿè®¸ä¼šå¦’å¿Œï¼Œæˆ–è€…æ˜¯å€¾ä½©ã€‚ä½†æ˜¯è¿™ä¸¤è€…ä¹‹åæˆ‘çš„ååº”å°±æ˜¯éš¾è¿‡ä¸å®³æ€•ã€‚ä¹Ÿè®¸è¿™é‡Œå®³æ€•è¿™ä¸ªè¯ç”¨çš„è¿‡äºå¤¸å¼ ï¼Œä½†æ˜¯æˆ‘æƒ³è¯´çš„è¿™ä¸ªè¯ç”¨çš„å¾ˆå‡†ç¡®ã€‚æˆ‘ä¸€å‘è§‰å¾—æœ‰äº›äº‹æƒ…å¦‚æœå‘ç”Ÿåœ¨åˆ«äººçš„èº«ä¸Šé‚£å°±æ˜¯åˆ«äººçš„äº‹æƒ…ï¼Œè·Ÿæˆ‘ä¸æˆ‘è‡ªå·±æ‰€å¤„äºçš„ä¸–ç•Œæ˜¯æ— å…³çš„ã€‚è¿™æ˜¯æˆ‘åŸºæœ¬çš„ç†å¿µï¼Œä½†æ˜¯æˆ‘ä¸ºä»€ä¹ˆä¼šæ„Ÿåˆ°å®³æ€•å‘¢ï¼Ÿç©¶ç«Ÿæ˜¯å®³æ€•ä»€ä¹ˆå‘¢ï¼Ÿä»…ä»…æ˜¯å®³æ€•åˆ«äººåšçš„æ›´å¥½è§‰å¾—è‡ªå·±ä¼šè¢«å˜²ç¬‘å—ï¼Ÿæˆ‘è§‰å¾—å¯èƒ½æ˜¯æˆ‘æ€§æ ¼ä¸Šçš„é—®é¢˜ï¼Œæˆ‘å¯èƒ½è¿˜æ˜¯æœ‰ç‚¹éœ€è¦è¢«è‚¯å®šï¼Œè¢«ç§¯æå¯¹å¾…çš„å¿ƒç†ã€‚ç®€å•æ¥è¯´æ˜¯éœ€è¦å¾—åˆ°æ›´å¤šçš„çˆ±ä¸å…³æ€€ã€‚å½“é‡åˆ°è¿™æ ·çš„äº‹æƒ…ä¹‹åï¼Œæˆ‘çš„ç¬¬ä¸€ååº”æ˜¯ä»–åšçš„æ›´å¥½äº†ï¼Œæˆ‘ä¸ºä»€ä¹ˆåšä¸åˆ°ï¼Œé‚£è‚¯å®šæ˜¯æˆ‘è‡ªå·±å¤ªæ²¡ç”¨äº†ï¼Œè‡ªå·±å¤ªæ²¡ç”¨äº†ï¼Œé‚£ä¹ˆåˆ«äººä¸€å®šä¸ä¼šæ³¨æ„åˆ°è¿™ä¹ˆå¤±è´¥çš„è‡ªå·±ï¼Œå› ä¸ºè‡ªå·±å¤ªæ²¡ç”¨äº†ã€‚è€Œä¸”æœ€è‡´å‘½çš„å¯èƒ½å°±æ˜¯ï¼Œè§‰å¾—è‡ªå·±æ— è®ºæ€ä¹ˆåŠªåŠ›éƒ½æ— æ³•è¶…è¿‡ä»–ã€‚åˆ°æœ€åè™½ç„¶è‡ªå·±å´‡å°šç”Ÿæ´»åœ¨è‡ªå·±çš„ä¸–ç•Œé‡Œï¼Œä½†æ˜¯è¿˜æ˜¯ç”¨åˆ«äººçš„ä»·å€¼è§‚å’Œåˆ«äººçš„æˆåŠŸä¸å¤±è´¥çš„æ¥è¡¡é‡è‡ªå·±ã€‚æˆ‘è§‰å¾—è¿™æ˜¯æˆ‘è¿™ä¸€ä¸ªé˜¶æ®µéœ€è¦è§£å†³çš„é—®é¢˜ã€‚å½’æ ¹åˆ°åº•ï¼Œä¹Ÿæ˜¯è‡ªå·±ä¸å¤Ÿå¼ºå¤§ï¼Œå†…å¿ƒä¸–ç•Œè¿˜æ²¡æœ‰åƒé’¢é“ä¸€èˆ¬ã€‚è¯´å®è¯ï¼Œç›®å‰çš„æˆ‘æ‰¾ä¸åˆ°è§£å†³è¿™ä¸ªå¾ˆå¥½çš„åŠæ³•ï¼Œä½†æ˜¯å¯ä»¥ä¸€æ­¥ä¸€æ­¥çš„æ”¹å˜ï¼Œè€Œä¸”è¿™äº›æ”¹å˜ä¹Ÿåœ¨æˆ‘çš„èº«ä¸Šæ½œç§»é»˜åŒ–çš„è¿›è¡Œç€ï¼Œæ¯”å¦‚è¯´ï¼Œæ›´åŠ å¦ç„¶çš„é¢å¯¹è‡ªå·±ï¼Œé¢å¯¹ç”Ÿæ´»ä¸­çš„åˆ«äººçš„ä¼˜ç‚¹ä¸ç¼ºç‚¹ï¼Œä¸å†ä»‡è§†æ¯”è¾ƒï¼Œä¸å†è¿‡å¤šçš„å»å…³æ³¨æ¯”è¾ƒåçš„å¿«ä¹ä¸æ‚²ä¼¤ï¼Œè™½ç„¶ç°åœ¨è¿˜æ˜¯ä¼šæœ‰ä¸€äº›ä¼˜è¶Šæ€§è´¨çš„é«˜å…´ä¸éš¾è¿‡ï¼Œä½†æ˜¯ä¸ä¼šå»ä¸»å¯¼è‡ªå·±å¿ƒæƒ…ã€‚è™½ç„¶ä»ç„¶æ— æ³•ä¸“æ³¨ä¸è‡ªå·±çš„ç”Ÿæ´»ï¼Œä½†æ˜¯ä¸€è·¯èµ°æ¥æˆ‘è§‰å¾—è‡ªå·±æˆé•¿çš„å¿ƒè·¯å†ç¨‹ä¹Ÿæ˜¯æˆ‘æœ€ä¼Ÿå¤§çš„è´¢å¯Œã€‚ç¥è‡ªå·±ä¸­ç§‹èŠ‚å¿«ä¹ã€‚]]></content>
      <categories>
        <category>æˆé•¿</category>
      </categories>
      <tags>
        <tag>æˆé•¿</tag>
        <tag>ä¸­ç§‹èŠ‚</tag>
        <tag>é’æ˜¥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å…³äºå†›è®­ä½“åˆ¶çš„ä¸€äº›æ€è€ƒ]]></title>
    <url>%2F2017%2F09%2F15%2F%E5%85%B3%E4%BA%8E%E5%86%9B%E8%AE%AD%E4%BD%93%E5%88%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©æ˜¯å†›è®­çš„ç¬¬ä¸ƒå¤©ï¼Œåˆ°äº†å†›è®­æœ€åçš„é˜¶æ®µäº†ï¼ŒæŒ‰ç…§å¤§å®¶çš„è¯´æ³•å’Œæ•™å®˜ä»¬çš„é»˜è®¸ï¼Œæœ€åå‡ å¤©å°±æ˜¯çº¯æ”¾æ¾å‹çš„äº¤å‹ç››ä¼šã€‚å›é¡¾æœ€å…ˆå¼€å§‹çš„å‡ å¤©ï¼Œæˆ‘è§‰å¾—æ‰€æœ‰å¯¹è¿™å¯¹ç”Ÿæ´»é‡Œç¾å¥½çš„æœŸæœ›å…¨éƒ¨è¢«ä¸€äº›å­˜åœ¨ä¸ç”Ÿç†ä¸Šçš„ç—›è‹¦æ‰€æ‘§æ¯ã€‚åœ¨æœ€åˆå¼€å§‹çš„å‡ å¤©é‡Œï¼Œæˆ‘ç°åœ¨å”¯ä¸€è®°ä¸‹å»çš„å°±æ˜¯æˆ‘ä»¬çš„æ•™å®˜è¿é•¿æ˜¯å¦‚ä½•å¼æˆ‘ä»¬ï¼Œç”¨ä»–æ‰€è°“çš„é˜¶çº§æ€æƒ³æ¥å‹æ¦¨æˆ‘ä»¬çš„è‡ªç”±ï¼Œæˆ‘ä¸çŸ¥é“è‡ªå·±è¿™æ ·çš„è¯´æ³•æ˜¯ä¸æ˜¯å±äºæ­£ç¡®çš„ï¼Œå› ä¸ºåœ¨æˆ‘ä»¬å›½å®¶è¿™ç§éƒ¨é˜Ÿåˆ¶åº¦ï¼Œæœ¬æ¥å°±æ˜¯å†›äººåŠ¡å¿…æœä»å‘½ä»¤çš„æ€æƒ³æ”¯æ’‘ã€‚åœ¨æ­¤ä¹‹å‰æˆ‘çš„æ‰€æœ‰æ€æƒ³ä½“ç³»ï¼Œå…¨éƒ¨éƒ½æ˜¯åŸºäºä¸€ç‚¹ï¼Œä»»ä½•äººéƒ½ä¸èƒ½é˜»æŒ¡ä½æˆ‘çš„è‡ªç”±ã€‚è¯´å®è¯ï¼Œè¿™ç§æ€æƒ³æˆ‘è®¤çœŸæƒ³äº†æƒ³ï¼Œå°±æ˜¯è€ƒè™‘äº†ä¸‹äº§ç”Ÿè¿™ç§æ€æƒ³çš„åŸå› ï¼Œå¤§æ¦‚ç‡å¯èƒ½æ˜¯é’æ˜¥æœŸé‡Œçš„å›é€†ï¼Ÿè¿˜æ˜¯ç‹¬ç«‹æ€æƒ³åŠç‹¬ç«‹äººæ ¼ä½œæ€ªï¼Ÿæˆ‘æ›¾ç»åœ¨ä¸€æœ¬ä¹¦é‡Œçœ‹åˆ°çš„ä¸€å¥è¯ï¼Œäººæ°¸è¿œä¸å¯èƒ½å®Œå…¨è‡ªç”±ï¼Œä¹Ÿå°±æ˜¯ä¸å¯èƒ½å®Œå…¨è·Ÿç€å¤©æ€§çš„æ–¹å‘è¡Œèµ°ï¼Œå› ä¸ºç¤¾ä¼šè¿™ä¸ªäº§ç‰©ï¼Œæœ¬æ¥å°±æ˜¯å„ç§è§„åˆ™ç›¸äº’ç¢°æ’çš„ç»“æœã€‚ä½†æ˜¯åœ¨ç°åœ¨è¿™ç§éƒ¨é˜Ÿåˆ¶åº¦è¶Šæ¥è¶Šå˜å‘³ã€‚æˆ‘æ‰€ç†è§£æœä»å‘½ä»¤åº”è¯¥æ˜¯åŠ©äºç®¡ç†ï¼Œä»¥ä¾¿äºæå‡å®Œæˆä»»åŠ¡çš„æ•ˆç‡ã€‚è€Œç°åœ¨è¿™ç§æœä»å‘½ä»¤è¶Šæ¥è¶Šå¤šçš„è½¬åŒ–æˆäº†å¯¹æƒåˆ©çš„ä¸€ç§ç‹‚çƒ­ï¼Œä¹Ÿå°±æ˜¯æ‰€è°“çš„å®˜å¤§ä½ ä¸€çº§å‹æ­»ä½ ã€‚è¶Šæ¥è¶Šå¤šçš„äººç”¨å‘½ä»¤è¿›è¡Œå‹è¿«åšä¸€äº›æ— æ³•ç†è§£ç”šè‡³æ˜¯åˆ©å·±çš„äº‹æƒ…ï¼Œä¹Ÿå°±æ˜¯è¶Šæ¥è¶Šå¤šçš„åœ¨éƒ¨é˜Ÿé‡Œé¢çš„äººå¼€å§‹å´‡æ‹œæƒåˆ©ã€‚äºæ˜¯è¶Šæ¥è¶Šå¤šçš„å†›ç—äº§ç”Ÿäº†ã€‚æˆ‘è§‰å¾—å†›äººåœ¨ä»»ä½•æ—¶å€™é¦–å…ˆè¦åšçš„äº‹ä¸¥æ ¼è¦æ±‚è‡ªå·±ï¼Œæ¯”å¦‚è¯´ä¸€äº›åŸºæœ¬çš„å†›äººå¸¸è¯†ï¼Œä¸è¦æ€»æ˜¯è¦æ±‚åˆ«äººåšåˆ°ï¼Œç„¶è€Œè‡ªå·±å´åšä¸åˆ°ã€‚åè€Œè¿èƒŒäº†å†›äººæœä»å‘½ä»¤çš„åˆè¡·ã€‚æˆ‘çŸ¥é“å¹¶ä¸”ä¹Ÿç›¸ä¿¡ç€æˆ‘æ‰€é‡è§çš„å†›äººä¸­æœ‰å¾ˆå¤§ä¸€éƒ¨åˆ†åªèƒ½è¢«ç§°ä½œä¸ºå†›ç—ï¼Œä½†æ˜¯è¿™ä¸ªä¸–ç•Œä¸Šæ­£ç›´çš„å†›äººä¸€å®šå¾ˆå¤šçš„ã€‚ä½†æ˜¯æœ‰è¿™æ ·çš„ç»å†ä¹Ÿä¸å¯èƒ½å®Œå…¨é¿å…æ‰ï¼Œåœ¨è¿™äº›å¤©é‡Œï¼Œæˆ‘æ”¶è·æœ€å¤šçš„æ˜¯æˆ‘ä¼šè¢«ç£¨å¹³çš„æ€¥æ€§å­å’Œè‡ªå·±çš„å¿è€èƒ½åŠ›ã€‚è™½ç„¶æ¯å¤©éƒ½åœ¨å€’è®¡æ—¶æ•°æ•°è¿˜å‰©ä¸‹å¤šå°‘å¤©ï¼Œè™½ç„¶æ¯å¤©éƒ½åœ¨å¿ƒåº•é‡Œä¸è¿™ç§åœ¨æˆ‘çœ‹æ¥æ¯«æ— æ„ä¹‰ç”šè‡³æ˜¯æ¯ç­äººæ€§çš„è™å¾…ä½œæ–—äº‰ï¼Œä½†æ˜¯æˆ‘çŸ¥é“è¿™ç§æ—¶å€™å¯ä»¥åæŠ—ï¼Œå¯ä»¥ç›´æ¥ç”©è„¸å°±èµ°ï¼Œä½†æ˜¯è‡ªå·±å·²ç»æˆäººäº†ï¼Œæˆäººå¿…é¡»å…·å¤‡è¿™æ ·çš„ä¸€ä¸ªè§‚ç‚¹ï¼Œæˆäººçš„ä¸–ç•Œé‡Œå¿…é¡»éµå®ˆè§„åˆ™ã€‚ä¸éµå®ˆè§„åˆ™çš„äººç›´æ¥å‡ºå±€ã€‚æ‰€ä»¥å°±ä¼šæœ‰å¿è€çš„å­˜åœ¨ã€‚ç°åœ¨çœŸçš„æ˜¯ä»€ä¹ˆå†³å®šæœ€åçš„æ‰¿æ‹…è€…å¿…é¡»æ˜¯è‡ªå·±äº†ï¼Œå¯¹è‡ªå·±è´Ÿè´£ï¼Œéµå®ˆæ¸¸æˆè§„åˆ™ã€‚è¿™æ¬¡å†›è®­å‰é¢å¾ˆç´¯åé¢å¾ˆè½»æ¾ï¼Œæ–°çš„ç”Ÿæ´»å³å°†å¼€å§‹ï¼Œå‡†å¤‡å¥½è‡ªå·±çš„å¥èº«è®¡åˆ’ï¼Œè‹±è¯­å’Œè¯»ä¹¦è®¡åˆ’ï¼Œè¿™æ˜¯ä½ éœ€è¦åšçš„äº‹æƒ…ã€‚æœ€åæ¥ä¸€å¥æŒ¯å¥‹äººå¿ƒçš„é¸¡æ±¤ã€‚æœªæ¥çš„ä½ ä¸€å®šä¼šæ„Ÿè°¢ç°åœ¨æ‹¼å‘½åŠªåŠ›çš„è‡ªå·±ã€‚]]></content>
      <categories>
        <category>æˆé•¿</category>
      </categories>
      <tags>
        <tag>é’æ˜¥</tag>
        <tag>ç»å†</tag>
        <tag>å†›è®­</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é—å¤±çš„2016ä¸æ— é™å¯èƒ½çš„2017]]></title>
    <url>%2F2017%2F08%2F01%2F%E9%81%97%E5%A4%B1%E7%9A%842016%E4%B8%8E%E6%97%A0%E9%99%90%E5%8F%AF%E8%83%BD%E7%9A%842017%2F</url>
    <content type="text"><![CDATA[ä¸ä¸Šä¸€æ¬¡å†™ä¸‹åšå®¢çš„æ—¶é—´å®åœ¨æ˜¯è¿‡å»äº†å¤ªä¹…å¤ªä¹…ï¼Œä»å»å¹´é«˜è€ƒçš„æ„å¤–å¤±è´¥ï¼Œåˆ°ä»Šå¹´é«˜è€ƒè¿‡åä¸çŸ¥é“æ˜¯åº”è¯¥å¼€å¿ƒè¿˜æ˜¯æƒ‹æƒœçš„å±€é¢ã€‚æˆ‘çŸ¥é“è‡ªå·±å¹¶ä¸æ˜¯ä¸€ä¸ªå¼ºè°ƒé«˜è€ƒä¸€å®šæ˜¯ä¸€ä»¶å…³ä¹ç”Ÿæ­»çš„å¤§äº‹ã€‚ä¹‹æ‰€ä»¥é€‰æ‹©å¤è¯»è¿™æ¡è·¯å‘¢ï¼Œæ˜¯è§‰å¾—ä¸ç”˜å¿ƒï¼Œå› ä¸ºçŸ¥é“è‡ªå·±æ˜¯ä¸€ä¸ªå®¹æ˜“å—ç¯å¢ƒå½±å“çš„äººï¼Œä¸ç”˜å¿ƒå°±æ­¤å¹³åº¸ä¸‹å»ã€‚äºæ˜¯è¿™ä¸€å¹´å°±åƒæ˜¯æ¶ˆå¤±ï¼Œä¸å†å…³å¿ƒç½‘ä¸Šçš„ä¸€äº›åŠ¨æ€ã€‚å…ˆå¼€å§‹æ˜¯æŠ±ç€è‹¦è¯»ä¹¦çš„å¿ƒæ€åŠ å…¥åˆ°äº†å¤è¯»çš„é˜Ÿä¼ä¸­ï¼Œä½†æ˜¯ç­‰åˆ°çœŸæ­£èå…¥åˆ°é‚£ä¸ªç¯å¢ƒä¸­è‡ªå·±ä¸€ä¸ªè‡´å‘½çš„æ¯›ç—…å†ä¸€æ¬¡çŠ¯äº†ï¼Œå¼€å§‹è½»è§†è‡ªå·±æœ€åçš„ç›®æ ‡ã€‚å¼€å§‹æµªï¼Œå¼€å§‹æ²¡æœ‰é«˜ä¸‰é‚£å¹´è¿™ä¹ˆä¸è®¤çœŸå­¦ä¹ ã€‚è™½ç„¶æœ€åç»“æœä¸å·®ï¼Œä»æ¹–åŒ—çœçš„66000å¤šåè·³åˆ°äº†24000åï¼Œä½†æ˜¯æˆ‘è§‰å¾—å¦‚æœå½“æ—¶è‡ªå·±ä¸é‚£ä¹ˆè½»è§†é«˜è€ƒçš„è¯ï¼Œè‚¯å®šä¼šæ›´å¥½ã€‚ä½†æ˜¯äººç”Ÿå°±æ˜¯äººç”Ÿï¼Œç»å†è¿‡æ‰ä¼šåˆ»è‹¦é“­å¿ƒã€‚è¿™ä¸€å¹´è¯´é•¿ä¹Ÿä¸é•¿ï¼Œè¯´çŸ­å‘¢ï¼Œå€’ä¹Ÿæ˜¯ç›¼äº†æ•°ä¸æ¸…çš„æ—¥æ—¥å¤œå¤œã€‚åœ¨å¤è¯»çš„ç­çº§é‡Œæˆ‘è§è¿‡å„å¼å„æ ·çš„é¢“åºŸï¼Œä¸å„å¼å„æ ·çš„æƒ¨æ·¡ï¼Œè¿˜æœ‰å„å¼å„æ ·çš„å¯¹æ¢¦æƒ³çš„æ‘§æ®‹ä¸äºµæ¸ï¼Œç”šè‡³åœ¨æœ‰ä¸€äº›äººèº«ä¸Šå®Œå…¨ä¸ç”¨è·Ÿä»–ä»¬è°ˆè®ºæ¢¦æƒ³ã€‚æˆ‘è§‰å¾—è¿™å°±æ˜¯ä¸€ç§æå‰è¡°è€çš„ä¸–ä¿—æ°”å’Œæ­»æ°”ï¼Œè·Ÿä»–ä»¬ç›¸äº’äº¤æµçš„è¿‡ç¨‹ä¸­ï¼Œéš¾å…ä¸ä¼šè¢«å…¶æ²¾æŸ“åˆ†æ¯«ã€‚ç”±äºç§ç§åŸå› æ¢åˆ°å¤–é¢çš„åˆç§Ÿå¯å®¤ä¸å¦å¤–ä¸€ä¸ªå¤è¯»ç­çº§ã€‚ä¸è¿‡è¿˜æ˜¯ç»å¸¸ç”¨ä¸€äº›ç¨€å¥‡å¤æ€ªçš„ç†ç”±å»ç¿˜è¯¾ã€‚ç°åœ¨æƒ³æ¥æ²¡æœ‰æŒ‡è´£ï¼Œä¹Ÿæ²¡æœ‰ä»€ä¹ˆå¼•ä»¥ä¸ºè±ªçš„å˜æ€æƒ³æ³•ï¼Œåªå‰©ä¸‹ä¸€ç§å¥½ç¬‘çš„æƒ³æ³•ã€‚ä¸è¿‡åœ¨å¤è¯»çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘æœ‰ä¸€æ¬¡è¿˜ç»å†è¯·æ¥äº†è­¦å¯Ÿï¼Œäº‹æƒ…çš„åŸå› æ˜¯æˆ‘å¿å—ä¸äº†ä¸€äº›ç‹—è¡€ä¸è’è°¬çš„è§„å®šï¼Œæˆ‘äºæ˜¯å°±ä¸å…¶å¯¹ç€å¹²ï¼Œç„¶åå¯¹æ–¹ä»¥æˆ‘é—¹äº‹ä¸ºåè¯·æ¥äº†è­¦å¯Ÿã€‚å°±è·Ÿè­¦å¯Ÿå¥½å¥½èŠèŠå‘—ã€‚æœ€åå¾—å‡ºçš„ç»“è®ºï¼Œä¹Ÿå°±æ˜¯ä»è¿™ä»¶äº‹æƒ…å¾—å‡ºæ¥çš„æƒ³æ³•ï¼Œç¤¾ä¼šä¸Šæ˜¯å­˜åœ¨ç‹—çœ¼çœ‹äººä½çš„ç°è±¡ï¼Œä¹Ÿå­˜åœ¨æŸäº›è’è°¬çš„è§„å®šï¼Œä½†æ˜¯å¦‚æœä½ æ²¡æœ‰æ”¹å˜è¿™äº›è§„åˆ™çš„èƒ½åŠ›ä¸ç­¹ç çš„æ—¶å€™ï¼Œä½ æœ€å¥½è¿˜æ˜¯å¿ä¸‹æ¥ï¼Œå…å¾—æœ€åå—ä¼¤å®³å’Œå‡ºç¬‘è¯çš„éƒ½æ˜¯ä½ ã€‚æœ€å6ä¸ªæœˆå’Œ7ä¸ªæœˆçš„æ—¶å€™æ¢äº†å¯å®¤ï¼Œè·Ÿä¸¤ä¸ªè‡ªè®¤ä¸ºç©çš„ä¸é”™çš„æœ‹å‹åˆç§Ÿäº†æˆ¿å­ï¼Œä¹‹æ‰€ä»¥ä¼šäº§ç”ŸçŸ›ç›¾å°±æ˜¯è§‰å¾—æ¨¡ç³Šäº†æœ‹å‹ä¸å®¤å‹çš„å…³ç³»ã€‚æˆ‘è§‰å¾—è¿™ä¸€ç‚¹æˆ‘åˆ°å¤§å­¦å»ä¸€å®šå¾—æ³¨æ„ã€‚æœ‹å‹æ˜¯å¿—åŒé“åˆçš„ï¼Œæ˜¯å¯ä»¥äº¤å¿ƒçš„ã€‚è€Œå®¤å‹åˆ™æ˜¯åªæ˜¯ä½åœ¨ä¸€èµ·ï¼Œæœ‰çš„æ—¶å€™ä¸éœ€è¦æœ‰å…±åŒçš„å¥‹æ–—ç›®æ ‡ï¼Œåªæ˜¯ä½åœ¨ä¸€èµ·ï¼Œè¡£é£Ÿä½è¡Œä¸Šçš„ç›¸äº’ç…§åº”ã€‚å®¤å‹æ²¡æœ‰å¿…è¦ä¼šæˆä¸ºå¥½æœ‹å‹ã€‚è¿™å°±æ˜¯ä»¥åéœ€è¦æ³¨æ„çš„åœ°æ–¹äº†ã€‚ç„¶åå°±æ˜¯ä½“é‡é—®é¢˜äº†ï¼Œè¿™ä¸ªæ˜¯ç¡¬ä¼¤ï¼Œæœ¬æ¥å»å¹´å»å¤è¯»å‰ä½“é‡ä¸º84å…¬æ–¤ï¼Œå¥½ä¸å®¹æ˜“ç˜¦ä¸‹æ¥çš„ï¼Œç°åœ¨æ‰åˆšåˆšæ¢å¤åˆ°é¡¶å°–æ°´å¹³ã€‚ä¸è¿‡åŠ æ²¹å§ã€‚è¿™ä¸ªä¸œè¥¿æ˜¯æ€¥ä¸æ¥çš„æ…¢æ…¢åŠ æ²¹ä¸€å®šä¼šçœ‹åˆ°æˆæ•ˆçš„ï¼Œæ­£æ‰€è°“ï¼Œç‰æ ‘åˆ™ä¸è¾¾å˜›ã€‚ä¸è¿‡ä»¥åè¿˜æ˜¯è¦æœ‰ä¸€ä¸ªå¥½çš„å¥èº«è®¡åˆ’å’Œå¥åº·çš„ä½œæ¯æ—¶é—´è¡¨ã€‚è¦è¯´è¿™ä¸€å¹´æˆé•¿äº†ä¹ˆï¼Œæˆ‘è§‰å¾—ä¸»è¦æ˜¯ç”±ä»¥å‰ç†æ€§çš„æ€ç»´å˜å¾—æ›´åŠ å¤šå…ƒä»¥åŠæ›´åŠ æ·±å…¥ï¼Œè°¢è°¢å¥‡è‘©è¯´å’Œç‹¼äººæ€è¿™ä¸¤é¡¹äº‹ç‰©è®©æˆ‘çœ‹åˆ°äº†è¿™ä¸ªä¸–ç•Œä¸Šè¿˜å­˜åœ¨ç€è¯¸å¤šå¯èƒ½æ€§ã€‚å‘µå‘µï¼Œå¹´è½»å°±æœ‰æ— é™å¯èƒ½å˜›è¿˜æœ‰ä¸€ä¸ªæœˆå°±è¦è¯»å¤§å­¦ã€‚è™½ç„¶æœ‰æ—¶å€™è§‰å¾—è¿™ä¸ªå¤§å­¦ä¹Ÿé€‰çš„ä¸æ€ä¹ˆæ ·ï¼Œæ¯•ç«Ÿå¯ä»¥å½“ä½œæ˜¯æ»‘æ¡£ä¸‹æ¥è¯»çš„ä¸€æ‰€å¤§å­¦ï¼Œä½†æ˜¯å¬åˆ°ä¸€å¥è¯ï¼Œä½ æ²¡æœ‰åˆ°è¿™ä¸ªå­¦æ ¡çš„ç¬¬ä¸€åï¼Œä½ æ˜¯æ²¡æœ‰èµ„æ ¼æŒ‡è´£è¿™ä¸ªå­¦æ ¡å¯¹ä½ æ˜¯æ²¡æœ‰ç›Šå¤„çš„ï¼Œå› ä¸ºåœ¨è¿™ä¸ªå­¦æ ¡é‡Œé¢ä½ æ€»æ˜¯ä¼šæœ‰ä¸Šå‡çš„ç©ºé—´ã€‚ä»¥å‰çœŸçš„æœ‰ä¸€ç§å¿ƒæ€ï¼Œå°±æ˜¯ç‰¹åˆ«æƒ³æ‰¾ä¸€ä¸ªå¯¹è±¡ï¼Œå¥½å¥½è¿‡ï¼Œå¥½å¥½é£èŠ±é›ªæœˆï¼Œæ›¾ç»ä¹Ÿå •è½è¿‡ï¼Œä¹Ÿç³œä¹±è¿‡ï¼Œæœ‰çš„æ—¶å€™æƒ³æƒ³æˆ‘ä»¬è¿™ä¸ªå¹´çºªå¾ˆå®¹æ˜“æŠŠæ¬£èµå½“ä½œæ˜¯å–œæ¬¢ï¼ŒæŠŠä¸€ç§ç¾¡æ…•çš„æƒ³æˆä¸ºå½“ä½œæ˜¯çˆ±æƒ…ï¼Œåˆ°æœ€ååè€Œä½¿çˆ±æƒ…çš„çœŸè°›éšä¸‹å»äº†ï¼Œæˆ‘è§‰å¾—çˆ±æƒ…å°±æ˜¯å¹³ç­‰ï¼Œç²¾ç¥ä¸Šçš„å¹³ç­‰ï¼Œäº’ç›¸æˆé•¿ï¼Œäº’ç›¸åŠ æ·±å¯¹äººç”Ÿçš„ç†è§£ï¼Œä¹Ÿè®¸æœ‰çš„æ—¶å€™æ€§å’Œæ¬²æœ›ä¼šå¸¸å¸¸æ¥å¹²æ¶‰ï¼Œä½†æ˜¯æ— è®ºå¦‚ä½•éƒ½å æ®ä¸äº†çˆ±æƒ…çš„çœŸè°›ã€‚æˆ‘å¹´çºªè¿˜å°ï¼Œå¯¹å©šå§»çš„ç†è§£è¿˜å°šåœ¨ä¸Šä¸€è¾ˆä¹‹é—´ï¼Œä»–ä»¬è®©æˆ‘æ„Ÿå—åˆ°æœ€å¤šçš„æ˜¯ç”Ÿæ´»çš„è¿«ä¸å¾—å·²ï¼Œä¹Ÿå°±æ˜¯æ— å¯å¥ˆä½•çš„ä¸€èµ·è¿‡æ—¥å­ã€‚ä¼šä¸ä¼šç»“å©šï¼Œèƒ½ä¸èƒ½ç»“å©šï¼Œè¿™éƒ½ä¸æ˜¯ç°åœ¨åº”è¯¥è€ƒè™‘çš„é—®é¢˜ï¼Œæˆ‘ä¸€ç”Ÿéƒ½ä¼šç§‰æŒç€ä¸€ä¸ªç†å¿µï¼ŒFollow my heart ã€‚æˆ‘ç°åœ¨æ‰€åšçš„ä¸€èµ·åŠªåŠ›ä½¿ä¸ºäº†è®©æœªæ¥çš„æˆ‘åœ¨äº‹æƒ…çš„æŠ‰æ‹©æ–¹é¢èƒ½æ›´åŠ é è¿‘æœ¬å¿ƒæœ¬æ„¿ä¸€è¾¹ã€‚å½“ç„¶ç°åœ¨è¿˜ä¸èƒ½æŠŠå¤§å­¦æœ€ç»ˆæœå“ªä¸ªæ–¹å‘å®šä¸‹æ¥ã€‚ä½†æ˜¯å‹‡æ•¢ï¼Œæ— ç•ï¼Œæˆ‘è§‰å¾—æ˜¯äººç”Ÿä¸­æœ€é‡è¦çš„å“è´¨ã€‚åœ¨æˆ‘çš„è§†è§’é‡Œè’åºŸçš„2016å¹´ï¼Œå°±ç»™2017å¹´çš„æˆ‘æ— é™çš„å¯èƒ½ã€‚åœ¨ä»Šåçš„ç”Ÿæ´»ä¸­æˆ‘è§‰å¾—ä¸€å¥è¯å¯ä»¥æˆä¸ºæˆ‘çš„è·¯æ ‡æ²¡æœ‰ä»€ä¹ˆå¯ä»¥é€šå‘çœŸè¯šï¼Œå› ä¸ºçœŸè¯šæ˜¯é€šå‘ä¸€åˆ‡é“è·¯ã€‚çœŸè¯šé¢å¯¹äººï¼Œé¢å¯¹äº‹ï¼Œé¢å¯¹ä»Šåå¯èƒ½å‡ºç°çš„æ— é™æŒ«æŠ˜éš¾è¿‡ï¼Œä»¥åŠå¼€å¿ƒå®Œç¾ä¸èƒœåˆ©ã€‚æœªæ¥æ— è®ºå¦‚ä½•ï¼Œæ€»ä¹‹æˆ‘çœŸè¯šï¼Œæˆ‘å¦è¡ï¼Œæˆ‘ä¼šè®©è¿™æ— é™çš„å¯èƒ½å°½å¯èƒ½çš„æŒ‰ç…§æˆ‘å¿ƒæƒ³è±¡çš„æ–¹å‘å‰è¿›ã€‚åŠ æ²¹ã€‚å› ä¸ºä½ å«ç‹èˆ’å•¸ã€‚]]></content>
      <categories>
        <category>æˆé•¿</category>
      </categories>
      <tags>
        <tag>æˆé•¿</tag>
        <tag>é’æ˜¥</tag>
        <tag>ç»å†</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015å¹´å¹´åº¦æ€»ç»“]]></title>
    <url>%2F2015%2F12%2F02%2F2015%E5%B9%B4%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[ä»Šå¹´æ˜¯ä¸€ä¸ªç¥å¥‡çš„ä¸€å¹´ï¼Œåšäº†è®¸å¤šä»¥å‰æ²¡æœ‰æƒ³è¿‡çš„äº‹æƒ…ã€‚ä½†ä¹Ÿç¢°è§¦åˆ°äº†ä¸€äº›ç¦å¿Œçš„äº‹ã€‚æ³°æˆˆå°”ä¹Ÿè¯´è¿‡ï¼Œäººå¤©ç”Ÿæœ€å¼ºå¤§çš„åŠ›é‡ä¾¿æ˜¯æˆé•¿ã€‚å¯¹ï¼Œå°±æ˜¯æˆé•¿ã€‚æˆ‘ä»¬æ¯ä¸€ä¸ªäººç”Ÿæ¥å°±ä¸æ˜¯å®Œç¾çš„ï¼Œæˆ‘çŸ¥é“è‡ªå·±çš„ç¼ºç‚¹ï¼Œè‡ªå·±çš„æ‡¦å¼±ï¼Œè‡ªå·±åœ¨2015å¹´æ‰€çŠ¯ä¸‹çš„é”™è¯¯ã€‚ä½†æ˜¯è¿˜å¥½ï¼Œå·²ç»è¿‡å»äº†ï¼Œæˆ‘ä¹Ÿåº”è¯¥é•¿å¤§äº†ã€‚æˆ‘ä¹ŸåŒæ ·è®°å¾—æŸ´é™è¯´è¿‡çš„ï¼Œåªæœ‰åŒæ ·ç»å†è¿‡çš„äººæ‰æœ‰èµ„æ ¼è¯´æˆ‘ç†è§£ä½ ã€‚2015å¹´ä¸ŠåŠå¹´ç»å†è¿‡ä¸€åœºè½¦ç¥¸ï¼Œç»ˆäºä»å°å­©å­çš„è®¤çŸ¥ï¼Œå¼ºè¡Œæå‡åˆ°äº†æˆäººé˜¶æ®µï¼Œè™½ç„¶æœ‰è¯¸å¤šä¸æ„¿ï¼Œä½†æ˜¯ï¼Œä»åœ¨æ…¢æ…¢é€‚åº”ã€‚é«˜äºŒä¸Šå­¦æœŸï¼Œé«˜äºŒä¸‹å­¦æœŸï¼Œé«˜ä¸‰ã€‚æ—¶é—´è¿‡å¾—å¾ˆå¿«ã€‚æˆ‘ç†è§£äº†å¾ˆå¤šä»¥å‰ä¸ç†è§£çš„ï¼Œçœ‹åˆ°äº†ä»¥å‰çœ‹ä¸åˆ°çš„ã€‚äººçœŸçš„åªæœ‰ç»å†è¿‡ç—›è‹¦æ‰ä¼šçŸ¥é“è‡ªå·±çœŸæ­£æƒ³è¦çš„æ˜¯ä»€ä¹ˆã€‚æœ‰çš„æ—¶å€™æ¬²æœ›ï¼Œè´ªå¿µï¼ŒçœŸçš„ä¼šæ¯æ‰ä¸€ä¸ªäººï¼Œä½†æ˜¯ä¹Ÿåªæœ‰æ‰¿å—ä½æ¥è‡ªä¸å…¶ç£¨éš¾æ‰å¯ä»¥çœŸæ­£æˆäººã€‚ ä½†æ˜¯ç”±äºè‡ªå·±çš„æ„å¿—åŠ›ä¸å¤Ÿï¼Œæ€»æ˜¯å¤±è´¥ï¼Œä½†æ˜¯æˆ‘ä¹Ÿä¸ä¼šå¦¥åï¼ŒæŠ—äº‰åˆ°åº•ï¼Œè¿™æ‰æ˜¯æˆ‘ã€‚ä¸è¿‡è¯´åˆ°æ„å¿—åŠ›ï¼Œä½•è°“æ„å¿—åŠ›å‘¢ï¼Œä¸ªäººè§‰å¾—æ˜¯ä¸€ç§æŠ—é€†çš„èƒ½åŠ›ã€‚æŠ—æ‹’ç—›è‹¦å’Œè¯±æƒ‘çš„èƒ½åŠ›ã€‚ä¸å·§ï¼Œæ›¾ç»æ‹¥æœ‰è¿‡çš„å“è´¨ï¼Œç”±äºç”Ÿæ´»è¿‡äºå®‰é€¸ï¼Œå†é€æ¸æ¶ˆå¤±ã€‚æ¯”å¦‚è¯´è‡ªå·±çš„æ‹–å»¶ç—‡ï¼Œè¯´å¤§ä¸å¤§ï¼Œä½†æ˜¯è¯´å°ä¹Ÿä¸å°ã€‚æˆ‘è®¨åŒç—›è‹¦ï¼Œè¿™å°±æ˜¯æ‹–å»¶ç—‡æœ¬è´¨çš„åŸå› ã€‚åŒ…æ‹¬ï¼Œç»™è‡ªå·±çš„ä»»åŠ¡å®Œæˆä¸äº†ï¼Œè¿™ä¹Ÿæ˜¯å…¶åŸå› é€ æˆçš„ã€‚æ²¡æœ‰æ¯…åŠ›ã€‚å®¹æ˜“åœ¨å®¶äººé¢å‰æ§åˆ¶ä¸ä½è‡ªå·±çš„æƒ…ç»ªã€‚æ–°çš„ä¸€å¹´ï¼Œæˆ‘ä¸€å®šä¼šæ”¹å˜è¿™äº›ã€‚è¿™ä¸€å¹´é‡Œï¼Œä¹Ÿç»“è¯†äº†è®¸å¤šäººï¼Œé€æ¸çŸ¥é“ç¤¾ä¼š7ä¸Šçš„äººæƒ…å†·æš–ï¼Œä»¥åŠäººè„‰ã€‚æˆ‘ä¸æƒ³çŸ¥é“è¿™äº›ï¼Œä½†æ˜¯ç°åœ¨èƒ½åšçš„ä¹Ÿå°±æ˜¯é»˜é»˜çš„æ¥å—ï¼Œæ€»å¥½æ¯”ä¸€å‘³çš„æŠ—æ‹’ã€‚è‡ªå·±çš„æ€§æ ¼ä¹Ÿæ”¹äº†å¾ˆå¤šï¼Œä¸€åˆ‡æœå¥½çš„æ–¹å‘è¿›è¡Œè½¬å˜ã€‚ç°åœ¨çš„æˆ‘ï¼Œä¹Ÿä¼šå­¦ä¹ æ¯ä¸ªäººè‡ªå·±æ‰€é‡åˆ°äººçš„ä¼˜ç‚¹ï¼Œä»è€Œæ”¹å˜è‡ªå·±ã€‚ä¹Ÿè®¸ç¼“æ…¢ï¼Œä½†æ˜¯æ–¹å‘æ˜¯å¯¹çš„ã€‚å…³äºä½ è‡ªå·±ï¼Œæˆ‘çŸ¥é“æœ‰çš„æ—¶å€™ä¼šæœ‰ä¸€ç§å¥‡å¼‚çš„æ„Ÿè§‰åŒ…å›´ç€ä½ ï¼Œä½†æ˜¯è¯·ç›¸ä¿¡ä¸€åˆ‡çš„ä¸€åˆ‡éƒ½ä¼šå¥½çš„ã€‚æ‰“ç ´å¸¸è§„ï¼Œéµå¾ªæœ¬å¿ƒã€‚åªå½“åšçœ‹é˜´é˜³é€ åŒ–äº†ã€‚ä»Šåçš„æ—¥å­ï¼Œæˆ‘å¸Œæœ›è‡ªå·±èƒ½å¤Ÿå¦è¡åšäººï¼Œæ´»å‡ºçœŸå®çš„è‡ªå·±ï¼Œä¸è‡ªå·±çš„é‚ªå¿µæŠ—äº‰åˆ°åº•ï¼Œå®Œæˆè‡ªå·±çš„ç›®æ ‡ï¼Œè¿‡ä¸€ç§â€œæ²¡æœ‰ä»»ä½•å€Ÿå£â€çš„ç”Ÿæ´»ã€‚å¯¹è‡ªå·±ï¼Œå¯¹åˆ«äººï¼Œå¯¹ä¸€åˆ‡è´Ÿè´£ã€‚æœ€åçš„æœ€åï¼Œç¥è‡ªå·±é«˜è€ƒåœ†æ»¡ï¼Œä¸æ±‚ç—´å¿ƒå¦„æƒ³ï¼Œåªæ±‚é—®å¿ƒæ— æ„§ã€‚]]></content>
      <categories>
        <category>æˆé•¿</category>
      </categories>
      <tags>
        <tag>æˆé•¿</tag>
        <tag>æ€»ç»“</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[çœ‹è§ä¸ç»å†]]></title>
    <url>%2F2015%2F08%2F29%2F%E7%9C%8B%E8%A7%81%E4%B8%8E%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[ä¸€ç›´ä»¥æ¥éƒ½æ˜¯æƒ³å†™ç‚¹ä»€ä¹ˆï¼Œè·ç¦»æˆ‘ä¸Šä¸€æ¬¡å‘åšæ–‡ä¹Ÿå·²ç»è¿‡å»å°†è¿‘åŠå¹´äº†ï¼Œè¿™åŠå¹´é‡Œï¼Œä¹Ÿå¯ä»¥è¯´è¿™2015å¹´é‡Œå¯¹æˆ‘çš„æ”¹å˜ä¹Ÿæ˜¯æŒºå¤§çš„ã€‚çŸ¥é“ä»€ä¹ˆæ˜¯è‹¦ï¼Œä»€ä¹ˆæ˜¯ä¹ï¼Œä»€ä¹ˆæ˜¯æ¬²æœ›ï¼Œä»€ä¹ˆæ˜¯çˆ±ã€‚ä»Šå¤©æ˜¯è·ç¦»é«˜ä¸‰å¼€å­¦çš„æœ€åä¸€å¤©ï¼Œä¸çŸ¥é“æˆ‘ä¸ºä»€ä¹ˆæ€»æ˜¯è¿™ä¹ˆå–œæ¬¢åšè¿™æ ·çš„äº‹ï¼Œç›´åˆ°æœ€åä¸€æ­¥æ‰å¼€å§‹å®Œæˆã€‚æˆ‘çŸ¥é“æ¥è‡ªäºè‡ªèº«é‡Œçš„ç¼ºé™·ã€‚æˆ‘æ‡’ï¼Œæˆ‘æ²¡æœ‰è¿‡å¤§çš„è‡ªåˆ¶åŠ›ï¼Œä¹Ÿæ²¡æœ‰å¤ªå¼ºçš„æ‰§è¡ŒåŠ›ã€‚ æˆ‘å¾ˆæ‡¦å¼±ï¼Œæ‰€ä»¥é€ƒé¿ã€‚æˆ‘ä¸€ç›´åšä¿¡ç€ä¸€ä¸ªäººæœ€å¯æ€•çš„å¹¶ä¸æ˜¯å¼±ç‚¹ï¼Œè€Œæ˜¯åœ¨æœ‰ç”Ÿä¹‹å¹´å¹¶ä¸å»æ”¹å˜è¿™äº›ç¼ºç‚¹ã€‚å¼ºç‚¹å°±æ˜¯å°†è‡ªå·±çš„æ‡¦å¼± å‰äº›æ—¥å­ä¹Ÿçœ‹è¿‡ä¸€äº›ä¹¦ç±ï¼Œè¿™æœ¬ä¹¦å¯¹æˆ‘çš„å¯å‘å¾ˆå¤§ï¼Œå¹¶ä¸èƒ½è¯´è¿™æœ¬ä¹¦ç»™äº†æˆ‘å¾ˆå¤§çš„æ„Ÿå—ï¼Œå› ä¸ºé‚£éƒ½æ˜¯åˆ«äººçš„ç”Ÿæ´»ï¼Œåˆ«äººçš„äººç”Ÿå†ç»ƒã€‚ä½†æ˜¯ä»–æ‰“å¼€äº†æˆ‘é€šå‘è¿™ä¸ªä¸–ç•Œçš„å¤§é—¨ã€‚æˆ‘çŸ¥é“ç”Ÿï¼Œä¹ŸçŸ¥é“æ­»ï¼Œä¹ŸçŸ¥é“çˆ±ï¼Œåªæ˜¯æœ‰çš„äº²èº«ç»å†è¿‡ï¼Œæœ‰çš„å¹¶æ²¡æœ‰ç»å†è¿‡ã€‚æˆ‘çŸ¥é“ä¸»è§‚ï¼Œä¹ŸçŸ¥é“å®¢è§‚ã€‚è¿™äº›å¸¦ç»™æˆ‘çš„éƒ½åªæ˜¯æˆ‘äººç”Ÿè·¯ä¸Šçš„ä¸€ä¸ªç»å†ã€‚æ›¾ç»çš„æˆ‘è®¤ä¸ºè¦å¯¹èº«è¾¹çš„äººæ— ä¸‹é™çš„å¥½ï¼Œä¹Ÿæ›¾ç»è®¤ä¸ºè‡ªå·±å·²ç»å¾ˆæˆç†Ÿã€‚è®¤ä¸ºè‡ªå·±çš„æ¶ˆæçš„æ€åº¦å°±æ˜¯æˆç†Ÿä¹‹äººå¿…å¤‡çš„ã€‚é”™é”™é”™ã€‚çœŸæ­£çš„æˆç†Ÿå°±æ˜¯è¦åœ¨å¤–ç•Œçš„å‹åŠ›å’Œå†…ç•Œçš„èœ•å˜ä¸‹æ‰¾åˆ°çœŸæ­£çš„è‡ªå·±ï¼Œæ‰€è°“ç ´è€Œåç«‹ï¼Œå½“ä½ å·²ç»ç«‹åˆ°ä¸èƒ½å†ç ´çš„æ—¶å€™ï¼Œä½ ä¹Ÿå°±å½¢æˆäº†è‡ªå·±çš„æ€æƒ³ç†è®ºå’Œè‡ªå·±æœ‰åˆ«äºä»–äººçš„é²œæ˜ä¸ªæ€§ã€‚è€Œå¾€å¾€æ¥è¯´è¿™ä¸ªè¿‡ç¨‹å´æ˜¯è¦èŠ±è´¹ä¸€è¾ˆå­çš„æ—¶é—´ã€‚ é©¬ä¸Šè¿™ä¸ªæš‘å‡ä¹Ÿè¿‡å»äº†ï¼Œåœ¨è¿™ä¸ªæš‘å‡é‡Œï¼Œæˆ‘ç”±è¡·çš„è§‰å¾—æ¬²æœ›å’Œçˆ±ä¹‹é—´çš„å…³ç³»ï¼Œæˆ‘å¯ä»¥åšä¸€ä¸ªåªæœ‰æ¬²æœ›çš„äººï¼Œé¢å¯¹å½¢å½¢è‰²è‰²çš„äººä¸åŠ¨è‡ªå·±çš„ç”Ÿè‰²ã€‚æˆ‘ç›®å‰è§‰å¾—æ‰¾ä¸€ä¸ªä¸è‡ªå·±æƒºæƒºç›¸æƒœçš„äººé‚£ç§é»˜å¥‘æ‰æ˜¯æˆ‘çœŸæ­£éœ€è¦çš„ã€‚å½“äººè€ƒè™‘è¿™äº›ä¸œè¥¿è¦ç­‰åˆ°å¤§åŠå¹´ä¹‹åï¼Œç­‰æˆ‘é«˜ä¸‰ç»“æŸä¹‹æ—¶ï¼Œä¹Ÿå°±æ˜¯æˆ‘äººç”Ÿè§‰é†’ä¹‹åˆ»ã€‚è¿™ä¸ªå¤å¤©å­¦ä¼šäº†ä¸€ä¸ªäººå»æ—…è¡Œï¼Œå­¦ä¼šäº†çœ‹é¢˜å›¾ï¼Œå­¦ä¼šäº†å¤„ç†è‡ªå·±ä¸è¿åŠ¨ä¹‹é—´çš„å…³ç³»ã€‚æ˜å¤©æˆ‘å°†å†æ¬¡è¸ä¸Šæˆ˜åœºï¼Œæ•´è£…å¾…å‘ã€‚ ä¸€ç›´ç›¸ä¿¡è‡ªå·±ï¼Œä»ä¸ä¼šå¤±æœ›ã€‚ å¢¨æ©¹ å†™äº 8æœˆ30æ—¥]]></content>
      <categories>
        <category>æˆé•¿</category>
      </categories>
      <tags>
        <tag>æˆé•¿</tag>
        <tag>ç»å†</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ã€ä¹¦è®°ã€‘æ´»ç€]]></title>
    <url>%2F2015%2F04%2F06%2F%E3%80%90%E4%B9%A6%E8%AE%B0%E3%80%91%E6%B4%BB%E7%9D%80%2F</url>
    <content type="text"><![CDATA[æˆ‘ä»Šå¤©è¦åˆ†äº«çš„å°è¯´æ˜¯æ´»ç€ï¼Œè¿™æœ¬å°è¯´è®²è¿°çš„æ˜¯ä¸€ä¸ªäººä¸å‘½è¿ä¹‹é—´çš„å…³ç³»ï¼Œä»–ä»¬æ— æ³•æ¥å—å¯¹æ–¹ï¼Œä½†åŒæ—¶ä¹Ÿæ²¡æœ‰åŠæ³•èƒŒç¦»å¯¹æ–¹ã€‚è¿™æœ¬ä¹¦æˆ‘çš„å¾ˆå¤šæœ‹å‹éƒ½çœ‹è¿‡ï¼Œä»–ä»¬ä¸ºæ•…äº‹é‡Œçš„æ‚²å‰§è§’è‰²å¹æ¯ï¼Œç”šè‡³æœ‰å‡ ä¸ªæ„Ÿæ€§çš„æœ‹å‹æ¯æ¯è°ˆèµ·è¿™æœ¬ä¹¦æ€»ä¼šæ³ªæ»´ç‚¹ç‚¹ã€‚è¿™æœ¬ä¹¦å¦‚æœæ•´ä¸ªçœ‹ä¸‹æ¥æˆ‘çœ‹è¿‡9éï¼Œåªæ˜¯ä¸€éƒ¨åˆ†ä¸€éƒ¨åˆ†çš„çœ‹çš„è¯ï¼Œæˆ‘çœ‹è¿‡ä¸æ­¢åå…«éã€‚è™½ç„¶è¿™é‡Œæ²¡æœ‰åƒâ€˜ä¹¦è¯»ç™¾éï¼Œå…¶ä¹‰è‡ªç°â€™çš„ä½“ä¼šï¼Œä½†è¿˜æ˜¯æœ‰äº†è‡ªå·±æ„Ÿå—ã€‚é¦–å…ˆæˆ‘å…ˆå£°æ˜æˆ‘è®²çš„ä¸œè¥¿å¹¶ä¸æ·±åˆ»ï¼Œä¹Ÿæ²¡æœ‰æ·±åº¦ã€‚ä½ ä»¬çŸ¥é“ä»€ä¹ˆå«ä½œæ·±åˆ»ä¹ˆï¼Ÿå…¶å®ä¸€ä¸ªäººçš„å­˜åœ¨å¹¶ä¸æ·±åˆ»ï¼Œä½†æ˜¯è¿™ä¸ªäººèƒŒåæ‰€æµ“ç¼©çš„æŸäº›ç‰¹ç‚¹ï¼Œä¸æ•´ä¸ªç¤¾ä¼šçš„å®¢è§‚å­˜åœ¨æŸç§ç°è±¡çš„ç›¸è”ç³»ï¼Œè¿™æ‰æ˜¯æ·±åˆ»ã€‚æˆ‘å¹¶ä¸æƒ³å»æ‰¹åˆ¤é‚£ä¸ªæ—¶ä»£æ‰€å‘ˆç°çš„åŠ£æ ¹ï¼Œå› ä¸ºè¿™å¸¸å¸¸æ‰æ˜¯ä½¿äººç»æœ›çš„åœ°æ–¹.æˆ‘ç°åœ¨å°±å‘å¤§å®¶ç®€è¦ä»‹ç»ä¸€ä¸‹ã€Šæ´»ç€ã€‹è¿™æœ¬ä¹¦çš„æ•…äº‹å‰§æƒ…ï¼šæ•…äº‹é‡Œçš„ä¸»äººå…¬å«åšç¦è´µï¼Œæ˜¯ä¸€ä¸ªé˜”ç»°çš„å°‘çˆ·ï¼Œä»–å¨¶äº†ä¸€ä¸ªå¦»å­å®¶çï¼Œå¹¶ä¸”æœ‰ä¸€ä¸ª4å²çš„å¥³å„¿å«åšå‡¤éœã€‚ä¹‹åçš„æ‚²å‰§ä¹Ÿå°±æ˜¯ä»è¿™é‡Œå¼€å§‹çš„ã€‚ç¦è´µå› ä¸ºå‚ä¸èµŒåšè¢«é»‘ï¼Œå–æ‰äº†æˆ¿å­ï¼Œè¾“äº†å…¨å®¶ä¸‰ä»£ç§¯ç´¯ä¸‹æ¥çš„è´¢å¯Œï¼Œè‡ªå·±æ€€å­•çš„å¦»å­å®¶çè¢«è€ä¸ˆäººæ— æƒ…å¸¦èµ°ã€‚ç•™ä¸‹å¥³å„¿å’Œæ¯äº²ç›¸ä¾ä¸ºå‘½ï¼Œå†è¿‡äº†ä¸€å¹´å¤šçš„è‹¦ç”Ÿæ´»åï¼Œå®¶çå°±å¸¦ç€ä¸€å²çš„å„¿å­æœ‰åº†å›æ¥ï¼Œå¼€å§‹äº†ä¸€å®¶äººçš„å¹³å‡¡çš„å†œæ°‘ç”Ÿæ´»ã€‚ä½†æ˜¯å°±åœ¨ä¸ä¹…ä¹‹åï¼Œç¦è´µçš„æ¯äº²ç—…äº†ï¼Œç¦è´µå»åŸé•‡é‡Œè¯·å¤§å¤«ï¼Œä½†æ˜¯è¢«å›½æ°‘å…šå†›æŠ“å–åšå£®ä¸ï¼Œè¾—è½¬ä¸¤å¹´è¢«è§£æ”¾å†›æ‰€æ•‘ï¼Œå³åä¹Ÿå°±è·Ÿè¿™è§£æ”¾å†›å›å®¶äº†ã€‚æ­¤æ—¶å®¶é‡Œï¼Œæ¯äº²å·²ç»å»ä¸–ï¼Œå¥³å„¿å‡¤éœåœ¨ä¸€æ¬¡é«˜çƒ§åå˜æˆäº†è‹å“‘äººï¼Œå¬å¦»å­è¯´æ¯äº²ä¸´ç»ˆå‰ä¸€éä¸€éçš„å¯¹å¦»å­è¯´ï¼Œç¦è´µæ˜¯ä¸ä¼šå»èµŒåšçš„ã€‚ç¦è´µä¹Ÿå°±åœ¨å®¶é‡Œå®‰é¡¿ä¸‹æ¥ï¼Œè¿‡äº†å¥½å‡ å¹´ï¼Œå› ä¸ºå®¶é‡Œç©·ï¼Œåªèƒ½å–å¥³å„¿ï¼Œè®©å„¿å­å»ä¸Šå­¦ï¼Œæœ€åå¥³å„¿è·‘å›æ¥ä¸å¿é€èµ°ï¼Œå°±ç•™ä¸‹æ¥äº†ã€‚æ—¥å­å°±è¿™ä¹ˆä¸€å¤©å¤©çš„è¿‡å»ï¼Œæœ‰ä¸€å¤©å› ä¸ºå¿é•¿çš„è€å©†ç”Ÿå­©å­è¦è¾“è¡€ï¼Œç»“æœå„¿å­æœ‰åº†è¢«ä¸€ä¸ªä¸è´Ÿè´£ä»»çš„å¤§å¤«ï¼Œç»™æŠ½æ­»äº†ã€‚åæ¥ç«Ÿç„¶å‘ç°å¿é•¿ç«Ÿç„¶æ˜¯ç¦è´µå½“å¹´ç›¸ä¾ä¸ºå‘½çš„æˆ˜å‹æ˜¥ç”Ÿï¼Œä¸è¿‡æ˜¥ç”Ÿä¹‹åä¹Ÿæ­»äºæ–‡åŒ–å¤§é©å‘½ã€‚è¿‡äº†å¥½å‡ å¹´ï¼Œå‡¤éœå«äº†ä¸€ä¸ªåå¤´å¥³å©¿äºŒå–œï¼Œä¸ä¹…åæ­»äºäº§åå¤§å‡ºè¡€ã€‚ä¸¤ä¸ªå­©å­å»ä¸–åï¼Œå¦»å­å®¶çæŠŠå¤–å­™æ¥åˆ°ä¹¡ä¸‹æ¥ä½ï¼Œå¯æ²¡è¿‡å¤šä¹…å°±å®‰å®‰é™é™çš„æ­»äº†ã€‚å¥³å©¿äºŒå–œä¹‹åæ­»äºä¸€åœºäº‹æ•…ï¼Œæ­»çš„æ—¶å€™å¤–å­™è‹¦æ ¹ä»…ä»…4å²ï¼Œè¿˜ä¸çŸ¥é“æ­»çš„æ¦‚å¿µã€‚åªç•™ä¸‹ç¥–å­™ä¿©äººæ´»ç€ï¼Œä½†æ˜¯å¥½æ™¯ä¸é•¿ï¼Œå°è‹¦æ ¹ä¹Ÿæ„å¤–å¤±å»äº†è‡ªå·±çš„ç”Ÿå‘½ã€‚æ™šå¹´çš„ç¦è´µä¹°äº†ä¸€å¤´è€ç‰›ï¼Œå–åä¸ºç¦è´µã€‚ä¸€èµ·å®‰äº«æ™šå¹´ã€‚æˆ‘è¿™é‡Œå¹¶ä¸æƒ³å»è®²è¿™æœ¬ä¹¦é‡Œæ‰€å‘ˆç°å‡ºæ¥çš„ç°å®ï¼Œä¹Ÿä¸æƒ³å»è¯„ä»·è¿™æœ¬ä¹¦é‡Œçš„äººç‰©å½¢è±¡ã€‚è¿™æœ¬ä¹¦æˆ‘çœ‹äº†å¾ˆå¤šéï¼Œæˆ‘ç”šè‡³è®¤ä¸ºä»–ä»¬å°±åƒæ˜¯æˆ‘æ›¾ç»ä¸æˆ‘ç²¾ç¥äº¤æµçš„æœ‹å‹ã€‚å› ä¸ºæœ´ç´ ï¼Œæ‰€ä»¥çœŸå®ï¼›å› ä¸ºçœŸå®ï¼Œæ‰€ä»¥çœŸæŒšï¼›å› ä¸ºçœŸæŒšï¼Œæ‰€ä»¥æ‰ä¼šæ·±æ·±çš„è§¦åŠ¨æˆ‘ã€‚åœ¨è¿™é‡Œæˆ‘åªæ˜¯æƒ³è®²ç”±è¿™æœ¬ä¹¦é‡Œæˆ‘ä¸»ç®¡é‡Œå»¶ä¼¸å‡ºæ¥çš„3ä¸ªé—®é¢˜å—ï¼Œå¹¶ä¸”ç”¨æˆ‘è‡ªå·±çš„ç”Ÿæ´»æ„Ÿæ‚Ÿå’Œç»éªŒï¼Œä¸»è§‚æè¿°ï¼Œå®¢è§‚é˜è¿°ï¼Œè§£å†³çš„è¿™ä¸‰ä¸ªé—®é¢˜ ä»€ä¹ˆæ˜¯æ´»ç€ã€‚ ä¸ºä»€ä¹ˆè¦æ´»ç€ã€‚ æ€ä¹ˆæ´»ç€ã€‚é¦–å…ˆç¬¬ä¸€ä¸ªé—®é¢˜ï¼šä»€ä¹ˆæ‰æ˜¯æ´»ç€ã€‚ä¼—æ‰€å‘¨çŸ¥ï¼Œç”Ÿæ´»çš„ä¸‰å¤§ä¸»é¢˜ï¼Œç”Ÿï¼Œæ­»ï¼Œçˆ±ã€‚è¿™ä¸‰å¤§æ°¸æ’çš„ä¸»é¢˜å°†ä¼šå½±å“æˆ‘ä»¬çš„ä¸€ç”Ÿï¼Œç”Ÿæ­»ç›¸äº’å¯¹ç«‹è€Œåˆ¶è¡¡ï¼Œä½†æ˜¯çˆ±å¯ä»¥è¶…è¶Šå®ƒä»¬ã€‚ï¼ˆè¿™é‡Œçš„çˆ±å¹¶ä¸åªæ˜¯ç”·å¥³ä¹‹é—´çš„æƒ…æ„«ï¼Œä¹Ÿå¹¶ä¸æ˜¯äººä¸äººä¹‹é—´äº§ç”Ÿçš„æƒ…æ„Ÿï¼Œå…·ä½“æ¥è¯´å®ƒæ˜¯ä¸€ç§ä¸»è§‚æ„Ÿå—ï¼Œæ¯”å¦‚è¯´å–œæ€’å“€ä¹æ¨ï¼Œä»–ä»¬éƒ½æ˜¯çˆ±çš„ä¸€ç§è¡¨ç°ï¼‰è¿™é‡Œå°±ä¸ºå¤§å®¶æ‹“å±•ä¸‹çˆ±ã€‚å¤§å®¶è°ˆåˆ°çˆ±å…ä¸åˆ°å°±ä¼šæƒ³åˆ°ã€Šç½—å¯†æ¬§ä¸æœ±ä¸½å¶ã€‹ï¼Œã€Šæ¢å±±ä¼¯ä¸ç¥è‹±å°ã€‹è¿™ä¸¤ç¯‡éƒ½æ˜¯å‡„ç¾ä¸”ç»å…¸çš„çˆ±æƒ…æ•…äº‹ï¼Œä»–ä»¬æ‰€ä¼ è¾¾å‡ºæ¥çš„æ€æƒ³åˆ™æ˜¯â€æˆ‘çˆ±ä½ ï¼Œæ‰€ä»¥æˆ‘è¦ä¸ºä½ æ®‰æƒ…â€œå¤§å®¶çŸ¥é“éšåå³å‡ºçš„ç”µå½±ã€Šæ³°å¦å°¼å…‹å·ã€‹ä¸ºä»€ä¹ˆé‚£ä¹ˆæœ‰åï¼Œä»…ä»…è°ˆçˆ±æƒ…ä¸€ä¸¾è¶…è¿‡äº†å‰é¢ä¸¤éƒ¨å½±ç‰‡å‘¢ï¼Œç”šè‡³è¾¾åˆ°è¿‘å‡ åå¹´æ— äººèƒ½æ•Œçš„æ–°çš„é«˜å³°å‘¢ï¼Œå› ä¸ºå…¶æå‡ºäº†ä¸€ä¸ªåœ¨å½“æ—¶ç‰¹åˆ«å‰å«çš„æ€æƒ³ç†è®ºâ€˜æˆ‘çˆ±ä½ ï¼Œæ‰€ä»¥æˆ‘å°±ä¸ºä½ æ´»ä¸‹å»ï¼Œè¿åŒä½ çš„é‚£ä¸€ä»½ä¸€èµ·æ´»ä¸‹å»ã€‚â€è¿™å°±æ˜¯çˆ±ï¼Œä¸€å®šç¨‹åº¦é‡Œçˆ±å¯ä»¥è¶…è¶Šç”Ÿæ­»ã€‚æ¥ä¸‹æ¥ä¾¿æ˜¯æˆ‘ä¸ªäººå¯¹ç”Ÿæ­»çš„çœ‹æ³•äº†ï¼Œå› ä¸ºæˆ‘æœ‰è¿‡è¿™æ–¹é¢çš„ç»å†æ‰€ä»¥æˆ‘æœ‰è¿™ä¸ªèµ„æ ¼æ‹¿å‡ºæ¥æ¥ç»™å¤§å®¶åˆ†äº«ï¼Œå…¶å®æˆ‘ä»Šå¹´17å²ã€‚åœ¨æ­¤ä¹‹å‰å¯¹ç”Ÿæ­»ä¸€ç‚¹æ¦‚å¿µéƒ½æ˜¯æ²¡æœ‰çš„ï¼Œä½•è°“ç”Ÿï¼Œä½•è°“æ­»å‘¢ï¼Œä¹‹å‰æˆ‘çš„ä¸»è§‚æ„Ÿè§‰å°±æ˜¯æ•™ç§‘ä¹¦çš„ç”Ÿä¸æ­»ã€‚ç›´åˆ°æˆ‘ç»å†ä»–ã€‚å¤§å®¶çŸ¥é“æ¥è§¦ç”Ÿæ­»çš„ç¬¬ä¸€æ„Ÿè§‰æ˜¯ä»€ä¹ˆå—ï¼Ÿä¹Ÿè®¸å¤§å®¶å¹¶ä¸çŸ¥é“ï¼Œä»…ä»…åªæ˜¯ä»¥ä¸ºæ˜¯å®³æ€•ï¼Œæ˜¯ææƒ§ã€‚é‚£ä¹ˆä½ å°±é”™äº†ï¼Œå¹¶ä¸æ˜¯è¿™æ ·ã€‚æ¥è§¦ç”Ÿæ­»çš„ç¬¬ä¸€æ„Ÿè§‰ä¸æ˜¯ææ…Œï¼Œè€Œæ°æ°æ˜¯å…´å¥‹ï¼Œæˆ‘æ— æ³•æè¿°æ˜¯ä¸€ç§æ€æ ·çš„å…´å¥‹ï¼Œå› ä¸ºæŒç»­çš„æ—¶é—´ç‰¹åˆ«çŸ­ï¼Œå¤§æ¦‚å¯ä»¥ç±»æ¯”ä¸ºæ˜¯ä¸€ä¸ªä»æ²¡æœ‰åƒè¿‡ç³–çš„å­©å­ï¼Œç¬¬ä¸€æ¬¡åƒç³–çš„æ„Ÿè§‰ï¼Œå¤šå°‘æœ‰ç‚¹æ–°é²œæ„Ÿåœ¨é‡Œé¢ã€‚ä¹‹åå°±æ˜¯ä¸€ç§å®‰ä¸ä¸‹å¿ƒçš„ææƒ§æ„Ÿï¼Œè¿™ç§æ„Ÿè§‰æ²¡æœ‰ç»å†è¿‡çš„äººæ˜¯ä¸çŸ¥é“çš„ï¼Œé‚£æ˜¯ä¸€ç§æ— æ³•è£…å‡ºæ¥çš„æ„Ÿè§‰ã€‚äº‹åæˆ‘ä¹Ÿè¿›è¡Œç›¸å…³èµ„æ–™çš„æŸ¥é˜…ï¼Œå¥½åƒæ˜¯ä¸€ä¸ªå«ä»€ä¹ˆå¡çš„ç†è®ºç§‘å­¦å®¶å‘è¡¨çš„ä¸€ç¯‡è®ºæ–‡å«ã€Šç”Ÿæ­»è®ºã€‹é‡Œæåˆ°äººåœ¨æ¿’ä¸´æ­»äº¡çš„é‚£ä¸€åˆ»ï¼Œæ½œæ„è¯†é‡Œå·²ç»æŠŠè‡ªå·±å½“ä½œæ­»äº¡ï¼Œè¿™æ—¶çš„ææƒ§å°†æ˜¯å¯¹ç”Ÿæ´»ä»¥åŠå…¶ä»–äººæˆ–äº‹ç‰©çš„æ— é™çœ·å¿µäº§ç”Ÿçš„ã€‚æ‰€ä»¥å°±åƒæˆ‘çš„ä¸€ä¸ªè€å¸ˆæ‰€è®²çš„è¿™ä¸ªæ—¶å€™çš„äººç¬¬ä¸€æƒ³æ³•å°±æ˜¯æƒ³è‡ªå·±æœ€äº²è¿‘çš„äººï¼Œæ¯”å¦‚è¯´å¦ˆå¦ˆã€‚å‘µå‘µã€‚æˆ‘å½“æ—¶ä¹Ÿæ˜¯æ— æ³•é™ä¸‹å¿ƒï¼Œå¿ƒé‡Œä¸€ç›´æƒ³å¦‚æœå¦ˆå¦ˆåœ¨èº«è¾¹å°±å¥½äº†ï¼Œå°±å¥½åƒè¿™ä¸ªäººå¯ä»¥ç»™ä½ å¸¦æ¥æ— å°½çš„å¿ƒå®‰ã€‚ä¹‹åè¿‡äº†ä¸€ä¼šå„¿åè‡ªå·±çš„å¿ƒå°±é™ä¸‹æ¥äº†ï¼Œé‚£ç§é™ä¸‹æ¥çš„æ„Ÿè§‰å«åšåº†å¹¸ã€‚æ„Ÿè°¢è‡ªå·±ä»–å¦ˆçš„è¿˜æ´»ç€ã€‚è¯´å¥å®è¯ï¼Œé‚£æ¬¡çš„ç»å†è®©æˆ‘ä¹‹åçš„ä¸€ä¸ªæœˆå¾ˆä¸å¥½è¿‡å»ï¼Œä½†æ˜¯ä»–å¯¹æˆ‘æœ€å¤§çš„æ„ä¹‰å°±æ˜¯ä»–å®Œå…¨æ‰“å¼€äº†æˆ‘å¯¹å¤–ç•Œäº‹ç‰©æ„ŸçŸ¥ï¼Œå°±åƒä¸€ä¸ªç¾å¦™çš„æ°”å­”è¢«æ­å¼€ï¼Œç„¶åè¿›è¡Œæ°”ä½“äº¤æµçš„æ„Ÿè§‰ã€‚åªæœ‰åˆ°äº†é‚£ä¸ªæ—¶å€™æˆ‘æ‰çœŸæ­£çš„çŸ¥é“åˆ°åº•ä»€ä¹ˆæ˜¯æ´»ç€ã€‚å°±åƒæˆ‘å‰é¢æ‰€è¯´çš„çˆ±æ˜¯ä¸€åˆ‡æ„Ÿå—çš„æºæ³‰ï¼Œæ‰€ä»¥æ´»ç€å°±æ˜¯æˆ‘ä»¬åœ¨è¿™ä¸ªä¸–ç•Œä¸Šä¸»è§‚ä¸Šå­˜åœ¨çš„æ„Ÿå—ã€‚åŒ…æ‹¬ç”Ÿï¼ŒåŒ…æ‹¬æ­»ï¼ŒåŒ…æ‹¬çˆ±ï¼ŒåŒ…æ‹¬æˆ‘ä»¬ç”Ÿæ´»çš„ä»»ä½•ä¸€ç§ä¸»è§‚æ„Ÿè§‰ï¼Œè¿™å°±æ˜¯æ´»ç€ã€‚ æˆ‘ä»¬ä¸ºä»€ä¹ˆè¦æ´»ç€ æˆ‘å¾ˆåæ„Ÿå¾ˆå¤šä¸“å®¶ç±»çš„äººç‰©æ•´å¤©æ‰¹åˆ¤ä¸­å›½äººæ²¡æœ‰ä¿¡ä»°ï¼Œä¸­å›½äººçš„ä¿¡ä»°å°±æ˜¯â€œå¥½æ­»ä¸å¦‚èµ–æ´»ç€ï¼Œæ— è®ºå‘ç”Ÿä»€ä¹ˆæ´»ç€å°±è¡Œäº†ã€‚â€æ´»ç€è¿™æœ¬ä¹¦ä¹Ÿå°±æ˜¯è®²ä¸ºä»€ä¹ˆæ´»ç€è¿™ä¸ªé—®é¢˜çš„ï¼Œç¦è´µåœ¨ä¹¦é‡Œæ˜¯è¿™ä¹ˆå½¢å®¹è‡ªå·±çš„ä¸€ç”Ÿï¼š&quot;æˆ‘æ˜¯æœ‰æ—¶å€™æƒ³æƒ³ä¼¤å¿ƒï¼Œæœ‰æ—¶å€™æƒ³æƒ³åˆå¾ˆè¸å®â€ä¸€ä¸ªæ—©å·²è¿›å»å‚æš®ä¹‹å¹´çš„è€äººå°šä¸”å¦‚æ­¤ï¼Œå…¨å®¶äººçš„è‘¬éƒ½æ˜¯è¿™æ ·ä¸€ä½è€äººé€èµ°çš„ï¼Œå…¶ä¸­çš„æ»‹å‘³æ˜¯æˆ‘ä»¬æ‰€æ²¡åŠæ³•æƒ³è±¡çš„ã€‚é‚£è”ç³»åˆ°å®é™…ï¼Œæˆ‘ä»¬ä¸ºä»€ä¹ˆæ´»ç€å‘¢ï¼Œå…¶å®è¿™ä¸ªé—®é¢˜å¤å¾€ä»Šæ¥æ— æ•°äººå£«éƒ½å‚ä¸è¿‡æ¢è®¨ï¼Œéƒ½æ²¡æœ‰å¾—å‡ºä¸€ä¸ªç§‘å­¦æ€§çš„ç»“è®ºã€‚ä»–ä»¬çš„æ¢è®¨çš„è¿‡ç¨‹å¤§å¤šæ•°éƒ½æ˜¯å¾®è§‚ç»†èƒçš„å­˜åœ¨å½¢å¼ï¼Œå’Œå®è§‚å®‡å®™çš„ç¥ç§˜æ„å›¾ã€‚ç”±æˆ‘ä¸ªäººçš„è§‚ç‚¹ï¼Œå¹¶æ²¡æœ‰ å¾®åŠç»†èƒï¼Œå¤§è‡³å®‡å®™ï¼Œä¹Ÿä¸åƒè¿™æœ¬ä¹¦é‡Œçš„è§‚ç‚¹ã€‚æ´»ç€å¹¶ä¸æ˜¯ä¸ºäº†æ´»ç€ä»¥å¤–çš„äº‹ç‰©è€Œæ´»ç€ï¼Œè€Œæ˜¯ä¸ºäº†æ´»ç€æœ¬èº«è€Œæ´»ç€ã€‚å›´ç»•è¿™ä¸€ä¸ªæ¯”è¾ƒæŠ½è±¡çš„è¯´æ³•ï¼Œä¹Ÿå°±å±•å¼€äº†ç¦è´µçš„ä¸€ç”Ÿã€‚ä¸­å›½æœ‰ä¸€ä¸ªæˆè¯­å«åšåƒé’§ä¸€å‘ã€‚è®©ä¸€æ ¹å¤´å‘å»æ‰¿å—ä¸‰ä¸‡æ–¤çš„é‡å‹ï¼Œä½†æ˜¯å¤´å‘å¹¶æ²¡æœ‰æ–­ã€‚è¿™å°±æ˜¯ä¸­å›½äººçš„éŸ§æ€§ã€‚çœŸæ­£å¼ºå¤§çš„äººå¹¶ä¸æ˜¯çœ‹ä»–å¾æœäº†ä»€ä¹ˆï¼Œè€Œæ˜¯çœ‹ä»–å¯ä»¥æ‰¿å—ä»€ä¹ˆã€‚æ‰€ä»¥æˆ‘çš„ç­”æ¡ˆä¹Ÿå°±ç”±æ­¤è€Œäº§ç”Ÿæ´»ç€å°±æ˜¯ä¸ºäº†åšæŒï¼ŒåšæŒå»çˆ±ï¼ŒåšæŒäº«å—æ‰€æœ‰ç”±æ´»ç€å¸¦æ¥çš„ä¸€åˆ‡ä¸»è§‚æ„Ÿå—ï¼ŒåšæŒå¿å—ç”±æ­»å»å¸¦æ¥çš„ä¸€åˆ‡ææƒ§ä½“ä¼šï¼Œè¿™å°±æ˜¯æ´»ç€ã€‚æˆ‘çš„è§‚ç‚¹ä¹Ÿå°±æ˜¯è¿™ä¸ªï¼Œä¹Ÿè®¸åå¹´åæˆ‘ä¼šæ¨ç¿»æˆ‘çš„ç†è®ºï¼Œï¼ˆæˆ‘å·²ç»æ¨ç¿»äº†æˆ‘å°æ—¶å€™å¾ˆå¤šçš„æƒ³æ³•ç†è®ºã€‚ï¼‰ä½†è‡³å°‘ç°åœ¨ä¸ä¼šã€‚ ç¬¬ä¸‰ï¼Œæˆ‘ä»¬åº”è¯¥æ€ä¹ˆæ´»ã€‚è¿™é‡Œå…¶å®å°±è¦å®¢è§‚çš„æ¥è®²ä¸€ä¸‹è¿™æœ¬ä¹¦çš„å±€é™æ€§ã€‚è¿™æœ¬ä¹¦é‡Œè®²çš„æ˜¯ä¸Šä¸ªä¸–çºªä»è§£æ”¾åçš„åœŸåœ°æ”¹é©ã€äººæ°‘å…¬ç¤¾åˆ¶åº¦ã€å¤§ç‚¼é’¢é“ã€ä¸‰å¹´è‡ªç„¶ç¾å®³ã€æ–‡åŒ–å¤§é©å‘½ä¹‹é—´ï¼Œè®²çš„åªæ˜¯åº•å±‚äººæ°‘å¯¹äºæ¸©é¥±é—®é¢˜çŸ›ç›¾ï¼Œç¼ºå°‘çš„åˆ™æ˜¯ç²¾ç¥ä¸–ç•Œçš„å»ºè®¾ã€‚å½“ç„¶åœ¨é‚£ä¸ªå¹´ä»£è°ˆç²¾ç¥å¹´ä»£å°±åƒè¯´æ¢¦è¯ä¸€æ ·ã€‚ä½†æ˜¯ç°åœ¨çš„ç¤¾ä¼šæ°´å¹³å·²ç»é«˜äºå½“å¹´å¾ˆå¤šå€äº†ï¼Œä½†æ˜¯ç°åœ¨çš„äººæ°‘å¹¸ç¦åº¦å´è¿œä½å½“å¹´ã€‚è¿™åˆæ˜¯ä¸ºä»€ä¹ˆå‘¢ï¼Ÿå”¯ä¸€å¯ä»¥è§£é‡Šçš„åŸå› å°±æ˜¯ï¼Œäººä»¬è§£å†³äº†æ¸©é¥±ç±»çš„é—®é¢˜åï¼Œç²¾ç¥ä¸–ç•Œçš„åŒ®ä¹ç”šè‡³æ˜¯æºƒçƒ‚ï¼Œå‡ºç°äº†æå¤§çš„é—®é¢˜ã€‚é‚£ä¹ˆæ€ä¹ˆè§£å†³å‘¢ã€‚ç‰©è´¨å’Œç²¾ç¥ä¸Šçš„åè°ƒä¸å¹³è¡¡è¯¥å¦‚ä½•åšåˆ°å‘¢ï¼Ÿä¸€åˆ‡éšå¿ƒï¼Œéšè‡ªå·±çš„ä¸»è§‚æ„Ÿè§‰ï¼Œéšè‡ªå·±æƒ³è¦å®Œæˆçš„äº‹æƒ…ã€‚äººä¸ºä»€ä¹ˆä¼šä¸å¿«ä¹ï¼Œå¤§å®¶çŸ¥é“ä¹ˆï¼Ÿæ˜¯ç”±äºæˆ‘ä»¬ä¸ªäººçš„ä¸»è§‚æ„Ÿè§‰è¢«å®¢è§‚è§„å¾‹æ³•åˆ™æ‰€ç‰µåˆ¶ï¼Œå¯¼è‡´æˆ‘ä»¬å¹¶ä¸å¿«ä¹ã€‚è€Œå¾€å¾€è¿™äº›å®¢è§‚æ³•åˆ™è§„å¾‹å¸¸å¸¸æ˜¯æ²¡æœ‰æœ€æ­£ç¡®çš„ç†ç”±çš„ï¼Œæ¯”å¦‚è¯´ä¸ºä»€ä¹ˆè¯„åˆ¤ç°åœ¨ä¸€ä¸ªäººä¹¦è¯»çš„å¥½ï¼Œå°±ä¸€åˆ‡éƒ½å¥½ã€‚ä¸ºä»€ä¹ˆé•¿å¤§åèµšé’±çš„å¤šå°‘æ˜¯è¯„åˆ¤ä¸€ä¸ªäººæ˜¯å¦æˆåŠŸçš„é‡è¦ä¾æ®ã€‚å®ç°äººç”Ÿä»·å€¼è¯„åˆ¤æ–¹å¼æœ‰å¾ˆå¤šï¼Œä¸ºä»€ä¹ˆå•å•åªæ˜¯è¿™ä¸€ç‚¹ã€‚é‚£è¿˜æœ‰ä¸ºä»€ä¹ˆç”·å¤§å½“å©šï¼Œå¥³å¤§å½“å«â€¦è¿˜æœ‰å¾ˆå¤šé—®é¢˜æˆ‘ä»¬é—®ä¸å‡ºæ¥ç¼˜ç”±ï¼Œè¿™äº›éƒ½æ˜¯æ•´ä¸ªç¤¾ä¼šæ‰€ç»™äºˆçš„ã€‚é‚£ä¹ˆä¸ºä»€ä¹ˆç¤¾ä¼šè¦è¿™æ ·è§„å®šå‘¢ï¼Ÿè‚¯å®šæ˜¯å¯¹æ•´ä¸ªç¤¾ä¼šçš„å’Œè°ç¨³å®šæœ‰ç›Šå¤„ã€‚ä½†åŒæ—¶ä¹Ÿé€ æˆäº†å·¨å¤§çš„å‹åŠ›ç»™ä¸ªäººã€‚æŒ‰ç…§å¹¸ç¦æœ€å¤§åŒ–åŸç†ï¼Œæ²¡æœ‰äººï¼Œæˆ–è€…è¯´æ˜¯æ²¡æœ‰ç”Ÿç‰©ä»æœ¬è´¨ä¸Šè®²æ˜¯å–œæ¬¢ç—›è‹¦å’Œè‹¦éš¾çš„ã€‚ç„¶è€Œé¢å¯¹è¿™ä¸€åˆ‡å‹åŠ›ï¼Œä½†æ€»æ˜¯æœ‰äººæ´»çš„æ½‡æ´’ã€‚æ¯”å¦‚åº„å­çš„ç‰©æˆ‘åˆä¸€ï¼Œé™¶æ¸Šæ˜çš„ç‰©æˆ‘ä¸¤å¿˜ï¼Œè¿™äº›éƒ½æ˜¯å¢ƒç•Œä¸Šçš„æ½‡æ´’ã€‚è€Œæˆ‘ä»¬è¯¥å¦‚ä½•åšåˆ°è¿™äº›å‘¢ï¼Ÿå”¯æœ‰ä¿®å¿ƒã€‚æé«˜å¿ƒç†ç´ è´¨å’Œæ‰¿å—èƒ½åŠ›ï¼Œå¯»è§…ç‰©è´¨ä¸ç²¾ç¥å®ˆæ’çš„ä¸€ç‚¹ã€‚è¿™å°±æ˜¯æˆ‘ä»¬æ´»ç€è¯¥åšçš„äº‹æƒ…ã€‚äººç”Ÿçš„æœ€é«˜çš„å¢ƒç•Œä¾¿æ˜¯æ·¡ã€‚æˆ‘æ²¡æœ‰è¾¾åˆ°è¿™ä¸ªå¢ƒç•Œï¼Œæ‰€ä»¥æˆ‘æ²¡æœ‰åŠæ³•ä¸ºå¤§å®¶å±•å¼€ã€‚ä½†æ˜¯æŒ‰ç…§è‡ªå·±çš„å¿ƒæ´»ä¸‹å»ï¼Œæˆ‘ç›¸ä¿¡ä¸‡æ³•åŒä¸€ã€‚æ®Šé€”æ€»ä¼šåŒå½’çš„ã€‚ å†™ä¸2015å¹´4æœˆ6æ—¥ã€‚]]></content>
      <categories>
        <category>ä¹¦ç±</category>
      </categories>
      <tags>
        <tag>ä¹¦è¯„</tag>
        <tag>åˆ›ä½œ</tag>
      </tags>
  </entry>
</search>
